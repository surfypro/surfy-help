var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import * as React from "react";
import React__default, { forwardRef, useContext, useEffect } from "react";
import { RecoilRoot, atom, useRecoilValue_TRANSITION_SUPPORT_UNSTABLE, useRecoilState, atomFamily } from "recoil";
import { Typography } from "@mui/material";
function sortOnLevel(a2, b2) {
  return a2.level - b2.level;
}
function sortOnName(a2, b2) {
  return a2.name.localeCompare(b2.name);
}
const occupancyStatusObjectTypeDefintion = {
  "name": "occupancyStatus",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "occupancyStatus",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "occupancyStatus",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "occupancyStatus",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "occupancyStatus",
      "type": "color",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "occupancyStatus",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "occupancyStatus",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "occupancyStatus",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "occupancyStatus",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "occupancyStatusId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "occupancyStatuses",
  "camelized": {
    "singular": "occupancyStatus",
    "plural": "occupancyStatuses",
    "id": "occupancyStatusId"
  },
  "capitalized": {
    "singular": "OccupancyStatus",
    "plural": "OccupancyStatuses",
    "id": "OccupancyStatusId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "room"
    ],
    "belongsTo": []
  }
};
const userObjectTypeDefintion = {
  "name": "user",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "user",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "email": {
      "name": "email",
      "objectTypeName": "user",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "firstname": {
      "name": "firstname",
      "objectTypeName": "user",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "lastname": {
      "name": "lastname",
      "objectTypeName": "user",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "picture": {
      "name": "picture",
      "objectTypeName": "user",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "sub": {
      "name": "sub",
      "objectTypeName": "user",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "user",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "user",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "user",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanies": {
      "name": "userCompanies",
      "objectTypeName": "user",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanies",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "users",
  "camelized": {
    "singular": "user",
    "plural": "users",
    "id": "userId"
  },
  "capitalized": {
    "singular": "User",
    "plural": "Users",
    "id": "UserId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "userCompany"
    ],
    "belongsTo": []
  }
};
const userRefreshTokenObjectTypeDefintion = {
  "name": "userRefreshToken",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "userRefreshToken",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "refreshToken": {
      "name": "refreshToken",
      "objectTypeName": "userRefreshToken",
      "type": "password",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "userRefreshToken",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "userRefreshToken",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "userRefreshToken",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userId": {
      "name": "userId",
      "objectTypeName": "userRefreshToken",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userId",
        "targetModelName": "user",
        "propertyTypeName": "user",
        "options": {
          "readOnly": false
        }
      }
    },
    "user": {
      "name": "user",
      "objectTypeName": "userRefreshToken",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userId",
        "targetModelName": "user",
        "propertyTypeName": "user",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "userRefreshTokens",
  "camelized": {
    "singular": "userRefreshToken",
    "plural": "userRefreshTokens",
    "id": "userRefreshTokenId"
  },
  "capitalized": {
    "singular": "UserRefreshToken",
    "plural": "UserRefreshTokens",
    "id": "UserRefreshTokenId"
  },
  "hidden": true,
  "context": {
    "hasMany": [],
    "belongsTo": []
  }
};
const companyTypeObjectTypeDefintion = {
  "name": "companyType",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "companyType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "companyType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "billable": {
      "name": "billable",
      "objectTypeName": "companyType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "companyType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "companyType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "companyType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "companies": {
      "name": "companies",
      "objectTypeName": "companyType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyTypeId",
        "targetModelName": "company",
        "propertyTypeName": "companies",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "companyTypes",
  "camelized": {
    "singular": "companyType",
    "plural": "companyTypes",
    "id": "companyTypeId"
  },
  "capitalized": {
    "singular": "CompanyType",
    "plural": "CompanyTypes",
    "id": "CompanyTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "company"
    ],
    "belongsTo": []
  }
};
const companyObjectTypeDefintion = {
  "name": "company",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "company",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "company",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "logoPath": {
      "name": "logoPath",
      "objectTypeName": "company",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "iconPath": {
      "name": "iconPath",
      "objectTypeName": "company",
      "type": "square-image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "proxyImages": {
      "name": "proxyImages",
      "objectTypeName": "company",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "workingDaysCount": {
      "name": "workingDaysCount",
      "objectTypeName": "company",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "enablePathfinding": {
      "name": "enablePathfinding",
      "objectTypeName": "company",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "planningNumberOfDays": {
      "name": "planningNumberOfDays",
      "objectTypeName": "company",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 14
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "company",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "company",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "company",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "companyTypeId": {
      "name": "companyTypeId",
      "objectTypeName": "company",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyTypeId",
        "targetModelName": "companyType",
        "propertyTypeName": "companyType",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyType": {
      "name": "companyType",
      "objectTypeName": "company",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyTypeId",
        "targetModelName": "companyType",
        "propertyTypeName": "companyType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanies": {
      "name": "userCompanies",
      "objectTypeName": "company",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanies",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingTypes": {
      "name": "buildingTypes",
      "objectTypeName": "company",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "buildingType",
        "propertyTypeName": "buildingTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildings": {
      "name": "buildings",
      "objectTypeName": "company",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "building",
        "propertyTypeName": "buildings",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "companies",
  "camelized": {
    "singular": "company",
    "plural": "companies",
    "id": "companyId"
  },
  "capitalized": {
    "singular": "Company",
    "plural": "Companies",
    "id": "CompanyId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "userCompany",
      "buildingType",
      "building"
    ],
    "belongsTo": []
  }
};
const campusObjectTypeDefintion = {
  "name": "campus",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "campus",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "campus",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "campus",
      "type": "color",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "address": {
      "name": "address",
      "objectTypeName": "campus",
      "type": "address",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "campus",
      "type": "surface",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "campus",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "campus",
      "type": "surface-by-people",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "campus",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "campus",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "campus",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "campus",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "campus",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "campus",
      "type": "weight",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "campus",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "campus",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "campus",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "campus",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "campus",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "campus",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "campus",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "campus",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "campus",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "buildings": {
      "name": "buildings",
      "objectTypeName": "campus",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "campusId",
        "targetModelName": "building",
        "propertyTypeName": "buildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "campus",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "campus",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "campuses",
  "camelized": {
    "singular": "campus",
    "plural": "campuses",
    "id": "campusId"
  },
  "capitalized": {
    "singular": "Campus",
    "plural": "Campuses",
    "id": "CampusId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "building"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const roomConnectorTypeObjectTypeDefintion = {
  "name": "roomConnectorType",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomConnectorType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "roomConnectorType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomConnectorType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomConnectorType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomConnectorType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomConnectors": {
      "name": "roomConnectors",
      "objectTypeName": "roomConnectorType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomConnectorTypeId",
        "targetModelName": "roomConnector",
        "propertyTypeName": "roomConnectors",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "roomConnectorTypes",
  "camelized": {
    "singular": "roomConnectorType",
    "plural": "roomConnectorTypes",
    "id": "roomConnectorTypeId"
  },
  "capitalized": {
    "singular": "RoomConnectorType",
    "plural": "RoomConnectorTypes",
    "id": "RoomConnectorTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomConnector"
    ],
    "belongsTo": []
  }
};
const roomConnectorObjectTypeDefintion = {
  "name": "roomConnector",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomConnector",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "roomConnector",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "waitTime": {
      "name": "waitTime",
      "objectTypeName": "roomConnector",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "timePerFloor": {
      "name": "timePerFloor",
      "objectTypeName": "roomConnector",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomConnector",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomConnector",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomConnector",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomConnectorTypeId": {
      "name": "roomConnectorTypeId",
      "objectTypeName": "roomConnector",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomConnectorTypeId",
        "targetModelName": "roomConnectorType",
        "propertyTypeName": "roomConnectorType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomConnectorType": {
      "name": "roomConnectorType",
      "objectTypeName": "roomConnector",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomConnectorTypeId",
        "targetModelName": "roomConnectorType",
        "propertyTypeName": "roomConnectorType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomConnector",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomConnector",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomConnector",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomConnector",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "roomConnector",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomConnectorId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomConnector",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomConnector",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomConnectors",
  "camelized": {
    "singular": "roomConnector",
    "plural": "roomConnectors",
    "id": "roomConnectorId"
  },
  "capitalized": {
    "singular": "RoomConnector",
    "plural": "RoomConnectors",
    "id": "RoomConnectorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "room"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const userCompanyObjectTypeDefintion = {
  "name": "userCompany",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "userCompany",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "userCompany",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "userCompany",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "userCompany",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "campusCreatedBies": {
      "name": "campusCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "campus",
        "propertyTypeName": "campusCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "campusUpdatedBies": {
      "name": "campusUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "campus",
        "propertyTypeName": "campusUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomConnectorCreatedBies": {
      "name": "roomConnectorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomConnector",
        "propertyTypeName": "roomConnectorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomConnectorUpdatedBies": {
      "name": "roomConnectorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomConnector",
        "propertyTypeName": "roomConnectorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userId": {
      "name": "userId",
      "objectTypeName": "userCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userId",
        "targetModelName": "user",
        "propertyTypeName": "user",
        "options": {
          "readOnly": false
        }
      }
    },
    "user": {
      "name": "user",
      "objectTypeName": "userCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userId",
        "targetModelName": "user",
        "propertyTypeName": "user",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "userCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": false
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "userCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": false
        }
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "userCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "userCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "userCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "userCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBies": {
      "name": "userCompanyCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "userCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "userCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBies": {
      "name": "userCompanyUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyCreatedBies": {
      "name": "personCompanyCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompanyCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyUpdatedBies": {
      "name": "personCompanyUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompanyUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "buildingTypeCreatedBies": {
      "name": "buildingTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "buildingType",
        "propertyTypeName": "buildingTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "buildingTypeUpdatedBies": {
      "name": "buildingTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "buildingType",
        "propertyTypeName": "buildingTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "organizationCreatedBies": {
      "name": "organizationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "organization",
        "propertyTypeName": "organizationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "organizationUpdatedBies": {
      "name": "organizationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "organization",
        "propertyTypeName": "organizationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypeFamilyCreatedBies": {
      "name": "itemTypeFamilyCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "itemTypeFamily",
        "propertyTypeName": "itemTypeFamilyCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypeFamilyUpdatedBies": {
      "name": "itemTypeFamilyUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "itemTypeFamily",
        "propertyTypeName": "itemTypeFamilyUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "manufacturerCreatedBies": {
      "name": "manufacturerCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "manufacturer",
        "propertyTypeName": "manufacturerCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "manufacturerUpdatedBies": {
      "name": "manufacturerUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "manufacturer",
        "propertyTypeName": "manufacturerUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypeCreatedBies": {
      "name": "itemTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "itemType",
        "propertyTypeName": "itemTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypeUpdatedBies": {
      "name": "itemTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "itemType",
        "propertyTypeName": "itemTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "buildingOwners": {
      "name": "buildingOwners",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyOwnerId",
        "targetModelName": "building",
        "propertyTypeName": "buildingOwners",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingCreatedBies": {
      "name": "buildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "building",
        "propertyTypeName": "buildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "buildingUpdatedBies": {
      "name": "buildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "building",
        "propertyTypeName": "buildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "mapScaleCreatedBies": {
      "name": "mapScaleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "mapScale",
        "propertyTypeName": "mapScaleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "mapScaleUpdatedBies": {
      "name": "mapScaleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "mapScale",
        "propertyTypeName": "mapScaleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "structureCreatedBies": {
      "name": "structureCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "structure",
        "propertyTypeName": "structureCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "structureUpdatedBies": {
      "name": "structureUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "structure",
        "propertyTypeName": "structureUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "structurePointCreatedBies": {
      "name": "structurePointCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "structurePoint",
        "propertyTypeName": "structurePointCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "structurePointUpdatedBies": {
      "name": "structurePointUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "structurePoint",
        "propertyTypeName": "structurePointUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "floorCreatedBies": {
      "name": "floorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "floor",
        "propertyTypeName": "floorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "floorUpdatedBies": {
      "name": "floorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "floor",
        "propertyTypeName": "floorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "distributionCostTypeCreatedBies": {
      "name": "distributionCostTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "distributionCostType",
        "propertyTypeName": "distributionCostTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "distributionCostTypeUpdatedBies": {
      "name": "distributionCostTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "distributionCostType",
        "propertyTypeName": "distributionCostTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeCreatedBies": {
      "name": "roomTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomType",
        "propertyTypeName": "roomTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeUpdatedBies": {
      "name": "roomTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomType",
        "propertyTypeName": "roomTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupToRoomTypeCreatedBies": {
      "name": "roomTypeGroupToRoomTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomTypeGroupToRoomType",
        "propertyTypeName": "roomTypeGroupToRoomTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupToRoomTypeUpdatedBies": {
      "name": "roomTypeGroupToRoomTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomTypeGroupToRoomType",
        "propertyTypeName": "roomTypeGroupToRoomTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupFloorCreatedBies": {
      "name": "roomTypeGroupFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomTypeGroupFloor",
        "propertyTypeName": "roomTypeGroupFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupFloorUpdatedBies": {
      "name": "roomTypeGroupFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomTypeGroupFloor",
        "propertyTypeName": "roomTypeGroupFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupBuildingCreatedBies": {
      "name": "roomTypeGroupBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomTypeGroupBuilding",
        "propertyTypeName": "roomTypeGroupBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupBuildingUpdatedBies": {
      "name": "roomTypeGroupBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomTypeGroupBuilding",
        "propertyTypeName": "roomTypeGroupBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterCreatedBies": {
      "name": "costCenterCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenterCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterUpdatedBies": {
      "name": "costCenterUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenterUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterBuildingCreatedBies": {
      "name": "costCenterBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "costCenterBuilding",
        "propertyTypeName": "costCenterBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterBuildingUpdatedBies": {
      "name": "costCenterBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "costCenterBuilding",
        "propertyTypeName": "costCenterBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterFloorCreatedBies": {
      "name": "costCenterFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "costCenterFloor",
        "propertyTypeName": "costCenterFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterFloorUpdatedBies": {
      "name": "costCenterFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "costCenterFloor",
        "propertyTypeName": "costCenterFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomCreatedBies": {
      "name": "roomCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "room",
        "propertyTypeName": "roomCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomUpdatedBies": {
      "name": "roomUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "room",
        "propertyTypeName": "roomUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointCreatedBies": {
      "name": "roomPointCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPointCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointUpdatedBies": {
      "name": "roomPointUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPointUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointRoomCreatedBies": {
      "name": "roomPointRoomCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomPointRoom",
        "propertyTypeName": "roomPointRoomCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointRoomUpdatedBies": {
      "name": "roomPointRoomUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomPointRoom",
        "propertyTypeName": "roomPointRoomUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointSegmentCreatedBies": {
      "name": "roomPointSegmentCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomPointSegment",
        "propertyTypeName": "roomPointSegmentCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointSegmentUpdatedBies": {
      "name": "roomPointSegmentUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomPointSegment",
        "propertyTypeName": "roomPointSegmentUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypePointCreatedBies": {
      "name": "itemTypePointCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "itemTypePoint",
        "propertyTypeName": "itemTypePointCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypePointUpdatedBies": {
      "name": "itemTypePointUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "itemTypePoint",
        "propertyTypeName": "itemTypePointUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionTypeCreatedBies": {
      "name": "dimensionTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionTypeUpdatedBies": {
      "name": "dimensionTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionCreatedBies": {
      "name": "dimensionCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimension",
        "propertyTypeName": "dimensionCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionUpdatedBies": {
      "name": "dimensionUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimension",
        "propertyTypeName": "dimensionUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionRoomCreatedBies": {
      "name": "dimensionRoomCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimensionRoom",
        "propertyTypeName": "dimensionRoomCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionRoomUpdatedBies": {
      "name": "dimensionRoomUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimensionRoom",
        "propertyTypeName": "dimensionRoomUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionFloorCreatedBies": {
      "name": "dimensionFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimensionFloor",
        "propertyTypeName": "dimensionFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionFloorUpdatedBies": {
      "name": "dimensionFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimensionFloor",
        "propertyTypeName": "dimensionFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionBuildingCreatedBies": {
      "name": "dimensionBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimensionBuilding",
        "propertyTypeName": "dimensionBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionBuildingUpdatedBies": {
      "name": "dimensionBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimensionBuilding",
        "propertyTypeName": "dimensionBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "factTypeCreatedBies": {
      "name": "factTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "factType",
        "propertyTypeName": "factTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "factTypeUpdatedBies": {
      "name": "factTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "factType",
        "propertyTypeName": "factTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "factCreatedBies": {
      "name": "factCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "fact",
        "propertyTypeName": "factCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "factUpdatedBies": {
      "name": "factUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "fact",
        "propertyTypeName": "factUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personStateCreatedBies": {
      "name": "personStateCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personState",
        "propertyTypeName": "personStateCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personStateUpdatedBies": {
      "name": "personStateUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personState",
        "propertyTypeName": "personStateUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personSecurityProfileCreatedBies": {
      "name": "personSecurityProfileCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personSecurityProfile",
        "propertyTypeName": "personSecurityProfileCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personSecurityProfileUpdatedBies": {
      "name": "personSecurityProfileUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personSecurityProfile",
        "propertyTypeName": "personSecurityProfileUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCreatedBies": {
      "name": "personCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "person",
        "propertyTypeName": "personCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personUpdatedBies": {
      "name": "personUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "person",
        "propertyTypeName": "personUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToPersonTypeCreatedBies": {
      "name": "personToPersonTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personToPersonType",
        "propertyTypeName": "personToPersonTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToPersonTypeUpdatedBies": {
      "name": "personToPersonTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personToPersonType",
        "propertyTypeName": "personToPersonTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToPersonCreatedBies": {
      "name": "personToPersonCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personToPerson",
        "propertyTypeName": "personToPersonCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToPersonUpdatedBies": {
      "name": "personToPersonUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personToPerson",
        "propertyTypeName": "personToPersonUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomAffectationCreatedBies": {
      "name": "roomAffectationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomAffectation",
        "propertyTypeName": "roomAffectationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomAffectationUpdatedBies": {
      "name": "roomAffectationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomAffectation",
        "propertyTypeName": "roomAffectationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceTypeCreatedBies": {
      "name": "workplaceTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "workplaceType",
        "propertyTypeName": "workplaceTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceTypeUpdatedBies": {
      "name": "workplaceTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "workplaceType",
        "propertyTypeName": "workplaceTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceTypeItemTypeCreatedBies": {
      "name": "workplaceTypeItemTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "workplaceTypeItemType",
        "propertyTypeName": "workplaceTypeItemTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceTypeItemTypeUpdatedBies": {
      "name": "workplaceTypeItemTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "workplaceTypeItemType",
        "propertyTypeName": "workplaceTypeItemTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceCreatedBies": {
      "name": "workplaceCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "workplace",
        "propertyTypeName": "workplaceCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceUpdatedBies": {
      "name": "workplaceUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "workplace",
        "propertyTypeName": "workplaceUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemCreatedBies": {
      "name": "itemCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "item",
        "propertyTypeName": "itemCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemUpdatedBies": {
      "name": "itemUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "item",
        "propertyTypeName": "itemUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceAffectationCreatedBies": {
      "name": "workplaceAffectationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "workplaceAffectation",
        "propertyTypeName": "workplaceAffectationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceAffectationUpdatedBies": {
      "name": "workplaceAffectationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "workplaceAffectation",
        "propertyTypeName": "workplaceAffectationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "organizationFloorCreatedBies": {
      "name": "organizationFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "organizationFloor",
        "propertyTypeName": "organizationFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "organizationFloorUpdatedBies": {
      "name": "organizationFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "organizationFloor",
        "propertyTypeName": "organizationFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "organizationBuildingCreatedBies": {
      "name": "organizationBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "organizationBuilding",
        "propertyTypeName": "organizationBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "organizationBuildingUpdatedBies": {
      "name": "organizationBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "organizationBuilding",
        "propertyTypeName": "organizationBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeFloorCreatedBies": {
      "name": "roomTypeFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomTypeFloor",
        "propertyTypeName": "roomTypeFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeFloorUpdatedBies": {
      "name": "roomTypeFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomTypeFloor",
        "propertyTypeName": "roomTypeFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeBuildingCreatedBies": {
      "name": "roomTypeBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "roomTypeBuilding",
        "propertyTypeName": "roomTypeBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeBuildingUpdatedBies": {
      "name": "roomTypeBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "roomTypeBuilding",
        "propertyTypeName": "roomTypeBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemToPersonCreatedBies": {
      "name": "itemToPersonCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "itemToPerson",
        "propertyTypeName": "itemToPersonCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemToPersonUpdatedBies": {
      "name": "itemToPersonUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "itemToPerson",
        "propertyTypeName": "itemToPersonUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToBuildingCreatedBies": {
      "name": "personToBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personToBuilding",
        "propertyTypeName": "personToBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToBuildingUpdatedBies": {
      "name": "personToBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personToBuilding",
        "propertyTypeName": "personToBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionToPersonCreatedBies": {
      "name": "dimensionToPersonCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimensionToPerson",
        "propertyTypeName": "dimensionToPersonCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionToPersonUpdatedBies": {
      "name": "dimensionToPersonUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimensionToPerson",
        "propertyTypeName": "dimensionToPersonUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionTypeToBuildingCreatedBies": {
      "name": "dimensionTypeToBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "dimensionTypeToBuilding",
        "propertyTypeName": "dimensionTypeToBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionTypeToBuildingUpdatedBies": {
      "name": "dimensionTypeToBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "dimensionTypeToBuilding",
        "propertyTypeName": "dimensionTypeToBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personWorkingLocationCreatedBies": {
      "name": "personWorkingLocationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personWorkingLocationUpdatedBies": {
      "name": "personWorkingLocationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToWorkplaceBookingCreatedBies": {
      "name": "personToWorkplaceBookingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personToWorkplaceBooking",
        "propertyTypeName": "personToWorkplaceBookingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToWorkplaceBookingUpdatedBies": {
      "name": "personToWorkplaceBookingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personToWorkplaceBooking",
        "propertyTypeName": "personToWorkplaceBookingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToRoomBookingCreatedBies": {
      "name": "personToRoomBookingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personToRoomBooking",
        "propertyTypeName": "personToRoomBookingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToRoomBookingUpdatedBies": {
      "name": "personToRoomBookingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personToRoomBooking",
        "propertyTypeName": "personToRoomBookingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToDimensionBookingCreatedBies": {
      "name": "personToDimensionBookingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personToDimensionBooking",
        "propertyTypeName": "personToDimensionBookingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToDimensionBookingUpdatedBies": {
      "name": "personToDimensionBookingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personToDimensionBooking",
        "propertyTypeName": "personToDimensionBookingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyToItemTypeCreatedBies": {
      "name": "personCompanyToItemTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personCompanyToItemType",
        "propertyTypeName": "personCompanyToItemTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyToItemTypeUpdatedBies": {
      "name": "personCompanyToItemTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personCompanyToItemType",
        "propertyTypeName": "personCompanyToItemTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyToRoomTypeCreatedBies": {
      "name": "personCompanyToRoomTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personCompanyToRoomType",
        "propertyTypeName": "personCompanyToRoomTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyToRoomTypeUpdatedBies": {
      "name": "personCompanyToRoomTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personCompanyToRoomType",
        "propertyTypeName": "personCompanyToRoomTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyToItemCreatedBies": {
      "name": "personCompanyToItemCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "personCompanyToItem",
        "propertyTypeName": "personCompanyToItemCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "personCompanyToItemUpdatedBies": {
      "name": "personCompanyToItemUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "personCompanyToItem",
        "propertyTypeName": "personCompanyToItemUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "legendCreatedBies": {
      "name": "legendCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "legend",
        "propertyTypeName": "legendCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "legendUpdatedBies": {
      "name": "legendUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "legend",
        "propertyTypeName": "legendUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "openerPostMessageHostCreatedBies": {
      "name": "openerPostMessageHostCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "openerPostMessageHost",
        "propertyTypeName": "openerPostMessageHostCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "openerPostMessageHostUpdatedBies": {
      "name": "openerPostMessageHostUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "openerPostMessageHost",
        "propertyTypeName": "openerPostMessageHostUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleCreatedBies": {
      "name": "contentRoleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRoleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleUpdatedBies": {
      "name": "contentRoleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRoleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "jupUserCompanyToJupRoles": {
      "name": "jupUserCompanyToJupRoles",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyId",
        "targetModelName": "jupUserCompanyToJupRole",
        "propertyTypeName": "jupUserCompanyToJupRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUserCompanyToJupRoleCreatedBies": {
      "name": "jupUserCompanyToJupRoleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "jupUserCompanyToJupRole",
        "propertyTypeName": "jupUserCompanyToJupRoleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "jupUserCompanyToJupRoleUpdatedBies": {
      "name": "jupUserCompanyToJupRoleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "jupUserCompanyToJupRole",
        "propertyTypeName": "jupUserCompanyToJupRoleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToBuildingCreatedBies": {
      "name": "contentRoleToBuildingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "contentRoleToBuilding",
        "propertyTypeName": "contentRoleToBuildingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToBuildingUpdatedBies": {
      "name": "contentRoleToBuildingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "contentRoleToBuilding",
        "propertyTypeName": "contentRoleToBuildingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToUserCompanies": {
      "name": "contentRoleToUserCompanies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyId",
        "targetModelName": "contentRoleToUserCompany",
        "propertyTypeName": "contentRoleToUserCompanies",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleToUserCompanyCreatedBies": {
      "name": "contentRoleToUserCompanyCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "contentRoleToUserCompany",
        "propertyTypeName": "contentRoleToUserCompanyCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToUserCompanyUpdatedBies": {
      "name": "contentRoleToUserCompanyUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "contentRoleToUserCompany",
        "propertyTypeName": "contentRoleToUserCompanyUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToFloorCreatedBies": {
      "name": "contentRoleToFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "contentRoleToFloor",
        "propertyTypeName": "contentRoleToFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToFloorUpdatedBies": {
      "name": "contentRoleToFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "contentRoleToFloor",
        "propertyTypeName": "contentRoleToFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerApiCredentialCreatedBies": {
      "name": "partnerApiCredentialCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "partnerApiCredential",
        "propertyTypeName": "partnerApiCredentialCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerApiCredentialUpdatedBies": {
      "name": "partnerApiCredentialUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "partnerApiCredential",
        "propertyTypeName": "partnerApiCredentialUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserCreatedBies": {
      "name": "apiUserCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "apiUser",
        "propertyTypeName": "apiUserCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserUpdatedBies": {
      "name": "apiUserUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "apiUser",
        "propertyTypeName": "apiUserUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserToJupRoleCreatedBies": {
      "name": "apiUserToJupRoleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "apiUserToJupRole",
        "propertyTypeName": "apiUserToJupRoleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserToJupRoleUpdatedBies": {
      "name": "apiUserToJupRoleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "apiUserToJupRole",
        "propertyTypeName": "apiUserToJupRoleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserToContentRoleCreatedBies": {
      "name": "apiUserToContentRoleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "apiUserToContentRole",
        "propertyTypeName": "apiUserToContentRoleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserToContentRoleUpdatedBies": {
      "name": "apiUserToContentRoleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "apiUserToContentRole",
        "propertyTypeName": "apiUserToContentRoleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "jupUiTenantOperationCreatedBies": {
      "name": "jupUiTenantOperationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "jupUiTenantOperation",
        "propertyTypeName": "jupUiTenantOperationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "jupUiTenantOperationUpdatedBies": {
      "name": "jupUiTenantOperationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "jupUiTenantOperation",
        "propertyTypeName": "jupUiTenantOperationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToJupUiTenantOperationCreatedBies": {
      "name": "contentRoleToJupUiTenantOperationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "contentRoleToJupUiTenantOperation",
        "propertyTypeName": "contentRoleToJupUiTenantOperationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToJupUiTenantOperationUpdatedBies": {
      "name": "contentRoleToJupUiTenantOperationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "contentRoleToJupUiTenantOperation",
        "propertyTypeName": "contentRoleToJupUiTenantOperationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleCreatedBies": {
      "name": "userRegistrationTenantRuleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRuleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleUpdatedBies": {
      "name": "userRegistrationTenantRuleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRuleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleToJupRoleCreatedBies": {
      "name": "userRegistrationTenantRuleToJupRoleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userRegistrationTenantRuleToJupRole",
        "propertyTypeName": "userRegistrationTenantRuleToJupRoleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleToJupRoleUpdatedBies": {
      "name": "userRegistrationTenantRuleToJupRoleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userRegistrationTenantRuleToJupRole",
        "propertyTypeName": "userRegistrationTenantRuleToJupRoleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleToContentRoleCreatedBies": {
      "name": "userRegistrationTenantRuleToContentRoleCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userRegistrationTenantRuleToContentRole",
        "propertyTypeName": "userRegistrationTenantRuleToContentRoleCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleToContentRoleUpdatedBies": {
      "name": "userRegistrationTenantRuleToContentRoleUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userRegistrationTenantRuleToContentRole",
        "propertyTypeName": "userRegistrationTenantRuleToContentRoleUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingConfigurationCreatedBies": {
      "name": "partnerExportMappingConfigurationCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "partnerExportMappingConfiguration",
        "propertyTypeName": "partnerExportMappingConfigurationCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingConfigurationUpdatedBies": {
      "name": "partnerExportMappingConfigurationUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "partnerExportMappingConfiguration",
        "propertyTypeName": "partnerExportMappingConfigurationUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingCreatedBies": {
      "name": "partnerExportMappingCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "partnerExportMapping",
        "propertyTypeName": "partnerExportMappingCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingUpdatedBies": {
      "name": "partnerExportMappingUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "partnerExportMapping",
        "propertyTypeName": "partnerExportMappingUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingToRoomTypeCreatedBies": {
      "name": "partnerExportMappingToRoomTypeCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "partnerExportMappingToRoomType",
        "propertyTypeName": "partnerExportMappingToRoomTypeCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingToRoomTypeUpdatedBies": {
      "name": "partnerExportMappingToRoomTypeUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "partnerExportMappingToRoomType",
        "propertyTypeName": "partnerExportMappingToRoomTypeUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingConfigurationToFloorCreatedBies": {
      "name": "partnerExportMappingConfigurationToFloorCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "partnerExportMappingConfigurationToFloor",
        "propertyTypeName": "partnerExportMappingConfigurationToFloorCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingConfigurationToFloorUpdatedBies": {
      "name": "partnerExportMappingConfigurationToFloorUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "partnerExportMappingConfigurationToFloor",
        "propertyTypeName": "partnerExportMappingConfigurationToFloorUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemFactCreatedBies": {
      "name": "itemFactCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "itemFact",
        "propertyTypeName": "itemFactCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemFactUpdatedBies": {
      "name": "itemFactUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "itemFact",
        "propertyTypeName": "itemFactUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureFamilyCreatedBies": {
      "name": "featureFamilyCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "featureFamily",
        "propertyTypeName": "featureFamilyCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureFamilyUpdatedBies": {
      "name": "featureFamilyUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "featureFamily",
        "propertyTypeName": "featureFamilyUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureGroupCreatedBies": {
      "name": "featureGroupCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "featureGroup",
        "propertyTypeName": "featureGroupCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureGroupUpdatedBies": {
      "name": "featureGroupUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "featureGroup",
        "propertyTypeName": "featureGroupUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureCreatedBies": {
      "name": "featureCreatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "feature",
        "propertyTypeName": "featureCreatedBies",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureUpdatedBies": {
      "name": "featureUpdatedBies",
      "objectTypeName": "userCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "feature",
        "propertyTypeName": "featureUpdatedBies",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "userCompanies",
  "camelized": {
    "singular": "userCompany",
    "plural": "userCompanies",
    "id": "userCompanyId"
  },
  "capitalized": {
    "singular": "UserCompany",
    "plural": "UserCompanies",
    "id": "UserCompanyId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "campus",
      "roomConnector",
      "userCompany",
      "personCompany",
      "buildingType",
      "organization",
      "itemTypeFamily",
      "manufacturer",
      "itemType",
      "building",
      "mapScale",
      "structure",
      "structurePoint",
      "floor",
      "distributionCostType",
      "roomType",
      "roomTypeGroupToRoomType",
      "roomTypeGroupFloor",
      "roomTypeGroupBuilding",
      "costCenter",
      "costCenterBuilding",
      "costCenterFloor",
      "room",
      "roomPoint",
      "roomPointRoom",
      "roomPointSegment",
      "itemTypePoint",
      "dimensionType",
      "dimension",
      "dimensionRoom",
      "dimensionFloor",
      "dimensionBuilding",
      "factType",
      "fact",
      "personState",
      "personSecurityProfile",
      "person",
      "personToPersonType",
      "personToPerson",
      "roomAffectation",
      "workplaceType",
      "workplaceTypeItemType",
      "workplace",
      "item",
      "workplaceAffectation",
      "organizationFloor",
      "organizationBuilding",
      "roomTypeFloor",
      "roomTypeBuilding",
      "itemToPerson",
      "personToBuilding",
      "dimensionToPerson",
      "dimensionTypeToBuilding",
      "personWorkingLocation",
      "personToWorkplaceBooking",
      "personToRoomBooking",
      "personToDimensionBooking",
      "personCompanyToItemType",
      "personCompanyToRoomType",
      "personCompanyToItem",
      "legend",
      "openerPostMessageHost",
      "contentRole",
      "jupUserCompanyToJupRole",
      "contentRoleToBuilding",
      "contentRoleToUserCompany",
      "contentRoleToFloor",
      "partnerApiCredential",
      "apiUser",
      "apiUserToJupRole",
      "apiUserToContentRole",
      "jupUiTenantOperation",
      "contentRoleToJupUiTenantOperation",
      "userRegistrationTenantRule",
      "userRegistrationTenantRuleToJupRole",
      "userRegistrationTenantRuleToContentRole",
      "partnerExportMappingConfiguration",
      "partnerExportMapping",
      "partnerExportMappingToRoomType",
      "partnerExportMappingConfigurationToFloor",
      "itemFact",
      "featureFamily",
      "featureGroup",
      "feature"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const personGenderObjectTypeDefintion = {
  "name": "personGender",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personGender",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "personGender",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personGender",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personGender",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personGender",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "people": {
      "name": "people",
      "objectTypeName": "personGender",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personGenderId",
        "targetModelName": "person",
        "propertyTypeName": "people",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "personGenders",
  "camelized": {
    "singular": "personGender",
    "plural": "personGenders",
    "id": "personGenderId"
  },
  "capitalized": {
    "singular": "PersonGender",
    "plural": "PersonGenders",
    "id": "PersonGenderId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "person"
    ],
    "belongsTo": []
  }
};
const personCompanyObjectTypeDefintion = {
  "name": "personCompany",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personCompany",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "personCompany",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "comment": {
      "name": "comment",
      "objectTypeName": "personCompany",
      "type": "text-md",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "contact": {
      "name": "contact",
      "objectTypeName": "personCompany",
      "type": "text-md",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "documents": {
      "name": "documents",
      "objectTypeName": "personCompany",
      "type": "url",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personCompany",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personCompany",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personCompany",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "people": {
      "name": "people",
      "objectTypeName": "personCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "person",
        "propertyTypeName": "people",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToItemTypes": {
      "name": "personCompanyToItemTypes",
      "objectTypeName": "personCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompanyToItemType",
        "propertyTypeName": "personCompanyToItemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToRoomTypes": {
      "name": "personCompanyToRoomTypes",
      "objectTypeName": "personCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompanyToRoomType",
        "propertyTypeName": "personCompanyToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToItems": {
      "name": "personCompanyToItems",
      "objectTypeName": "personCompany",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompanyToItem",
        "propertyTypeName": "personCompanyToItems",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personCompanies",
  "camelized": {
    "singular": "personCompany",
    "plural": "personCompanies",
    "id": "personCompanyId"
  },
  "capitalized": {
    "singular": "PersonCompany",
    "plural": "PersonCompanies",
    "id": "PersonCompanyId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "person",
      "personCompanyToItemType",
      "personCompanyToRoomType",
      "personCompanyToItem"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const jupUiLayoutObjectTypeDefintion = {
  "name": "jupUiLayout",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupUiLayout",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupUiLayout",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupUiLayout",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupUiLayout",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupUiLayout",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "buildings": {
      "name": "buildings",
      "objectTypeName": "jupUiLayout",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiLayoutId",
        "targetModelName": "building",
        "propertyTypeName": "buildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupUiLayouts": {
      "name": "jupRoleToJupUiLayouts",
      "objectTypeName": "jupUiLayout",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiLayoutId",
        "targetModelName": "jupRoleToJupUiLayout",
        "propertyTypeName": "jupRoleToJupUiLayouts",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupUiLayouts",
  "camelized": {
    "singular": "jupUiLayout",
    "plural": "jupUiLayouts",
    "id": "jupUiLayoutId"
  },
  "capitalized": {
    "singular": "JupUiLayout",
    "plural": "JupUiLayouts",
    "id": "JupUiLayoutId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "building",
      "jupRoleToJupUiLayout"
    ],
    "belongsTo": []
  }
};
const buildingTypeObjectTypeDefintion = {
  "name": "buildingType",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "buildingType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "buildingType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "buildingType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "buildingType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "buildingType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "buildingType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "buildingType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "buildingType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": false
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "buildingType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "buildingType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "buildingType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "buildingType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "buildingType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "buildings": {
      "name": "buildings",
      "objectTypeName": "buildingType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingTypeId",
        "targetModelName": "building",
        "propertyTypeName": "buildings",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "buildingTypes",
  "camelized": {
    "singular": "buildingType",
    "plural": "buildingTypes",
    "id": "buildingTypeId"
  },
  "capitalized": {
    "singular": "BuildingType",
    "plural": "BuildingTypes",
    "id": "BuildingTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "building"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const organizationObjectTypeDefintion = {
  "name": "organization",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "organization",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "organization",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "organization",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "organization",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "organization",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "organization",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "organization",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "organizationId": {
      "name": "organizationId",
      "objectTypeName": "organization",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organization": {
      "name": "organization",
      "objectTypeName": "organization",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizations": {
      "name": "organizations",
      "objectTypeName": "organization",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organizations",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "organization",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "organization",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "organization",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "organization",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "organization",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "people": {
      "name": "people",
      "objectTypeName": "organization",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "person",
        "propertyTypeName": "people",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaces": {
      "name": "workplaces",
      "objectTypeName": "organization",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplaces",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationFloors": {
      "name": "organizationFloors",
      "objectTypeName": "organization",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organizationFloor",
        "propertyTypeName": "organizationFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationBuildings": {
      "name": "organizationBuildings",
      "objectTypeName": "organization",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organizationBuilding",
        "propertyTypeName": "organizationBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "organization",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "organization",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "organizations",
  "camelized": {
    "singular": "organization",
    "plural": "organizations",
    "id": "organizationId"
  },
  "capitalized": {
    "singular": "Organization",
    "plural": "Organizations",
    "id": "OrganizationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "organization",
      "room",
      "person",
      "workplace",
      "organizationFloor",
      "organizationBuilding"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const itemTypeFamilyObjectTypeDefintion = {
  "name": "itemTypeFamily",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "itemTypeFamily",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "itemTypeFamily",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "itemTypeFamily",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "itemTypeFamily",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "itemTypeFamily",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "itemTypeFamily",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "itemTypeFamily",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "itemTypeFamily",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "itemTypeFamily",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "itemTypeFamily",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypes": {
      "name": "itemTypes",
      "objectTypeName": "itemTypeFamily",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeFamilyId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "itemTypeFamily",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "itemTypeFamily",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "itemTypeFamilies",
  "camelized": {
    "singular": "itemTypeFamily",
    "plural": "itemTypeFamilies",
    "id": "itemTypeFamilyId"
  },
  "capitalized": {
    "singular": "ItemTypeFamily",
    "plural": "ItemTypeFamilies",
    "id": "ItemTypeFamilyId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "itemType"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const manufacturerObjectTypeDefintion = {
  "name": "manufacturer",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "manufacturer",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "manufacturer",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "website": {
      "name": "website",
      "objectTypeName": "manufacturer",
      "type": "url",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "manufacturer",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "manufacturer",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "manufacturer",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "manufacturer",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "manufacturer",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "manufacturer",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "manufacturer",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypes": {
      "name": "itemTypes",
      "objectTypeName": "manufacturer",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "manufacturerId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "manufacturer",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "manufacturer",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "manufacturers",
  "camelized": {
    "singular": "manufacturer",
    "plural": "manufacturers",
    "id": "manufacturerId"
  },
  "capitalized": {
    "singular": "Manufacturer",
    "plural": "Manufacturers",
    "id": "ManufacturerId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "itemType"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const object3dModelObjectTypeDefintion = {
  "name": "object3dModel",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "object3dModel",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "object3dModel",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "type": {
      "name": "type",
      "objectTypeName": "object3dModel",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "obj"
      }
    },
    "rotation": {
      "name": "rotation",
      "objectTypeName": "object3dModel",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "origin": {
      "name": "origin",
      "objectTypeName": "object3dModel",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "X"
      }
    },
    "model": {
      "name": "model",
      "objectTypeName": "object3dModel",
      "type": "model3d",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "object3dModel",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "object3dModel",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "object3dModel",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "itemTypes": {
      "name": "itemTypes",
      "objectTypeName": "object3dModel",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "object3dModelId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemTypes",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "object3dModels",
  "camelized": {
    "singular": "object3dModel",
    "plural": "object3dModels",
    "id": "object3dModelId"
  },
  "capitalized": {
    "singular": "Object3dModel",
    "plural": "Object3dModels",
    "id": "Object3dModelId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "itemType"
    ],
    "belongsTo": []
  }
};
const itemTypeObjectTypeDefintion = {
  "name": "itemType",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "itemType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "itemType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "picture": {
      "name": "picture",
      "objectTypeName": "itemType",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "displayItemReferenceInMap": {
      "name": "displayItemReferenceInMap",
      "objectTypeName": "itemType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "itemType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "icon": {
      "name": "icon",
      "objectTypeName": "itemType",
      "type": "icon",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "itemType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "#FFFFFF"
      }
    },
    "height": {
      "name": "height",
      "objectTypeName": "itemType",
      "type": "distance",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "unit": {
          "type": "distance",
          "value": "centimeter"
        },
        "defaultValue": 0
      }
    },
    "zIndex": {
      "name": "zIndex",
      "objectTypeName": "itemType",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "description": {
      "name": "description",
      "objectTypeName": "itemType",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "price": {
      "name": "price",
      "objectTypeName": "itemType",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "itemType",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "itemType",
      "type": "weight",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "iconShape": {
      "name": "iconShape",
      "objectTypeName": "itemType",
      "type": "icon-shape",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "circle"
      }
    },
    "iconBackgroundColor": {
      "name": "iconBackgroundColor",
      "objectTypeName": "itemType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "#000000"
      }
    },
    "iconBorderColor": {
      "name": "iconBorderColor",
      "objectTypeName": "itemType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "isAffectable": {
      "name": "isAffectable",
      "objectTypeName": "itemType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "excludeFromPathfinding": {
      "name": "excludeFromPathfinding",
      "objectTypeName": "itemType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "itemType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "itemType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "itemType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "itemTypeFamilyId": {
      "name": "itemTypeFamilyId",
      "objectTypeName": "itemType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemTypeFamilyId",
        "targetModelName": "itemTypeFamily",
        "propertyTypeName": "itemTypeFamily",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemTypeFamily": {
      "name": "itemTypeFamily",
      "objectTypeName": "itemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeFamilyId",
        "targetModelName": "itemTypeFamily",
        "propertyTypeName": "itemTypeFamily",
        "options": {
          "readOnly": false
        }
      }
    },
    "manufacturerId": {
      "name": "manufacturerId",
      "objectTypeName": "itemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "manufacturerId",
        "targetModelName": "manufacturer",
        "propertyTypeName": "manufacturer",
        "options": {
          "readOnly": false
        }
      }
    },
    "manufacturer": {
      "name": "manufacturer",
      "objectTypeName": "itemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "manufacturerId",
        "targetModelName": "manufacturer",
        "propertyTypeName": "manufacturer",
        "options": {
          "readOnly": false
        }
      }
    },
    "object3dModelId": {
      "name": "object3dModelId",
      "objectTypeName": "itemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "object3dModelId",
        "targetModelName": "object3dModel",
        "propertyTypeName": "object3dModel",
        "options": {
          "readOnly": false
        }
      }
    },
    "object3dModel": {
      "name": "object3dModel",
      "objectTypeName": "itemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "object3dModelId",
        "targetModelName": "object3dModel",
        "propertyTypeName": "object3dModel",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "itemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "itemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "itemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "itemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemTypePoints": {
      "name": "itemTypePoints",
      "objectTypeName": "itemType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemTypePoint",
        "propertyTypeName": "itemTypePoints",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceTypeItemTypes": {
      "name": "workplaceTypeItemTypes",
      "objectTypeName": "itemType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "workplaceTypeItemType",
        "propertyTypeName": "workplaceTypeItemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "items": {
      "name": "items",
      "objectTypeName": "itemType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "item",
        "propertyTypeName": "items",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToItemTypes": {
      "name": "personCompanyToItemTypes",
      "objectTypeName": "itemType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "personCompanyToItemType",
        "propertyTypeName": "personCompanyToItemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "itemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "itemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "itemTypes",
  "camelized": {
    "singular": "itemType",
    "plural": "itemTypes",
    "id": "itemTypeId"
  },
  "capitalized": {
    "singular": "ItemType",
    "plural": "ItemTypes",
    "id": "ItemTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "itemTypePoint",
      "workplaceTypeItemType",
      "item",
      "personCompanyToItemType"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const buildingObjectTypeDefintion = {
  "name": "building",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "building",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "building",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "building",
      "type": "color",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "surface": {
      "name": "surface",
      "objectTypeName": "building",
      "type": "surface",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "leaseStartDate": {
      "name": "leaseStartDate",
      "objectTypeName": "building",
      "type": "date",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "leaseEndDate": {
      "name": "leaseEndDate",
      "objectTypeName": "building",
      "type": "date",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "purchaseDate": {
      "name": "purchaseDate",
      "objectTypeName": "building",
      "type": "date",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "documents": {
      "name": "documents",
      "objectTypeName": "building",
      "type": "url",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "picture": {
      "name": "picture",
      "objectTypeName": "building",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "regulatoryCapacity": {
      "name": "regulatoryCapacity",
      "objectTypeName": "building",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "parkingSpaceCount": {
      "name": "parkingSpaceCount",
      "objectTypeName": "building",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "constructionYear": {
      "name": "constructionYear",
      "objectTypeName": "building",
      "type": "year",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "yearlyCondominiumFees": {
      "name": "yearlyCondominiumFees",
      "objectTypeName": "building",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "yearlyRent": {
      "name": "yearlyRent",
      "objectTypeName": "building",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "yearlyParkingRent": {
      "name": "yearlyParkingRent",
      "objectTypeName": "building",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "yearlyTaxFees": {
      "name": "yearlyTaxFees",
      "objectTypeName": "building",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "yearlyExploitationFees": {
      "name": "yearlyExploitationFees",
      "objectTypeName": "building",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "rentReferenceIndex": {
      "name": "rentReferenceIndex",
      "objectTypeName": "building",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "securityDeposit": {
      "name": "securityDeposit",
      "objectTypeName": "building",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "building",
      "type": "surface",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "building",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "building",
      "type": "surface-by-people",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "building",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "building",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "building",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "building",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "building",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "building",
      "type": "weight",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "building",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "building",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "dimensionPeopleCount": {
      "name": "dimensionPeopleCount",
      "objectTypeName": "building",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "address": {
      "name": "address",
      "objectTypeName": "building",
      "type": "address",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "building",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "building",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "building",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": false
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingTypeId": {
      "name": "buildingTypeId",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingTypeId",
        "targetModelName": "buildingType",
        "propertyTypeName": "buildingType",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingType": {
      "name": "buildingType",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingTypeId",
        "targetModelName": "buildingType",
        "propertyTypeName": "buildingType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyOwnerId": {
      "name": "userCompanyOwnerId",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyOwnerId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyOwner",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyOwner": {
      "name": "userCompanyOwner",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyOwnerId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyOwner",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiLayoutId": {
      "name": "jupUiLayoutId",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupUiLayoutId",
        "targetModelName": "jupUiLayout",
        "propertyTypeName": "jupUiLayout",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiLayout": {
      "name": "jupUiLayout",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiLayoutId",
        "targetModelName": "jupUiLayout",
        "propertyTypeName": "jupUiLayout",
        "options": {
          "readOnly": false
        }
      }
    },
    "campusId": {
      "name": "campusId",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "campusId",
        "targetModelName": "campus",
        "propertyTypeName": "campus",
        "options": {
          "readOnly": false
        }
      }
    },
    "campus": {
      "name": "campus",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "campusId",
        "targetModelName": "campus",
        "propertyTypeName": "campus",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildings": {
      "name": "buildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "buildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "building",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "building",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "floors": {
      "name": "floors",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "floor",
        "propertyTypeName": "floors",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeGroupBuildings": {
      "name": "roomTypeGroupBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "roomTypeGroupBuilding",
        "propertyTypeName": "roomTypeGroupBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenterBuildings": {
      "name": "costCenterBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "costCenterBuilding",
        "propertyTypeName": "costCenterBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionBuildings": {
      "name": "dimensionBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "dimensionBuilding",
        "propertyTypeName": "dimensionBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "facts": {
      "name": "facts",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "fact",
        "propertyTypeName": "facts",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationBuildings": {
      "name": "organizationBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "organizationBuilding",
        "propertyTypeName": "organizationBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeBuildings": {
      "name": "roomTypeBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "roomTypeBuilding",
        "propertyTypeName": "roomTypeBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToBuildings": {
      "name": "personToBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "personToBuilding",
        "propertyTypeName": "personToBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionTypeToBuildings": {
      "name": "dimensionTypeToBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "dimensionTypeToBuilding",
        "propertyTypeName": "dimensionTypeToBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleToBuildings": {
      "name": "contentRoleToBuildings",
      "objectTypeName": "building",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "contentRoleToBuilding",
        "propertyTypeName": "contentRoleToBuildings",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "buildings",
  "camelized": {
    "singular": "building",
    "plural": "buildings",
    "id": "buildingId"
  },
  "capitalized": {
    "singular": "Building",
    "plural": "Buildings",
    "id": "BuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "building",
      "floor",
      "roomTypeGroupBuilding",
      "costCenterBuilding",
      "dimensionBuilding",
      "fact",
      "organizationBuilding",
      "roomTypeBuilding",
      "personToBuilding",
      "dimensionTypeToBuilding",
      "contentRoleToBuilding"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const mapScaleObjectTypeDefintion = {
  "name": "mapScale",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "mapScale",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "mapScale",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "p1": {
      "name": "p1",
      "objectTypeName": "mapScale",
      "type": "point2d",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": {
          "x": 0,
          "y": 0
        }
      }
    },
    "p2": {
      "name": "p2",
      "objectTypeName": "mapScale",
      "type": "point2d",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": {
          "x": 0,
          "y": 0
        }
      }
    },
    "length": {
      "name": "length",
      "objectTypeName": "mapScale",
      "type": "distance",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "unit": {
          "type": "distance",
          "value": "meter"
        },
        "defaultValue": 0
      }
    },
    "ratio": {
      "name": "ratio",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "strokeWidth": {
      "name": "strokeWidth",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "roomTextSize": {
      "name": "roomTextSize",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 18
      }
    },
    "workplaceTextSize": {
      "name": "workplaceTextSize",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 12
      }
    },
    "segmentDistanceTextSize": {
      "name": "segmentDistanceTextSize",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 6
      }
    },
    "itemTypeIconSize": {
      "name": "itemTypeIconSize",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 12
      }
    },
    "roomIconSize": {
      "name": "roomIconSize",
      "objectTypeName": "mapScale",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 64
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "mapScale",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "mapScale",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "mapScale",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "mapScale",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "mapScale",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "mapScale",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "mapScale",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "floors": {
      "name": "floors",
      "objectTypeName": "mapScale",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "mapScaleId",
        "targetModelName": "floor",
        "propertyTypeName": "floors",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "mapScale",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "mapScale",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "mapScales",
  "camelized": {
    "singular": "mapScale",
    "plural": "mapScales",
    "id": "mapScaleId"
  },
  "capitalized": {
    "singular": "MapScale",
    "plural": "MapScales",
    "id": "MapScaleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "floor"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const structureObjectTypeDefintion = {
  "name": "structure",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "structure",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "structure",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "transform": {
      "name": "transform",
      "objectTypeName": "structure",
      "type": "transform",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "structure",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "structure",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "structure",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "structure",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "structure",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "structure",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "structure",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "structurePoints": {
      "name": "structurePoints",
      "objectTypeName": "structure",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "structureId",
        "targetModelName": "structurePoint",
        "propertyTypeName": "structurePoints",
        "options": {
          "readOnly": false
        }
      }
    },
    "floors": {
      "name": "floors",
      "objectTypeName": "structure",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "structureId",
        "targetModelName": "floor",
        "propertyTypeName": "floors",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "structure",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "structure",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "structures",
  "camelized": {
    "singular": "structure",
    "plural": "structures",
    "id": "structureId"
  },
  "capitalized": {
    "singular": "Structure",
    "plural": "Structures",
    "id": "StructureId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "structurePoint",
      "floor"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const structurePointObjectTypeDefintion = {
  "name": "structurePoint",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "structurePoint",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "x": {
      "name": "x",
      "objectTypeName": "structurePoint",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "y": {
      "name": "y",
      "objectTypeName": "structurePoint",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "sortIndex": {
      "name": "sortIndex",
      "objectTypeName": "structurePoint",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "structurePoint",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "structurePoint",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "structurePoint",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "structureId": {
      "name": "structureId",
      "objectTypeName": "structurePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "structureId",
        "targetModelName": "structure",
        "propertyTypeName": "structure",
        "options": {
          "readOnly": false
        }
      }
    },
    "structure": {
      "name": "structure",
      "objectTypeName": "structurePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "structureId",
        "targetModelName": "structure",
        "propertyTypeName": "structure",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "structurePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "structurePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "structurePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "structurePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "structurePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "structurePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "structurePoints",
  "camelized": {
    "singular": "structurePoint",
    "plural": "structurePoints",
    "id": "structurePointId"
  },
  "capitalized": {
    "singular": "StructurePoint",
    "plural": "StructurePoints",
    "id": "StructurePointId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const floorObjectTypeDefintion = {
  "name": "floor",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "floor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "floor",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "level": {
      "name": "level",
      "objectTypeName": "floor",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "height": {
      "name": "height",
      "objectTypeName": "floor",
      "type": "distance",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "unit": {
          "type": "distance",
          "value": "centimeter"
        },
        "defaultValue": 240
      }
    },
    "regulatoryCapacity": {
      "name": "regulatoryCapacity",
      "objectTypeName": "floor",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "floor",
      "type": "surface",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "floor",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "floor",
      "type": "surface-by-people",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "floor",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "floor",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "floor",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "floor",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "floor",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "floor",
      "type": "weight",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "floor",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "floor",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "backgroundLayout": {
      "name": "backgroundLayout",
      "objectTypeName": "floor",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "backgroundLayoutOpacity": {
      "name": "backgroundLayoutOpacity",
      "objectTypeName": "floor",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "pathfindingGraph": {
      "name": "pathfindingGraph",
      "objectTypeName": "floor",
      "type": "floor-navigation-graph",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "floor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "floor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "floor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "floor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "floor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "mapScaleId": {
      "name": "mapScaleId",
      "objectTypeName": "floor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "mapScaleId",
        "targetModelName": "mapScale",
        "propertyTypeName": "mapScale",
        "options": {
          "readOnly": false
        }
      }
    },
    "mapScale": {
      "name": "mapScale",
      "objectTypeName": "floor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "mapScaleId",
        "targetModelName": "mapScale",
        "propertyTypeName": "mapScale",
        "options": {
          "readOnly": false
        }
      }
    },
    "structureId": {
      "name": "structureId",
      "objectTypeName": "floor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "structureId",
        "targetModelName": "structure",
        "propertyTypeName": "structure",
        "options": {
          "readOnly": false
        }
      }
    },
    "structure": {
      "name": "structure",
      "objectTypeName": "floor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "structureId",
        "targetModelName": "structure",
        "propertyTypeName": "structure",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "floor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "floor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "floor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "floor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupFloors": {
      "name": "roomTypeGroupFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "roomTypeGroupFloor",
        "propertyTypeName": "roomTypeGroupFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenterFloors": {
      "name": "costCenterFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "costCenterFloor",
        "propertyTypeName": "costCenterFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPoints": {
      "name": "roomPoints",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPoints",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionFloors": {
      "name": "dimensionFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "dimensionFloor",
        "propertyTypeName": "dimensionFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationFloors": {
      "name": "organizationFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "organizationFloor",
        "propertyTypeName": "organizationFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeFloors": {
      "name": "roomTypeFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "roomTypeFloor",
        "propertyTypeName": "roomTypeFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleToFloors": {
      "name": "contentRoleToFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "contentRoleToFloor",
        "propertyTypeName": "contentRoleToFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "partnerExportMappingConfigurationToFloors": {
      "name": "partnerExportMappingConfigurationToFloors",
      "objectTypeName": "floor",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "partnerExportMappingConfigurationToFloor",
        "propertyTypeName": "partnerExportMappingConfigurationToFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "floor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "floor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "floors",
  "camelized": {
    "singular": "floor",
    "plural": "floors",
    "id": "floorId"
  },
  "capitalized": {
    "singular": "Floor",
    "plural": "Floors",
    "id": "FloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomTypeGroupFloor",
      "costCenterFloor",
      "room",
      "roomPoint",
      "dimensionFloor",
      "organizationFloor",
      "roomTypeFloor",
      "contentRoleToFloor",
      "partnerExportMappingConfigurationToFloor"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const distributionCostTypeObjectTypeDefintion = {
  "name": "distributionCostType",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "distributionCostType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "distributionCostType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "distributionCostType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "distributionCostType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "distributionCostType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "distributionCostType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "distributionCostType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "distributionCostType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "distributionCostType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "distributionCostType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypes": {
      "name": "roomTypes",
      "objectTypeName": "distributionCostType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "distributionCostTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "distributionCostType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "distributionCostTypeId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "distributionCostType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "distributionCostType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "distributionCostTypes",
  "camelized": {
    "singular": "distributionCostType",
    "plural": "distributionCostTypes",
    "id": "distributionCostTypeId"
  },
  "capitalized": {
    "singular": "DistributionCostType",
    "plural": "DistributionCostTypes",
    "id": "DistributionCostTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomType",
      "room"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const roomTypeGroupObjectTypeDefintion = {
  "name": "roomTypeGroup",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomTypeGroup",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "roomTypeGroup",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "roomTypeGroup",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "roomTypeGroup",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "exclude": {
      "name": "exclude",
      "objectTypeName": "roomTypeGroup",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomTypeGroup",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomTypeGroup",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomTypeGroup",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomTypeGroupToRoomTypes": {
      "name": "roomTypeGroupToRoomTypes",
      "objectTypeName": "roomTypeGroup",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroupToRoomType",
        "propertyTypeName": "roomTypeGroupToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeGroupFloors": {
      "name": "roomTypeGroupFloors",
      "objectTypeName": "roomTypeGroup",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroupFloor",
        "propertyTypeName": "roomTypeGroupFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeGroupBuildings": {
      "name": "roomTypeGroupBuildings",
      "objectTypeName": "roomTypeGroup",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroupBuilding",
        "propertyTypeName": "roomTypeGroupBuildings",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "roomTypeGroups",
  "camelized": {
    "singular": "roomTypeGroup",
    "plural": "roomTypeGroups",
    "id": "roomTypeGroupId"
  },
  "capitalized": {
    "singular": "RoomTypeGroup",
    "plural": "RoomTypeGroups",
    "id": "RoomTypeGroupId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomTypeGroupToRoomType",
      "roomTypeGroupFloor",
      "roomTypeGroupBuilding"
    ],
    "belongsTo": []
  }
};
const roomTypeObjectTypeDefintion = {
  "name": "roomType",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "roomType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "roomType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "icon": {
      "name": "icon",
      "objectTypeName": "roomType",
      "type": "icon",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color3d": {
      "name": "color3d",
      "objectTypeName": "roomType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "roomType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "displayWallsOn3d": {
      "name": "displayWallsOn3d",
      "objectTypeName": "roomType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": true
      }
    },
    "cadence": {
      "name": "cadence",
      "objectTypeName": "roomType",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "isBookable": {
      "name": "isBookable",
      "objectTypeName": "roomType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "distributionCostTypeId": {
      "name": "distributionCostTypeId",
      "objectTypeName": "roomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "distributionCostTypeId",
        "targetModelName": "distributionCostType",
        "propertyTypeName": "distributionCostType",
        "options": {
          "readOnly": false
        }
      }
    },
    "distributionCostType": {
      "name": "distributionCostType",
      "objectTypeName": "roomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "distributionCostTypeId",
        "targetModelName": "distributionCostType",
        "propertyTypeName": "distributionCostType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomTypeGroupToRoomTypes": {
      "name": "roomTypeGroupToRoomTypes",
      "objectTypeName": "roomType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomTypeGroupToRoomType",
        "propertyTypeName": "roomTypeGroupToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "roomType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeFloors": {
      "name": "roomTypeFloors",
      "objectTypeName": "roomType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomTypeFloor",
        "propertyTypeName": "roomTypeFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeBuildings": {
      "name": "roomTypeBuildings",
      "objectTypeName": "roomType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomTypeBuilding",
        "propertyTypeName": "roomTypeBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToRoomTypes": {
      "name": "personCompanyToRoomTypes",
      "objectTypeName": "roomType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "personCompanyToRoomType",
        "propertyTypeName": "personCompanyToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "partnerExportMappingToRoomTypes": {
      "name": "partnerExportMappingToRoomTypes",
      "objectTypeName": "roomType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "partnerExportMappingToRoomType",
        "propertyTypeName": "partnerExportMappingToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomTypes",
  "camelized": {
    "singular": "roomType",
    "plural": "roomTypes",
    "id": "roomTypeId"
  },
  "capitalized": {
    "singular": "RoomType",
    "plural": "RoomTypes",
    "id": "RoomTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomTypeGroupToRoomType",
      "room",
      "roomTypeFloor",
      "roomTypeBuilding",
      "personCompanyToRoomType",
      "partnerExportMappingToRoomType"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const roomTypeGroupToRoomTypeObjectTypeDefintion = {
  "name": "roomTypeGroupToRoomType",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomTypeGroupId": {
      "name": "roomTypeGroupId",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroup",
        "propertyTypeName": "roomTypeGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeGroup": {
      "name": "roomTypeGroup",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroup",
        "propertyTypeName": "roomTypeGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeId": {
      "name": "roomTypeId",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomType": {
      "name": "roomType",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomTypeGroupToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomTypeGroupToRoomTypes",
  "camelized": {
    "singular": "roomTypeGroupToRoomType",
    "plural": "roomTypeGroupToRoomTypes",
    "id": "roomTypeGroupToRoomTypeId"
  },
  "capitalized": {
    "singular": "RoomTypeGroupToRoomType",
    "plural": "RoomTypeGroupToRoomTypes",
    "id": "RoomTypeGroupToRoomTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomTypeGroupFloorObjectTypeDefintion = {
  "name": "roomTypeGroupFloor",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomTypeGroupId": {
      "name": "roomTypeGroupId",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroup",
        "propertyTypeName": "roomTypeGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeGroup": {
      "name": "roomTypeGroup",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroup",
        "propertyTypeName": "roomTypeGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomTypeGroupFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomTypeGroupFloors",
  "camelized": {
    "singular": "roomTypeGroupFloor",
    "plural": "roomTypeGroupFloors",
    "id": "roomTypeGroupFloorId"
  },
  "capitalized": {
    "singular": "RoomTypeGroupFloor",
    "plural": "RoomTypeGroupFloors",
    "id": "RoomTypeGroupFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomTypeGroupBuildingObjectTypeDefintion = {
  "name": "roomTypeGroupBuilding",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomTypeGroupId": {
      "name": "roomTypeGroupId",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroup",
        "propertyTypeName": "roomTypeGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeGroup": {
      "name": "roomTypeGroup",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeGroupId",
        "targetModelName": "roomTypeGroup",
        "propertyTypeName": "roomTypeGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomTypeGroupBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomTypeGroupBuildings",
  "camelized": {
    "singular": "roomTypeGroupBuilding",
    "plural": "roomTypeGroupBuildings",
    "id": "roomTypeGroupBuildingId"
  },
  "capitalized": {
    "singular": "RoomTypeGroupBuilding",
    "plural": "RoomTypeGroupBuildings",
    "id": "RoomTypeGroupBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const costCenterObjectTypeDefintion = {
  "name": "costCenter",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "costCenter",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "costCenter",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "costCenter",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "info": {
      "name": "info",
      "objectTypeName": "costCenter",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "distributeByFloor": {
      "name": "distributeByFloor",
      "objectTypeName": "costCenter",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "distributeByBuilding": {
      "name": "distributeByBuilding",
      "objectTypeName": "costCenter",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "costCenter",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "costCenter",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "costCenter",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "costCenter",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "costCenter",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "costCenter",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "costCenter",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "costCenter",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "costCenterBuildings": {
      "name": "costCenterBuildings",
      "objectTypeName": "costCenter",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenterBuilding",
        "propertyTypeName": "costCenterBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenterFloors": {
      "name": "costCenterFloors",
      "objectTypeName": "costCenter",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenterFloor",
        "propertyTypeName": "costCenterFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "rooms": {
      "name": "rooms",
      "objectTypeName": "costCenter",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "room",
        "propertyTypeName": "rooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "people": {
      "name": "people",
      "objectTypeName": "costCenter",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "person",
        "propertyTypeName": "people",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaces": {
      "name": "workplaces",
      "objectTypeName": "costCenter",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplaces",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "costCenter",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "costCenter",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "costCenters",
  "camelized": {
    "singular": "costCenter",
    "plural": "costCenters",
    "id": "costCenterId"
  },
  "capitalized": {
    "singular": "CostCenter",
    "plural": "CostCenters",
    "id": "CostCenterId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "costCenterBuilding",
      "costCenterFloor",
      "room",
      "person",
      "workplace"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const costCenterBuildingObjectTypeDefintion = {
  "name": "costCenterBuilding",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "costCenterBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "costCenterBuilding",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "costCenterBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "costCenterBuilding",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "costCenterBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "costCenterBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "costCenterBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "costCenterBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "costCenterBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "costCenterId": {
      "name": "costCenterId",
      "objectTypeName": "costCenterBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenter": {
      "name": "costCenter",
      "objectTypeName": "costCenterBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "costCenterBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "costCenterBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "costCenterBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "costCenterBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "costCenterBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "costCenterBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "costCenterBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "costCenterBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "costCenterBuildings",
  "camelized": {
    "singular": "costCenterBuilding",
    "plural": "costCenterBuildings",
    "id": "costCenterBuildingId"
  },
  "capitalized": {
    "singular": "CostCenterBuilding",
    "plural": "CostCenterBuildings",
    "id": "CostCenterBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const costCenterFloorObjectTypeDefintion = {
  "name": "costCenterFloor",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "costCenterFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "costCenterFloor",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "costCenterFloor",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "costCenterFloor",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "costCenterFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "costCenterFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "costCenterFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "costCenterFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "costCenterFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "costCenterFloor",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "costCenterFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "costCenterFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "costCenterFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "costCenterFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "costCenterFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "costCenterId": {
      "name": "costCenterId",
      "objectTypeName": "costCenterFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenter": {
      "name": "costCenter",
      "objectTypeName": "costCenterFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "costCenterFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "costCenterFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "costCenterFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "costCenterFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "costCenterFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "costCenterFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "costCenterFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "costCenterFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "costCenterFloors",
  "camelized": {
    "singular": "costCenterFloor",
    "plural": "costCenterFloors",
    "id": "costCenterFloorId"
  },
  "capitalized": {
    "singular": "CostCenterFloor",
    "plural": "CostCenterFloors",
    "id": "CostCenterFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomObjectTypeDefintion = {
  "name": "room",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "room",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "room",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "prettyName": {
      "name": "prettyName",
      "objectTypeName": "room",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "area": {
      "name": "area",
      "objectTypeName": "room",
      "type": "surface",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false
      }
    },
    "perimeter": {
      "name": "perimeter",
      "objectTypeName": "room",
      "type": "distance",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "distance",
          "value": "meter"
        },
        "defaultValue": 0
      }
    },
    "textAnchor": {
      "name": "textAnchor",
      "objectTypeName": "room",
      "type": "textAnchor",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "capacity": {
      "name": "capacity",
      "objectTypeName": "room",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "room",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "room",
      "type": "surface-by-people",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "room",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "room",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "room",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "room",
      "type": "percentage",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "room",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "room",
      "type": "weight",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "room",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "room",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "info": {
      "name": "info",
      "objectTypeName": "room",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "bookingEmail": {
      "name": "bookingEmail",
      "objectTypeName": "room",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "externalId2": {
      "name": "externalId2",
      "objectTypeName": "room",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "picture": {
      "name": "picture",
      "objectTypeName": "room",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "keyCylinderCode": {
      "name": "keyCylinderCode",
      "objectTypeName": "room",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "livePeopleCount": {
      "name": "livePeopleCount",
      "objectTypeName": "room",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "room",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "room",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "room",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "occupancyStatusId": {
      "name": "occupancyStatusId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "occupancyStatusId",
        "targetModelName": "occupancyStatus",
        "propertyTypeName": "occupancyStatus",
        "options": {
          "readOnly": false
        }
      }
    },
    "occupancyStatus": {
      "name": "occupancyStatus",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "occupancyStatusId",
        "targetModelName": "occupancyStatus",
        "propertyTypeName": "occupancyStatus",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeId": {
      "name": "roomTypeId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomType": {
      "name": "roomType",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationId": {
      "name": "organizationId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organization": {
      "name": "organization",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenterId": {
      "name": "costCenterId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenter": {
      "name": "costCenter",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "distributionCostTypeId": {
      "name": "distributionCostTypeId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "distributionCostTypeId",
        "targetModelName": "distributionCostType",
        "propertyTypeName": "distributionCostType",
        "options": {
          "readOnly": false
        }
      }
    },
    "distributionCostType": {
      "name": "distributionCostType",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "distributionCostTypeId",
        "targetModelName": "distributionCostType",
        "propertyTypeName": "distributionCostType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomConnectorId": {
      "name": "roomConnectorId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomConnectorId",
        "targetModelName": "roomConnector",
        "propertyTypeName": "roomConnector",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomConnector": {
      "name": "roomConnector",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomConnectorId",
        "targetModelName": "roomConnector",
        "propertyTypeName": "roomConnector",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointRooms": {
      "name": "roomPointRooms",
      "objectTypeName": "room",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "roomPointRoom",
        "propertyTypeName": "roomPointRooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionRooms": {
      "name": "dimensionRooms",
      "objectTypeName": "room",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "dimensionRoom",
        "propertyTypeName": "dimensionRooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomAffectations": {
      "name": "roomAffectations",
      "objectTypeName": "room",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "roomAffectation",
        "propertyTypeName": "roomAffectations",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaces": {
      "name": "workplaces",
      "objectTypeName": "room",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplaces",
        "options": {
          "readOnly": false
        }
      }
    },
    "items": {
      "name": "items",
      "objectTypeName": "room",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "item",
        "propertyTypeName": "items",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToRoomBookings": {
      "name": "personToRoomBookings",
      "objectTypeName": "room",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "personToRoomBooking",
        "propertyTypeName": "personToRoomBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "room",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "room",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "rooms",
  "camelized": {
    "singular": "room",
    "plural": "rooms",
    "id": "roomId"
  },
  "capitalized": {
    "singular": "Room",
    "plural": "Rooms",
    "id": "RoomId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomPointRoom",
      "dimensionRoom",
      "roomAffectation",
      "workplace",
      "item",
      "personToRoomBooking"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const roomPointObjectTypeDefintion = {
  "name": "roomPoint",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomPoint",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "x": {
      "name": "x",
      "objectTypeName": "roomPoint",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "y": {
      "name": "y",
      "objectTypeName": "roomPoint",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomPoint",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomPoint",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomPoint",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "roomPoint",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "roomPoint",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomPoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomPoint",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomPoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomPoint",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "roomPointRooms": {
      "name": "roomPointRooms",
      "objectTypeName": "roomPoint",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointId",
        "targetModelName": "roomPointRoom",
        "propertyTypeName": "roomPointRooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointSegmentStarts": {
      "name": "roomPointSegmentStarts",
      "objectTypeName": "roomPoint",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointStartId",
        "targetModelName": "roomPointSegment",
        "propertyTypeName": "roomPointSegmentStarts",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointSegmentEnds": {
      "name": "roomPointSegmentEnds",
      "objectTypeName": "roomPoint",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointEndId",
        "targetModelName": "roomPointSegment",
        "propertyTypeName": "roomPointSegmentEnds",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomPoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomPoint",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomPoints",
  "camelized": {
    "singular": "roomPoint",
    "plural": "roomPoints",
    "id": "roomPointId"
  },
  "capitalized": {
    "singular": "RoomPoint",
    "plural": "RoomPoints",
    "id": "RoomPointId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomPointRoom",
      "roomPointSegment"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const roomPointRoomObjectTypeDefintion = {
  "name": "roomPointRoom",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomPointRoom",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "sortIndex": {
      "name": "sortIndex",
      "objectTypeName": "roomPointRoom",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomPointRoom",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomPointRoom",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomPointRoom",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomId": {
      "name": "roomId",
      "objectTypeName": "roomPointRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "room": {
      "name": "room",
      "objectTypeName": "roomPointRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointId": {
      "name": "roomPointId",
      "objectTypeName": "roomPointRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomPointId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPoint",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPoint": {
      "name": "roomPoint",
      "objectTypeName": "roomPointRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPoint",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomPointRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomPointRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomPointRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomPointRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomPointRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomPointRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomPointRooms",
  "camelized": {
    "singular": "roomPointRoom",
    "plural": "roomPointRooms",
    "id": "roomPointRoomId"
  },
  "capitalized": {
    "singular": "RoomPointRoom",
    "plural": "RoomPointRooms",
    "id": "RoomPointRoomId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomPointSegmentTypeObjectTypeDefintion = {
  "name": "roomPointSegmentType",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomPointSegmentType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "roomPointSegmentType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "roomPointSegmentType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomPointSegmentType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomPointSegmentType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomPointSegmentType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomPointSegments": {
      "name": "roomPointSegments",
      "objectTypeName": "roomPointSegmentType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointSegmentTypeId",
        "targetModelName": "roomPointSegment",
        "propertyTypeName": "roomPointSegments",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "roomPointSegmentTypes",
  "camelized": {
    "singular": "roomPointSegmentType",
    "plural": "roomPointSegmentTypes",
    "id": "roomPointSegmentTypeId"
  },
  "capitalized": {
    "singular": "RoomPointSegmentType",
    "plural": "RoomPointSegmentTypes",
    "id": "RoomPointSegmentTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "roomPointSegment"
    ],
    "belongsTo": []
  }
};
const roomPointSegmentObjectTypeDefintion = {
  "name": "roomPointSegment",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomPointSegment",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "reversePoints": {
      "name": "reversePoints",
      "objectTypeName": "roomPointSegment",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "displayBothSides": {
      "name": "displayBothSides",
      "objectTypeName": "roomPointSegment",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomPointSegment",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomPointSegment",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomPointSegment",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomPointSegmentTypeId": {
      "name": "roomPointSegmentTypeId",
      "objectTypeName": "roomPointSegment",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomPointSegmentTypeId",
        "targetModelName": "roomPointSegmentType",
        "propertyTypeName": "roomPointSegmentType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointSegmentType": {
      "name": "roomPointSegmentType",
      "objectTypeName": "roomPointSegment",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointSegmentTypeId",
        "targetModelName": "roomPointSegmentType",
        "propertyTypeName": "roomPointSegmentType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointStartId": {
      "name": "roomPointStartId",
      "objectTypeName": "roomPointSegment",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomPointStartId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPointStart",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointStart": {
      "name": "roomPointStart",
      "objectTypeName": "roomPointSegment",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointStartId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPointStart",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointEndId": {
      "name": "roomPointEndId",
      "objectTypeName": "roomPointSegment",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomPointEndId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPointEnd",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomPointEnd": {
      "name": "roomPointEnd",
      "objectTypeName": "roomPointSegment",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomPointEndId",
        "targetModelName": "roomPoint",
        "propertyTypeName": "roomPointEnd",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomPointSegment",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomPointSegment",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomPointSegment",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomPointSegment",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomPointSegment",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomPointSegment",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomPointSegments",
  "camelized": {
    "singular": "roomPointSegment",
    "plural": "roomPointSegments",
    "id": "roomPointSegmentId"
  },
  "capitalized": {
    "singular": "RoomPointSegment",
    "plural": "RoomPointSegments",
    "id": "RoomPointSegmentId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const itemTypePointObjectTypeDefintion = {
  "name": "itemTypePoint",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "itemTypePoint",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "x": {
      "name": "x",
      "objectTypeName": "itemTypePoint",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "y": {
      "name": "y",
      "objectTypeName": "itemTypePoint",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "sortIndex": {
      "name": "sortIndex",
      "objectTypeName": "itemTypePoint",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "itemTypePoint",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "itemTypePoint",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "itemTypePoint",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "itemTypeId": {
      "name": "itemTypeId",
      "objectTypeName": "itemTypePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemType": {
      "name": "itemType",
      "objectTypeName": "itemTypePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "itemTypePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "itemTypePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "itemTypePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "itemTypePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "itemTypePoint",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "itemTypePoint",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "itemTypePoints",
  "camelized": {
    "singular": "itemTypePoint",
    "plural": "itemTypePoints",
    "id": "itemTypePointId"
  },
  "capitalized": {
    "singular": "ItemTypePoint",
    "plural": "ItemTypePoints",
    "id": "ItemTypePointId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionTypeObjectTypeDefintion = {
  "name": "dimensionType",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimensionType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "dimensionType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "dimensionType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "order": {
      "name": "order",
      "objectTypeName": "dimensionType",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "description": {
      "name": "description",
      "objectTypeName": "dimensionType",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimensionType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimensionType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimensionType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimensionType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimensionType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimensionType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimensionType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensions": {
      "name": "dimensions",
      "objectTypeName": "dimensionType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimensions",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionRooms": {
      "name": "dimensionRooms",
      "objectTypeName": "dimensionType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionRoom",
        "propertyTypeName": "dimensionRooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionFloors": {
      "name": "dimensionFloors",
      "objectTypeName": "dimensionType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionFloor",
        "propertyTypeName": "dimensionFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionBuildings": {
      "name": "dimensionBuildings",
      "objectTypeName": "dimensionType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionBuilding",
        "propertyTypeName": "dimensionBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionTypeToBuildings": {
      "name": "dimensionTypeToBuildings",
      "objectTypeName": "dimensionType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionTypeToBuilding",
        "propertyTypeName": "dimensionTypeToBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimensionType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimensionType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensionTypes",
  "camelized": {
    "singular": "dimensionType",
    "plural": "dimensionTypes",
    "id": "dimensionTypeId"
  },
  "capitalized": {
    "singular": "DimensionType",
    "plural": "DimensionTypes",
    "id": "DimensionTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "dimension",
      "dimensionRoom",
      "dimensionFloor",
      "dimensionBuilding",
      "dimensionTypeToBuilding"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionObjectTypeDefintion = {
  "name": "dimension",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimension",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "dimension",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "dimension",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "value": {
      "name": "value",
      "objectTypeName": "dimension",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "dimension",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "dimension",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "manualPeopleCount": {
      "name": "manualPeopleCount",
      "objectTypeName": "dimension",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprintPerMeter": {
      "name": "carbonFootprintPerMeter",
      "objectTypeName": "dimension",
      "type": "weight",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimension",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimension",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimension",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionTypeId": {
      "name": "dimensionTypeId",
      "objectTypeName": "dimension",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionType": {
      "name": "dimensionType",
      "objectTypeName": "dimension",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimension",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimension",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimension",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimension",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "dimensionRooms": {
      "name": "dimensionRooms",
      "objectTypeName": "dimension",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimensionRoom",
        "propertyTypeName": "dimensionRooms",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionFloors": {
      "name": "dimensionFloors",
      "objectTypeName": "dimension",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimensionFloor",
        "propertyTypeName": "dimensionFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionBuildings": {
      "name": "dimensionBuildings",
      "objectTypeName": "dimension",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimensionBuilding",
        "propertyTypeName": "dimensionBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionToPeople": {
      "name": "dimensionToPeople",
      "objectTypeName": "dimension",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimensionToPerson",
        "propertyTypeName": "dimensionToPeople",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToDimensionBookings": {
      "name": "personToDimensionBookings",
      "objectTypeName": "dimension",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "personToDimensionBooking",
        "propertyTypeName": "personToDimensionBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimension",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimension",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensions",
  "camelized": {
    "singular": "dimension",
    "plural": "dimensions",
    "id": "dimensionId"
  },
  "capitalized": {
    "singular": "Dimension",
    "plural": "Dimensions",
    "id": "DimensionId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "dimensionRoom",
      "dimensionFloor",
      "dimensionBuilding",
      "dimensionToPerson",
      "personToDimensionBooking"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionRoomObjectTypeDefintion = {
  "name": "dimensionRoom",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimensionRoom",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimensionRoom",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimensionRoom",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimensionRoom",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionId": {
      "name": "dimensionId",
      "objectTypeName": "dimensionRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimension": {
      "name": "dimension",
      "objectTypeName": "dimensionRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomId": {
      "name": "roomId",
      "objectTypeName": "dimensionRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "room": {
      "name": "room",
      "objectTypeName": "dimensionRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionTypeId": {
      "name": "dimensionTypeId",
      "objectTypeName": "dimensionRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionType": {
      "name": "dimensionType",
      "objectTypeName": "dimensionRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimensionRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimensionRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimensionRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimensionRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimensionRoom",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimensionRoom",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensionRooms",
  "camelized": {
    "singular": "dimensionRoom",
    "plural": "dimensionRooms",
    "id": "dimensionRoomId"
  },
  "capitalized": {
    "singular": "DimensionRoom",
    "plural": "DimensionRooms",
    "id": "DimensionRoomId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionFloorObjectTypeDefintion = {
  "name": "dimensionFloor",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimensionFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "dimensionFloor",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "dimensionFloor",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "dimensionFloor",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "dimensionFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "dimensionFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "dimensionFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "dimensionFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "dimensionFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "dimensionFloor",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "dimensionFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "dimensionFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimensionFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimensionFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimensionFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionId": {
      "name": "dimensionId",
      "objectTypeName": "dimensionFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimension": {
      "name": "dimension",
      "objectTypeName": "dimensionFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionTypeId": {
      "name": "dimensionTypeId",
      "objectTypeName": "dimensionFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionType": {
      "name": "dimensionType",
      "objectTypeName": "dimensionFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "dimensionFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "dimensionFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimensionFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimensionFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimensionFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimensionFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimensionFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimensionFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensionFloors",
  "camelized": {
    "singular": "dimensionFloor",
    "plural": "dimensionFloors",
    "id": "dimensionFloorId"
  },
  "capitalized": {
    "singular": "DimensionFloor",
    "plural": "DimensionFloors",
    "id": "DimensionFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionBuildingObjectTypeDefintion = {
  "name": "dimensionBuilding",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimensionBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionPeopleCount": {
      "name": "dimensionPeopleCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "dimensionBuilding",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "dimensionBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "dimensionBuilding",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "dimensionBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "dimensionBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimensionBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimensionBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimensionBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionId": {
      "name": "dimensionId",
      "objectTypeName": "dimensionBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimension": {
      "name": "dimension",
      "objectTypeName": "dimensionBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionTypeId": {
      "name": "dimensionTypeId",
      "objectTypeName": "dimensionBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionType": {
      "name": "dimensionType",
      "objectTypeName": "dimensionBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "dimensionBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "dimensionBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimensionBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimensionBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimensionBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimensionBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimensionBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimensionBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensionBuildings",
  "camelized": {
    "singular": "dimensionBuilding",
    "plural": "dimensionBuildings",
    "id": "dimensionBuildingId"
  },
  "capitalized": {
    "singular": "DimensionBuilding",
    "plural": "DimensionBuildings",
    "id": "DimensionBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const factTypeObjectTypeDefintion = {
  "name": "factType",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "factType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "factType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "factType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "factType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "factType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "factType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "factType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "factType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "factType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "factType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "facts": {
      "name": "facts",
      "objectTypeName": "factType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "factTypeId",
        "targetModelName": "fact",
        "propertyTypeName": "facts",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "factType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "factType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "factTypes",
  "camelized": {
    "singular": "factType",
    "plural": "factTypes",
    "id": "factTypeId"
  },
  "capitalized": {
    "singular": "FactType",
    "plural": "FactTypes",
    "id": "FactTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "fact"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const factObjectTypeDefintion = {
  "name": "fact",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "fact",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "value": {
      "name": "value",
      "objectTypeName": "fact",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "date": {
      "name": "date",
      "objectTypeName": "fact",
      "type": "date",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "fact",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "fact",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "fact",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "factTypeId": {
      "name": "factTypeId",
      "objectTypeName": "fact",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "factTypeId",
        "targetModelName": "factType",
        "propertyTypeName": "factType",
        "options": {
          "readOnly": false
        }
      }
    },
    "factType": {
      "name": "factType",
      "objectTypeName": "fact",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "factTypeId",
        "targetModelName": "factType",
        "propertyTypeName": "factType",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "fact",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "fact",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "fact",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "fact",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "fact",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "fact",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "fact",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "fact",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "facts",
  "camelized": {
    "singular": "fact",
    "plural": "facts",
    "id": "factId"
  },
  "capitalized": {
    "singular": "Fact",
    "plural": "Facts",
    "id": "FactId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personStateObjectTypeDefintion = {
  "name": "personState",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personState",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "personState",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personState",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personState",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personState",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personState",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personState",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personState",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personState",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "people": {
      "name": "people",
      "objectTypeName": "personState",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personStateId",
        "targetModelName": "person",
        "propertyTypeName": "people",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personState",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personState",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personStates",
  "camelized": {
    "singular": "personState",
    "plural": "personStates",
    "id": "personStateId"
  },
  "capitalized": {
    "singular": "PersonState",
    "plural": "PersonStates",
    "id": "PersonStateId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "person"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const personSecurityProfileObjectTypeDefintion = {
  "name": "personSecurityProfile",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personSecurityProfile",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "personSecurityProfile",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "personSecurityProfile",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "icon": {
      "name": "icon",
      "objectTypeName": "personSecurityProfile",
      "type": "icon",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personSecurityProfile",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personSecurityProfile",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personSecurityProfile",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personSecurityProfile",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personSecurityProfile",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personSecurityProfile",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personSecurityProfile",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "people": {
      "name": "people",
      "objectTypeName": "personSecurityProfile",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personSecurityProfileId",
        "targetModelName": "person",
        "propertyTypeName": "people",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personSecurityProfile",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personSecurityProfile",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personSecurityProfiles",
  "camelized": {
    "singular": "personSecurityProfile",
    "plural": "personSecurityProfiles",
    "id": "personSecurityProfileId"
  },
  "capitalized": {
    "singular": "PersonSecurityProfile",
    "plural": "PersonSecurityProfiles",
    "id": "PersonSecurityProfileId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "person"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const personObjectTypeDefintion = {
  "name": "person",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "person",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "firstname": {
      "name": "firstname",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "lastname": {
      "name": "lastname",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "fullname": {
      "name": "fullname",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false
      }
    },
    "email": {
      "name": "email",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "picture": {
      "name": "picture",
      "objectTypeName": "person",
      "type": "image",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "title": {
      "name": "title",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "monitorReference": {
      "name": "monitorReference",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "computerReference": {
      "name": "computerReference",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "telephone": {
      "name": "telephone",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "cellphone": {
      "name": "cellphone",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "badgeNumber": {
      "name": "badgeNumber",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "badgeRestaurant": {
      "name": "badgeRestaurant",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "boxNumber": {
      "name": "boxNumber",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "registrationNumber": {
      "name": "registrationNumber",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "startDate": {
      "name": "startDate",
      "objectTypeName": "person",
      "type": "date",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "endDate": {
      "name": "endDate",
      "objectTypeName": "person",
      "type": "date",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "info": {
      "name": "info",
      "objectTypeName": "person",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "notAffectable": {
      "name": "notAffectable",
      "objectTypeName": "person",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "person",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "person",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "person",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanies": {
      "name": "userCompanies",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanies",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationId": {
      "name": "organizationId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organization": {
      "name": "organization",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "personStateId": {
      "name": "personStateId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personStateId",
        "targetModelName": "personState",
        "propertyTypeName": "personState",
        "options": {
          "readOnly": false
        }
      }
    },
    "personState": {
      "name": "personState",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personStateId",
        "targetModelName": "personState",
        "propertyTypeName": "personState",
        "options": {
          "readOnly": false
        }
      }
    },
    "personSecurityProfileId": {
      "name": "personSecurityProfileId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personSecurityProfileId",
        "targetModelName": "personSecurityProfile",
        "propertyTypeName": "personSecurityProfile",
        "options": {
          "readOnly": false
        }
      }
    },
    "personSecurityProfile": {
      "name": "personSecurityProfile",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personSecurityProfileId",
        "targetModelName": "personSecurityProfile",
        "propertyTypeName": "personSecurityProfile",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenterId": {
      "name": "costCenterId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenter": {
      "name": "costCenter",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyId": {
      "name": "personCompanyId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompany": {
      "name": "personCompany",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "personGenderId": {
      "name": "personGenderId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personGenderId",
        "targetModelName": "personGender",
        "propertyTypeName": "personGender",
        "options": {
          "readOnly": false
        }
      }
    },
    "personGender": {
      "name": "personGender",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personGenderId",
        "targetModelName": "personGender",
        "propertyTypeName": "personGender",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToPersonSources": {
      "name": "personToPersonSources",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personSourceId",
        "targetModelName": "personToPerson",
        "propertyTypeName": "personToPersonSources",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToPersonTargets": {
      "name": "personToPersonTargets",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personTargetId",
        "targetModelName": "personToPerson",
        "propertyTypeName": "personToPersonTargets",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomAffectations": {
      "name": "roomAffectations",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "roomAffectation",
        "propertyTypeName": "roomAffectations",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceAffectations": {
      "name": "workplaceAffectations",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "workplaceAffectation",
        "propertyTypeName": "workplaceAffectations",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemToPeople": {
      "name": "itemToPeople",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "itemToPerson",
        "propertyTypeName": "itemToPeople",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToBuildings": {
      "name": "personToBuildings",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "personToBuilding",
        "propertyTypeName": "personToBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionToPeople": {
      "name": "dimensionToPeople",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "dimensionToPerson",
        "propertyTypeName": "dimensionToPeople",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocations": {
      "name": "personWorkingLocations",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocations",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToWorkplaceBookings": {
      "name": "personToWorkplaceBookings",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "personToWorkplaceBooking",
        "propertyTypeName": "personToWorkplaceBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToRoomBookings": {
      "name": "personToRoomBookings",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "personToRoomBooking",
        "propertyTypeName": "personToRoomBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToDimensionBookings": {
      "name": "personToDimensionBookings",
      "objectTypeName": "person",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "personToDimensionBooking",
        "propertyTypeName": "personToDimensionBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "person",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "person",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "people",
  "camelized": {
    "singular": "person",
    "plural": "people",
    "id": "personId"
  },
  "capitalized": {
    "singular": "Person",
    "plural": "People",
    "id": "PersonId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "userCompany",
      "personToPerson",
      "roomAffectation",
      "workplaceAffectation",
      "itemToPerson",
      "personToBuilding",
      "dimensionToPerson",
      "personWorkingLocation",
      "personToWorkplaceBooking",
      "personToRoomBooking",
      "personToDimensionBooking"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const personToPersonTypeObjectTypeDefintion = {
  "name": "personToPersonType",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personToPersonType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "labelForward": {
      "name": "labelForward",
      "objectTypeName": "personToPersonType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "labelBackward": {
      "name": "labelBackward",
      "objectTypeName": "personToPersonType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "personToPersonType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personToPersonType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personToPersonType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personToPersonType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personToPersonType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personToPersonType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personToPersonType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personToPersonType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToPeople": {
      "name": "personToPeople",
      "objectTypeName": "personToPersonType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personToPersonTypeId",
        "targetModelName": "personToPerson",
        "propertyTypeName": "personToPeople",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personToPersonType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personToPersonType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personToPersonTypes",
  "camelized": {
    "singular": "personToPersonType",
    "plural": "personToPersonTypes",
    "id": "personToPersonTypeId"
  },
  "capitalized": {
    "singular": "PersonToPersonType",
    "plural": "PersonToPersonTypes",
    "id": "PersonToPersonTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "personToPerson"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const personToPersonObjectTypeDefintion = {
  "name": "personToPerson",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personToPerson",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personToPerson",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personToPerson",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personToPerson",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personToPersonTypeId": {
      "name": "personToPersonTypeId",
      "objectTypeName": "personToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personToPersonTypeId",
        "targetModelName": "personToPersonType",
        "propertyTypeName": "personToPersonType",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToPersonType": {
      "name": "personToPersonType",
      "objectTypeName": "personToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personToPersonTypeId",
        "targetModelName": "personToPersonType",
        "propertyTypeName": "personToPersonType",
        "options": {
          "readOnly": false
        }
      }
    },
    "personSourceId": {
      "name": "personSourceId",
      "objectTypeName": "personToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personSourceId",
        "targetModelName": "person",
        "propertyTypeName": "personSource",
        "options": {
          "readOnly": false
        }
      }
    },
    "personSource": {
      "name": "personSource",
      "objectTypeName": "personToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personSourceId",
        "targetModelName": "person",
        "propertyTypeName": "personSource",
        "options": {
          "readOnly": false
        }
      }
    },
    "personTargetId": {
      "name": "personTargetId",
      "objectTypeName": "personToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personTargetId",
        "targetModelName": "person",
        "propertyTypeName": "personTarget",
        "options": {
          "readOnly": false
        }
      }
    },
    "personTarget": {
      "name": "personTarget",
      "objectTypeName": "personToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personTargetId",
        "targetModelName": "person",
        "propertyTypeName": "personTarget",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personToPeople",
  "camelized": {
    "singular": "personToPerson",
    "plural": "personToPeople",
    "id": "personToPersonId"
  },
  "capitalized": {
    "singular": "PersonToPerson",
    "plural": "PersonToPeople",
    "id": "PersonToPersonId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomAffectationObjectTypeDefintion = {
  "name": "roomAffectation",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomAffectation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomAffectation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomAffectation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomAffectation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "roomAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "roomAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomId": {
      "name": "roomId",
      "objectTypeName": "roomAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "room": {
      "name": "room",
      "objectTypeName": "roomAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomAffectations",
  "camelized": {
    "singular": "roomAffectation",
    "plural": "roomAffectations",
    "id": "roomAffectationId"
  },
  "capitalized": {
    "singular": "RoomAffectation",
    "plural": "RoomAffectations",
    "id": "RoomAffectationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const workplaceTypeObjectTypeDefintion = {
  "name": "workplaceType",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "workplaceType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "workplaceType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "zIndex": {
      "name": "zIndex",
      "objectTypeName": "workplaceType",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "color": {
      "name": "color",
      "objectTypeName": "workplaceType",
      "type": "color",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "#FFFFFF"
      }
    },
    "center": {
      "name": "center",
      "objectTypeName": "workplaceType",
      "type": "point3d",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "size": {
      "name": "size",
      "objectTypeName": "workplaceType",
      "type": "size",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "workplaceType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "workplaceType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "workplaceType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "workplaceType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "workplaceType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "workplaceType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "workplaceType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "workplaceTypeItemTypes": {
      "name": "workplaceTypeItemTypes",
      "objectTypeName": "workplaceType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceTypeId",
        "targetModelName": "workplaceTypeItemType",
        "propertyTypeName": "workplaceTypeItemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaces": {
      "name": "workplaces",
      "objectTypeName": "workplaceType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceTypeId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplaces",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "workplaceType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "workplaceType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "workplaceTypes",
  "camelized": {
    "singular": "workplaceType",
    "plural": "workplaceTypes",
    "id": "workplaceTypeId"
  },
  "capitalized": {
    "singular": "WorkplaceType",
    "plural": "WorkplaceTypes",
    "id": "WorkplaceTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "workplaceTypeItemType",
      "workplace"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const workplaceTypeItemTypeObjectTypeDefintion = {
  "name": "workplaceTypeItemType",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "workplaceTypeItemType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "position": {
      "name": "position",
      "objectTypeName": "workplaceTypeItemType",
      "type": "point3d",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "physicalInventory": {
      "name": "physicalInventory",
      "objectTypeName": "workplaceTypeItemType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "rotation": {
      "name": "rotation",
      "objectTypeName": "workplaceTypeItemType",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "zIndex": {
      "name": "zIndex",
      "objectTypeName": "workplaceTypeItemType",
      "type": "integer",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "workplaceTypeItemType",
      "type": "integer-count",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "workplaceTypeItemType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "workplaceTypeItemType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "workplaceTypeItemType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "workplaceTypeId": {
      "name": "workplaceTypeId",
      "objectTypeName": "workplaceTypeItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "workplaceTypeId",
        "targetModelName": "workplaceType",
        "propertyTypeName": "workplaceType",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceType": {
      "name": "workplaceType",
      "objectTypeName": "workplaceTypeItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceTypeId",
        "targetModelName": "workplaceType",
        "propertyTypeName": "workplaceType",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemTypeId": {
      "name": "itemTypeId",
      "objectTypeName": "workplaceTypeItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemType": {
      "name": "itemType",
      "objectTypeName": "workplaceTypeItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "workplaceTypeItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "workplaceTypeItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "workplaceTypeItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "workplaceTypeItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "workplaceTypeItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "workplaceTypeItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "workplaceTypeItemTypes",
  "camelized": {
    "singular": "workplaceTypeItemType",
    "plural": "workplaceTypeItemTypes",
    "id": "workplaceTypeItemTypeId"
  },
  "capitalized": {
    "singular": "WorkplaceTypeItemType",
    "plural": "WorkplaceTypeItemTypes",
    "id": "WorkplaceTypeItemTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const workplaceObjectTypeDefintion = {
  "name": "workplace",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "workplace",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "position": {
      "name": "position",
      "objectTypeName": "workplace",
      "type": "point3d",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": {
          "x": 0,
          "y": 0,
          "z": 0
        }
      }
    },
    "rotation": {
      "name": "rotation",
      "objectTypeName": "workplace",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "isFlex": {
      "name": "isFlex",
      "objectTypeName": "workplace",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "isTransit": {
      "name": "isTransit",
      "objectTypeName": "workplace",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "isShared": {
      "name": "isShared",
      "objectTypeName": "workplace",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "textAnchor": {
      "name": "textAnchor",
      "objectTypeName": "workplace",
      "type": "textAnchor",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "workplace",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "workplaceAffectationsCalculatedRateSum": {
      "name": "workplaceAffectationsCalculatedRateSum",
      "objectTypeName": "workplace",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplaceAffectationsCount": {
      "name": "workplaceAffectationsCount",
      "objectTypeName": "workplace",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "comment": {
      "name": "comment",
      "objectTypeName": "workplace",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "isBookable": {
      "name": "isBookable",
      "objectTypeName": "workplace",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "workplace",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "workplace",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "workplace",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "workplaceTypeId": {
      "name": "workplaceTypeId",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "workplaceTypeId",
        "targetModelName": "workplaceType",
        "propertyTypeName": "workplaceType",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceType": {
      "name": "workplaceType",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceTypeId",
        "targetModelName": "workplaceType",
        "propertyTypeName": "workplaceType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomId": {
      "name": "roomId",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "room": {
      "name": "room",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "organizationId": {
      "name": "organizationId",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organization": {
      "name": "organization",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenterId": {
      "name": "costCenterId",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "costCenter": {
      "name": "costCenter",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "costCenterId",
        "targetModelName": "costCenter",
        "propertyTypeName": "costCenter",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "items": {
      "name": "items",
      "objectTypeName": "workplace",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "item",
        "propertyTypeName": "items",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceAffectations": {
      "name": "workplaceAffectations",
      "objectTypeName": "workplace",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplaceAffectation",
        "propertyTypeName": "workplaceAffectations",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToWorkplaceBookings": {
      "name": "personToWorkplaceBookings",
      "objectTypeName": "workplace",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "personToWorkplaceBooking",
        "propertyTypeName": "personToWorkplaceBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "workplace",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "workplace",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "workplaces",
  "camelized": {
    "singular": "workplace",
    "plural": "workplaces",
    "id": "workplaceId"
  },
  "capitalized": {
    "singular": "Workplace",
    "plural": "Workplaces",
    "id": "WorkplaceId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "item",
      "workplaceAffectation",
      "personToWorkplaceBooking"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const itemObjectTypeDefintion = {
  "name": "item",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "item",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "item",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "reference": {
      "name": "reference",
      "objectTypeName": "item",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "purchaseDate": {
      "name": "purchaseDate",
      "objectTypeName": "item",
      "type": "date",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "position": {
      "name": "position",
      "objectTypeName": "item",
      "type": "point3d",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "rotation": {
      "name": "rotation",
      "objectTypeName": "item",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "textAnchor": {
      "name": "textAnchor",
      "objectTypeName": "item",
      "type": "textAnchor",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": false
      }
    },
    "price": {
      "name": "price",
      "objectTypeName": "item",
      "type": "currency",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "itemAffectationsCount": {
      "name": "itemAffectationsCount",
      "objectTypeName": "item",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "item",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "item",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "item",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "itemTypeId": {
      "name": "itemTypeId",
      "objectTypeName": "item",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemType": {
      "name": "itemType",
      "objectTypeName": "item",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomId": {
      "name": "roomId",
      "objectTypeName": "item",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "room": {
      "name": "room",
      "objectTypeName": "item",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceId": {
      "name": "workplaceId",
      "objectTypeName": "item",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplace",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplace": {
      "name": "workplace",
      "objectTypeName": "item",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplace",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "item",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "item",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "item",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "item",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "itemToPeople": {
      "name": "itemToPeople",
      "objectTypeName": "item",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "itemToPerson",
        "propertyTypeName": "itemToPeople",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToItems": {
      "name": "personCompanyToItems",
      "objectTypeName": "item",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "personCompanyToItem",
        "propertyTypeName": "personCompanyToItems",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemFacts": {
      "name": "itemFacts",
      "objectTypeName": "item",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "itemFact",
        "propertyTypeName": "itemFacts",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "item",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "item",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "items",
  "camelized": {
    "singular": "item",
    "plural": "items",
    "id": "itemId"
  },
  "capitalized": {
    "singular": "Item",
    "plural": "Items",
    "id": "ItemId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "itemToPerson",
      "personCompanyToItem",
      "itemFact"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const workplaceAffectationObjectTypeDefintion = {
  "name": "workplaceAffectation",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "workplaceAffectation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "rate": {
      "name": "rate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "calculatedRate": {
      "name": "calculatedRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 1
      }
    },
    "mondayRate": {
      "name": "mondayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "tuesdayRate": {
      "name": "tuesdayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "wednesdayRate": {
      "name": "wednesdayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "thursdayRate": {
      "name": "thursdayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "fridayRate": {
      "name": "fridayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 1
      }
    },
    "saturdayRate": {
      "name": "saturdayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sundayRate": {
      "name": "sundayRate",
      "objectTypeName": "workplaceAffectation",
      "type": "percentage0-1",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "workplaceAffectation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "workplaceAffectation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "workplaceAffectation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "workplaceAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "workplaceAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceId": {
      "name": "workplaceId",
      "objectTypeName": "workplaceAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplace",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplace": {
      "name": "workplace",
      "objectTypeName": "workplaceAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplace",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "workplaceAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "workplaceAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "workplaceAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "workplaceAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "workplaceAffectation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "workplaceAffectation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "workplaceAffectations",
  "camelized": {
    "singular": "workplaceAffectation",
    "plural": "workplaceAffectations",
    "id": "workplaceAffectationId"
  },
  "capitalized": {
    "singular": "WorkplaceAffectation",
    "plural": "WorkplaceAffectations",
    "id": "WorkplaceAffectationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const organizationFloorObjectTypeDefintion = {
  "name": "organizationFloor",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "organizationFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "organizationFloor",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "organizationFloor",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "organizationFloor",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "organizationFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "organizationFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "organizationFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "organizationFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "organizationFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "organizationFloor",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "organizationFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "organizationFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "organizationFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "organizationFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "organizationFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "organizationId": {
      "name": "organizationId",
      "objectTypeName": "organizationFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organization": {
      "name": "organization",
      "objectTypeName": "organizationFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "organizationFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "organizationFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "organizationFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "organizationFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "organizationFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "organizationFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "organizationFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "organizationFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "organizationFloors",
  "camelized": {
    "singular": "organizationFloor",
    "plural": "organizationFloors",
    "id": "organizationFloorId"
  },
  "capitalized": {
    "singular": "OrganizationFloor",
    "plural": "OrganizationFloors",
    "id": "OrganizationFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const organizationBuildingObjectTypeDefintion = {
  "name": "organizationBuilding",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "organizationBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "organizationBuilding",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "organizationBuilding",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "organizationBuilding",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "organizationBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "organizationBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "organizationBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "organizationBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "organizationBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "organizationBuilding",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "organizationBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "organizationBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "organizationBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "organizationBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "organizationBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "organizationId": {
      "name": "organizationId",
      "objectTypeName": "organizationBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "organization": {
      "name": "organization",
      "objectTypeName": "organizationBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "organizationId",
        "targetModelName": "organization",
        "propertyTypeName": "organization",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "organizationBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "organizationBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "organizationBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "organizationBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "organizationBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "organizationBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "organizationBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "organizationBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "organizationBuildings",
  "camelized": {
    "singular": "organizationBuilding",
    "plural": "organizationBuildings",
    "id": "organizationBuildingId"
  },
  "capitalized": {
    "singular": "OrganizationBuilding",
    "plural": "OrganizationBuildings",
    "id": "OrganizationBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomTypeFloorObjectTypeDefintion = {
  "name": "roomTypeFloor",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomTypeFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "roomTypeFloor",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "roomTypeFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "roomTypeFloor",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "roomTypeFloor",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "roomTypeFloor",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomTypeFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomTypeFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomTypeFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomTypeId": {
      "name": "roomTypeId",
      "objectTypeName": "roomTypeFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomType": {
      "name": "roomType",
      "objectTypeName": "roomTypeFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "roomTypeFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "roomTypeFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomTypeFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomTypeFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomTypeFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomTypeFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomTypeFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomTypeFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomTypeFloors",
  "camelized": {
    "singular": "roomTypeFloor",
    "plural": "roomTypeFloors",
    "id": "roomTypeFloorId"
  },
  "capitalized": {
    "singular": "RoomTypeFloor",
    "plural": "RoomTypeFloors",
    "id": "RoomTypeFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const roomTypeBuildingObjectTypeDefintion = {
  "name": "roomTypeBuilding",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": true,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "roomTypeBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomsArea": {
      "name": "roomsArea",
      "objectTypeName": "roomTypeBuilding",
      "type": "surface",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "roomsCount": {
      "name": "roomsCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesCount": {
      "name": "workplacesCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "workplacesRatio": {
      "name": "workplacesRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "surface-by-workplace",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleCount": {
      "name": "peopleCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsCount": {
      "name": "seatsCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "peopleRatio": {
      "name": "peopleRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "surface-by-people",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "occupancyRate": {
      "name": "occupancyRate",
      "objectTypeName": "roomTypeBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "expansionRatio": {
      "name": "expansionRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "freeWorkplacesCount": {
      "name": "freeWorkplacesCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexWorkplacesCount": {
      "name": "flexWorkplacesCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesCount": {
      "name": "sharedWorkplacesCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "sharedWorkplacesRatio": {
      "name": "sharedWorkplacesRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "transitWorkplacesCount": {
      "name": "transitWorkplacesCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "flexRatio": {
      "name": "flexRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "percentage",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "seatsPeopleRatio": {
      "name": "seatsPeopleRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalPeopleCount": {
      "name": "totalPeopleCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "carbonFootprint": {
      "name": "carbonFootprint",
      "objectTypeName": "roomTypeBuilding",
      "type": "weight",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "unit": {
          "type": "weight",
          "value": "kilogram"
        },
        "defaultValue": 0
      }
    },
    "totalCapacityCount": {
      "name": "totalCapacityCount",
      "objectTypeName": "roomTypeBuilding",
      "type": "integer-count",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "totalCapacityWorkplaceCountRatio": {
      "name": "totalCapacityWorkplaceCountRatio",
      "objectTypeName": "roomTypeBuilding",
      "type": "percentage0-1",
      "options": {
        "mandatory": true,
        "readOnly": true,
        "calculated": true,
        "technical": false,
        "defaultValue": 0
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "roomTypeBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "roomTypeBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "roomTypeBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "roomTypeId": {
      "name": "roomTypeId",
      "objectTypeName": "roomTypeBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomType": {
      "name": "roomType",
      "objectTypeName": "roomTypeBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "roomTypeBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "roomTypeBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "roomTypeBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "roomTypeBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "roomTypeBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "roomTypeBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "roomTypeBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "roomTypeBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "roomTypeBuildings",
  "camelized": {
    "singular": "roomTypeBuilding",
    "plural": "roomTypeBuildings",
    "id": "roomTypeBuildingId"
  },
  "capitalized": {
    "singular": "RoomTypeBuilding",
    "plural": "RoomTypeBuildings",
    "id": "RoomTypeBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const itemToPersonObjectTypeDefintion = {
  "name": "itemToPerson",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "itemToPerson",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "itemToPerson",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "itemToPerson",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "itemToPerson",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "itemToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "itemToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemId": {
      "name": "itemId",
      "objectTypeName": "itemToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "item",
        "propertyTypeName": "item",
        "options": {
          "readOnly": false
        }
      }
    },
    "item": {
      "name": "item",
      "objectTypeName": "itemToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "item",
        "propertyTypeName": "item",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "itemToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "itemToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "itemToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "itemToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "itemToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "itemToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "itemToPeople",
  "camelized": {
    "singular": "itemToPerson",
    "plural": "itemToPeople",
    "id": "itemToPersonId"
  },
  "capitalized": {
    "singular": "ItemToPerson",
    "plural": "ItemToPeople",
    "id": "ItemToPersonId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personToBuildingObjectTypeDefintion = {
  "name": "personToBuilding",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personToBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "addToPeopleCount": {
      "name": "addToPeopleCount",
      "objectTypeName": "personToBuilding",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personToBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personToBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personToBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "personToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "personToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "personToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "personToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personToBuildings",
  "camelized": {
    "singular": "personToBuilding",
    "plural": "personToBuildings",
    "id": "personToBuildingId"
  },
  "capitalized": {
    "singular": "PersonToBuilding",
    "plural": "PersonToBuildings",
    "id": "PersonToBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionToPersonObjectTypeDefintion = {
  "name": "dimensionToPerson",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimensionToPerson",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimensionToPerson",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimensionToPerson",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimensionToPerson",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionId": {
      "name": "dimensionId",
      "objectTypeName": "dimensionToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimension": {
      "name": "dimension",
      "objectTypeName": "dimensionToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "dimensionToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "dimensionToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimensionToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimensionToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimensionToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimensionToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimensionToPerson",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimensionToPerson",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensionToPeople",
  "camelized": {
    "singular": "dimensionToPerson",
    "plural": "dimensionToPeople",
    "id": "dimensionToPersonId"
  },
  "capitalized": {
    "singular": "DimensionToPerson",
    "plural": "DimensionToPeople",
    "id": "DimensionToPersonId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const dimensionTypeToBuildingObjectTypeDefintion = {
  "name": "dimensionTypeToBuilding",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "dimensionTypeId": {
      "name": "dimensionTypeId",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionType": {
      "name": "dimensionType",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionTypeId",
        "targetModelName": "dimensionType",
        "propertyTypeName": "dimensionType",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "dimensionTypeToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "dimensionTypeToBuildings",
  "camelized": {
    "singular": "dimensionTypeToBuilding",
    "plural": "dimensionTypeToBuildings",
    "id": "dimensionTypeToBuildingId"
  },
  "capitalized": {
    "singular": "DimensionTypeToBuilding",
    "plural": "DimensionTypeToBuildings",
    "id": "DimensionTypeToBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const workingLocationObjectTypeDefintion = {
  "name": "workingLocation",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "workingLocation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "workingLocation",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "workingLocation",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "workingLocation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "workingLocation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "workingLocation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personWorkingLocations": {
      "name": "personWorkingLocations",
      "objectTypeName": "workingLocation",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocations",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "workingLocations",
  "camelized": {
    "singular": "workingLocation",
    "plural": "workingLocations",
    "id": "workingLocationId"
  },
  "capitalized": {
    "singular": "WorkingLocation",
    "plural": "WorkingLocations",
    "id": "WorkingLocationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "personWorkingLocation"
    ],
    "belongsTo": []
  }
};
const personWorkingLocationObjectTypeDefintion = {
  "name": "personWorkingLocation",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personWorkingLocation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "date": {
      "name": "date",
      "objectTypeName": "personWorkingLocation",
      "type": "date",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "daySlotType": {
      "name": "daySlotType",
      "objectTypeName": "personWorkingLocation",
      "type": "day-slot",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": null
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personWorkingLocation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personWorkingLocation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personWorkingLocation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "personWorkingLocation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "personWorkingLocation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "workingLocationId": {
      "name": "workingLocationId",
      "objectTypeName": "personWorkingLocation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "workingLocationId",
        "targetModelName": "workingLocation",
        "propertyTypeName": "workingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "workingLocation": {
      "name": "workingLocation",
      "objectTypeName": "personWorkingLocation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workingLocationId",
        "targetModelName": "workingLocation",
        "propertyTypeName": "workingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personWorkingLocation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personWorkingLocation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personWorkingLocation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personWorkingLocation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "personToWorkplaceBookings": {
      "name": "personToWorkplaceBookings",
      "objectTypeName": "personWorkingLocation",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personToWorkplaceBooking",
        "propertyTypeName": "personToWorkplaceBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToRoomBookings": {
      "name": "personToRoomBookings",
      "objectTypeName": "personWorkingLocation",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personToRoomBooking",
        "propertyTypeName": "personToRoomBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "personToDimensionBookings": {
      "name": "personToDimensionBookings",
      "objectTypeName": "personWorkingLocation",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personToDimensionBooking",
        "propertyTypeName": "personToDimensionBookings",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personWorkingLocation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personWorkingLocation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personWorkingLocations",
  "camelized": {
    "singular": "personWorkingLocation",
    "plural": "personWorkingLocations",
    "id": "personWorkingLocationId"
  },
  "capitalized": {
    "singular": "PersonWorkingLocation",
    "plural": "PersonWorkingLocations",
    "id": "PersonWorkingLocationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "personToWorkplaceBooking",
      "personToRoomBooking",
      "personToDimensionBooking"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const personToWorkplaceBookingObjectTypeDefintion = {
  "name": "personToWorkplaceBooking",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "startDatetime": {
      "name": "startDatetime",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "datetime",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "endDatetime": {
      "name": "endDatetime",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "datetime",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplaceId": {
      "name": "workplaceId",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplace",
        "options": {
          "readOnly": false
        }
      }
    },
    "workplace": {
      "name": "workplace",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "workplaceId",
        "targetModelName": "workplace",
        "propertyTypeName": "workplace",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocationId": {
      "name": "personWorkingLocationId",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocation": {
      "name": "personWorkingLocation",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personToWorkplaceBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personToWorkplaceBookings",
  "camelized": {
    "singular": "personToWorkplaceBooking",
    "plural": "personToWorkplaceBookings",
    "id": "personToWorkplaceBookingId"
  },
  "capitalized": {
    "singular": "PersonToWorkplaceBooking",
    "plural": "PersonToWorkplaceBookings",
    "id": "PersonToWorkplaceBookingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personToRoomBookingObjectTypeDefintion = {
  "name": "personToRoomBooking",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personToRoomBooking",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "startDatetime": {
      "name": "startDatetime",
      "objectTypeName": "personToRoomBooking",
      "type": "datetime",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "endDatetime": {
      "name": "endDatetime",
      "objectTypeName": "personToRoomBooking",
      "type": "datetime",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personToRoomBooking",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personToRoomBooking",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personToRoomBooking",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "personToRoomBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "personToRoomBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomId": {
      "name": "roomId",
      "objectTypeName": "personToRoomBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "room": {
      "name": "room",
      "objectTypeName": "personToRoomBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomId",
        "targetModelName": "room",
        "propertyTypeName": "room",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocationId": {
      "name": "personWorkingLocationId",
      "objectTypeName": "personToRoomBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocation": {
      "name": "personWorkingLocation",
      "objectTypeName": "personToRoomBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personToRoomBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personToRoomBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personToRoomBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personToRoomBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personToRoomBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personToRoomBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personToRoomBookings",
  "camelized": {
    "singular": "personToRoomBooking",
    "plural": "personToRoomBookings",
    "id": "personToRoomBookingId"
  },
  "capitalized": {
    "singular": "PersonToRoomBooking",
    "plural": "PersonToRoomBookings",
    "id": "PersonToRoomBookingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personToDimensionBookingObjectTypeDefintion = {
  "name": "personToDimensionBooking",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personToDimensionBooking",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "startDatetime": {
      "name": "startDatetime",
      "objectTypeName": "personToDimensionBooking",
      "type": "datetime",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "endDatetime": {
      "name": "endDatetime",
      "objectTypeName": "personToDimensionBooking",
      "type": "datetime",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personToDimensionBooking",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personToDimensionBooking",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personToDimensionBooking",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personId": {
      "name": "personId",
      "objectTypeName": "personToDimensionBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "person": {
      "name": "person",
      "objectTypeName": "personToDimensionBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personId",
        "targetModelName": "person",
        "propertyTypeName": "person",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimensionId": {
      "name": "dimensionId",
      "objectTypeName": "personToDimensionBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "dimension": {
      "name": "dimension",
      "objectTypeName": "personToDimensionBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "dimensionId",
        "targetModelName": "dimension",
        "propertyTypeName": "dimension",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocationId": {
      "name": "personWorkingLocationId",
      "objectTypeName": "personToDimensionBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "personWorkingLocation": {
      "name": "personWorkingLocation",
      "objectTypeName": "personToDimensionBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personWorkingLocationId",
        "targetModelName": "personWorkingLocation",
        "propertyTypeName": "personWorkingLocation",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personToDimensionBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personToDimensionBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personToDimensionBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personToDimensionBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personToDimensionBooking",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personToDimensionBooking",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personToDimensionBookings",
  "camelized": {
    "singular": "personToDimensionBooking",
    "plural": "personToDimensionBookings",
    "id": "personToDimensionBookingId"
  },
  "capitalized": {
    "singular": "PersonToDimensionBooking",
    "plural": "PersonToDimensionBookings",
    "id": "PersonToDimensionBookingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personCompanyMissionObjectTypeDefintion = {
  "name": "personCompanyMission",
  "type": "table",
  "scope": "public",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personCompanyMission",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "personCompanyMission",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personCompanyMission",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personCompanyMission",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personCompanyMission",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personCompanyToItemTypes": {
      "name": "personCompanyToItemTypes",
      "objectTypeName": "personCompanyMission",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyMissionId",
        "targetModelName": "personCompanyToItemType",
        "propertyTypeName": "personCompanyToItemTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyToRoomTypes": {
      "name": "personCompanyToRoomTypes",
      "objectTypeName": "personCompanyMission",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyMissionId",
        "targetModelName": "personCompanyToRoomType",
        "propertyTypeName": "personCompanyToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "personCompanyMissions",
  "camelized": {
    "singular": "personCompanyMission",
    "plural": "personCompanyMissions",
    "id": "personCompanyMissionId"
  },
  "capitalized": {
    "singular": "PersonCompanyMission",
    "plural": "PersonCompanyMissions",
    "id": "PersonCompanyMissionId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "personCompanyToItemType",
      "personCompanyToRoomType"
    ],
    "belongsTo": []
  }
};
const personCompanyToItemTypeObjectTypeDefintion = {
  "name": "personCompanyToItemType",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personCompanyToItemType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personCompanyToItemType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personCompanyToItemType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personCompanyToItemType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personCompanyId": {
      "name": "personCompanyId",
      "objectTypeName": "personCompanyToItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompany": {
      "name": "personCompany",
      "objectTypeName": "personCompanyToItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemTypeId": {
      "name": "itemTypeId",
      "objectTypeName": "personCompanyToItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemType": {
      "name": "itemType",
      "objectTypeName": "personCompanyToItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemTypeId",
        "targetModelName": "itemType",
        "propertyTypeName": "itemType",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyMissionId": {
      "name": "personCompanyMissionId",
      "objectTypeName": "personCompanyToItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personCompanyMissionId",
        "targetModelName": "personCompanyMission",
        "propertyTypeName": "personCompanyMission",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyMission": {
      "name": "personCompanyMission",
      "objectTypeName": "personCompanyToItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyMissionId",
        "targetModelName": "personCompanyMission",
        "propertyTypeName": "personCompanyMission",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personCompanyToItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personCompanyToItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personCompanyToItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personCompanyToItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personCompanyToItemType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personCompanyToItemType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personCompanyToItemTypes",
  "camelized": {
    "singular": "personCompanyToItemType",
    "plural": "personCompanyToItemTypes",
    "id": "personCompanyToItemTypeId"
  },
  "capitalized": {
    "singular": "PersonCompanyToItemType",
    "plural": "PersonCompanyToItemTypes",
    "id": "PersonCompanyToItemTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personCompanyToRoomTypeObjectTypeDefintion = {
  "name": "personCompanyToRoomType",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personCompanyToRoomType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personCompanyToRoomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personCompanyToRoomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personCompanyToRoomType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personCompanyId": {
      "name": "personCompanyId",
      "objectTypeName": "personCompanyToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompany": {
      "name": "personCompany",
      "objectTypeName": "personCompanyToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeId": {
      "name": "roomTypeId",
      "objectTypeName": "personCompanyToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomType": {
      "name": "roomType",
      "objectTypeName": "personCompanyToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyMissionId": {
      "name": "personCompanyMissionId",
      "objectTypeName": "personCompanyToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personCompanyMissionId",
        "targetModelName": "personCompanyMission",
        "propertyTypeName": "personCompanyMission",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompanyMission": {
      "name": "personCompanyMission",
      "objectTypeName": "personCompanyToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyMissionId",
        "targetModelName": "personCompanyMission",
        "propertyTypeName": "personCompanyMission",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personCompanyToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personCompanyToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personCompanyToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personCompanyToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personCompanyToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personCompanyToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personCompanyToRoomTypes",
  "camelized": {
    "singular": "personCompanyToRoomType",
    "plural": "personCompanyToRoomTypes",
    "id": "personCompanyToRoomTypeId"
  },
  "capitalized": {
    "singular": "PersonCompanyToRoomType",
    "plural": "PersonCompanyToRoomTypes",
    "id": "PersonCompanyToRoomTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const personCompanyToItemObjectTypeDefintion = {
  "name": "personCompanyToItem",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "personCompanyToItem",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "datetime": {
      "name": "datetime",
      "objectTypeName": "personCompanyToItem",
      "type": "datetime",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "comment": {
      "name": "comment",
      "objectTypeName": "personCompanyToItem",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "personCompanyToItem",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "personCompanyToItem",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "personCompanyToItem",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "personCompanyId": {
      "name": "personCompanyId",
      "objectTypeName": "personCompanyToItem",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "personCompany": {
      "name": "personCompany",
      "objectTypeName": "personCompanyToItem",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "personCompanyId",
        "targetModelName": "personCompany",
        "propertyTypeName": "personCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "itemId": {
      "name": "itemId",
      "objectTypeName": "personCompanyToItem",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "item",
        "propertyTypeName": "item",
        "options": {
          "readOnly": false
        }
      }
    },
    "item": {
      "name": "item",
      "objectTypeName": "personCompanyToItem",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "item",
        "propertyTypeName": "item",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "personCompanyToItem",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "personCompanyToItem",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "personCompanyToItem",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "personCompanyToItem",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "personCompanyToItem",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "personCompanyToItem",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "personCompanyToItems",
  "camelized": {
    "singular": "personCompanyToItem",
    "plural": "personCompanyToItems",
    "id": "personCompanyToItemId"
  },
  "capitalized": {
    "singular": "PersonCompanyToItem",
    "plural": "PersonCompanyToItems",
    "id": "PersonCompanyToItemId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const legendObjectTypeDefintion = {
  "name": "legend",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "legend",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "legend",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "configuration": {
      "name": "configuration",
      "objectTypeName": "legend",
      "type": "legend-configuration",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "legend",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "legend",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "legend",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "legend",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "legend",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "legend",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "legend",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "legend",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "legend",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "legends",
  "camelized": {
    "singular": "legend",
    "plural": "legends",
    "id": "legendId"
  },
  "capitalized": {
    "singular": "Legend",
    "plural": "Legends",
    "id": "LegendId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const openerPostMessageHostObjectTypeDefintion = {
  "name": "openerPostMessageHost",
  "type": "table",
  "scope": "private",
  "isMasterData": true,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "openerPostMessageHost",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "host": {
      "name": "host",
      "objectTypeName": "openerPostMessageHost",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "description": {
      "name": "description",
      "objectTypeName": "openerPostMessageHost",
      "type": "text",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "openerPostMessageHost",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "openerPostMessageHost",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "openerPostMessageHost",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "openerPostMessageHost",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "openerPostMessageHost",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "openerPostMessageHost",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "openerPostMessageHost",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "openerPostMessageHost",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "openerPostMessageHost",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "openerPostMessageHosts",
  "camelized": {
    "singular": "openerPostMessageHost",
    "plural": "openerPostMessageHosts",
    "id": "openerPostMessageHostId"
  },
  "capitalized": {
    "singular": "OpenerPostMessageHost",
    "plural": "OpenerPostMessageHosts",
    "id": "OpenerPostMessageHostId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const jupObjectTypeObjectTypeDefintion = {
  "name": "jupObjectType",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupObjectType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupObjectType",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupObjectType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupObjectType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupObjectType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUiViews": {
      "name": "jupUiViews",
      "objectTypeName": "jupObjectType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupObjectTypeId",
        "targetModelName": "jupUiView",
        "propertyTypeName": "jupUiViews",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupObjectTypes": {
      "name": "jupRoleToJupObjectTypes",
      "objectTypeName": "jupObjectType",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupObjectTypeId",
        "targetModelName": "jupRoleToJupObjectType",
        "propertyTypeName": "jupRoleToJupObjectTypes",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupObjectTypes",
  "camelized": {
    "singular": "jupObjectType",
    "plural": "jupObjectTypes",
    "id": "jupObjectTypeId"
  },
  "capitalized": {
    "singular": "JupObjectType",
    "plural": "JupObjectTypes",
    "id": "JupObjectTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "jupUiView",
      "jupRoleToJupObjectType"
    ],
    "belongsTo": []
  }
};
const jupUiViewObjectTypeDefintion = {
  "name": "jupUiView",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupUiView",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupUiView",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "isDefaultView": {
      "name": "isDefaultView",
      "objectTypeName": "jupUiView",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": "false"
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupUiView",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupUiView",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupUiView",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupObjectTypeId": {
      "name": "jupObjectTypeId",
      "objectTypeName": "jupUiView",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupObjectTypeId",
        "targetModelName": "jupObjectType",
        "propertyTypeName": "jupObjectType",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupObjectType": {
      "name": "jupObjectType",
      "objectTypeName": "jupUiView",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupObjectTypeId",
        "targetModelName": "jupObjectType",
        "propertyTypeName": "jupObjectType",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupUiViews": {
      "name": "jupRoleToJupUiViews",
      "objectTypeName": "jupUiView",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiViewId",
        "targetModelName": "jupRoleToJupUiView",
        "propertyTypeName": "jupRoleToJupUiViews",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupUiViews",
  "camelized": {
    "singular": "jupUiView",
    "plural": "jupUiViews",
    "id": "jupUiViewId"
  },
  "capitalized": {
    "singular": "JupUiView",
    "plural": "JupUiViews",
    "id": "JupUiViewId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "jupRoleToJupUiView"
    ],
    "belongsTo": []
  }
};
const jupRoleObjectTypeDefintion = {
  "name": "jupRole",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "jupRole",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUserCompanyToJupRoles": {
      "name": "jupUserCompanyToJupRoles",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupUserCompanyToJupRole",
        "propertyTypeName": "jupUserCompanyToJupRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupUiViews": {
      "name": "jupRoleToJupUiViews",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRoleToJupUiView",
        "propertyTypeName": "jupRoleToJupUiViews",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupObjectTypes": {
      "name": "jupRoleToJupObjectTypes",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRoleToJupObjectType",
        "propertyTypeName": "jupRoleToJupObjectTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupUiOptions": {
      "name": "jupRoleToJupUiOptions",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRoleToJupUiOption",
        "propertyTypeName": "jupRoleToJupUiOptions",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupUiOperations": {
      "name": "jupRoleToJupUiOperations",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRoleToJupUiOperation",
        "propertyTypeName": "jupRoleToJupUiOperations",
        "options": {
          "readOnly": false
        }
      }
    },
    "apiUserToJupRoles": {
      "name": "apiUserToJupRoles",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "apiUserToJupRole",
        "propertyTypeName": "apiUserToJupRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "userRegistrationTenantRuleToJupRoles": {
      "name": "userRegistrationTenantRuleToJupRoles",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "userRegistrationTenantRuleToJupRole",
        "propertyTypeName": "userRegistrationTenantRuleToJupRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleToJupUiLayouts": {
      "name": "jupRoleToJupUiLayouts",
      "objectTypeName": "jupRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRoleToJupUiLayout",
        "propertyTypeName": "jupRoleToJupUiLayouts",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupRoles",
  "camelized": {
    "singular": "jupRole",
    "plural": "jupRoles",
    "id": "jupRoleId"
  },
  "capitalized": {
    "singular": "JupRole",
    "plural": "JupRoles",
    "id": "JupRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "jupUserCompanyToJupRole",
      "jupRoleToJupUiView",
      "jupRoleToJupObjectType",
      "jupRoleToJupUiOption",
      "jupRoleToJupUiOperation",
      "apiUserToJupRole",
      "userRegistrationTenantRuleToJupRole",
      "jupRoleToJupUiLayout"
    ],
    "belongsTo": []
  }
};
const jupUiOptionObjectTypeDefintion = {
  "name": "jupUiOption",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupUiOption",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupUiOption",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "scope": {
      "name": "scope",
      "objectTypeName": "jupUiOption",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupUiOption",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupUiOption",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupUiOption",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupRoleToJupUiOptions": {
      "name": "jupRoleToJupUiOptions",
      "objectTypeName": "jupUiOption",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiOptionId",
        "targetModelName": "jupRoleToJupUiOption",
        "propertyTypeName": "jupRoleToJupUiOptions",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupUiOptions",
  "camelized": {
    "singular": "jupUiOption",
    "plural": "jupUiOptions",
    "id": "jupUiOptionId"
  },
  "capitalized": {
    "singular": "JupUiOption",
    "plural": "JupUiOptions",
    "id": "JupUiOptionId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "jupRoleToJupUiOption"
    ],
    "belongsTo": []
  }
};
const jupUiOperationObjectTypeDefintion = {
  "name": "jupUiOperation",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupUiOperation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupUiOperation",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupUiOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupUiOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupUiOperation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupRoleToJupUiOperations": {
      "name": "jupRoleToJupUiOperations",
      "objectTypeName": "jupUiOperation",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiOperationId",
        "targetModelName": "jupRoleToJupUiOperation",
        "propertyTypeName": "jupRoleToJupUiOperations",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupUiOperations",
  "camelized": {
    "singular": "jupUiOperation",
    "plural": "jupUiOperations",
    "id": "jupUiOperationId"
  },
  "capitalized": {
    "singular": "JupUiOperation",
    "plural": "JupUiOperations",
    "id": "JupUiOperationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "jupRoleToJupUiOperation"
    ],
    "belongsTo": []
  }
};
const contentRoleObjectTypeDefintion = {
  "name": "contentRole",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "contentRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "contentRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "contentRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "contentRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "contentRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "contentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "contentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "contentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "contentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToBuildings": {
      "name": "contentRoleToBuildings",
      "objectTypeName": "contentRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRoleToBuilding",
        "propertyTypeName": "contentRoleToBuildings",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleToUserCompanies": {
      "name": "contentRoleToUserCompanies",
      "objectTypeName": "contentRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRoleToUserCompany",
        "propertyTypeName": "contentRoleToUserCompanies",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleToFloors": {
      "name": "contentRoleToFloors",
      "objectTypeName": "contentRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRoleToFloor",
        "propertyTypeName": "contentRoleToFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "apiUserToContentRoles": {
      "name": "apiUserToContentRoles",
      "objectTypeName": "contentRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "apiUserToContentRole",
        "propertyTypeName": "apiUserToContentRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleToJupUiTenantOperations": {
      "name": "contentRoleToJupUiTenantOperations",
      "objectTypeName": "contentRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRoleToJupUiTenantOperation",
        "propertyTypeName": "contentRoleToJupUiTenantOperations",
        "options": {
          "readOnly": false
        }
      }
    },
    "userRegistrationTenantRuleToContentRoles": {
      "name": "userRegistrationTenantRuleToContentRoles",
      "objectTypeName": "contentRole",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "userRegistrationTenantRuleToContentRole",
        "propertyTypeName": "userRegistrationTenantRuleToContentRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "contentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "contentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "contentRoles",
  "camelized": {
    "singular": "contentRole",
    "plural": "contentRoles",
    "id": "contentRoleId"
  },
  "capitalized": {
    "singular": "ContentRole",
    "plural": "ContentRoles",
    "id": "ContentRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "contentRoleToBuilding",
      "contentRoleToUserCompany",
      "contentRoleToFloor",
      "apiUserToContentRole",
      "contentRoleToJupUiTenantOperation",
      "userRegistrationTenantRuleToContentRole"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const jupUserCompanyToJupRoleObjectTypeDefintion = {
  "name": "jupUserCompanyToJupRole",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyId": {
      "name": "userCompanyId",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompany": {
      "name": "userCompany",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "jupUserCompanyToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "jupUserCompanyToJupRoles",
  "camelized": {
    "singular": "jupUserCompanyToJupRole",
    "plural": "jupUserCompanyToJupRoles",
    "id": "jupUserCompanyToJupRoleId"
  },
  "capitalized": {
    "singular": "JupUserCompanyToJupRole",
    "plural": "JupUserCompanyToJupRoles",
    "id": "JupUserCompanyToJupRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const jupRoleToJupUiViewObjectTypeDefintion = {
  "name": "jupRoleToJupUiView",
  "type": "many-to-many",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "canSee": {
      "name": "canSee",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUiViewId": {
      "name": "jupUiViewId",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupUiViewId",
        "targetModelName": "jupUiView",
        "propertyTypeName": "jupUiView",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiView": {
      "name": "jupUiView",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiViewId",
        "targetModelName": "jupUiView",
        "propertyTypeName": "jupUiView",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "jupRoleToJupUiView",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupRoleToJupUiViews",
  "camelized": {
    "singular": "jupRoleToJupUiView",
    "plural": "jupRoleToJupUiViews",
    "id": "jupRoleToJupUiViewId"
  },
  "capitalized": {
    "singular": "JupRoleToJupUiView",
    "plural": "JupRoleToJupUiViews",
    "id": "JupRoleToJupUiViewId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": []
  }
};
const jupRoleToJupObjectTypeObjectTypeDefintion = {
  "name": "jupRoleToJupObjectType",
  "type": "many-to-many",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "arCreate": {
      "name": "arCreate",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "arRead": {
      "name": "arRead",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "arUpdate": {
      "name": "arUpdate",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "arDelete": {
      "name": "arDelete",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupObjectTypeId": {
      "name": "jupObjectTypeId",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupObjectTypeId",
        "targetModelName": "jupObjectType",
        "propertyTypeName": "jupObjectType",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupObjectType": {
      "name": "jupObjectType",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupObjectTypeId",
        "targetModelName": "jupObjectType",
        "propertyTypeName": "jupObjectType",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "jupRoleToJupObjectType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupRoleToJupObjectTypes",
  "camelized": {
    "singular": "jupRoleToJupObjectType",
    "plural": "jupRoleToJupObjectTypes",
    "id": "jupRoleToJupObjectTypeId"
  },
  "capitalized": {
    "singular": "JupRoleToJupObjectType",
    "plural": "JupRoleToJupObjectTypes",
    "id": "JupRoleToJupObjectTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": []
  }
};
const jupRoleToJupUiOptionObjectTypeDefintion = {
  "name": "jupRoleToJupUiOption",
  "type": "many-to-many",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "canSee": {
      "name": "canSee",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUiOptionId": {
      "name": "jupUiOptionId",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupUiOptionId",
        "targetModelName": "jupUiOption",
        "propertyTypeName": "jupUiOption",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiOption": {
      "name": "jupUiOption",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiOptionId",
        "targetModelName": "jupUiOption",
        "propertyTypeName": "jupUiOption",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "jupRoleToJupUiOption",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupRoleToJupUiOptions",
  "camelized": {
    "singular": "jupRoleToJupUiOption",
    "plural": "jupRoleToJupUiOptions",
    "id": "jupRoleToJupUiOptionId"
  },
  "capitalized": {
    "singular": "JupRoleToJupUiOption",
    "plural": "JupRoleToJupUiOptions",
    "id": "JupRoleToJupUiOptionId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": []
  }
};
const jupRoleToJupUiOperationObjectTypeDefintion = {
  "name": "jupRoleToJupUiOperation",
  "type": "many-to-many",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "canSee": {
      "name": "canSee",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUiOperationId": {
      "name": "jupUiOperationId",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupUiOperationId",
        "targetModelName": "jupUiOperation",
        "propertyTypeName": "jupUiOperation",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiOperation": {
      "name": "jupUiOperation",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiOperationId",
        "targetModelName": "jupUiOperation",
        "propertyTypeName": "jupUiOperation",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "jupRoleToJupUiOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupRoleToJupUiOperations",
  "camelized": {
    "singular": "jupRoleToJupUiOperation",
    "plural": "jupRoleToJupUiOperations",
    "id": "jupRoleToJupUiOperationId"
  },
  "capitalized": {
    "singular": "JupRoleToJupUiOperation",
    "plural": "JupRoleToJupUiOperations",
    "id": "JupRoleToJupUiOperationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": []
  }
};
const contentRoleToBuildingObjectTypeDefintion = {
  "name": "contentRoleToBuilding",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "contentRoleToBuilding",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "contentRoleToBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "contentRoleToBuilding",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "contentRoleToBuilding",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "contentRoleId": {
      "name": "contentRoleId",
      "objectTypeName": "contentRoleToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRole": {
      "name": "contentRole",
      "objectTypeName": "contentRoleToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "buildingId": {
      "name": "buildingId",
      "objectTypeName": "contentRoleToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "building": {
      "name": "building",
      "objectTypeName": "contentRoleToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "buildingId",
        "targetModelName": "building",
        "propertyTypeName": "building",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "contentRoleToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "contentRoleToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "contentRoleToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "contentRoleToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "contentRoleToBuilding",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "contentRoleToBuilding",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "contentRoleToBuildings",
  "camelized": {
    "singular": "contentRoleToBuilding",
    "plural": "contentRoleToBuildings",
    "id": "contentRoleToBuildingId"
  },
  "capitalized": {
    "singular": "ContentRoleToBuilding",
    "plural": "ContentRoleToBuildings",
    "id": "ContentRoleToBuildingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const contentRoleToUserCompanyObjectTypeDefintion = {
  "name": "contentRoleToUserCompany",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyId": {
      "name": "userCompanyId",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompany": {
      "name": "userCompany",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userCompanyId",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompany",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleId": {
      "name": "contentRoleId",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRole": {
      "name": "contentRole",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "contentRoleToUserCompany",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "contentRoleToUserCompanies",
  "camelized": {
    "singular": "contentRoleToUserCompany",
    "plural": "contentRoleToUserCompanies",
    "id": "contentRoleToUserCompanyId"
  },
  "capitalized": {
    "singular": "ContentRoleToUserCompany",
    "plural": "ContentRoleToUserCompanies",
    "id": "ContentRoleToUserCompanyId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const contentRoleToFloorObjectTypeDefintion = {
  "name": "contentRoleToFloor",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "contentRoleToFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "contentRoleToFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "contentRoleToFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "contentRoleToFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "contentRoleId": {
      "name": "contentRoleId",
      "objectTypeName": "contentRoleToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRole": {
      "name": "contentRole",
      "objectTypeName": "contentRoleToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "contentRoleToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "contentRoleToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "contentRoleToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "contentRoleToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "contentRoleToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "contentRoleToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "contentRoleToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "contentRoleToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "contentRoleToFloors",
  "camelized": {
    "singular": "contentRoleToFloor",
    "plural": "contentRoleToFloors",
    "id": "contentRoleToFloorId"
  },
  "capitalized": {
    "singular": "ContentRoleToFloor",
    "plural": "ContentRoleToFloors",
    "id": "ContentRoleToFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const partnerApiCredentialObjectTypeDefintion = {
  "name": "partnerApiCredential",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "partnerApiCredential",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "label": {
      "name": "label",
      "objectTypeName": "partnerApiCredential",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "partnerApiCredential",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "host": {
      "name": "host",
      "objectTypeName": "partnerApiCredential",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "clientId": {
      "name": "clientId",
      "objectTypeName": "partnerApiCredential",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "clientSecret": {
      "name": "clientSecret",
      "objectTypeName": "partnerApiCredential",
      "type": "password",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "enable": {
      "name": "enable",
      "objectTypeName": "partnerApiCredential",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "partnerApiCredential",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "partnerApiCredential",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "partnerApiCredential",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "partnerApiCredential",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "partnerApiCredential",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "partnerApiCredential",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "partnerApiCredential",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "partnerApiCredential",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "partnerApiCredential",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "partnerApiCredentials",
  "camelized": {
    "singular": "partnerApiCredential",
    "plural": "partnerApiCredentials",
    "id": "partnerApiCredentialId"
  },
  "capitalized": {
    "singular": "PartnerApiCredential",
    "plural": "PartnerApiCredentials",
    "id": "PartnerApiCredentialId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const apiUserObjectTypeDefintion = {
  "name": "apiUser",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "apiUser",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "clientSecret": {
      "name": "clientSecret",
      "objectTypeName": "apiUser",
      "type": "password",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "apiUser",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "apiUser",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "apiUser",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "apiUser",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "apiUser",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "apiUser",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "apiUser",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "apiUser",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "apiUserToJupRoles": {
      "name": "apiUserToJupRoles",
      "objectTypeName": "apiUser",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "apiUserId",
        "targetModelName": "apiUserToJupRole",
        "propertyTypeName": "apiUserToJupRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "apiUserToContentRoles": {
      "name": "apiUserToContentRoles",
      "objectTypeName": "apiUser",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "apiUserId",
        "targetModelName": "apiUserToContentRole",
        "propertyTypeName": "apiUserToContentRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "apiUser",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "apiUser",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "apiUsers",
  "camelized": {
    "singular": "apiUser",
    "plural": "apiUsers",
    "id": "apiUserId"
  },
  "capitalized": {
    "singular": "ApiUser",
    "plural": "ApiUsers",
    "id": "ApiUserId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "apiUserToJupRole",
      "apiUserToContentRole"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const apiUserToJupRoleObjectTypeDefintion = {
  "name": "apiUserToJupRole",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "apiUserToJupRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "apiUserToJupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "apiUserToJupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "apiUserToJupRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "apiUserId": {
      "name": "apiUserId",
      "objectTypeName": "apiUserToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "apiUserId",
        "targetModelName": "apiUser",
        "propertyTypeName": "apiUser",
        "options": {
          "readOnly": false
        }
      }
    },
    "apiUser": {
      "name": "apiUser",
      "objectTypeName": "apiUserToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "apiUserId",
        "targetModelName": "apiUser",
        "propertyTypeName": "apiUser",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "apiUserToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "apiUserToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "apiUserToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "apiUserToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "apiUserToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "apiUserToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "apiUserToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "apiUserToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "apiUserToJupRoles",
  "camelized": {
    "singular": "apiUserToJupRole",
    "plural": "apiUserToJupRoles",
    "id": "apiUserToJupRoleId"
  },
  "capitalized": {
    "singular": "ApiUserToJupRole",
    "plural": "ApiUserToJupRoles",
    "id": "ApiUserToJupRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const apiUserToContentRoleObjectTypeDefintion = {
  "name": "apiUserToContentRole",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "apiUserToContentRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "apiUserToContentRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "apiUserToContentRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "apiUserToContentRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "apiUserId": {
      "name": "apiUserId",
      "objectTypeName": "apiUserToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "apiUserId",
        "targetModelName": "apiUser",
        "propertyTypeName": "apiUser",
        "options": {
          "readOnly": false
        }
      }
    },
    "apiUser": {
      "name": "apiUser",
      "objectTypeName": "apiUserToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "apiUserId",
        "targetModelName": "apiUser",
        "propertyTypeName": "apiUser",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleId": {
      "name": "contentRoleId",
      "objectTypeName": "apiUserToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRole": {
      "name": "contentRole",
      "objectTypeName": "apiUserToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "apiUserToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "apiUserToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "apiUserToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "apiUserToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "apiUserToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "apiUserToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "apiUserToContentRoles",
  "camelized": {
    "singular": "apiUserToContentRole",
    "plural": "apiUserToContentRoles",
    "id": "apiUserToContentRoleId"
  },
  "capitalized": {
    "singular": "ApiUserToContentRole",
    "plural": "ApiUserToContentRoles",
    "id": "ApiUserToContentRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const jupUiTenantOperationObjectTypeDefintion = {
  "name": "jupUiTenantOperation",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupUiTenantOperation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "jupUiTenantOperation",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupUiTenantOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupUiTenantOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupUiTenantOperation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "jupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "jupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "jupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "jupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "contentRoleToJupUiTenantOperations": {
      "name": "contentRoleToJupUiTenantOperations",
      "objectTypeName": "jupUiTenantOperation",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiTenantOperationId",
        "targetModelName": "contentRoleToJupUiTenantOperation",
        "propertyTypeName": "contentRoleToJupUiTenantOperations",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "jupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "jupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "jupUiTenantOperations",
  "camelized": {
    "singular": "jupUiTenantOperation",
    "plural": "jupUiTenantOperations",
    "id": "jupUiTenantOperationId"
  },
  "capitalized": {
    "singular": "JupUiTenantOperation",
    "plural": "JupUiTenantOperations",
    "id": "JupUiTenantOperationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "contentRoleToJupUiTenantOperation"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const contentRoleToJupUiTenantOperationObjectTypeDefintion = {
  "name": "contentRoleToJupUiTenantOperation",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "canSee": {
      "name": "canSee",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUiTenantOperationId": {
      "name": "jupUiTenantOperationId",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupUiTenantOperationId",
        "targetModelName": "jupUiTenantOperation",
        "propertyTypeName": "jupUiTenantOperation",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiTenantOperation": {
      "name": "jupUiTenantOperation",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiTenantOperationId",
        "targetModelName": "jupUiTenantOperation",
        "propertyTypeName": "jupUiTenantOperation",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleId": {
      "name": "contentRoleId",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRole": {
      "name": "contentRole",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "contentRoleToJupUiTenantOperation",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "contentRoleToJupUiTenantOperations",
  "camelized": {
    "singular": "contentRoleToJupUiTenantOperation",
    "plural": "contentRoleToJupUiTenantOperations",
    "id": "contentRoleToJupUiTenantOperationId"
  },
  "capitalized": {
    "singular": "ContentRoleToJupUiTenantOperation",
    "plural": "ContentRoleToJupUiTenantOperations",
    "id": "ContentRoleToJupUiTenantOperationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const authentificationConnectionObjectTypeDefintion = {
  "name": "authentificationConnection",
  "type": "table",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "authentificationConnection",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "authentificationConnection",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "authentificationConnection",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "authentificationConnection",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "authentificationConnection",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userRegistrationTenantRules": {
      "name": "userRegistrationTenantRules",
      "objectTypeName": "authentificationConnection",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "authentificationConnectionId",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRules",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "authentificationConnections",
  "camelized": {
    "singular": "authentificationConnection",
    "plural": "authentificationConnections",
    "id": "authentificationConnectionId"
  },
  "capitalized": {
    "singular": "AuthentificationConnection",
    "plural": "AuthentificationConnections",
    "id": "AuthentificationConnectionId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "userRegistrationTenantRule"
    ],
    "belongsTo": []
  }
};
const userRegistrationTenantRuleObjectTypeDefintion = {
  "name": "userRegistrationTenantRule",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "domains": {
      "name": "domains",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "automaticUserToRoleMapping": {
      "name": "automaticUserToRoleMapping",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "authentificationConnectionId": {
      "name": "authentificationConnectionId",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "authentificationConnectionId",
        "targetModelName": "authentificationConnection",
        "propertyTypeName": "authentificationConnection",
        "options": {
          "readOnly": false
        }
      }
    },
    "authentificationConnection": {
      "name": "authentificationConnection",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "authentificationConnectionId",
        "targetModelName": "authentificationConnection",
        "propertyTypeName": "authentificationConnection",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userRegistrationTenantRuleToJupRoles": {
      "name": "userRegistrationTenantRuleToJupRoles",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userRegistrationTenantRuleId",
        "targetModelName": "userRegistrationTenantRuleToJupRole",
        "propertyTypeName": "userRegistrationTenantRuleToJupRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "userRegistrationTenantRuleToContentRoles": {
      "name": "userRegistrationTenantRuleToContentRoles",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userRegistrationTenantRuleId",
        "targetModelName": "userRegistrationTenantRuleToContentRole",
        "propertyTypeName": "userRegistrationTenantRuleToContentRoles",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "userRegistrationTenantRule",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "userRegistrationTenantRules",
  "camelized": {
    "singular": "userRegistrationTenantRule",
    "plural": "userRegistrationTenantRules",
    "id": "userRegistrationTenantRuleId"
  },
  "capitalized": {
    "singular": "UserRegistrationTenantRule",
    "plural": "UserRegistrationTenantRules",
    "id": "UserRegistrationTenantRuleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "userRegistrationTenantRuleToJupRole",
      "userRegistrationTenantRuleToContentRole"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const userRegistrationTenantRuleToJupRoleObjectTypeDefintion = {
  "name": "userRegistrationTenantRuleToJupRole",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userRegistrationTenantRuleId": {
      "name": "userRegistrationTenantRuleId",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userRegistrationTenantRuleId",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRule",
        "options": {
          "readOnly": false
        }
      }
    },
    "userRegistrationTenantRule": {
      "name": "userRegistrationTenantRule",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userRegistrationTenantRuleId",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRule",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "userRegistrationTenantRuleToJupRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "userRegistrationTenantRuleToJupRoles",
  "camelized": {
    "singular": "userRegistrationTenantRuleToJupRole",
    "plural": "userRegistrationTenantRuleToJupRoles",
    "id": "userRegistrationTenantRuleToJupRoleId"
  },
  "capitalized": {
    "singular": "UserRegistrationTenantRuleToJupRole",
    "plural": "UserRegistrationTenantRuleToJupRoles",
    "id": "UserRegistrationTenantRuleToJupRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const userRegistrationTenantRuleToContentRoleObjectTypeDefintion = {
  "name": "userRegistrationTenantRuleToContentRole",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userRegistrationTenantRuleId": {
      "name": "userRegistrationTenantRuleId",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userRegistrationTenantRuleId",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRule",
        "options": {
          "readOnly": false
        }
      }
    },
    "userRegistrationTenantRule": {
      "name": "userRegistrationTenantRule",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "userRegistrationTenantRuleId",
        "targetModelName": "userRegistrationTenantRule",
        "propertyTypeName": "userRegistrationTenantRule",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRoleId": {
      "name": "contentRoleId",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "contentRole": {
      "name": "contentRole",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "contentRoleId",
        "targetModelName": "contentRole",
        "propertyTypeName": "contentRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "userRegistrationTenantRuleToContentRole",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "userRegistrationTenantRuleToContentRoles",
  "camelized": {
    "singular": "userRegistrationTenantRuleToContentRole",
    "plural": "userRegistrationTenantRuleToContentRoles",
    "id": "userRegistrationTenantRuleToContentRoleId"
  },
  "capitalized": {
    "singular": "UserRegistrationTenantRuleToContentRole",
    "plural": "UserRegistrationTenantRuleToContentRoles",
    "id": "UserRegistrationTenantRuleToContentRoleId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const partnerExportMappingConfigurationObjectTypeDefintion = {
  "name": "partnerExportMappingConfiguration",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "code": {
      "name": "code",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappings": {
      "name": "partnerExportMappings",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "partnerExportMappingConfigurationId",
        "targetModelName": "partnerExportMapping",
        "propertyTypeName": "partnerExportMappings",
        "options": {
          "readOnly": false
        }
      }
    },
    "partnerExportMappingConfigurationToFloors": {
      "name": "partnerExportMappingConfigurationToFloors",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "partnerExportMappingConfigurationId",
        "targetModelName": "partnerExportMappingConfigurationToFloor",
        "propertyTypeName": "partnerExportMappingConfigurationToFloors",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "partnerExportMappingConfiguration",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "partnerExportMappingConfigurations",
  "camelized": {
    "singular": "partnerExportMappingConfiguration",
    "plural": "partnerExportMappingConfigurations",
    "id": "partnerExportMappingConfigurationId"
  },
  "capitalized": {
    "singular": "PartnerExportMappingConfiguration",
    "plural": "PartnerExportMappingConfigurations",
    "id": "PartnerExportMappingConfigurationId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "partnerExportMapping",
      "partnerExportMappingConfigurationToFloor"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const partnerExportMappingObjectTypeDefintion = {
  "name": "partnerExportMapping",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "partnerExportMapping",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "partnerCode": {
      "name": "partnerCode",
      "objectTypeName": "partnerExportMapping",
      "type": "string",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "label": {
      "name": "label",
      "objectTypeName": "partnerExportMapping",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "partnerExportMapping",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "partnerExportMapping",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "partnerExportMapping",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "partnerExportMappingConfigurationId": {
      "name": "partnerExportMappingConfigurationId",
      "objectTypeName": "partnerExportMapping",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "partnerExportMappingConfigurationId",
        "targetModelName": "partnerExportMappingConfiguration",
        "propertyTypeName": "partnerExportMappingConfiguration",
        "options": {
          "readOnly": false
        }
      }
    },
    "partnerExportMappingConfiguration": {
      "name": "partnerExportMappingConfiguration",
      "objectTypeName": "partnerExportMapping",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "partnerExportMappingConfigurationId",
        "targetModelName": "partnerExportMappingConfiguration",
        "propertyTypeName": "partnerExportMappingConfiguration",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "partnerExportMapping",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "partnerExportMapping",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "partnerExportMapping",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "partnerExportMapping",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "partnerExportMappingToRoomTypes": {
      "name": "partnerExportMappingToRoomTypes",
      "objectTypeName": "partnerExportMapping",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "partnerExportMappingId",
        "targetModelName": "partnerExportMappingToRoomType",
        "propertyTypeName": "partnerExportMappingToRoomTypes",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "partnerExportMapping",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "partnerExportMapping",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "partnerExportMappings",
  "camelized": {
    "singular": "partnerExportMapping",
    "plural": "partnerExportMappings",
    "id": "partnerExportMappingId"
  },
  "capitalized": {
    "singular": "PartnerExportMapping",
    "plural": "PartnerExportMappings",
    "id": "PartnerExportMappingId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "partnerExportMappingToRoomType"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const partnerExportMappingToRoomTypeObjectTypeDefintion = {
  "name": "partnerExportMappingToRoomType",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "partnerExportMappingId": {
      "name": "partnerExportMappingId",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "partnerExportMappingId",
        "targetModelName": "partnerExportMapping",
        "propertyTypeName": "partnerExportMapping",
        "options": {
          "readOnly": false
        }
      }
    },
    "partnerExportMapping": {
      "name": "partnerExportMapping",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "partnerExportMappingId",
        "targetModelName": "partnerExportMapping",
        "propertyTypeName": "partnerExportMapping",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomTypeId": {
      "name": "roomTypeId",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "roomType": {
      "name": "roomType",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "roomTypeId",
        "targetModelName": "roomType",
        "propertyTypeName": "roomType",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "partnerExportMappingToRoomType",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "partnerExportMappingToRoomTypes",
  "camelized": {
    "singular": "partnerExportMappingToRoomType",
    "plural": "partnerExportMappingToRoomTypes",
    "id": "partnerExportMappingToRoomTypeId"
  },
  "capitalized": {
    "singular": "PartnerExportMappingToRoomType",
    "plural": "PartnerExportMappingToRoomTypes",
    "id": "PartnerExportMappingToRoomTypeId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const partnerExportMappingConfigurationToFloorObjectTypeDefintion = {
  "name": "partnerExportMappingConfigurationToFloor",
  "type": "many-to-many",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "partnerExportMappingConfigurationId": {
      "name": "partnerExportMappingConfigurationId",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "partnerExportMappingConfigurationId",
        "targetModelName": "partnerExportMappingConfiguration",
        "propertyTypeName": "partnerExportMappingConfiguration",
        "options": {
          "readOnly": false
        }
      }
    },
    "partnerExportMappingConfiguration": {
      "name": "partnerExportMappingConfiguration",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "partnerExportMappingConfigurationId",
        "targetModelName": "partnerExportMappingConfiguration",
        "propertyTypeName": "partnerExportMappingConfiguration",
        "options": {
          "readOnly": false
        }
      }
    },
    "floorId": {
      "name": "floorId",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "floor": {
      "name": "floor",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "floorId",
        "targetModelName": "floor",
        "propertyTypeName": "floor",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "partnerExportMappingConfigurationToFloor",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "partnerExportMappingConfigurationToFloors",
  "camelized": {
    "singular": "partnerExportMappingConfigurationToFloor",
    "plural": "partnerExportMappingConfigurationToFloors",
    "id": "partnerExportMappingConfigurationToFloorId"
  },
  "capitalized": {
    "singular": "PartnerExportMappingConfigurationToFloor",
    "plural": "PartnerExportMappingConfigurationToFloors",
    "id": "PartnerExportMappingConfigurationToFloorId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const jupRoleToJupUiLayoutObjectTypeDefintion = {
  "name": "jupRoleToJupUiLayout",
  "type": "many-to-many",
  "scope": "public",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": true,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "canSee": {
      "name": "canSee",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "boolean",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false,
        "defaultValue": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "jupUiLayoutId": {
      "name": "jupUiLayoutId",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupUiLayoutId",
        "targetModelName": "jupUiLayout",
        "propertyTypeName": "jupUiLayout",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupUiLayout": {
      "name": "jupUiLayout",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupUiLayoutId",
        "targetModelName": "jupUiLayout",
        "propertyTypeName": "jupUiLayout",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRoleId": {
      "name": "jupRoleId",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    },
    "jupRole": {
      "name": "jupRole",
      "objectTypeName": "jupRoleToJupUiLayout",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "jupRoleId",
        "targetModelName": "jupRole",
        "propertyTypeName": "jupRole",
        "options": {
          "readOnly": false
        }
      }
    }
  },
  "plural": "jupRoleToJupUiLayouts",
  "camelized": {
    "singular": "jupRoleToJupUiLayout",
    "plural": "jupRoleToJupUiLayouts",
    "id": "jupRoleToJupUiLayoutId"
  },
  "capitalized": {
    "singular": "JupRoleToJupUiLayout",
    "plural": "JupRoleToJupUiLayouts",
    "id": "JupRoleToJupUiLayoutId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": []
  }
};
const itemFactObjectTypeDefintion = {
  "name": "itemFact",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "itemFact",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "measure": {
      "name": "measure",
      "objectTypeName": "itemFact",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "value": {
      "name": "value",
      "objectTypeName": "itemFact",
      "type": "float",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "voltage": {
      "name": "voltage",
      "objectTypeName": "itemFact",
      "type": "float",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "time": {
      "name": "time",
      "objectTypeName": "itemFact",
      "type": "datetime",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "itemFact",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "itemFact",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "itemFact",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "itemId": {
      "name": "itemId",
      "objectTypeName": "itemFact",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "item",
        "propertyTypeName": "item",
        "options": {
          "readOnly": false
        }
      }
    },
    "item": {
      "name": "item",
      "objectTypeName": "itemFact",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "itemId",
        "targetModelName": "item",
        "propertyTypeName": "item",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "itemFact",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "itemFact",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "itemFact",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "itemFact",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "itemFact",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "itemFact",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "itemFacts",
  "camelized": {
    "singular": "itemFact",
    "plural": "itemFacts",
    "id": "itemFactId"
  },
  "capitalized": {
    "singular": "ItemFact",
    "plural": "ItemFacts",
    "id": "ItemFactId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
const featureFamilyObjectTypeDefintion = {
  "name": "featureFamily",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "featureFamily",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "featureFamily",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "featureFamily",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "featureFamily",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "featureFamily",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "featureFamily",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "featureFamily",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "featureFamily",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "featureFamily",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "featureGroups": {
      "name": "featureGroups",
      "objectTypeName": "featureFamily",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "featureFamilyId",
        "targetModelName": "featureGroup",
        "propertyTypeName": "featureGroups",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "featureFamily",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "featureFamily",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "featureFamilies",
  "camelized": {
    "singular": "featureFamily",
    "plural": "featureFamilies",
    "id": "featureFamilyId"
  },
  "capitalized": {
    "singular": "FeatureFamily",
    "plural": "FeatureFamilies",
    "id": "FeatureFamilyId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "featureGroup"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const featureGroupObjectTypeDefintion = {
  "name": "featureGroup",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "featureGroup",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "featureGroup",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "sortOrder": {
      "name": "sortOrder",
      "objectTypeName": "featureGroup",
      "type": "integer",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "featureGroup",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "featureGroup",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "featureGroup",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "featureFamilyId": {
      "name": "featureFamilyId",
      "objectTypeName": "featureGroup",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "featureFamilyId",
        "targetModelName": "featureFamily",
        "propertyTypeName": "featureFamily",
        "options": {
          "readOnly": false
        }
      }
    },
    "featureFamily": {
      "name": "featureFamily",
      "objectTypeName": "featureGroup",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "featureFamilyId",
        "targetModelName": "featureFamily",
        "propertyTypeName": "featureFamily",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "featureGroup",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "featureGroup",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "featureGroup",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "featureGroup",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "features": {
      "name": "features",
      "objectTypeName": "featureGroup",
      "type": "has-many-paginated",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "featureGroupId",
        "targetModelName": "feature",
        "propertyTypeName": "features",
        "options": {
          "readOnly": false
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "featureGroup",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "featureGroup",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "featureGroups",
  "camelized": {
    "singular": "featureGroup",
    "plural": "featureGroups",
    "id": "featureGroupId"
  },
  "capitalized": {
    "singular": "FeatureGroup",
    "plural": "FeatureGroups",
    "id": "FeatureGroupId"
  },
  "hidden": false,
  "context": {
    "hasMany": [
      "feature"
    ],
    "belongsTo": [
      "company"
    ]
  }
};
const featureObjectTypeDefintion = {
  "name": "feature",
  "type": "table",
  "scope": "private",
  "isMasterData": false,
  "isReportingData": false,
  "isSecurityData": false,
  "propertiesByName": {
    "id": {
      "name": "id",
      "objectTypeName": "feature",
      "type": "primary-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "name": {
      "name": "name",
      "objectTypeName": "feature",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": false
      }
    },
    "createdAt": {
      "name": "createdAt",
      "objectTypeName": "feature",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "updatedAt": {
      "name": "updatedAt",
      "objectTypeName": "feature",
      "type": "timestamp",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      }
    },
    "externalId": {
      "name": "externalId",
      "objectTypeName": "feature",
      "type": "string",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      }
    },
    "featureGroupId": {
      "name": "featureGroupId",
      "objectTypeName": "feature",
      "type": "foreign-key",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "featureGroupId",
        "targetModelName": "featureGroup",
        "propertyTypeName": "featureGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "featureGroup": {
      "name": "featureGroup",
      "objectTypeName": "feature",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "featureGroupId",
        "targetModelName": "featureGroup",
        "propertyTypeName": "featureGroup",
        "options": {
          "readOnly": false
        }
      }
    },
    "userCompanyCreatedById": {
      "name": "userCompanyCreatedById",
      "objectTypeName": "feature",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyCreatedBy": {
      "name": "userCompanyCreatedBy",
      "objectTypeName": "feature",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyCreatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyCreatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedById": {
      "name": "userCompanyUpdatedById",
      "objectTypeName": "feature",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": true,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "userCompanyUpdatedBy": {
      "name": "userCompanyUpdatedBy",
      "objectTypeName": "feature",
      "type": "belongs-to",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "userCompanyUpdatedById",
        "targetModelName": "userCompany",
        "propertyTypeName": "userCompanyUpdatedBy",
        "options": {
          "readOnly": true
        }
      }
    },
    "companyId": {
      "name": "companyId",
      "objectTypeName": "feature",
      "type": "foreign-key",
      "options": {
        "mandatory": false,
        "readOnly": false,
        "calculated": false,
        "technical": true
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    },
    "company": {
      "name": "company",
      "objectTypeName": "feature",
      "type": "belongs-to",
      "options": {
        "mandatory": true,
        "readOnly": false,
        "calculated": false,
        "technical": false
      },
      "association": {
        "foreignKey": "companyId",
        "targetModelName": "company",
        "propertyTypeName": "company",
        "options": {
          "readOnly": true
        }
      }
    }
  },
  "plural": "features",
  "camelized": {
    "singular": "feature",
    "plural": "features",
    "id": "featureId"
  },
  "capitalized": {
    "singular": "Feature",
    "plural": "Features",
    "id": "FeatureId"
  },
  "hidden": false,
  "context": {
    "hasMany": [],
    "belongsTo": [
      "company"
    ]
  }
};
var JupSchema;
((JupSchema2) => {
  JupSchema2.occupancyStatus = occupancyStatusObjectTypeDefintion;
  JupSchema2.user = userObjectTypeDefintion;
  JupSchema2.userRefreshToken = userRefreshTokenObjectTypeDefintion;
  JupSchema2.companyType = companyTypeObjectTypeDefintion;
  JupSchema2.company = companyObjectTypeDefintion;
  JupSchema2.campus = campusObjectTypeDefintion;
  JupSchema2.roomConnectorType = roomConnectorTypeObjectTypeDefintion;
  JupSchema2.roomConnector = roomConnectorObjectTypeDefintion;
  JupSchema2.userCompany = userCompanyObjectTypeDefintion;
  JupSchema2.personGender = personGenderObjectTypeDefintion;
  JupSchema2.personCompany = personCompanyObjectTypeDefintion;
  JupSchema2.jupUiLayout = jupUiLayoutObjectTypeDefintion;
  JupSchema2.buildingType = buildingTypeObjectTypeDefintion;
  JupSchema2.organization = organizationObjectTypeDefintion;
  JupSchema2.itemTypeFamily = itemTypeFamilyObjectTypeDefintion;
  JupSchema2.manufacturer = manufacturerObjectTypeDefintion;
  JupSchema2.object3dModel = object3dModelObjectTypeDefintion;
  JupSchema2.itemType = itemTypeObjectTypeDefintion;
  JupSchema2.building = buildingObjectTypeDefintion;
  JupSchema2.mapScale = mapScaleObjectTypeDefintion;
  JupSchema2.structure = structureObjectTypeDefintion;
  JupSchema2.structurePoint = structurePointObjectTypeDefintion;
  JupSchema2.floor = floorObjectTypeDefintion;
  JupSchema2.distributionCostType = distributionCostTypeObjectTypeDefintion;
  JupSchema2.roomTypeGroup = roomTypeGroupObjectTypeDefintion;
  JupSchema2.roomType = roomTypeObjectTypeDefintion;
  JupSchema2.roomTypeGroupToRoomType = roomTypeGroupToRoomTypeObjectTypeDefintion;
  JupSchema2.roomTypeGroupFloor = roomTypeGroupFloorObjectTypeDefintion;
  JupSchema2.roomTypeGroupBuilding = roomTypeGroupBuildingObjectTypeDefintion;
  JupSchema2.costCenter = costCenterObjectTypeDefintion;
  JupSchema2.costCenterBuilding = costCenterBuildingObjectTypeDefintion;
  JupSchema2.costCenterFloor = costCenterFloorObjectTypeDefintion;
  JupSchema2.room = roomObjectTypeDefintion;
  JupSchema2.roomPoint = roomPointObjectTypeDefintion;
  JupSchema2.roomPointRoom = roomPointRoomObjectTypeDefintion;
  JupSchema2.roomPointSegmentType = roomPointSegmentTypeObjectTypeDefintion;
  JupSchema2.roomPointSegment = roomPointSegmentObjectTypeDefintion;
  JupSchema2.itemTypePoint = itemTypePointObjectTypeDefintion;
  JupSchema2.dimensionType = dimensionTypeObjectTypeDefintion;
  JupSchema2.dimension = dimensionObjectTypeDefintion;
  JupSchema2.dimensionRoom = dimensionRoomObjectTypeDefintion;
  JupSchema2.dimensionFloor = dimensionFloorObjectTypeDefintion;
  JupSchema2.dimensionBuilding = dimensionBuildingObjectTypeDefintion;
  JupSchema2.factType = factTypeObjectTypeDefintion;
  JupSchema2.fact = factObjectTypeDefintion;
  JupSchema2.personState = personStateObjectTypeDefintion;
  JupSchema2.personSecurityProfile = personSecurityProfileObjectTypeDefintion;
  JupSchema2.person = personObjectTypeDefintion;
  JupSchema2.personToPersonType = personToPersonTypeObjectTypeDefintion;
  JupSchema2.personToPerson = personToPersonObjectTypeDefintion;
  JupSchema2.roomAffectation = roomAffectationObjectTypeDefintion;
  JupSchema2.workplaceType = workplaceTypeObjectTypeDefintion;
  JupSchema2.workplaceTypeItemType = workplaceTypeItemTypeObjectTypeDefintion;
  JupSchema2.workplace = workplaceObjectTypeDefintion;
  JupSchema2.item = itemObjectTypeDefintion;
  JupSchema2.workplaceAffectation = workplaceAffectationObjectTypeDefintion;
  JupSchema2.organizationFloor = organizationFloorObjectTypeDefintion;
  JupSchema2.organizationBuilding = organizationBuildingObjectTypeDefintion;
  JupSchema2.roomTypeFloor = roomTypeFloorObjectTypeDefintion;
  JupSchema2.roomTypeBuilding = roomTypeBuildingObjectTypeDefintion;
  JupSchema2.itemToPerson = itemToPersonObjectTypeDefintion;
  JupSchema2.personToBuilding = personToBuildingObjectTypeDefintion;
  JupSchema2.dimensionToPerson = dimensionToPersonObjectTypeDefintion;
  JupSchema2.dimensionTypeToBuilding = dimensionTypeToBuildingObjectTypeDefintion;
  JupSchema2.workingLocation = workingLocationObjectTypeDefintion;
  JupSchema2.personWorkingLocation = personWorkingLocationObjectTypeDefintion;
  JupSchema2.personToWorkplaceBooking = personToWorkplaceBookingObjectTypeDefintion;
  JupSchema2.personToRoomBooking = personToRoomBookingObjectTypeDefintion;
  JupSchema2.personToDimensionBooking = personToDimensionBookingObjectTypeDefintion;
  JupSchema2.personCompanyMission = personCompanyMissionObjectTypeDefintion;
  JupSchema2.personCompanyToItemType = personCompanyToItemTypeObjectTypeDefintion;
  JupSchema2.personCompanyToRoomType = personCompanyToRoomTypeObjectTypeDefintion;
  JupSchema2.personCompanyToItem = personCompanyToItemObjectTypeDefintion;
  JupSchema2.legend = legendObjectTypeDefintion;
  JupSchema2.openerPostMessageHost = openerPostMessageHostObjectTypeDefintion;
  JupSchema2.jupObjectType = jupObjectTypeObjectTypeDefintion;
  JupSchema2.jupUiView = jupUiViewObjectTypeDefintion;
  JupSchema2.jupRole = jupRoleObjectTypeDefintion;
  JupSchema2.jupUiOption = jupUiOptionObjectTypeDefintion;
  JupSchema2.jupUiOperation = jupUiOperationObjectTypeDefintion;
  JupSchema2.contentRole = contentRoleObjectTypeDefintion;
  JupSchema2.jupUserCompanyToJupRole = jupUserCompanyToJupRoleObjectTypeDefintion;
  JupSchema2.jupRoleToJupUiView = jupRoleToJupUiViewObjectTypeDefintion;
  JupSchema2.jupRoleToJupObjectType = jupRoleToJupObjectTypeObjectTypeDefintion;
  JupSchema2.jupRoleToJupUiOption = jupRoleToJupUiOptionObjectTypeDefintion;
  JupSchema2.jupRoleToJupUiOperation = jupRoleToJupUiOperationObjectTypeDefintion;
  JupSchema2.contentRoleToBuilding = contentRoleToBuildingObjectTypeDefintion;
  JupSchema2.contentRoleToUserCompany = contentRoleToUserCompanyObjectTypeDefintion;
  JupSchema2.contentRoleToFloor = contentRoleToFloorObjectTypeDefintion;
  JupSchema2.partnerApiCredential = partnerApiCredentialObjectTypeDefintion;
  JupSchema2.apiUser = apiUserObjectTypeDefintion;
  JupSchema2.apiUserToJupRole = apiUserToJupRoleObjectTypeDefintion;
  JupSchema2.apiUserToContentRole = apiUserToContentRoleObjectTypeDefintion;
  JupSchema2.jupUiTenantOperation = jupUiTenantOperationObjectTypeDefintion;
  JupSchema2.contentRoleToJupUiTenantOperation = contentRoleToJupUiTenantOperationObjectTypeDefintion;
  JupSchema2.authentificationConnection = authentificationConnectionObjectTypeDefintion;
  JupSchema2.userRegistrationTenantRule = userRegistrationTenantRuleObjectTypeDefintion;
  JupSchema2.userRegistrationTenantRuleToJupRole = userRegistrationTenantRuleToJupRoleObjectTypeDefintion;
  JupSchema2.userRegistrationTenantRuleToContentRole = userRegistrationTenantRuleToContentRoleObjectTypeDefintion;
  JupSchema2.partnerExportMappingConfiguration = partnerExportMappingConfigurationObjectTypeDefintion;
  JupSchema2.partnerExportMapping = partnerExportMappingObjectTypeDefintion;
  JupSchema2.partnerExportMappingToRoomType = partnerExportMappingToRoomTypeObjectTypeDefintion;
  JupSchema2.partnerExportMappingConfigurationToFloor = partnerExportMappingConfigurationToFloorObjectTypeDefintion;
  JupSchema2.jupRoleToJupUiLayout = jupRoleToJupUiLayoutObjectTypeDefintion;
  JupSchema2.itemFact = itemFactObjectTypeDefintion;
  JupSchema2.featureFamily = featureFamilyObjectTypeDefintion;
  JupSchema2.featureGroup = featureGroupObjectTypeDefintion;
  JupSchema2.feature = featureObjectTypeDefintion;
  JupSchema2.objectTypes = [JupSchema2.occupancyStatus, JupSchema2.user, JupSchema2.userRefreshToken, JupSchema2.companyType, JupSchema2.company, JupSchema2.campus, JupSchema2.roomConnectorType, JupSchema2.roomConnector, JupSchema2.userCompany, JupSchema2.personGender, JupSchema2.personCompany, JupSchema2.jupUiLayout, JupSchema2.buildingType, JupSchema2.organization, JupSchema2.itemTypeFamily, JupSchema2.manufacturer, JupSchema2.object3dModel, JupSchema2.itemType, JupSchema2.building, JupSchema2.mapScale, JupSchema2.structure, JupSchema2.structurePoint, JupSchema2.floor, JupSchema2.distributionCostType, JupSchema2.roomTypeGroup, JupSchema2.roomType, JupSchema2.roomTypeGroupToRoomType, JupSchema2.roomTypeGroupFloor, JupSchema2.roomTypeGroupBuilding, JupSchema2.costCenter, JupSchema2.costCenterBuilding, JupSchema2.costCenterFloor, JupSchema2.room, JupSchema2.roomPoint, JupSchema2.roomPointRoom, JupSchema2.roomPointSegmentType, JupSchema2.roomPointSegment, JupSchema2.itemTypePoint, JupSchema2.dimensionType, JupSchema2.dimension, JupSchema2.dimensionRoom, JupSchema2.dimensionFloor, JupSchema2.dimensionBuilding, JupSchema2.factType, JupSchema2.fact, JupSchema2.personState, JupSchema2.personSecurityProfile, JupSchema2.person, JupSchema2.personToPersonType, JupSchema2.personToPerson, JupSchema2.roomAffectation, JupSchema2.workplaceType, JupSchema2.workplaceTypeItemType, JupSchema2.workplace, JupSchema2.item, JupSchema2.workplaceAffectation, JupSchema2.organizationFloor, JupSchema2.organizationBuilding, JupSchema2.roomTypeFloor, JupSchema2.roomTypeBuilding, JupSchema2.itemToPerson, JupSchema2.personToBuilding, JupSchema2.dimensionToPerson, JupSchema2.dimensionTypeToBuilding, JupSchema2.workingLocation, JupSchema2.personWorkingLocation, JupSchema2.personToWorkplaceBooking, JupSchema2.personToRoomBooking, JupSchema2.personToDimensionBooking, JupSchema2.personCompanyMission, JupSchema2.personCompanyToItemType, JupSchema2.personCompanyToRoomType, JupSchema2.personCompanyToItem, JupSchema2.legend, JupSchema2.openerPostMessageHost, JupSchema2.jupObjectType, JupSchema2.jupUiView, JupSchema2.jupRole, JupSchema2.jupUiOption, JupSchema2.jupUiOperation, JupSchema2.contentRole, JupSchema2.jupUserCompanyToJupRole, JupSchema2.jupRoleToJupUiView, JupSchema2.jupRoleToJupObjectType, JupSchema2.jupRoleToJupUiOption, JupSchema2.jupRoleToJupUiOperation, JupSchema2.contentRoleToBuilding, JupSchema2.contentRoleToUserCompany, JupSchema2.contentRoleToFloor, JupSchema2.partnerApiCredential, JupSchema2.apiUser, JupSchema2.apiUserToJupRole, JupSchema2.apiUserToContentRole, JupSchema2.jupUiTenantOperation, JupSchema2.contentRoleToJupUiTenantOperation, JupSchema2.authentificationConnection, JupSchema2.userRegistrationTenantRule, JupSchema2.userRegistrationTenantRuleToJupRole, JupSchema2.userRegistrationTenantRuleToContentRole, JupSchema2.partnerExportMappingConfiguration, JupSchema2.partnerExportMapping, JupSchema2.partnerExportMappingToRoomType, JupSchema2.partnerExportMappingConfigurationToFloor, JupSchema2.jupRoleToJupUiLayout, JupSchema2.itemFact, JupSchema2.featureFamily, JupSchema2.featureGroup, JupSchema2.feature];
  JupSchema2.objectTypesBySingular = {
    occupancyStatus: JupSchema2.occupancyStatus,
    user: JupSchema2.user,
    userRefreshToken: JupSchema2.userRefreshToken,
    companyType: JupSchema2.companyType,
    company: JupSchema2.company,
    campus: JupSchema2.campus,
    roomConnectorType: JupSchema2.roomConnectorType,
    roomConnector: JupSchema2.roomConnector,
    userCompany: JupSchema2.userCompany,
    personGender: JupSchema2.personGender,
    personCompany: JupSchema2.personCompany,
    jupUiLayout: JupSchema2.jupUiLayout,
    buildingType: JupSchema2.buildingType,
    organization: JupSchema2.organization,
    itemTypeFamily: JupSchema2.itemTypeFamily,
    manufacturer: JupSchema2.manufacturer,
    object3dModel: JupSchema2.object3dModel,
    itemType: JupSchema2.itemType,
    building: JupSchema2.building,
    mapScale: JupSchema2.mapScale,
    structure: JupSchema2.structure,
    structurePoint: JupSchema2.structurePoint,
    floor: JupSchema2.floor,
    distributionCostType: JupSchema2.distributionCostType,
    roomTypeGroup: JupSchema2.roomTypeGroup,
    roomType: JupSchema2.roomType,
    roomTypeGroupToRoomType: JupSchema2.roomTypeGroupToRoomType,
    roomTypeGroupFloor: JupSchema2.roomTypeGroupFloor,
    roomTypeGroupBuilding: JupSchema2.roomTypeGroupBuilding,
    costCenter: JupSchema2.costCenter,
    costCenterBuilding: JupSchema2.costCenterBuilding,
    costCenterFloor: JupSchema2.costCenterFloor,
    room: JupSchema2.room,
    roomPoint: JupSchema2.roomPoint,
    roomPointRoom: JupSchema2.roomPointRoom,
    roomPointSegmentType: JupSchema2.roomPointSegmentType,
    roomPointSegment: JupSchema2.roomPointSegment,
    itemTypePoint: JupSchema2.itemTypePoint,
    dimensionType: JupSchema2.dimensionType,
    dimension: JupSchema2.dimension,
    dimensionRoom: JupSchema2.dimensionRoom,
    dimensionFloor: JupSchema2.dimensionFloor,
    dimensionBuilding: JupSchema2.dimensionBuilding,
    factType: JupSchema2.factType,
    fact: JupSchema2.fact,
    personState: JupSchema2.personState,
    personSecurityProfile: JupSchema2.personSecurityProfile,
    person: JupSchema2.person,
    personToPersonType: JupSchema2.personToPersonType,
    personToPerson: JupSchema2.personToPerson,
    roomAffectation: JupSchema2.roomAffectation,
    workplaceType: JupSchema2.workplaceType,
    workplaceTypeItemType: JupSchema2.workplaceTypeItemType,
    workplace: JupSchema2.workplace,
    item: JupSchema2.item,
    workplaceAffectation: JupSchema2.workplaceAffectation,
    organizationFloor: JupSchema2.organizationFloor,
    organizationBuilding: JupSchema2.organizationBuilding,
    roomTypeFloor: JupSchema2.roomTypeFloor,
    roomTypeBuilding: JupSchema2.roomTypeBuilding,
    itemToPerson: JupSchema2.itemToPerson,
    personToBuilding: JupSchema2.personToBuilding,
    dimensionToPerson: JupSchema2.dimensionToPerson,
    dimensionTypeToBuilding: JupSchema2.dimensionTypeToBuilding,
    workingLocation: JupSchema2.workingLocation,
    personWorkingLocation: JupSchema2.personWorkingLocation,
    personToWorkplaceBooking: JupSchema2.personToWorkplaceBooking,
    personToRoomBooking: JupSchema2.personToRoomBooking,
    personToDimensionBooking: JupSchema2.personToDimensionBooking,
    personCompanyMission: JupSchema2.personCompanyMission,
    personCompanyToItemType: JupSchema2.personCompanyToItemType,
    personCompanyToRoomType: JupSchema2.personCompanyToRoomType,
    personCompanyToItem: JupSchema2.personCompanyToItem,
    legend: JupSchema2.legend,
    openerPostMessageHost: JupSchema2.openerPostMessageHost,
    jupObjectType: JupSchema2.jupObjectType,
    jupUiView: JupSchema2.jupUiView,
    jupRole: JupSchema2.jupRole,
    jupUiOption: JupSchema2.jupUiOption,
    jupUiOperation: JupSchema2.jupUiOperation,
    contentRole: JupSchema2.contentRole,
    jupUserCompanyToJupRole: JupSchema2.jupUserCompanyToJupRole,
    jupRoleToJupUiView: JupSchema2.jupRoleToJupUiView,
    jupRoleToJupObjectType: JupSchema2.jupRoleToJupObjectType,
    jupRoleToJupUiOption: JupSchema2.jupRoleToJupUiOption,
    jupRoleToJupUiOperation: JupSchema2.jupRoleToJupUiOperation,
    contentRoleToBuilding: JupSchema2.contentRoleToBuilding,
    contentRoleToUserCompany: JupSchema2.contentRoleToUserCompany,
    contentRoleToFloor: JupSchema2.contentRoleToFloor,
    partnerApiCredential: JupSchema2.partnerApiCredential,
    apiUser: JupSchema2.apiUser,
    apiUserToJupRole: JupSchema2.apiUserToJupRole,
    apiUserToContentRole: JupSchema2.apiUserToContentRole,
    jupUiTenantOperation: JupSchema2.jupUiTenantOperation,
    contentRoleToJupUiTenantOperation: JupSchema2.contentRoleToJupUiTenantOperation,
    authentificationConnection: JupSchema2.authentificationConnection,
    userRegistrationTenantRule: JupSchema2.userRegistrationTenantRule,
    userRegistrationTenantRuleToJupRole: JupSchema2.userRegistrationTenantRuleToJupRole,
    userRegistrationTenantRuleToContentRole: JupSchema2.userRegistrationTenantRuleToContentRole,
    partnerExportMappingConfiguration: JupSchema2.partnerExportMappingConfiguration,
    partnerExportMapping: JupSchema2.partnerExportMapping,
    partnerExportMappingToRoomType: JupSchema2.partnerExportMappingToRoomType,
    partnerExportMappingConfigurationToFloor: JupSchema2.partnerExportMappingConfigurationToFloor,
    jupRoleToJupUiLayout: JupSchema2.jupRoleToJupUiLayout,
    itemFact: JupSchema2.itemFact,
    featureFamily: JupSchema2.featureFamily,
    featureGroup: JupSchema2.featureGroup,
    feature: JupSchema2.feature
  };
})(JupSchema || (JupSchema = {}));
function getObjectTypeDefinitionByName(objetTypeName) {
  return JupSchema[objetTypeName];
}
function getAllObjectTypeDefinitions() {
  return JupSchema.objectTypes;
}
function getObjectTypeDefintionFromCamelizedName(objectTypeName) {
  const otDef = getObjectTypeDefinitionByName(objectTypeName);
  if (!otDef) {
    throw new Error(`impossible to find object type with camedlized name <${objectTypeName}>`);
  }
  return otDef;
}
function getPropertyTypeByName(objectTypeName, propertyTypeName) {
  const objectTypeDefinition = getObjectTypeDefinitionByName(objectTypeName);
  const pt = objectTypeDefinition.propertiesByName[propertyTypeName];
  if (pt) {
    return pt;
  }
  throw new Error(`property type name not found (${propertyTypeName}) for object type (${objectTypeDefinition.camelized.singular})`);
}
function getObjectTypePropertyTypesWithFilter(objectTypeName, filters2) {
  return Object.values(getObjectTypeDefinitionByName(objectTypeName).propertiesByName).filter((p) => filters2.filter((f) => f(p)).length > 0);
}
function getPropertyTypeByCode(code) {
  const [objectTypeName, propertyName] = code.split(":");
  const otDef = getObjectTypeDefintionFromCamelizedName(objectTypeName);
  const propertyType = getPropertyTypeByName(otDef.name, propertyName);
  return propertyType;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a2, g) {
    var b2, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a2.key && (e = "" + a2.key);
    void 0 !== a2.ref && (h = a2.ref);
    for (b2 in a2) m.call(a2, b2) && !p.hasOwnProperty(b2) && (d[b2] = a2[b2]);
    if (c && c.defaultProps) for (b2 in a2 = c.defaultProps, a2) void 0 === d[b2] && (d[b2] = a2[b2]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item2) {
            return String(item2);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type2) {
        if (typeof type2 === "string" || typeof type2 === "function") {
          return true;
        }
        if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type2 === "object" && type2 !== null) {
          if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName2(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null) {
          return null;
        }
        {
          if (typeof type2.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type2 === "function") {
          return type2.displayName || type2.name || null;
        }
        if (typeof type2 === "string") {
          return type2;
        }
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 === "object") {
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName2(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign2 = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog
              }),
              info: assign2({}, props, {
                value: prevInfo
              }),
              warn: assign2({}, props, {
                value: prevWarn
              }),
              error: assign2({}, props, {
                value: prevError
              }),
              group: assign2({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix2;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix2 === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/);
              prefix2 = match2 && match2[1] || "";
            }
          }
          return "\n" + prefix2 + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
        if (type2 == null) {
          return "";
        }
        if (typeof type2 === "function") {
          {
            return describeNativeComponentFrame(type2, shouldConstruct(type2));
          }
        }
        if (typeof type2 === "string") {
          return describeBuiltInComponentFrame(type2);
        }
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 === "object") {
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a2) {
        return isArrayImpl(a2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type2, key, ref2, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type: type2,
          key,
          ref: ref2,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type2, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref2 = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref2 = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref2) {
            var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref2) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type2, key, ref2, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node2, parentType) {
        {
          if (typeof node2 !== "object") {
            return;
          }
          if (isArray(node2)) {
            for (var i = 0; i < node2.length; i++) {
              var child = node2[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node2)) {
            if (node2._store) {
              node2._store.validated = true;
            }
          } else if (node2) {
            var iteratorFn = getIteratorFn(node2);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node2.entries) {
                var iterator = iteratorFn.call(node2);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type2 = element.type;
          if (type2 === null || type2 === void 0 || typeof type2 === "string") {
            return;
          }
          var propTypes2;
          if (typeof type2 === "function") {
            propTypes2 = type2.propTypes;
          } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type2.$$typeof === REACT_MEMO_TYPE)) {
            propTypes2 = type2.propTypes;
          } else {
            return;
          }
          if (propTypes2) {
            var name = getComponentNameFromType(type2);
            checkPropTypes(propTypes2, element.props, "prop", name, element);
          } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type2);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type2, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (isArray(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type2, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children2 = props.children;
            if (children2 !== void 0) {
              if (isStaticChildren) {
                if (isArray(children2)) {
                  for (var i = 0; i < children2.length; i++) {
                    validateChildKeys(children2[i], type2);
                  }
                  if (Object.freeze) {
                    Object.freeze(children2);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children2, type2);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type2);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type2 === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type2, props, key) {
        {
          return jsxWithValidation(type2, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type2, props, key) {
        {
          return jsxWithValidation(type2, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  if (process.env.NODE_ENV === "production") {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  } else {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
function SetupRecoilContext(props) {
  const { defaultLanguage, I18nContext } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RecoilRoot, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(I18nContext, { defaultLanguage, children: props.children }) });
}
function isPlainObject(item2) {
  if (typeof item2 !== "object" || item2 === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item2);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item2) && !(Symbol.iterator in item2);
}
function deepClone(source) {
  if (/* @__PURE__ */ React.isValidElement(source) || !isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (/* @__PURE__ */ React.isValidElement(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var propTypes = { exports: {} };
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = "function" === typeof Symbol && Symbol.for, c = b2 ? Symbol.for("react.element") : 60103, d = b2 ? Symbol.for("react.portal") : 60106, e = b2 ? Symbol.for("react.fragment") : 60107, f = b2 ? Symbol.for("react.strict_mode") : 60108, g = b2 ? Symbol.for("react.profiler") : 60114, h = b2 ? Symbol.for("react.provider") : 60109, k = b2 ? Symbol.for("react.context") : 60110, l = b2 ? Symbol.for("react.async_mode") : 60111, m = b2 ? Symbol.for("react.concurrent_mode") : 60111, n = b2 ? Symbol.for("react.forward_ref") : 60112, p = b2 ? Symbol.for("react.suspense") : 60113, q = b2 ? Symbol.for("react.suspense_list") : 60120, r2 = b2 ? Symbol.for("react.memo") : 60115, t = b2 ? Symbol.for("react.lazy") : 60116, v = b2 ? Symbol.for("react.block") : 60121, w = b2 ? Symbol.for("react.fundamental") : 60117, x = b2 ? Symbol.for("react.responder") : 60118, y = b2 ? Symbol.for("react.scope") : 60119;
  function z(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var u = a2.$$typeof;
      switch (u) {
        case c:
          switch (a2 = a2.type, a2) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k:
                case n:
                case t:
                case r2:
                case h:
                  return a2;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a2) {
    return z(a2) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a2) {
    return A(a2) || z(a2) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a2) {
    return z(a2) === k;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return z(a2) === h;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return z(a2) === n;
  };
  reactIs_production_min.isFragment = function(a2) {
    return z(a2) === e;
  };
  reactIs_production_min.isLazy = function(a2) {
    return z(a2) === t;
  };
  reactIs_production_min.isMemo = function(a2) {
    return z(a2) === r2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return z(a2) === d;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return z(a2) === g;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return z(a2) === f;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return z(a2) === p;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m || a2 === g || a2 === f || a2 === p || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r2 || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var reactIs_development$1 = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  if (hasRequiredReactIs_development$1) return reactIs_development$1;
  hasRequiredReactIs_development$1 = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type2) {
        return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = object.type;
              switch (type2) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type2;
                default:
                  var $$typeofType = type2 && type2.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development$1.AsyncMode = AsyncMode;
      reactIs_development$1.ConcurrentMode = ConcurrentMode;
      reactIs_development$1.ContextConsumer = ContextConsumer;
      reactIs_development$1.ContextProvider = ContextProvider;
      reactIs_development$1.Element = Element2;
      reactIs_development$1.ForwardRef = ForwardRef;
      reactIs_development$1.Fragment = Fragment;
      reactIs_development$1.Lazy = Lazy;
      reactIs_development$1.Memo = Memo;
      reactIs_development$1.Portal = Portal;
      reactIs_development$1.Profiler = Profiler;
      reactIs_development$1.StrictMode = StrictMode;
      reactIs_development$1.Suspense = Suspense;
      reactIs_development$1.isAsyncMode = isAsyncMode;
      reactIs_development$1.isConcurrentMode = isConcurrentMode;
      reactIs_development$1.isContextConsumer = isContextConsumer;
      reactIs_development$1.isContextProvider = isContextProvider;
      reactIs_development$1.isElement = isElement;
      reactIs_development$1.isForwardRef = isForwardRef;
      reactIs_development$1.isFragment = isFragment;
      reactIs_development$1.isLazy = isLazy;
      reactIs_development$1.isMemo = isMemo;
      reactIs_development$1.isPortal = isPortal;
      reactIs_development$1.isProfiler = isProfiler;
      reactIs_development$1.isStrictMode = isStrictMode;
      reactIs_development$1.isSuspense = isSuspense;
      reactIs_development$1.isValidElementType = isValidElementType;
      reactIs_development$1.typeOf = typeOf;
    })();
  }
  return reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  if (process.env.NODE_ENV === "production") {
    reactIs$1.exports = requireReactIs_production_min();
  } else {
    reactIs$1.exports = requireReactIs_development$1();
  }
  return reactIs$1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val2) {
    if (val2 === null || val2 === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val2);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key in from2) {
        if (hasOwnProperty.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from2, symbols[i])) {
            to[symbols[i]] = from2[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var has$1;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas) return has$1;
  hasRequiredHas = 1;
  has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
  return has$1;
}
var checkPropTypes_1;
var hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes) return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var printWarning = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
    var loggedTypeFailures = {};
    var has2 = /* @__PURE__ */ requireHas();
    printWarning = function(text2) {
      var message = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
  }
  function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
    if (process.env.NODE_ENV !== "production") {
      for (var typeSpecName in typeSpecs) {
        if (has2(typeSpecs, typeSpecName)) {
          var error;
          try {
            if (typeof typeSpecs[typeSpecName] !== "function") {
              var err = Error(
                (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              err.name = "Invariant Violation";
              throw err;
            }
            error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            );
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning(
              "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
            );
          }
        }
      }
    }
  }
  checkPropTypes.resetWarningCache = function() {
    if (process.env.NODE_ENV !== "production") {
      loggedTypeFailures = {};
    }
  };
  checkPropTypes_1 = checkPropTypes;
  return checkPropTypes_1;
}
var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var ReactIs = requireReactIs$1();
  var assign2 = requireObjectAssign();
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  var has2 = /* @__PURE__ */ requireHas();
  var checkPropTypes = /* @__PURE__ */ requireCheckPropTypes();
  var printWarning = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    printWarning = function(text2) {
      var message = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    var ANONYMOUS = "<<anonymous>>";
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker("array"),
      bigint: createPrimitiveTypeChecker("bigint"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      symbol: createPrimitiveTypeChecker("symbol"),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    function is2(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function PropTypeError(message, data2) {
      this.message = message;
      this.data = data2 && typeof data2 === "object" ? data2 : {};
      this.stack = "";
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== "production") {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            err.name = "Invariant Violation";
            throw err;
          } else if (process.env.NODE_ENV !== "production" && typeof console !== "undefined") {
            var cacheKey = componentName + ":" + propName;
            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
            }
            return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError(
            "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
            { expectedType }
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (process.env.NODE_ENV !== "production") {
          if (arguments.length > 1) {
            printWarning(
              "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
            );
          } else {
            printWarning("Invalid argument supplied to oneOf, expected an array.");
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is2(propValue, expectedValues[i])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type2 = getPreciseType(value);
          if (type2 === "symbol") {
            return String(value);
          }
          return value;
        });
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
        }
        for (var key in propValue) {
          if (has2(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== "production" ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
        return emptyFunctionThatReturnsNull;
      }
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== "function") {
          printWarning(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
          );
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate(props, propName, componentName, location, propFullName) {
        var expectedTypes = [];
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker2 = arrayOfTypeCheckers[i2];
          var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type2) {
      return new PropTypeError(
        (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
      );
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        var allKeys = assign2({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (has2(shapeTypes, key) && typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
            );
          }
          var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !propValue;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      if (propType === "symbol") {
        return true;
      }
      if (!propValue) {
        return false;
      }
      if (propValue["@@toStringTag"] === "Symbol") {
        return true;
      }
      if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (isSymbol(propType, propValue)) {
        return "symbol";
      }
      return propType;
    }
    function getPreciseType(propValue) {
      if (typeof propValue === "undefined" || propValue === null) {
        return "" + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === "object") {
        if (propValue instanceof Date) {
          return "date";
        } else if (propValue instanceof RegExp) {
          return "regexp";
        }
      }
      return propType;
    }
    function getPostfixForTypeWarning(value) {
      var type2 = getPreciseType(value);
      switch (type2) {
        case "array":
        case "object":
          return "an " + type2;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + type2;
        default:
          return type2;
      }
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithTypeCheckers;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim2(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bigint: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  if (process.env.NODE_ENV !== "production") {
    var ReactIs = requireReactIs$1();
    var throwOnDirectAccess = true;
    propTypes.exports = /* @__PURE__ */ requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
  } else {
    propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}
var reactIs = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type2) {
    return "string" === typeof type2 || "function" === typeof type2 || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || type2 === REACT_OFFSCREEN_TYPE || "object" === typeof type2 && null !== type2 && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_CONSUMER_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type2.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var reactIs_development = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  "production" !== process.env.NODE_ENV && function() {
    function typeOf(object) {
      if ("object" === typeof object && null !== object) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object = object.type, object) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return object;
              default:
                switch (object = object && object.$$typeof, object) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object;
                  case REACT_CONSUMER_TYPE:
                    return object;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    reactIs_development.ContextConsumer = REACT_CONSUMER_TYPE;
    reactIs_development.ContextProvider = REACT_CONTEXT_TYPE;
    reactIs_development.Element = REACT_ELEMENT_TYPE;
    reactIs_development.ForwardRef = REACT_FORWARD_REF_TYPE;
    reactIs_development.Fragment = REACT_FRAGMENT_TYPE;
    reactIs_development.Lazy = REACT_LAZY_TYPE;
    reactIs_development.Memo = REACT_MEMO_TYPE;
    reactIs_development.Portal = REACT_PORTAL_TYPE;
    reactIs_development.Profiler = REACT_PROFILER_TYPE;
    reactIs_development.StrictMode = REACT_STRICT_MODE_TYPE;
    reactIs_development.Suspense = REACT_SUSPENSE_TYPE;
    reactIs_development.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    reactIs_development.isContextConsumer = function(object) {
      return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    reactIs_development.isContextProvider = function(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    reactIs_development.isElement = function(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    reactIs_development.isForwardRef = function(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    reactIs_development.isFragment = function(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    reactIs_development.isLazy = function(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    };
    reactIs_development.isMemo = function(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    };
    reactIs_development.isPortal = function(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    };
    reactIs_development.isProfiler = function(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    };
    reactIs_development.isStrictMode = function(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    reactIs_development.isSuspense = function(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    reactIs_development.isSuspenseList = function(object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    reactIs_development.isValidElementType = function(type2) {
      return "string" === typeof type2 || "function" === typeof type2 || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || type2 === REACT_OFFSCREEN_TYPE || "object" === typeof type2 && null !== type2 && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_CONSUMER_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type2.getModuleId) ? true : false;
    };
    reactIs_development.typeOf = typeOf;
  }();
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  if (process.env.NODE_ENV === "production") {
    reactIs.exports = /* @__PURE__ */ requireReactIs_production();
  } else {
    reactIs.exports = /* @__PURE__ */ requireReactIs_development();
  }
  return reactIs.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs();
function getFunctionComponentName(Component, fallback = "") {
  return Component.displayName || Component.name || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
function getDisplayName(Component) {
  if (Component == null) {
    return void 0;
  }
  if (typeof Component === "string") {
    return Component;
  }
  if (typeof Component === "function") {
    return getFunctionComponentName(Component, "Component");
  }
  if (typeof Component === "object") {
    switch (Component.$$typeof) {
      case reactIsExports.ForwardRef:
        return getWrappedName(Component, Component.render, "ForwardRef");
      case reactIsExports.Memo:
        return getWrappedName(Component, Component.type, "memo");
      default:
        return void 0;
    }
  }
  return void 0;
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function resolveProps(defaultProps, props) {
  const output = {
    ...props
  };
  for (const key in defaultProps) {
    if (Object.prototype.hasOwnProperty.call(defaultProps, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            }
          }
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps[propName];
      }
    }
  }
  return output;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start = true;
    for (let i = 0; i < slot.length; i += 1) {
      const value = slot[i];
      if (value) {
        buffer += (start === true ? "" : " ") + getUtilityClass(value);
        start = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function clamp(val2, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val2, max2));
}
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
function merge$1(acc, item2) {
  if (!item2) {
    return acc;
  }
  return deepmerge(acc, item2, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const responsivePropType = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object, PropTypes.array]) : {};
function sortContainerQueries(theme, css2) {
  if (!theme.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a2, b2) => {
    var _a2, _b;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a2 = a2.match(regex)) == null ? void 0 : _a2[1]) || 0) - +(((_b = b2.match(regex)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key) => {
    const value = css2[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    if (process.env.NODE_ENV !== "production") {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The provided shorthand ${`(${shorthand})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : formatMuiErrorMessage(18, `(${shorthand})`));
    }
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node3, name) {
    node3.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node3.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node3.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node3.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node3.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const values = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item2, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a2;
  const breakpointsInOrder = (_a2 = breakpointsInput.keys) == null ? void 0 : _a2.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val2 = `vars.${path}`.split(".").reduce((acc, item2) => acc && acc[item2] ? acc[item2] : null, obj);
    if (val2 != null) {
      return val2;
    }
  }
  return path.split(".").reduce((acc, item2) => {
    if (acc && acc[item2] != null) {
      return acc[item2];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop: prop2,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn = (props) => {
    if (props[prop2] == null) {
      return null;
    }
    const propValue = props[prop2];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop2}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = process.env.NODE_ENV !== "production" ? {
    [prop2]: responsivePropType
  } : {};
  fn.filterProps = [prop2];
  return fn;
}
function memoize$1(fn) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases$1 = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$1((prop2) => {
  if (prop2.length > 2) {
    if (aliases$1[prop2]) {
      prop2 = aliases$1[prop2];
    } else {
      return [prop2];
    }
  }
  const [a2, b2] = prop2.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val2) => {
      if (typeof val2 === "string") {
        return val2;
      }
      if (process.env.NODE_ENV !== "production") {
        if (typeof val2 !== "number") {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${val2}.`);
        }
      }
      if (typeof themeSpacing === "string") {
        return `calc(${val2} * ${themeSpacing})`;
      }
      return themeSpacing * val2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val2) => {
      if (typeof val2 === "string") {
        return val2;
      }
      const abs2 = Math.abs(val2);
      if (process.env.NODE_ENV !== "production") {
        if (!Number.isInteger(abs2)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
        } else if (abs2 > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs2}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs2} > ${themeSpacing.length - 1}, you need to add the missing values.`].join("\n"));
        }
      }
      const transformed = themeSpacing[abs2];
      if (val2 >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  if (process.env.NODE_ENV !== "production") {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8, "spacing");
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop2, transformer) {
  if (!keys.includes(prop2)) {
    return null;
  }
  const cssProperties = getCssProperties(prop2);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop2];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop2) => resolveCssProperty(props, keys, prop2, transformer)).reduce(merge$1, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = process.env.NODE_ENV !== "production" ? marginKeys.reduce((obj, key) => {
  obj[key] = responsivePropType;
  return obj;
}, {}) : {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = process.env.NODE_ENV !== "production" ? paddingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType;
  return obj;
}, {}) : {};
padding.filterProps = paddingKeys;
process.env.NODE_ENV !== "production" ? spacingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType;
  return obj;
}, {}) : {};
function compose(...styles) {
  const handlers = styles.reduce((acc, style2) => {
    style2.filterProps.forEach((prop2) => {
      acc[prop2] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop2) => {
      if (handlers[prop2]) {
        return merge$1(acc, handlers[prop2](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = process.env.NODE_ENV !== "production" ? styles.reduce((acc, style2) => Object.assign(acc, style2.propTypes), {}) : {};
  fn.filterProps = styles.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop2, transform) {
  return style$1({
    prop: prop2,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: responsivePropType
} : {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8, "gap");
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: responsivePropType
} : {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: responsivePropType
} : {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: responsivePropType
} : {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a2, _b, _c, _d, _e;
      const breakpoint = ((_c = (_b = (_a2 = props.theme) == null ? void 0 : _a2.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop2, val2, theme, config) {
    const props = {
      [prop2]: val2,
      theme
    };
    const options = config[prop2];
    if (!options) {
      return {
        [prop2]: val2
      };
    }
    const {
      cssProperty = prop2,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val2 == null) {
      return null;
    }
    if (themeKey === "typography" && val2 === "inherit") {
      return {
        [prop2]: val2
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop2}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val2, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config = theme.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config[styleKey]) {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x) => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css2 = merge$1(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config));
          }
        }
      });
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var isDevelopment$2 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before2;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before2 = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before2 = _this.container.firstChild;
        } else {
          before2 = _this.before;
        }
      } else {
        before2 = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before2);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$2 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs$1 = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append$2(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent2, type2, props, children2, length2) {
  return { value, root, parent: parent2, type: type2, props, children: children2, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign$1(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev$1() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next$1() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice$1(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type2) {
  switch (type2) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice$1(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace$1(type2) {
  while (character = peek())
    if (character < 33)
      next$1();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next$1())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$1(index2, caret() + (count < 6 && peek() == 32 && next$1() == 32));
}
function delimiter(type2) {
  while (next$1())
    switch (character) {
      // ] ) " '
      case type2:
        return position;
      // " '
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      // \
      case 92:
        next$1();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next$1())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$1(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next$1());
}
function identifier(index2) {
  while (!token(peek()))
    next$1();
  return slice$1(index2, position);
}
function compile$1(value) {
  return dealloc(parse$3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$3(value, root, parent2, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children2 = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next$1()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append$2(comment(commenter(next$1(), caret()), root, parent2), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append$2(property > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append$2(reference = ruleset(characters2, root, parent2, index2, offset, rules, points, type2, props = [], children2 = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$3(characters2, root, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$3(value, reference, reference, rule && append$2(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse$3(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next$1());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent2, index2, offset, rules, points, type2, props, children2, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs$1(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent2, offset === 0 ? RULESET : type2, props, children2, length2);
}
function comment(value, root, parent2) {
  return node(value, root, parent2, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent2, length2) {
  return node(value, root, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children2, callback) {
  var output = "";
  var length2 = sizeof(children2);
  for (var i = 0; i < length2; i++)
    output += callback(children2[i], i, children2, callback) || "";
  return output;
}
function stringify$1(element, index2, children2, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children2 + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children2, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children2, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn(arg2);
    return cache[arg2];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next$1();
  }
  return slice$1(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next$1());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent2 = element.parent;
  var isImplicitRule = element.column === parent2.column && element.line === parent2.line;
  while (parent2.type !== "rule") {
    parent2 = parent2.parent;
    if (!parent2) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent2)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent2.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix$1(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children2, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix$1(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize$1([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize$1([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize$1([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert2;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$1, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize$1(compile$1(styles), serializer);
    };
    _insert2 = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert2
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment$1 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p22) {
          cursor = {
            name: p1,
            styles: p22,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes = interpolation;
      if (keyframes.anim === 1) {
        cursor = {
          name: keyframes.name,
          styles: keyframes.styles,
          next: cursor
        };
        return keyframes.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$1) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var EmotionCacheContext = /* @__PURE__ */ React.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ forwardRef(function(props, ref2) {
    var cache = useContext(EmotionCacheContext);
    return func(props, cache, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ React.createContext({});
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop2) {
    return reactPropsRegex.test(prop2) || prop2.charCodeAt(0) === 111 && prop2.charCodeAt(1) === 110 && prop2.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment = false;
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      var templateStringsArr = args[0];
      styles.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles.push(args[i], templateStringsArr[i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref2) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref2) {
        newProps.ref = ref2;
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ React.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled2 = createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled2.apply(void 0, styles);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind(null);
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
/**
 * @mui/styled-engine v6.2.1
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$1(tag, options) {
  const stylesFactory = newStyled(tag, options);
  if (process.env.NODE_ENV !== "production") {
    return (...styles) => {
      const component = typeof tag === "string" ? `"${tag}"` : "component";
      if (styles.length === 0) {
        console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join("\n"));
      } else if (styles.some((style2) => style2 === void 0)) {
        console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
      }
      return stylesFactory(...styles);
    };
  }
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles) {
  wrapper[0] = styles;
  return serializeStyles(wrapper);
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end2) {
    const endIndex = keys.indexOf(end2);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not2(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not: not2,
    unit,
    ...other
  };
}
const shape = {
  borderRadius: 4
};
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    if (process.env.NODE_ENV !== "production") {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function applyStyles(key, styles) {
  var _a2;
  const theme = this;
  if (theme.vars) {
    if (!((_a2 = theme.colorSchemes) == null ? void 0 : _a2[key]) || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key);
    if (selector === "&") {
      return styles;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles
    };
  }
  if (theme.palette.mode === key) {
    return styles;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function preprocessStyles(input) {
  const {
    variants,
    ...style2
  } = input;
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop2) {
  return prop2 !== "ownerState" && prop2 !== "theme" && prop2 !== "sx" && prop2 !== "as";
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles) => styles[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = resolvedStyle.style;
    } else {
      const {
        variants,
        ...otherStyles
      } = resolvedStyle;
      rootStyle = otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
  }
  if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
    return resolvedStyle.style;
  }
  return resolvedStyle;
}
function processStyleVariants(props, variants, results = []) {
  var _a2;
  let mergedState;
  variantLoop: for (let i = 0; i < variants.length; i += 1) {
    const variant = variants[i];
    if (typeof variant.props === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key in variant.props) {
        if (props[key] !== variant.props[key] && ((_a2 = props.ownerState) == null ? void 0 : _a2[key]) !== variant.props[key]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      results.push(variant.style(mergedState));
    } else {
      results.push(variant.style);
    }
  }
  return results;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles) => styles.filter((style2) => style2 !== styleFunctionSx));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$1(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel(componentName, componentSlot),
      ...options
    });
    const transformStyle = (style2) => {
      if (typeof style2 === "function" && style2.__emotion_real !== style2) {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2);
        };
      }
      if (isPlainObject(style2)) {
        const serialized = preprocessStyles(style2);
        if (!serialized.variants) {
          return serialized.style;
        }
        return function styleObjectProcessor(props) {
          return processStyle(props, serialized);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver) {
        expressionsTail.push(function styleThemeOverrides(props) {
          var _a2, _b;
          const theme = props.theme;
          const styleOverrides = (_b = (_a2 = theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
          }
          return overridesResolver(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          var _a2, _b;
          const theme = props.theme;
          const themeVariants = (_b = (_a2 = theme == null ? void 0 : theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      if (process.env.NODE_ENV !== "production") {
        Component.displayName = generateDisplayName(componentName, componentSlot, tag);
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateDisplayName(componentName, componentSlot, tag) {
  if (componentName) {
    return `${componentName}${capitalize(componentSlot || "")}`;
  }
  return `Styled(${getDisplayName(tag)})`;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  if (process.env.NODE_ENV !== "production") {
    if (componentName) {
      label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`;
    }
  }
  return label;
}
function isObjectEmpty(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  if (process.env.NODE_ENV !== "production") {
    if (value < min2 || value > max2) {
      console.error(`MUI: The value provided ${value} is out of range [${min2}, ${max2}].`);
    }
  }
  return clamp(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  if (process.env.NODE_ENV !== "production") {
    if (color2.length !== color2.trim().length) {
      console.error(`MUI: The color: "${color2}" is invalid. Make sure the color input doesn't contain leading/trailing space.`);
    }
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index2) => {
    return index2 < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type2 = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type2)) {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${color2}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type2 === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type: type2,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val2, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val2}%` : val2).join(" ");
};
const private_safeColorChannel = (color2, warning) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    if (warning && process.env.NODE_ENV !== "production") {
      console.warn(warning);
    }
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type: type2,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type2.includes("rgb")) {
    values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type2.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type2.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type2}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h = values2[0];
  const s = values2[1] / 100;
  const l = values2[2] / 100;
  const a2 = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type2 = "rgb";
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color2.type === "hsla") {
    type2 += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type: type2,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val2) => {
    if (color2.type !== "color") {
      val2 /= 255;
    }
    return val2 <= 0.03928 ? val2 / 12.92 : ((val2 + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha$1(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning) {
  try {
    return alpha$1(color2, value);
  } catch (error) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
const PropsContext = /* @__PURE__ */ React.createContext(void 0);
process.env.NODE_ENV !== "production" ? {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: PropTypes.node,
  /**
   * @ignore
   */
  value: PropTypes.object
} : void 0;
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config = theme.components[name];
  if (config.defaultProps) {
    return resolveProps(config.defaultProps, props);
  }
  if (!config.styleOverrides && !config.variants) {
    return resolveProps(config, props);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = React.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k, index2) => {
    if (index2 === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k]) {
        temp[k] = arrayKeys.includes(k) ? [] : {};
      }
      temp = temp[k];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop2) => keys.includes(prop2))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a2, _b;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _a2, _b;
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: {
            ...css2
          }
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_b = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css: css2
    }]) => {
      var _a3, _b2;
      const cssColorSheme = (_b2 = (_a3 = colorSchemes[key]) == null ? void 0 : _a3.palette) == null ? void 0 : _b2.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      if (process.env.NODE_ENV !== "production") {
        if (colorScheme !== "light" && colorScheme !== "dark") {
          console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${colorScheme}'.`);
        }
      }
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
const common = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const green$1 = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const contrast = getContrastRatio(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color2.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  if (process.env.NODE_ENV !== "production") {
    if (!modeHydrated) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries = Object.entries(typography);
  entries.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  if (process.env.NODE_ENV !== "production") {
    if (typeof fontSize !== "number") {
      console.error("MUI: `fontSize` is required to be a number.");
    }
    if (typeof htmlFontSize !== "number") {
      console.error("MUI: `htmlFontSize` is required to be a number.");
    }
  }
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => ({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing / size)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0,
      ...other
    } = options;
    if (process.env.NODE_ENV !== "production") {
      const isString = (value) => typeof value === "string";
      const isNumber2 = (value) => !Number.isNaN(parseFloat(value));
      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber2(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber2(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (typeof options !== "object") {
        console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join("\n"));
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val2) {
  return isPlainObject(val2) || typeof val2 === "undefined" || typeof val2 === "string" || typeof val2 === "boolean" || typeof val2 === "number" || Array.isArray(val2);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index2 = 0; index2 < array.length; index2++) {
      const [key, value] = array[index2];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject(value)) {
        object[key] = {
          ...value
        };
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars) {
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : formatMuiErrorMessage(20));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  if (process.env.NODE_ENV !== "production") {
    const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
    const traverse = (node2, component) => {
      let key;
      for (key in node2) {
        const child = node2[key];
        if (stateClasses.includes(key) && Object.keys(child).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const stateClass = generateUtilityClass("", key);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node2, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
          }
          node2[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach((component) => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.startsWith("Mui")) {
        traverse(styleOverrides, component);
      }
    });
  }
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    ...rest
  } = options;
  const palette = createPalette(paletteInput);
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys) {
  var _a2;
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!((_a2 = keys[1]) == null ? void 0 : _a2.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme) => (colorScheme, css2) => {
  const root = theme.rootSelector || ":root";
  const selector = theme.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root]: {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};
function assignNode(obj, keys) {
  keys.forEach((k) => {
    if (!obj[k]) {
      obj[k] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn) => {
  try {
    return fn();
  } catch (error) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode,
        ...scheme == null ? void 0 : scheme.palette
      }
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode,
      ...scheme == null ? void 0 : scheme.palette
    }
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette,
    opacity: {
      ...getOpacity(mode),
      ...scheme == null ? void 0 : scheme.opacity
    },
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The \`colorSchemes.${defaultColorScheme}\` option is either missing or invalid.` : formatMuiErrorMessage(21, defaultColorScheme));
  }
  const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSchemes, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key) => {
    const palette = theme.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
    theme[key] = value;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input == null ? void 0 : input.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}
function attachColorScheme(theme, scheme, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme = createTheme();
const THEME_ID = "$$material";
function slotShouldForwardProp(prop2) {
  return prop2 !== "ownerState" && prop2 !== "theme" && prop2 !== "sx" && prop2 !== "as";
}
const rootShouldForwardProp = (prop2) => slotShouldForwardProp(prop2) && prop2 !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme,
  rootShouldForwardProp
});
const memoTheme = unstable_memoTheme;
process.env.NODE_ENV !== "production" ? {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: PropTypes.node,
  /**
   * @ignore
   */
  value: PropTypes.object.isRequired
} : void 0;
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.color !== "inherit" && styles[`color${capitalize(ownerState.color)}`], styles[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme
}) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (_d = (_a2 = theme.transitions) == null ? void 0 : _a2.create) == null ? void 0 : _d.call(_a2, "fill", {
      duration: (_c = (_b = (theme.vars ?? theme).transitions) == null ? void 0 : _b.duration) == null ? void 0 : _c.shorter
    }),
    variants: [
      {
        props: (props) => !props.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((_f = (_e = theme.typography) == null ? void 0 : _e.pxToRem) == null ? void 0 : _f.call(_e, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((_h = (_g = theme.typography) == null ? void 0 : _g.pxToRem) == null ? void 0 : _h.call(_g, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((_j = (_i = theme.typography) == null ? void 0 : _i.pxToRem) == null ? void 0 : _j.call(_i, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color2]) => {
        var _a3, _b2;
        return {
          props: {
            color: color2
          },
          style: {
            color: (_b2 = (_a3 = (theme.vars ?? theme).palette) == null ? void 0 : _a3[color2]) == null ? void 0 : _b2.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (_l = (_k = (theme.vars ?? theme).palette) == null ? void 0 : _k.action) == null ? void 0 : _l.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_n = (_m = (theme.vars ?? theme).palette) == null ? void 0 : _m.action) == null ? void 0 : _n.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
}));
const SvgIcon = /* @__PURE__ */ React.forwardRef(function SvgIcon2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children: children2,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24",
    ...other
  } = props;
  const hasSvgAsChild = /* @__PURE__ */ React.isValidElement(children2) && children2.type === "svg";
  const ownerState = {
    ...props,
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  };
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, {
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref: ref2,
    ...more,
    ...other,
    ...hasSvgAsChild && children2.props,
    ownerState,
    children: [hasSvgAsChild ? children2.props.children : children2, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  });
});
process.env.NODE_ENV !== "production" ? SvgIcon.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Node passed into the SVG element.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "large", "medium", "small"]), PropTypes.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: PropTypes.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: PropTypes.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: PropTypes.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: PropTypes.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: PropTypes.string
} : void 0;
if (SvgIcon) {
  SvgIcon.muiName = "SvgIcon";
}
function createSvgIcon(path, displayName) {
  function Component(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, {
      "data-testid": `${displayName}Icon`,
      ref: ref2,
      ...props,
      children: path
    });
  }
  if (process.env.NODE_ENV !== "production") {
    Component.displayName = `${displayName}Icon`;
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(Component));
}
const NewReleases = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m23 12-2.44-2.78.34-3.68-3.61-.82-1.89-3.18L12 3 8.6 1.54 6.71 4.72l-3.61.81.34 3.68L1 12l2.44 2.78-.34 3.69 3.61.82 1.89 3.18L12 21l3.4 1.46 1.89-3.18 3.61-.82-.34-3.68zm-10 5h-2v-2h2zm0-4h-2V7h2z"
}), "NewReleases");
const PropertyTypeMandatoryIcon = React__default.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(NewReleases, { ref: ref2, ...props }));
const polyglotApiAtom = atom({
  key: "polyglotApiAtom",
  default: void 0
});
function useI18nApiOptional() {
  return useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(polyglotApiAtom);
}
function useI18nApi() {
  const i18n = useI18nApiOptional();
  if (!i18n) {
    throw new Error("i18n not initialized in state");
  }
  return i18n;
}
function useGlobalTranslationCode() {
  const i18n = useI18nApi();
  return i18n.locale;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pluralize$1 = { exports: {} };
var pluralize = pluralize$1.exports;
var hasRequiredPluralize;
function requirePluralize() {
  if (hasRequiredPluralize) return pluralize$1.exports;
  hasRequiredPluralize = 1;
  (function(module, exports) {
    (function(root, pluralize2) {
      if (typeof commonjsRequire === "function" && true && true) {
        module.exports = pluralize2();
      } else {
        root.pluralize = pluralize2();
      }
    })(pluralize, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2) return token2;
        if (word === word.toLowerCase()) return token2.toLowerCase();
        if (word === word.toUpperCase()) return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match2, index2) {
          return args[index2] || "";
        });
      }
      function replace2(word, rule) {
        return word.replace(rule[0], function(match2, index2) {
          var result = interpolate(rule[1], arguments);
          if (match2 === "") {
            return restoreCase(word[index2 - 1], result);
          }
          return restoreCase(match2, result);
        });
      }
      function sanitizeWord(token2, word, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace2(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) return true;
          if (replaceMap.hasOwnProperty(token2)) return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize2(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  })(pluralize$1);
  return pluralize$1.exports;
}
var pluralizeExports = requirePluralize();
const toUnderscore = (input) => {
  return input.replace(/([A-Z])/g, ($1) => "_" + $1.toLowerCase());
};
const toPlural = (s) => {
  return pluralizeExports.plural(s);
};
const singularize = (s) => {
  return pluralizeExports.singular(s);
};
function capitalizeFirstLetter(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
const jupKeyIdSuffix = "Id";
function getTargetObjectTypeCapitalizedName(propertyType) {
  const { type: type2, name } = propertyType;
  if (["belongs-to"].includes(type2)) {
    return capitalizeFirstLetter(name);
  }
  if (["has-many-paginated", "has-many"].includes(type2)) {
    return singularize(capitalizeFirstLetter(name));
  }
  if (["foreign-key"].includes(type2)) {
    const regexp = new RegExp(`${jupKeyIdSuffix}$`, "gi");
    return capitalizeFirstLetter(name.replace(regexp, ""));
  }
}
const tenantInfo = {
  objectType: "company",
  idProperty: "companyId"
};
function includeJupType(list, type2) {
  return list.includes(type2);
}
function isPropertyTypeScalar(propertyType) {
  const { type: type2 } = propertyType;
  return !includeJupType(["belongs-to", "has-many-paginated", "has-many"], type2);
}
function isPropertyTypeId(propertyType) {
  const { type: type2 } = propertyType;
  if (includeJupType(["primary-key", "foreign-key"], type2)) {
    return true;
  }
  return false;
}
function isPropertyTypeBelongsTo(propertyType) {
  const { type: type2 } = propertyType;
  return includeJupType(["belongs-to"], type2);
}
function isPropertyTypeHasMany(propertyType) {
  const { type: type2 } = propertyType;
  return includeJupType(["has-many", "has-many-paginated"], type2);
}
function getTargetObjectTypeDefinition(propertyType) {
  const { association } = propertyType;
  if (association) {
    return getObjectTypeDefinitionByName(association.targetModelName);
  }
  throw new Error(`missing target property type for property <${propertyType.name}> on ${propertyType.objectTypeName}`);
}
function objectTypePluralLabel(translation, objectTypeName) {
  const otDef = getObjectTypeDefinitionByName(objectTypeName);
  if (!otDef) {
    return toPlural(objectTypeName);
  }
  return translation(`models.${otDef.capitalized.singular}.plural`);
}
function objectTypeCapitalizedPluralLabel(translation, objectTypeName) {
  return capitalizeFirstLetter(objectTypePluralLabel(translation, objectTypeName));
}
const technicalPropertyTypeNames = {
  externalId: "externalId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  userCompanyCreatedBy: "userCompanyCreatedBy",
  userCompanyCreatedById: "userCompanyCreatedById",
  userCompanyUpdatedBy: "userCompanyUpdatedBy",
  userCompanyUpdatedById: "userCompanyUpdatedById"
};
const technicalPropertyTypes = [
  technicalPropertyTypeNames.externalId,
  technicalPropertyTypeNames.createdAt,
  technicalPropertyTypeNames.updatedAt,
  technicalPropertyTypeNames.userCompanyCreatedBy,
  technicalPropertyTypeNames.userCompanyCreatedById,
  technicalPropertyTypeNames.userCompanyUpdatedBy,
  technicalPropertyTypeNames.userCompanyUpdatedById
];
const calculatedSpacesPropertyNames = [
  "workplacesCount",
  "workplacesRatio",
  "freeWorkplacesCount",
  "flexWorkplacesCount",
  "flexRatio",
  "sharedWorkplacesCount",
  "sharedWorkplacesRatio",
  "transitWorkplacesCount",
  "seatsCount",
  "totalCapacityCount",
  "totalCapacityWorkplaceCountRatio",
  "carbonFootprint"
];
const calculatedPeoplePropertyNames = [
  "totalPeopleCount",
  "peopleRatio",
  "expansionRatio",
  "seatsPeopleRatio",
  "occupancyRate"
];
const calculatedInfoPropertyNames = [
  ...calculatedPeoplePropertyNames,
  ...calculatedSpacesPropertyNames
];
const roomPropertyNames = [
  "roomsCount",
  "roomsArea"
];
const calculatedGlobalPropertyNames = [
  ...roomPropertyNames,
  ...calculatedInfoPropertyNames
];
const allCalculatedPropertiesForTranslations = [
  ...calculatedGlobalPropertyNames,
  "peopleCount"
];
function getObjectTypeSingularLabel(translation, objectTypeName) {
  const otDef = getObjectTypeDefinitionByName(objectTypeName);
  if (!otDef) {
    return objectTypeName;
  }
  return translation(`models.${otDef.capitalized.singular}.singular`);
}
function getObjectTypeCapitalizedSingularLabel(translation, objectTypeName) {
  return capitalizeFirstLetter(getObjectTypeSingularLabel(translation, objectTypeName));
}
function getPropertyTypeLabelWithTranslation(i18n, propertyType) {
  var _a2, _b;
  const { objectTypeName, type: type2, name } = propertyType;
  const objectTypeDefinition = getObjectTypeDefinitionByName(objectTypeName);
  if (technicalPropertyTypes.includes(name)) {
    return i18n.translate(`entity.properties.${name}.label`);
  }
  const defaultKey = `models.${objectTypeDefinition.capitalized.singular}.properties.${name}.label`;
  const d = i18n.translate(defaultKey);
  if (i18n.has(defaultKey)) {
    return d;
  }
  if (allCalculatedPropertiesForTranslations.includes(name)) {
    const key = `calculatedProperties.properties.${name}.label`;
    if (i18n.has(key)) {
      return i18n.translate(key);
    }
  }
  const belongsToCapitalizedObjectTypeName = getTargetObjectTypeCapitalizedName(propertyType);
  if (isPropertyTypeBelongsTo(propertyType)) {
    return capitalizeFirstLetter(i18n.translate(`models.${belongsToCapitalizedObjectTypeName}.singular`));
  }
  if (type2 === "foreign-key") {
    const fkKey = `models.${belongsToCapitalizedObjectTypeName}.properties.id.label`;
    if (i18n.has(fkKey)) {
      return i18n.translate(fkKey);
    } else if ((_a2 = propertyType.association) == null ? void 0 : _a2.targetModelName) {
      return `Id (${getObjectTypeSingularLabel(i18n.translate, (_b = propertyType.association) == null ? void 0 : _b.targetModelName)})`;
    } else {
      return "Id (?)";
    }
  }
  if (isPropertyTypeHasMany(propertyType)) {
    const targetObjectType = getTargetObjectTypeDefinition(propertyType);
    return objectTypeCapitalizedPluralLabel(i18n.translate, targetObjectType.name);
  }
  return d || `<${name}>`;
}
function PropertyTypeMandatoryText(props) {
  const { propertyType } = props;
  const i18n = useI18nApi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getPropertyTypeMandatoryText(i18n, propertyType) });
}
function getPropertyTypeMandatoryText(i18nApi, propertyType) {
  return i18nApi.translate("entity.properties.mandatory", { name: getPropertyTypeLabelWithTranslation(i18nApi, propertyType) });
}
function PropertyTypeMandatoryLabel(props) {
  const { propertyType } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", style: { display: "flex", alignItems: "center" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTypeMandatoryIcon, { sx: { marginRight: 1 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTypeMandatoryText, { propertyType })
  ] });
}
function getTranslatedUnit(translation, unit) {
  if (unit) {
    return translation(`${unit.type}.${unit.value}`);
  }
}
const PropertyTypeLabel = React__default.forwardRef((props, ref2) => {
  const { propertyType, displayUnit, style: style2, ...otherProps } = props;
  const i18n = useI18nApi();
  const unit = displayUnit && propertyType.options.unit && ` (${getTranslatedUnit(i18n.translate, propertyType.options.unit)})`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { ref: ref2, style: style2, ...otherProps, children: [
    getPropertyTypeLabelWithTranslation(i18n, props.propertyType),
    unit
  ] });
});
const versionCookieKeyName = "x-version";
const version = { "major": 3, "minor": 4, "build": 61 };
function getAppVersion() {
  const { major, minor, build } = version;
  return `${major}.${minor}.${build}`;
}
const appVersion = getAppVersion();
var isArguments;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1) return isArguments;
  hasRequiredIsArguments$1 = 1;
  var toStr = Object.prototype.toString;
  isArguments = function isArguments2(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
  return isArguments;
}
var implementation$2;
var hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2) return implementation$2;
  hasRequiredImplementation$2 = 1;
  var keysShim;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = requireIsArguments$1();
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys(object) {
      var isObject = object !== null && typeof object === "object";
      var isFunction = toStr.call(object) === "[object Function]";
      var isArguments2 = isArgs(object);
      var isString = isObject && toStr.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject && !isFunction && !isArguments2) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction;
      if (isString && object.length > 0 && !has2.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments2 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && has2.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has2.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$2 = keysShim;
  return implementation$2;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var slice2 = Array.prototype.slice;
  var isArgs = requireIsArguments$1();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
  } : requireImplementation$2();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object) {
          if (isArgs(object)) {
            return originalKeys(slice2.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  objectKeys = keysShim;
  return objectKeys;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties) return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var keys = requireObjectKeys();
  var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var defineDataProperty2 = /* @__PURE__ */ requireDefineDataProperty();
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var supportsDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var defineProperty = function(object, name, value, predicate) {
    if (name in object) {
      if (predicate === true) {
        if (object[name] === value) {
          return;
        }
      } else if (!isFunction(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty2(object, name, value, true);
    } else {
      defineDataProperty2(object, name, value);
    }
  };
  var defineProperties = function(object, map2) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map2);
    if (hasSymbols2) {
      props = concat.call(props, Object.getOwnPropertySymbols(map2));
    }
    for (var i = 0; i < props.length; i += 1) {
      defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  defineProperties_1 = defineProperties;
  return defineProperties_1;
}
var callBind = { exports: {} };
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor$1;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor$1;
  hasRequiredFloor = 1;
  floor$1 = Math.floor;
  return floor$1;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1;
  hasRequiredImplementation$1 = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a2, b2) {
    var arr = [];
    for (var i = 0; i < a2.length; i += 1) {
      arr[i] = a2[i];
    }
    for (var j = 0; j < b2.length; j += 1) {
      arr[j + a2.length] = b2[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation$1 = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$1;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation$1();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
var get$1;
var hasRequiredGet$1;
function requireGet$1() {
  if (hasRequiredGet$1) return get$1;
  hasRequiredGet$1 = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get$1;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getDunderProto = /* @__PURE__ */ requireGet$1();
  var getProto = typeof Reflect === "function" && Reflect.getPrototypeOf || $Object.getPrototypeOf || getDunderProto;
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn2 = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first2 = $strSlice(string, 0, 1);
    var last2 = $strSlice(string, -1);
    if (first2 === "%" && last2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last2 === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match2, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn2(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last2 = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn2(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn2(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = /* @__PURE__ */ requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length2) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor(length2) !== length2) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc = gOPD2(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length2,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length2
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var actualApply2 = requireActualApply();
  applyBind = function applyBind2() {
    return actualApply2(bind, $apply, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var callBindBasic = requireCallBindApplyHelpers();
    var applyBind2 = requireApplyBind();
    module.exports = function callBind2(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind2 });
    } else {
      module.exports.apply = applyBind2;
    }
  })(callBind);
  return callBind.exports;
}
var RequireObjectCoercible;
var hasRequiredRequireObjectCoercible;
function requireRequireObjectCoercible() {
  if (hasRequiredRequireObjectCoercible) return RequireObjectCoercible;
  hasRequiredRequireObjectCoercible = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  RequireObjectCoercible = function RequireObjectCoercible2(value) {
    if (value == null) {
      throw new $TypeError(arguments.length > 0 && arguments[1] || "Cannot call method on " + value);
    }
    return value;
  };
  return RequireObjectCoercible;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var RequireObjectCoercible2 = /* @__PURE__ */ requireRequireObjectCoercible();
  var callBound2 = requireCallBound();
  var $isEnumerable = callBound2("Object.prototype.propertyIsEnumerable");
  var $push = callBound2("Array.prototype.push");
  implementation = function entries(O) {
    var obj = RequireObjectCoercible2(O);
    var entrys = [];
    for (var key in obj) {
      if ($isEnumerable(obj, key)) {
        $push(entrys, [key, obj[key]]);
      }
    }
    return entrys;
  };
  return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var implementation2 = requireImplementation();
  polyfill = function getPolyfill() {
    return typeof Object.entries === "function" ? Object.entries : implementation2;
  };
  return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim;
  hasRequiredShim = 1;
  var getPolyfill = requirePolyfill();
  var define = requireDefineProperties();
  shim = function shimEntries() {
    var polyfill2 = getPolyfill();
    define(Object, { entries: polyfill2 }, {
      entries: function testEntries() {
        return Object.entries !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim;
}
var object_entries;
var hasRequiredObject_entries;
function requireObject_entries() {
  if (hasRequiredObject_entries) return object_entries;
  hasRequiredObject_entries = 1;
  var define = requireDefineProperties();
  var callBind2 = requireCallBind();
  var implementation2 = requireImplementation();
  var getPolyfill = requirePolyfill();
  var shim2 = requireShim();
  var polyfill2 = callBind2(getPolyfill(), Object);
  define(polyfill2, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  object_entries = polyfill2;
  return object_entries;
}
var warning_1;
var hasRequiredWarning;
function requireWarning() {
  if (hasRequiredWarning) return warning_1;
  hasRequiredWarning = 1;
  var __DEV__ = process.env.NODE_ENV !== "production";
  var warning = function() {
  };
  if (__DEV__) {
    var printWarning = function printWarning2(format, args) {
      var len = arguments.length;
      args = new Array(len > 1 ? len - 1 : 0);
      for (var key = 1; key < len; key++) {
        args[key - 1] = arguments[key];
      }
      var argIndex = 0;
      var message = "Warning: " + format.replace(/%s/g, function() {
        return args[argIndex++];
      });
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
    warning = function(condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);
      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }
      if (format === void 0) {
        throw new Error(
          "`warning(condition, format, ...args)` requires a warning message argument"
        );
      }
      if (!condition) {
        printWarning.apply(null, [format].concat(args));
      }
    };
  }
  warning_1 = warning;
  return warning_1;
}
var nodePolyglot;
var hasRequiredNodePolyglot;
function requireNodePolyglot() {
  if (hasRequiredNodePolyglot) return nodePolyglot;
  hasRequiredNodePolyglot = 1;
  var entries = requireObject_entries();
  var warning = requireWarning();
  var has2 = /* @__PURE__ */ requireHasown();
  var warn = function warn2(message) {
    warning(false, message);
  };
  var defaultReplace = String.prototype.replace;
  var split = String.prototype.split;
  var delimiter2 = "||||";
  var russianPluralGroups = function(n) {
    var lastTwo = n % 100;
    var end2 = lastTwo % 10;
    if (lastTwo !== 11 && end2 === 1) {
      return 0;
    }
    if (2 <= end2 && end2 <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {
      return 1;
    }
    return 2;
  };
  var defaultPluralRules = {
    // Mapping from pluralization group plural logic.
    pluralTypes: {
      arabic: function(n) {
        if (n < 3) {
          return n;
        }
        var lastTwo = n % 100;
        if (lastTwo >= 3 && lastTwo <= 10) return 3;
        return lastTwo >= 11 ? 4 : 5;
      },
      bosnian_serbian: russianPluralGroups,
      chinese: function() {
        return 0;
      },
      croatian: russianPluralGroups,
      french: function(n) {
        return n >= 2 ? 1 : 0;
      },
      german: function(n) {
        return n !== 1 ? 1 : 0;
      },
      russian: russianPluralGroups,
      lithuanian: function(n) {
        if (n % 10 === 1 && n % 100 !== 11) {
          return 0;
        }
        return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;
      },
      czech: function(n) {
        if (n === 1) {
          return 0;
        }
        return n >= 2 && n <= 4 ? 1 : 2;
      },
      polish: function(n) {
        if (n === 1) {
          return 0;
        }
        var end2 = n % 10;
        return 2 <= end2 && end2 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
      },
      icelandic: function(n) {
        return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;
      },
      slovenian: function(n) {
        var lastTwo = n % 100;
        if (lastTwo === 1) {
          return 0;
        }
        if (lastTwo === 2) {
          return 1;
        }
        if (lastTwo === 3 || lastTwo === 4) {
          return 2;
        }
        return 3;
      },
      romanian: function(n) {
        if (n === 1) {
          return 0;
        }
        var lastTwo = n % 100;
        if (n === 0 || lastTwo >= 2 && lastTwo <= 19) {
          return 1;
        }
        return 2;
      },
      ukrainian: russianPluralGroups
    },
    // Mapping from pluralization group to individual language codes/locales.
    // Will look up based on exact match, if not found and it's a locale will parse the locale
    // for language code, and if that does not exist will default to 'en'
    pluralTypeToLanguages: {
      arabic: ["ar"],
      bosnian_serbian: ["bs-Latn-BA", "bs-Cyrl-BA", "srl-RS", "sr-RS"],
      chinese: ["id", "id-ID", "ja", "ko", "ko-KR", "lo", "ms", "th", "th-TH", "zh"],
      croatian: ["hr", "hr-HR"],
      german: ["fa", "da", "de", "en", "es", "fi", "el", "he", "hi-IN", "hu", "hu-HU", "it", "nl", "no", "pt", "sv", "tr"],
      french: ["fr", "tl", "pt-br"],
      russian: ["ru", "ru-RU"],
      lithuanian: ["lt"],
      czech: ["cs", "cs-CZ", "sk"],
      polish: ["pl"],
      icelandic: ["is", "mk"],
      slovenian: ["sl-SL"],
      romanian: ["ro"],
      ukrainian: ["uk", "ua"]
    }
  };
  function langToTypeMap(mapping) {
    var ret = {};
    var mappingEntries = entries(mapping);
    for (var i = 0; i < mappingEntries.length; i += 1) {
      var type2 = mappingEntries[i][0];
      var langs = mappingEntries[i][1];
      for (var j = 0; j < langs.length; j += 1) {
        ret[langs[j]] = type2;
      }
    }
    return ret;
  }
  function pluralTypeName(pluralRules, locale) {
    var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);
    return langToPluralType[locale] || langToPluralType[split.call(locale, /-/, 1)[0]] || langToPluralType.en;
  }
  function pluralTypeIndex(pluralRules, pluralType, count) {
    return pluralRules.pluralTypes[pluralType](count);
  }
  function createMemoizedPluralTypeNameSelector() {
    var localePluralTypeStorage = {};
    return function(pluralRules, locale) {
      var pluralType = localePluralTypeStorage[locale];
      if (pluralType && !pluralRules.pluralTypes[pluralType]) {
        pluralType = null;
        localePluralTypeStorage[locale] = pluralType;
      }
      if (!pluralType) {
        pluralType = pluralTypeName(pluralRules, locale);
        if (pluralType) {
          localePluralTypeStorage[locale] = pluralType;
        }
      }
      return pluralType;
    };
  }
  function escape2(token2) {
    return token2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function constructTokenRegex(opts) {
    var prefix2 = opts && opts.prefix || "%{";
    var suffix = opts && opts.suffix || "}";
    if (prefix2 === delimiter2 || suffix === delimiter2) {
      throw new RangeError('"' + delimiter2 + '" token is reserved for pluralization');
    }
    return new RegExp(escape2(prefix2) + "(.*?)" + escape2(suffix), "g");
  }
  var memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();
  var defaultTokenRegex = /%\{(.*?)\}/g;
  function transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules, replaceImplementation) {
    if (typeof phrase !== "string") {
      throw new TypeError("Polyglot.transformPhrase expects argument #1 to be string");
    }
    if (substitutions == null) {
      return phrase;
    }
    var result = phrase;
    var interpolationRegex = tokenRegex || defaultTokenRegex;
    var replace2 = replaceImplementation || defaultReplace;
    var options = typeof substitutions === "number" ? { smart_count: substitutions } : substitutions;
    if (options.smart_count != null && phrase) {
      var pluralRulesOrDefault = pluralRules || defaultPluralRules;
      var texts = split.call(phrase, delimiter2);
      var bestLocale = locale || "en";
      var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);
      var pluralTypeWithCount = pluralTypeIndex(
        pluralRulesOrDefault,
        pluralType,
        options.smart_count
      );
      result = defaultReplace.call(texts[pluralTypeWithCount] || texts[0], /^[^\S]*|[^\S]*$/g, "");
    }
    result = replace2.call(result, interpolationRegex, function(expression, argument) {
      if (!has2(options, argument) || options[argument] == null) {
        return expression;
      }
      return options[argument];
    });
    return result;
  }
  function Polyglot2(options) {
    var opts = options || {};
    this.phrases = {};
    this.extend(opts.phrases || {});
    this.currentLocale = opts.locale || "en";
    var allowMissing = opts.allowMissing ? transformPhrase : null;
    this.onMissingKey = typeof opts.onMissingKey === "function" ? opts.onMissingKey : allowMissing;
    this.warn = opts.warn || warn;
    this.replaceImplementation = opts.replace || defaultReplace;
    this.tokenRegex = constructTokenRegex(opts.interpolation);
    this.pluralRules = opts.pluralRules || defaultPluralRules;
  }
  Polyglot2.prototype.locale = function(newLocale) {
    if (newLocale) this.currentLocale = newLocale;
    return this.currentLocale;
  };
  Polyglot2.prototype.extend = function(morePhrases, prefix2) {
    var phraseEntries = entries(morePhrases || {});
    for (var i = 0; i < phraseEntries.length; i += 1) {
      var key = phraseEntries[i][0];
      var phrase = phraseEntries[i][1];
      var prefixedKey = prefix2 ? prefix2 + "." + key : key;
      if (typeof phrase === "object") {
        this.extend(phrase, prefixedKey);
      } else {
        this.phrases[prefixedKey] = phrase;
      }
    }
  };
  Polyglot2.prototype.unset = function(morePhrases, prefix2) {
    if (typeof morePhrases === "string") {
      delete this.phrases[morePhrases];
    } else {
      var phraseEntries = entries(morePhrases || {});
      for (var i = 0; i < phraseEntries.length; i += 1) {
        var key = phraseEntries[i][0];
        var phrase = phraseEntries[i][1];
        var prefixedKey = prefix2 ? prefix2 + "." + key : key;
        if (typeof phrase === "object") {
          this.unset(phrase, prefixedKey);
        } else {
          delete this.phrases[prefixedKey];
        }
      }
    }
  };
  Polyglot2.prototype.clear = function() {
    this.phrases = {};
  };
  Polyglot2.prototype.replace = function(newPhrases) {
    this.clear();
    this.extend(newPhrases);
  };
  Polyglot2.prototype.t = function(key, options) {
    var phrase, result;
    var opts = options == null ? {} : options;
    if (typeof this.phrases[key] === "string") {
      phrase = this.phrases[key];
    } else if (typeof opts._ === "string") {
      phrase = opts._;
    } else if (this.onMissingKey) {
      var onMissingKey = this.onMissingKey;
      result = onMissingKey(
        key,
        opts,
        this.currentLocale,
        this.tokenRegex,
        this.pluralRules,
        this.replaceImplementation
      );
    } else {
      this.warn('Missing translation for key: "' + key + '"');
      result = key;
    }
    if (typeof phrase === "string") {
      result = transformPhrase(
        phrase,
        opts,
        this.currentLocale,
        this.tokenRegex,
        this.pluralRules,
        this.replaceImplementation
      );
    }
    return result;
  };
  Polyglot2.prototype.has = function(key) {
    return has2(this.phrases, key);
  };
  Polyglot2.transformPhrase = function transform(phrase, substitutions, locale) {
    return transformPhrase(phrase, substitutions, locale);
  };
  nodePolyglot = Polyglot2;
  return nodePolyglot;
}
var nodePolyglotExports = requireNodePolyglot();
const Polyglot = /* @__PURE__ */ getDefaultExportFromCjs(nodePolyglotExports);
const prefix = "gqlb";
class LocalMemory {
  constructor(props, key, defaultValue) {
    __publicField(this, "memoryKey");
    __publicField(this, "props");
    __publicField(this, "defaultValue");
    this.memoryKey = key !== void 0 ? `${prefix}-${key}` : prefix;
    this.props = props;
    this.defaultValue = defaultValue;
  }
  getKey(k) {
    return `${this.memoryKey}-${k}`;
  }
  get memory() {
    const { localStorage } = this.props;
    if (localStorage) {
      const memory = localStorage.getItem(this.memoryKey);
      if (memory === null) {
        return this.defaultValue;
      }
      const m = JSON.parse(memory);
      return m;
    }
  }
  set(m) {
    const memory = { ...this.memory, ...m };
    const { localStorage } = this.props;
    return localStorage && localStorage.setItem(this.memoryKey, JSON.stringify(memory));
  }
  seta(key, o) {
    const { localStorage } = this.props;
    if (localStorage) {
      if (o === void 0) {
        localStorage.removeItem(this.getKey(`${key}`));
      } else {
        localStorage.setItem(this.getKey(`${key}`), JSON.stringify(o));
      }
    }
  }
  geta(key) {
    const { localStorage } = this.props;
    if (localStorage) {
      const memory = localStorage.getItem(this.getKey(`${key}`));
      return memory ? JSON.parse(memory) : void 0;
    }
  }
}
var window_1;
var hasRequiredWindow;
function requireWindow() {
  if (hasRequiredWindow) return window_1;
  hasRequiredWindow = 1;
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof window !== "undefined") {
    win = window;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  window_1 = win;
  return window_1;
}
var windowExports = requireWindow();
const window$1 = /* @__PURE__ */ getDefaultExportFromCjs(windowExports);
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var document_1;
var hasRequiredDocument;
function requireDocument() {
  if (hasRequiredDocument) return document_1;
  hasRequiredDocument = 1;
  var topLevel = typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : {};
  var minDoc = require$$0;
  var doccy;
  if (typeof document !== "undefined") {
    doccy = document;
  } else {
    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
    if (!doccy) {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
    }
  }
  document_1 = doccy;
  return document_1;
}
var documentExports = requireDocument();
const document$1 = /* @__PURE__ */ getDefaultExportFromCjs(documentExports);
function getNavigator() {
  if (typeof navigator !== "undefined") {
    return navigator;
  }
}
function getLocalStorage() {
  const window2 = getWindow();
  if (window2 == null ? void 0 : window2.localStorage) {
    return window2.localStorage;
  }
}
function getWindow() {
  return window$1;
}
function getDocument() {
  return document$1;
}
function getDocumentLocation() {
  var _a2;
  return (_a2 = getDocument()) == null ? void 0 : _a2.location;
}
class GQLBMemory extends LocalMemory {
  set language(ln) {
    this.seta("language", ln);
  }
  get language() {
    return this.geta("language");
  }
}
const gqlbMemory = new GQLBMemory({ localStorage: getLocalStorage() }, "gqlb", {});
const enUS$1 = {
  /*
  components: {
    MuiBreadcrumbs: { defaultProps: {
      expandText: 'Show path',
    }},
    MuiTablePagination: { defaultProps: {
      getItemAriaLabel: (type) => {
        if (type === 'first') {
          return 'Go to first page';
        }
        if (type === 'last') {
          return 'Go to last page';
        }
        if (type === 'next') {
          return 'Go to next page';
        }
        // if (type === 'previous') {
        return 'Go to previous page';
      },
      labelRowsPerPage: 'Rows per page:',
      labelDisplayedRows: ({ from, to, count }) =>
  `${from}–${to} of ${count !== -1 ? count : `more than ${to}`}`, 
    }},
    MuiRating: { defaultProps: {
      getLabelText: value => `${value} Star${value !== 1 ? 's' : ''}`,
      emptyLabelText: 'Empty',
    }},
    MuiAutocomplete: { defaultProps: {
      clearText: 'Clear',
      closeText: 'Close',
      loadingText: 'Loading…',
      noOptionsText: 'No options',
      openText: 'Open',
    }},
    MuiAlert: { defaultProps: {
      closeText: 'Close',
    }},
    MuiPagination: {  defaultProps: {
      'aria-label': 'Pagination navigation',
      getItemAriaLabel: (type, page, selected) => {
        if (type === 'page') {
          return `${selected ? '' : 'Go to '}page ${page}`;
        }
        if (type === 'first') {
          return 'Go to first page';
        }
        if (type === 'last') {
          return 'Go to last page';
        }
        if (type === 'next') {
          return 'Go to next page';
        }
        // if (type === 'previous') {
        return 'Go to previous page';
      },
    }},
  },
  */
};
const esES$1 = {
  components: {
    MuiBreadcrumbs: {
      defaultProps: {
        expandText: "Mostrar ruta"
      }
    },
    MuiTablePagination: {
      defaultProps: {
        getItemAriaLabel: (type2) => {
          if (type2 === "first") {
            return "Ir a la primera página";
          }
          if (type2 === "last") {
            return "Ir a la última página";
          }
          if (type2 === "next") {
            return "Ir a la página siguiente";
          }
          return "Ir a la página anterior";
        },
        labelRowsPerPage: "Filas por página:",
        labelDisplayedRows: ({
          from: from2,
          to,
          count
        }) => `${from2}–${to} de ${count !== -1 ? count : `más de ${to}`}`
      }
    },
    MuiRating: {
      defaultProps: {
        getLabelText: (value) => `${value} Estrella${value !== 1 ? "s" : ""}`,
        emptyLabelText: "Vacío"
      }
    },
    MuiAutocomplete: {
      defaultProps: {
        clearText: "Limpiar",
        closeText: "Cerrar",
        loadingText: "Cargando…",
        noOptionsText: "Sin opciones",
        openText: "Abierto"
      }
    },
    MuiAlert: {
      defaultProps: {
        closeText: "Cerrar"
      }
    },
    MuiPagination: {
      defaultProps: {
        "aria-label": "Paginador",
        getItemAriaLabel: (type2, page, selected) => {
          if (type2 === "page") {
            return `${selected ? "" : "Ir a la "}página ${page}`;
          }
          if (type2 === "first") {
            return "Ir a la primera página";
          }
          if (type2 === "last") {
            return "Ir a la última página";
          }
          if (type2 === "next") {
            return "Ir a la página siguiente";
          }
          return "Ir a la página anterior";
        }
      }
    }
  }
};
const frFR$1 = {
  components: {
    MuiBreadcrumbs: {
      defaultProps: {
        expandText: "Montrer le chemin"
      }
    },
    MuiTablePagination: {
      defaultProps: {
        getItemAriaLabel: (type2) => {
          if (type2 === "first") {
            return "Aller à la première page";
          }
          if (type2 === "last") {
            return "Aller à la dernière page";
          }
          if (type2 === "next") {
            return "Aller à la page suivante";
          }
          return "Aller à la page précédente";
        },
        labelRowsPerPage: "Lignes par page :",
        labelDisplayedRows: ({
          from: from2,
          to,
          count
        }) => `${from2}–${to} sur ${count !== -1 ? count : `plus que ${to}`}`
      }
    },
    MuiRating: {
      defaultProps: {
        getLabelText: (value) => `${value} Etoile${value !== 1 ? "s" : ""}`,
        emptyLabelText: "Vide"
      }
    },
    MuiAutocomplete: {
      defaultProps: {
        clearText: "Vider",
        closeText: "Fermer",
        loadingText: "Chargement…",
        noOptionsText: "Pas de résultats",
        openText: "Ouvrir"
      }
    },
    MuiAlert: {
      defaultProps: {
        closeText: "Fermer"
      }
    },
    MuiPagination: {
      defaultProps: {
        "aria-label": "navigation de pagination",
        getItemAriaLabel: (type2, page, selected) => {
          if (type2 === "page") {
            return `${selected ? "" : "Aller à la "}page ${page}`;
          }
          if (type2 === "first") {
            return "Aller à la première page";
          }
          if (type2 === "last") {
            return "Aller à la dernière page";
          }
          if (type2 === "next") {
            return "Aller à la page suivante";
          }
          return "Aller à la page précédente";
        }
      }
    }
  }
};
const itIT$1 = {
  components: {
    MuiBreadcrumbs: {
      defaultProps: {
        expandText: "Visualizza percorso"
      }
    },
    MuiTablePagination: {
      defaultProps: {
        getItemAriaLabel: (type2) => {
          if (type2 === "first") {
            return "Vai alla prima pagina";
          }
          if (type2 === "last") {
            return "Vai all'ultima pagina";
          }
          if (type2 === "next") {
            return "Vai alla pagina successiva";
          }
          return "Vai alla pagina precedente";
        },
        labelRowsPerPage: "Righe per pagina:",
        labelDisplayedRows: ({
          from: from2,
          to,
          count
        }) => `${from2}–${to} di ${count !== -1 ? count : `più di ${to}`}`
      }
    },
    MuiRating: {
      defaultProps: {
        getLabelText: (value) => `${value} Stell${value !== 1 ? "e" : "a"}`,
        emptyLabelText: "Vuoto"
      }
    },
    MuiAutocomplete: {
      defaultProps: {
        clearText: "Svuota",
        closeText: "Chiudi",
        loadingText: "Caricamento in corso…",
        noOptionsText: "Nessuna opzione",
        openText: "Apri"
      }
    },
    MuiAlert: {
      defaultProps: {
        closeText: "Chiudi"
      }
    },
    MuiPagination: {
      defaultProps: {
        "aria-label": "Navigazione impaginata",
        getItemAriaLabel: (type2, page, selected) => {
          if (type2 === "page") {
            return `${selected ? "" : "Vai alla "}pagina ${page}`;
          }
          if (type2 === "first") {
            return "Vai alla prima pagina";
          }
          if (type2 === "last") {
            return "Vai all'ultima pagina";
          }
          if (type2 === "next") {
            return "Vai alla pagina successiva";
          }
          return "Vai alla pagina precedente";
        }
      }
    }
  }
};
const nlNL$1 = {
  components: {
    MuiBreadcrumbs: {
      defaultProps: {
        expandText: "Pad tonen"
      }
    },
    MuiTablePagination: {
      defaultProps: {
        getItemAriaLabel: (type2) => {
          if (type2 === "first") {
            return "Ga naar eerste pagina";
          }
          if (type2 === "last") {
            return "Ga naar laatste pagina";
          }
          if (type2 === "next") {
            return "Ga naar volgende pagina";
          }
          return "Ga naar vorige pagina";
        },
        labelRowsPerPage: "Regels per pagina:",
        labelDisplayedRows: ({
          from: from2,
          to,
          count
        }) => `${from2}–${to} van ${count !== -1 ? count : `meer dan ${to}`}`
      }
    },
    MuiRating: {
      defaultProps: {
        getLabelText: (value) => `${value} Ster${value !== 1 ? "ren" : ""}`,
        emptyLabelText: "Leeg"
      }
    },
    MuiAutocomplete: {
      defaultProps: {
        clearText: "Wissen",
        closeText: "Sluiten",
        loadingText: "Laden…",
        noOptionsText: "Geen opties",
        openText: "Openen"
      }
    },
    MuiAlert: {
      defaultProps: {
        closeText: "Sluiten"
      }
    },
    MuiPagination: {
      defaultProps: {
        "aria-label": "Navigatie via paginering",
        getItemAriaLabel: (type2, page, selected) => {
          if (type2 === "page") {
            return `${selected ? "" : "Ga naar "}pagina ${page}`;
          }
          if (type2 === "first") {
            return "Ga naar eerste pagina";
          }
          if (type2 === "last") {
            return "Ga naar laatste pagina";
          }
          if (type2 === "next") {
            return "Ga naar volgende pagina";
          }
          return "Ga naar vorige pagina";
        }
      }
    }
  }
};
const getPickersLocalization = (pickersTranslations) => {
  return {
    components: {
      MuiLocalizationProvider: {
        defaultProps: {
          localeText: _extends({}, pickersTranslations)
        }
      }
    }
  };
};
const enUSPickers = {
  // Calendar navigation
  previousMonth: "Previous month",
  nextMonth: "Next month",
  // View navigation
  openPreviousView: "Open previous view",
  openNextView: "Open next view",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
  // DateRange labels
  start: "Start",
  end: "End",
  startDate: "Start date",
  startTime: "Start time",
  endDate: "End date",
  endTime: "End time",
  // Action bar
  cancelButtonLabel: "Cancel",
  clearButtonLabel: "Clear",
  okButtonLabel: "OK",
  todayButtonLabel: "Today",
  // Toolbar titles
  datePickerToolbarTitle: "Select date",
  dateTimePickerToolbarTitle: "Select date & time",
  timePickerToolbarTitle: "Select time",
  dateRangePickerToolbarTitle: "Select date range",
  // Clock labels
  clockLabelText: (view, time, utils, formattedTime) => `Select ${view}. ${!formattedTime && (time === null || !utils.isValid(time)) ? "No time selected" : `Selected time is ${formattedTime ?? utils.format(time, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} hours`,
  minutesClockNumberText: (minutes) => `${minutes} minutes`,
  secondsClockNumberText: (seconds) => `${seconds} seconds`,
  // Digital clock labels
  selectViewText: (view) => `Select ${view}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Week number",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils, formattedDate) => formattedDate || value !== null && utils.isValid(value) ? `Choose date, selected date is ${formattedDate ?? utils.format(value, "fullDate")}` : "Choose date",
  openTimePickerDialogue: (value, utils, formattedTime) => formattedTime || value !== null && utils.isValid(value) ? `Choose time, selected time is ${formattedTime ?? utils.format(value, "fullTime")}` : "Choose time",
  fieldClearLabel: "Clear",
  // Table labels
  timeTableLabel: "pick time",
  dateTableLabel: "pick date",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Year",
  month: "Month",
  day: "Day",
  weekDay: "Week day",
  hours: "Hours",
  minutes: "Minutes",
  seconds: "Seconds",
  meridiem: "Meridiem",
  // Common
  empty: "Empty"
};
const enUS = getPickersLocalization(enUSPickers);
const views$2 = {
  hours: "Horas",
  minutes: "Minutos",
  seconds: "Segundos",
  meridiem: "Meridiano"
};
const esESPickers = {
  // Calendar navigation
  previousMonth: "Mes anterior",
  nextMonth: "Mes siguiente",
  // View navigation
  openPreviousView: "Abrir la última vista",
  openNextView: "Abrir la siguiente vista",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "la vista anual está abierta, cambie a la vista de calendario" : "la vista de calendario está abierta, cambie a la vista anual",
  // DateRange labels
  start: "Empezar",
  end: "Terminar",
  startDate: "Fecha inicio",
  startTime: "Hora inicio",
  endDate: "Fecha final",
  endTime: "Hora final",
  // Action bar
  cancelButtonLabel: "Cancelar",
  clearButtonLabel: "Limpiar",
  okButtonLabel: "OK",
  todayButtonLabel: "Hoy",
  // Toolbar titles
  datePickerToolbarTitle: "Seleccionar fecha",
  dateTimePickerToolbarTitle: "Seleccionar fecha y hora",
  timePickerToolbarTitle: "Seleccionar hora",
  dateRangePickerToolbarTitle: "Seleccionar rango de fecha",
  // Clock labels
  clockLabelText: (view, time, utils, formattedTime) => `Seleccione ${views$2[view]}. ${!formattedTime && (time === null || !utils.isValid(time)) ? "No hay hora seleccionada" : `La hora seleccionada es ${formattedTime ?? utils.format(time, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} horas`,
  minutesClockNumberText: (minutes) => `${minutes} minutos`,
  secondsClockNumberText: (seconds) => `${seconds} segundos`,
  // Digital clock labels
  selectViewText: (view) => `Seleccionar ${views$2[view]}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Número de semana",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Semana ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils, formattedDate) => formattedDate || value !== null && utils.isValid(value) ? `Elige fecha, la fecha elegida es ${formattedDate ?? utils.format(value, "fullDate")}` : "Elige fecha",
  openTimePickerDialogue: (value, utils, formattedTime) => formattedTime || value !== null && utils.isValid(value) ? `Elige hora, la hora elegida es ${formattedTime ?? utils.format(value, "fullTime")}` : "Elige hora",
  fieldClearLabel: "Limpiar valor",
  // Table labels
  timeTableLabel: "elige hora",
  dateTableLabel: "elige fecha",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "A".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Año",
  month: "Mes",
  day: "Dia",
  weekDay: "Dia de la semana",
  hours: "Horas",
  minutes: "Minutos",
  seconds: "Segundos",
  meridiem: "Meridiano",
  // Common
  empty: "Vacío"
};
const esES = getPickersLocalization(esESPickers);
const views$1 = {
  hours: "heures",
  minutes: "minutes",
  seconds: "secondes",
  meridiem: "méridien"
};
const frFRPickers = {
  // Calendar navigation
  previousMonth: "Mois précédent",
  nextMonth: "Mois suivant",
  // View navigation
  openPreviousView: "Ouvrir la vue précédente",
  openNextView: "Ouvrir la vue suivante",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "La vue année est ouverte, ouvrir la vue calendrier" : "La vue calendrier est ouverte, ouvrir la vue année",
  // DateRange labels
  start: "Début",
  end: "Fin",
  startDate: "Date de début",
  startTime: "Heure de début",
  endDate: "Date de fin",
  endTime: "Heure de fin",
  // Action bar
  cancelButtonLabel: "Annuler",
  clearButtonLabel: "Vider",
  okButtonLabel: "OK",
  todayButtonLabel: "Aujourd'hui",
  // Toolbar titles
  datePickerToolbarTitle: "Choisir une date",
  dateTimePickerToolbarTitle: "Choisir la date et l'heure",
  timePickerToolbarTitle: "Choisir l'heure",
  dateRangePickerToolbarTitle: "Choisir la plage de dates",
  // Clock labels
  clockLabelText: (view, time, utils, formattedTime) => `Choix des ${views$1[view]}. ${!formattedTime && (time === null || !utils.isValid(time)) ? "Aucune heure choisie" : `L'heure choisie est ${formattedTime ?? utils.format(time, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} heures`,
  minutesClockNumberText: (minutes) => `${minutes} minutes`,
  secondsClockNumberText: (seconds) => `${seconds} secondes`,
  // Digital clock labels
  selectViewText: (view) => `Choisir ${views$1[view]}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Semaine",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Semaine ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils, formattedDate) => formattedDate || value !== null && utils.isValid(value) ? `Choisir la date, la date sélectionnée est ${formattedDate ?? utils.format(value, "fullDate")}` : "Choisir la date",
  openTimePickerDialogue: (value, utils, formattedTime) => formattedTime ? `Choisir l'heure, l'heure sélectionnée est ${formattedTime ?? utils.format(value, "fullTime")}` : "Choisir l'heure",
  fieldClearLabel: "Effacer la valeur",
  // Table labels
  timeTableLabel: "choix de l'heure",
  dateTableLabel: "choix de la date",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "A".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "JJ",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Année",
  month: "Mois",
  day: "Jour",
  weekDay: "Jour de la semaine",
  hours: "Heures",
  minutes: "Minutes",
  seconds: "Secondes",
  meridiem: "Méridien",
  // Common
  empty: "Vider"
};
const frFR = getPickersLocalization(frFRPickers);
const views = {
  hours: "le ore",
  minutes: "i minuti",
  seconds: "i secondi",
  meridiem: "il meridiano"
};
const itITPickers = {
  // Calendar navigation
  previousMonth: "Mese precedente",
  nextMonth: "Mese successivo",
  // View navigation
  openPreviousView: "Apri la vista precedente",
  openNextView: "Apri la vista successiva",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "la vista dell'anno è aperta, passare alla vista del calendario" : "la vista dell'calendario è aperta, passare alla vista dell'anno",
  // DateRange labels
  start: "Inizio",
  end: "Fine",
  startDate: "Data di inizio",
  startTime: "Ora di inizio",
  endDate: "Data di fine",
  endTime: "Ora di fine",
  // Action bar
  cancelButtonLabel: "Cancellare",
  clearButtonLabel: "Sgomberare",
  okButtonLabel: "OK",
  todayButtonLabel: "Oggi",
  // Toolbar titles
  datePickerToolbarTitle: "Seleziona data",
  dateTimePickerToolbarTitle: "Seleziona data e orario",
  timePickerToolbarTitle: "Seleziona orario",
  dateRangePickerToolbarTitle: "Seleziona intervallo di date",
  // Clock labels
  clockLabelText: (view, time, utils, formattedTime) => `Seleziona ${views[view]}. ${!formattedTime && (time === null || !utils.isValid(time)) ? "Nessun orario selezionato" : `L'ora selezionata è ${formattedTime ?? utils.format(time, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} ore`,
  minutesClockNumberText: (minutes) => `${minutes} minuti`,
  secondsClockNumberText: (seconds) => `${seconds} secondi`,
  // Digital clock labels
  selectViewText: (view) => `Seleziona ${views[view]}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Numero settimana",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Settimana ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils, formattedDate) => formattedDate || value !== null && utils.isValid(value) ? `Scegli la data, la data selezionata è ${formattedDate ?? utils.format(value, "fullDate")}` : "Scegli la data",
  openTimePickerDialogue: (value, utils, formattedTime) => formattedTime || value !== null && utils.isValid(value) ? `Scegli l'ora, l'ora selezionata è ${formattedTime ?? utils.format(value, "fullTime")}` : "Scegli l'ora",
  fieldClearLabel: "Cancella valore",
  // Table labels
  timeTableLabel: "scegli un'ora",
  dateTableLabel: "scegli una data",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "A".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "GG",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "GGGG" : "GG",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Anno",
  month: "Mese",
  day: "Giorno",
  weekDay: "Giorno della settimana",
  hours: "Ore",
  minutes: "Minuti",
  seconds: "Secondi",
  meridiem: "Meridiano",
  // Common
  empty: "Vuoto"
};
const itIT = getPickersLocalization(itITPickers);
const timeViews = {
  hours: "uren",
  minutes: "minuten",
  seconds: "seconden",
  meridiem: "meridium"
};
const nlNLPickers = {
  // Calendar navigation
  previousMonth: "Vorige maand",
  nextMonth: "Volgende maand",
  // View navigation
  openPreviousView: "Open vorige view",
  openNextView: "Open volgende view",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "jaarweergave is geopend, schakel over naar kalenderweergave" : "kalenderweergave is geopend, switch naar jaarweergave",
  // DateRange labels
  start: "Start",
  end: "Einde",
  startDate: "Startdatum",
  startTime: "Starttijd",
  endDate: "Einddatum",
  endTime: "Eindtijd",
  // Action bar
  cancelButtonLabel: "Annuleren",
  clearButtonLabel: "Resetten",
  okButtonLabel: "OK",
  todayButtonLabel: "Vandaag",
  // Toolbar titles
  datePickerToolbarTitle: "Selecteer datum",
  dateTimePickerToolbarTitle: "Selecteer datum & tijd",
  timePickerToolbarTitle: "Selecteer tijd",
  dateRangePickerToolbarTitle: "Selecteer datumbereik",
  // Clock labels
  clockLabelText: (view, time, utils, formattedTime) => `Selecteer ${timeViews[view]}. ${!formattedTime && (time === null || !utils.isValid(time)) ? "Geen tijd geselecteerd" : `Geselecteerde tijd is ${formattedTime ?? utils.format(time, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} uren`,
  minutesClockNumberText: (minutes) => `${minutes} minuten`,
  secondsClockNumberText: (seconds) => `${seconds} seconden`,
  // Digital clock labels
  selectViewText: (view) => `Selecteer ${timeViews[view]}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Weeknummer",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils, formattedDate) => formattedDate || value !== null && utils.isValid(value) ? `Kies datum, geselecteerde datum is ${formattedDate ?? utils.format(value, "fullDate")}` : "Kies datum",
  openTimePickerDialogue: (value, utils, formattedTime) => formattedTime || value !== null && utils.isValid(value) ? `Kies tijd, geselecteerde tijd is ${formattedTime ?? utils.format(value, "fullTime")}` : "Kies tijd",
  fieldClearLabel: "Wissen",
  // Table labels
  timeTableLabel: "kies tijd",
  dateTableLabel: "kies datum",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "J".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "uu",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Jaar",
  month: "Maand",
  day: "Dag",
  weekDay: "Weekdag",
  hours: "Uren",
  minutes: "Minuten",
  seconds: "Seconden",
  meridiem: "Middag",
  // Common
  empty: "Leeg"
};
const nlNL = getPickersLocalization(nlNLPickers);
const origins$2 = ["https://localhost", "http://127.0.0.1:8080/"];
const endpoints$2 = { "backend": "https://localhost" };
const authentication$2 = { "google": { "clientId": "562537270489-apu3gn8jqr0aa2tj2mp80g2pi5clge7u.apps.googleusercontent.com" }, "auth0": { "clientId": "KnVZnc63CCohWDHsRLSdVp1uZz3lD9Lq" }, "msal": { "clientId": "a7f08378-a689-494c-b77c-c49fa1aa19cb" }, "okta-sephora": { "clientId": "0oa3pgmpbk6xfNYjc0x7" }, "te-digital-pass": { "clientId": "app-surfy-prod" }, "azure-vca": { "clientId": "0271aec8-d6fa-4328-82d5-93463001184a" }, "azure-te": { "clientId": "5792f57f-cf0d-4cf3-965c-7adcfa883fa3" } };
const google$2 = { "maps": "AIzaSyBRiwPWbrCraxyv6aAv-AuLSCpLy34FC0M" };
const dev = {
  origins: origins$2,
  endpoints: endpoints$2,
  authentication: authentication$2,
  google: google$2
};
const logRocket$1 = { "appId": "surfy/surfy-alpha" };
const authentication$1 = { "auth0": { "clientId": "gxqMWyQ1p4YAyi0sG7TS4VETVhHOPYjI" }, "msal": { "clientId": "d37902ef-290e-4b1f-b97d-c456e3a3f424" }, "google": { "clientId": "66899640159-4o5e9mbti0sap7md07vfaoplppbr9h3p.apps.googleusercontent.com" }, "okta-sephora": { "clientId": "0oa3pgmpbk6xfNYjc0x7" }, "te-digital-pass": { "clientId": "app-surfy-prod" }, "azure-vca": { "clientId": "0271aec8-d6fa-4328-82d5-93463001184a" }, "azure-te": { "clientId": "5792f57f-cf0d-4cf3-965c-7adcfa883fa3" } };
const origins$1 = ["https://app-alpha.surfy.pro"];
const endpoints$1 = { "backend": "https://app-alpha.surfy.pro" };
const google$1 = { "maps": "AIzaSyDLqHjb5Taeglcv5kfIeWM6pEwzCwMMjFU" };
const alpha = {
  logRocket: logRocket$1,
  authentication: authentication$1,
  origins: origins$1,
  endpoints: endpoints$1,
  google: google$1
};
const logRocket = { "appId": "surfy/surfy-production-9rwgq" };
const origins = ["https://app.surfy.pro", "https://help.surfy.pro"];
const endpoints = { "backend": "https://app.surfy.pro" };
const google = { "maps": "AIzaSyDLqHjb5Taeglcv5kfIeWM6pEwzCwMMjFU" };
const authentication = { "auth0": { "clientId": "pqF4xIJxyikS5FD7t11QUT6VH51JtXDS" }, "msal": { "clientId": "194145f8-c6dd-4fff-9162-4069cbd0c0b1" }, "google": { "clientId": "905042472880-rv5v9r3a45c02dp3nht2klqhdrqmlo6b.apps.googleusercontent.com" }, "okta-sephora": { "clientId": "0oa7exckjf7mnoM7c0i7" }, "te-digital-pass": { "clientId": "app-surfy-prod" }, "azure-vca": { "clientId": "0271aec8-d6fa-4328-82d5-93463001184a" }, "azure-te": { "clientId": "52c5380a-833f-422a-ad56-3d4a98842353" } };
const p2 = {
  logRocket,
  origins,
  endpoints,
  google,
  authentication
};
const providers = ["AzureADv2", "google-oauth2", "linkedin", "windowslive"];
const cloudinary = { "name": "app-surfy-pro", "presets": { "signed": "signed-upload", "unsigned": "by79qv6c" } };
const profile = { "logo": { "square": "https://res.cloudinary.com/app-surfy-pro/image/upload/v1515245191/app/surfy/logo-surfy-square.png", "normal": "https://res.cloudinary.com/app-surfy-pro/image/upload/v1660809543/app/surfy/logo-surfy.png" } };
const base = {
  providers,
  cloudinary,
  profile
};
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol2 = root.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction;
  return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var root = require_root();
  var coreJsData = root["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  _getValue = getValue2;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue2 = require_getValue();
  function getNative(object, key) {
    var value = getValue2(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative;
  return _getNative;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data2, key) ? data2[key] : void 0;
  }
  _hashGet = hashGet;
  return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
  }
  _hashHas = hashHas;
  return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq2;
  return eq_1;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq2 = requireEq();
  function assocIndexOf(array, key) {
    var length2 = array.length;
    while (length2--) {
      if (eq2(array[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root = require_root();
  var Map2 = getNative(root, "Map");
  _Map = Map2;
  return _Map;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key, value) {
    var data2 = getMapData(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd) return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas) return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache) return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values2) {
    var index2 = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index2 < length2) {
      this.add(values2[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex) return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN) return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf) return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array, value, fromIndex) {
    var index2 = fromIndex - 1, length2 = array.length;
    while (++index2 < length2) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf) return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes) return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array, value) {
    var length2 = array == null ? 0 : array.length;
    return !!length2 && baseIndexOf(array, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith) return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array, value, comparator) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (comparator(value, array[index2])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas) return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root = require_root();
  var Set2 = getNative(root, "Set");
  _Set = Set2;
  return _Set;
}
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop) return noop_1;
  hasRequiredNoop = 1;
  function noop() {
  }
  noop_1 = noop;
  return noop_1;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray) return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet) return _createSet;
  hasRequired_createSet = 1;
  var Set2 = require_Set(), noop = requireNoop(), setToArray = require_setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
    return new Set2(values2);
  };
  _createSet = createSet;
  return _createSet;
}
var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq) return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length2 >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length2) {
        var value = array[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}
var uniq_1;
var hasRequiredUniq;
function requireUniq() {
  if (hasRequiredUniq) return uniq_1;
  hasRequiredUniq = 1;
  var baseUniq = require_baseUniq();
  function uniq2(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  uniq_1 = uniq2;
  return uniq_1;
}
var uniqExports = requireUniq();
const uniq = /* @__PURE__ */ getDefaultExportFromCjs(uniqExports);
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear) return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete) return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet) return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas) return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet) return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache) {
      var pairs = data2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache(pairs);
    }
    data2.set(key, value);
    this.size = data2.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack) return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome) return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays) return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array) return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root = require_root();
  var Uint8Array2 = root.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray) return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag) return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq2 = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush) return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array, values2) {
    var index2 = -1, length2 = values2.length, offset = array.length;
    while (++index2 < length2) {
      array[offset + index2] = values2[index2];
    }
    return array;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray = requireIsArray();
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter) return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray) return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols) return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes) return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments) return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments2 = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments2;
  return isArguments_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse) return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module, exports) {
    var root = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary) return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil) return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module, exports) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments2 = requireIsArguments(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype) return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg) return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform) {
    return function(arg2) {
      return func(transform(arg2));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys) return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys) return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  keys_1 = keys;
  return keys_1;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = requireKeys();
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects) return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView) return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root = require_root();
  var DataView2 = getNative(root, "DataView");
  _DataView = DataView2;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise) return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root = require_root();
  var Promise2 = getNative(root, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap) return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root = require_root();
  var WeakMap2 = getNative(root, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag) return _getTag;
  hasRequired_getTag = 1;
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray = requireIsTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual) return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch) return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
    if (object == null) {
      return !length2;
    }
    object = Object(object);
    while (index2--) {
      var data2 = matchData[index2];
      if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
        return false;
      }
    }
    while (++index2 < length2) {
      data2 = matchData[index2];
      var key = data2[0], objValue = object[key], srcValue = data2[1];
      if (noCustomizer && data2[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable) return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData) return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys = requireKeys();
  function getMatchData(object) {
    var result = keys(object), length2 = result.length;
    while (length2--) {
      var key = result[length2], value = object[key];
      result[length2] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches) return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey) return _isKey;
  hasRequired_isKey = 1;
  var isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  _isKey = isKey;
  return _isKey;
}
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize) return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache)();
    return memoized;
  }
  memoize2.Cache = MapCache;
  memoize_1 = memoize2;
  return memoize_1;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped) return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize2 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath) return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match2, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array, iteratee) {
    var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array[index2], index2, array);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString2;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath) return _castPath;
  hasRequired_castPath = 1;
  var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString2 = requireToString();
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString2(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey) return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet) return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object, path) {
    path = castPath(path, object);
    var index2 = 0, length2 = path.length;
    while (object != null && index2 < length2) {
      object = object[toKey(path[index2++])];
    }
    return index2 && index2 == length2 ? object : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet();
  function get2(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get2;
  return get_1;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn) return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath) return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments2 = requireIsArguments(), isArray = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index2 = -1, length2 = path.length, result = false;
    while (++index2 < length2) {
      var key = toKey(path[index2]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object == null ? 0 : object.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object) || isArguments2(object));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn) return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get2(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity_1;
  hasRequiredIdentity = 1;
  function identity(value) {
    return value;
  }
  identity_1 = identity;
  return identity_1;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty) return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep) return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet();
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee) return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity = requireIdentity(), isArray = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var uniqBy_1;
var hasRequiredUniqBy;
function requireUniqBy() {
  if (hasRequiredUniqBy) return uniqBy_1;
  hasRequiredUniqBy = 1;
  var baseIteratee = require_baseIteratee(), baseUniq = require_baseUniq();
  function uniqBy(array, iteratee) {
    return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
  }
  uniqBy_1 = uniqBy;
  return uniqBy_1;
}
requireUniqBy();
var _baseDifference;
var hasRequired_baseDifference;
function require_baseDifference() {
  if (hasRequired_baseDifference) return _baseDifference;
  hasRequired_baseDifference = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), arrayMap = require_arrayMap(), baseUnary = require_baseUnary(), cacheHas = require_cacheHas();
  var LARGE_ARRAY_SIZE = 200;
  function baseDifference(array, values2, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, isCommon = true, length2 = array.length, result = [], valuesLength = values2.length;
    if (!length2) {
      return result;
    }
    if (iteratee) {
      values2 = arrayMap(values2, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values2.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values2 = new SetCache(values2);
    }
    outer:
      while (++index2 < length2) {
        var value = array[index2], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values2[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values2, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  _baseDifference = baseDifference;
  return _baseDifference;
}
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable) return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments2 = requireIsArguments(), isArray = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten) return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply) return _apply;
  hasRequired_apply = 1;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest) return _overRest;
  hasRequired_overRest = 1;
  var apply = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
      while (++index2 < length2) {
        array[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant) return constant_1;
  hasRequiredConstant = 1;
  function constant(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant;
  return constant_1;
}
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty = defineProperty;
  return _defineProperty;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString) return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant = requireConstant(), defineProperty = require_defineProperty(), identity = requireIdentity();
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut) return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString) return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest) return _baseRest;
  hasRequired_baseRest = 1;
  var identity = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject) return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike = requireIsArrayLike(), isObjectLike = requireIsObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var last_1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast) return last_1;
  hasRequiredLast = 1;
  function last2(array) {
    var length2 = array == null ? 0 : array.length;
    return length2 ? array[length2 - 1] : void 0;
  }
  last_1 = last2;
  return last_1;
}
var differenceWith_1;
var hasRequiredDifferenceWith;
function requireDifferenceWith() {
  if (hasRequiredDifferenceWith) return differenceWith_1;
  hasRequiredDifferenceWith = 1;
  var baseDifference = require_baseDifference(), baseFlatten = require_baseFlatten(), baseRest = require_baseRest(), isArrayLikeObject = requireIsArrayLikeObject(), last2 = requireLast();
  var differenceWith2 = baseRest(function(array, values2) {
    var comparator = last2(values2);
    if (isArrayLikeObject(comparator)) {
      comparator = void 0;
    }
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), void 0, comparator) : [];
  });
  differenceWith_1 = differenceWith2;
  return differenceWith_1;
}
var differenceWithExports = requireDifferenceWith();
const differenceWith = /* @__PURE__ */ getDefaultExportFromCjs(differenceWithExports);
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue) return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq2 = requireEq();
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  _assignMergeValue = assignMergeValue;
  return _assignMergeValue;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor) return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor) return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module, exports) {
    var root = require_root();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array2 = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray) return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray) return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array) {
    var index2 = -1, length2 = source.length;
    array || (array = Array(length2));
    while (++index2 < length2) {
      array[index2] = source[index2];
    }
    return array;
  }
  _copyArray = copyArray;
  return _copyArray;
}
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate) return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject = requireIsObject();
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate;
  return _baseCreate;
}
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype) return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject) return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype(), isPrototype = require_isPrototype();
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject2;
  return isPlainObject_1;
}
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet) return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  _safeGet = safeGet;
  return _safeGet;
}
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue) return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq2 = requireEq();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject) return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue(), baseAssignValue = require_baseAssignValue();
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  _copyObject = copyObject;
  return _copyObject;
}
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn) return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn) return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject = requireIsObject(), isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn) return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject) return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  toPlainObject_1 = toPlainObject;
  return toPlainObject_1;
}
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep) return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments2 = requireIsArguments(), isArray = requireIsArray(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer(), isFunction = requireIsFunction(), isObject = requireIsObject(), isPlainObject2 = requireIsPlainObject(), isTypedArray = requireIsTypedArray(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
        newValue = objValue;
        if (isArguments2(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  _baseMergeDeep = baseMergeDeep;
  return _baseMergeDeep;
}
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge) return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor(), baseMergeDeep = require_baseMergeDeep(), isObject = requireIsObject(), keysIn = requireKeysIn(), safeGet = require_safeGet();
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  _baseMerge = baseMerge;
  return _baseMerge;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq2 = requireEq(), isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject = requireIsObject();
  function isIterateeCall(value, index2, object) {
    if (!isObject(object)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
      return eq2(object[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner) return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object = Object(object);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge_1;
  hasRequiredMerge = 1;
  var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
  var merge2 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  merge_1 = merge2;
  return merge_1;
}
var mergeExports = requireMerge();
const merge = /* @__PURE__ */ getDefaultExportFromCjs(mergeExports);
var _baseSlice;
var hasRequired_baseSlice;
function require_baseSlice() {
  if (hasRequired_baseSlice) return _baseSlice;
  hasRequired_baseSlice = 1;
  function baseSlice(array, start, end2) {
    var index2 = -1, length2 = array.length;
    if (start < 0) {
      start = -start > length2 ? 0 : length2 + start;
    }
    end2 = end2 > length2 ? length2 : end2;
    if (end2 < 0) {
      end2 += length2;
    }
    length2 = start > end2 ? 0 : end2 - start >>> 0;
    start >>>= 0;
    var result = Array(length2);
    while (++index2 < length2) {
      result[index2] = array[index2 + start];
    }
    return result;
  }
  _baseSlice = baseSlice;
  return _baseSlice;
}
var _parent;
var hasRequired_parent;
function require_parent() {
  if (hasRequired_parent) return _parent;
  hasRequired_parent = 1;
  var baseGet = require_baseGet(), baseSlice = require_baseSlice();
  function parent2(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }
  _parent = parent2;
  return _parent;
}
var _baseUnset;
var hasRequired_baseUnset;
function require_baseUnset() {
  if (hasRequired_baseUnset) return _baseUnset;
  hasRequired_baseUnset = 1;
  var castPath = require_castPath(), last2 = requireLast(), parent2 = require_parent(), toKey = require_toKey();
  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent2(object, path);
    return object == null || delete object[toKey(last2(path))];
  }
  _baseUnset = baseUnset;
  return _baseUnset;
}
var _basePullAt;
var hasRequired_basePullAt;
function require_basePullAt() {
  if (hasRequired_basePullAt) return _basePullAt;
  hasRequired_basePullAt = 1;
  var baseUnset = require_baseUnset(), isIndex = require_isIndex();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function basePullAt(array, indexes) {
    var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
    while (length2--) {
      var index2 = indexes[length2];
      if (length2 == lastIndex || index2 !== previous) {
        var previous = index2;
        if (isIndex(index2)) {
          splice.call(array, index2, 1);
        } else {
          baseUnset(array, index2);
        }
      }
    }
    return array;
  }
  _basePullAt = basePullAt;
  return _basePullAt;
}
var remove_1;
var hasRequiredRemove;
function requireRemove() {
  if (hasRequiredRemove) return remove_1;
  hasRequiredRemove = 1;
  var baseIteratee = require_baseIteratee(), basePullAt = require_basePullAt();
  function remove2(array, predicate) {
    var result = [];
    if (!(array && array.length)) {
      return result;
    }
    var index2 = -1, indexes = [], length2 = array.length;
    predicate = baseIteratee(predicate, 3);
    while (++index2 < length2) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result.push(value);
        indexes.push(index2);
      }
    }
    basePullAt(array, indexes);
    return result;
  }
  remove_1 = remove2;
  return remove_1;
}
requireRemove();
var _baseSum;
var hasRequired_baseSum;
function require_baseSum() {
  if (hasRequired_baseSum) return _baseSum;
  hasRequired_baseSum = 1;
  function baseSum(array, iteratee) {
    var result, index2 = -1, length2 = array.length;
    while (++index2 < length2) {
      var current = iteratee(array[index2]);
      if (current !== void 0) {
        result = result === void 0 ? current : result + current;
      }
    }
    return result;
  }
  _baseSum = baseSum;
  return _baseSum;
}
var sum_1;
var hasRequiredSum;
function requireSum() {
  if (hasRequiredSum) return sum_1;
  hasRequiredSum = 1;
  var baseSum = require_baseSum(), identity = requireIdentity();
  function sum(array) {
    return array && array.length ? baseSum(array, identity) : 0;
  }
  sum_1 = sum;
  return sum_1;
}
requireSum();
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger) return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var chunk_1;
var hasRequiredChunk;
function requireChunk() {
  if (hasRequiredChunk) return chunk_1;
  hasRequiredChunk = 1;
  var baseSlice = require_baseSlice(), isIterateeCall = require_isIterateeCall(), toInteger = requireToInteger();
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function chunk(array, size, guard) {
    if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
      size = 1;
    } else {
      size = nativeMax(toInteger(size), 0);
    }
    var length2 = array == null ? 0 : array.length;
    if (!length2 || size < 1) {
      return [];
    }
    var index2 = 0, resIndex = 0, result = Array(nativeCeil(length2 / size));
    while (index2 < length2) {
      result[resIndex++] = baseSlice(array, index2, index2 += size);
    }
    return result;
  }
  chunk_1 = chunk;
  return chunk_1;
}
requireChunk();
var isEmpty_1;
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty) return isEmpty_1;
  hasRequiredIsEmpty = 1;
  var baseKeys = require_baseKeys(), getTag = require_getTag(), isArguments2 = requireIsArguments(), isArray = requireIsArray(), isArrayLike = requireIsArrayLike(), isBuffer2 = requireIsBuffer(), isPrototype = require_isPrototype(), isTypedArray = requireIsTypedArray();
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments2(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  isEmpty_1 = isEmpty;
  return isEmpty_1;
}
requireIsEmpty();
requireIsObject();
requireIsArray();
var difference_1;
var hasRequiredDifference;
function requireDifference() {
  if (hasRequiredDifference) return difference_1;
  hasRequiredDifference = 1;
  var baseDifference = require_baseDifference(), baseFlatten = require_baseFlatten(), baseRest = require_baseRest(), isArrayLikeObject = requireIsArrayLikeObject();
  var difference = baseRest(function(array, values2) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
  });
  difference_1 = difference;
  return difference_1;
}
requireDifference();
var isNumber_1;
var hasRequiredIsNumber;
function requireIsNumber() {
  if (hasRequiredIsNumber) return isNumber_1;
  hasRequiredIsNumber = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var numberTag = "[object Number]";
  function isNumber2(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }
  isNumber_1 = isNumber2;
  return isNumber_1;
}
requireIsNumber();
var _castSlice;
var hasRequired_castSlice;
function require_castSlice() {
  if (hasRequired_castSlice) return _castSlice;
  hasRequired_castSlice = 1;
  var baseSlice = require_baseSlice();
  function castSlice(array, start, end2) {
    var length2 = array.length;
    end2 = end2 === void 0 ? length2 : end2;
    return !start && end2 >= length2 ? array : baseSlice(array, start, end2);
  }
  _castSlice = castSlice;
  return _castSlice;
}
var _charsEndIndex;
var hasRequired_charsEndIndex;
function require_charsEndIndex() {
  if (hasRequired_charsEndIndex) return _charsEndIndex;
  hasRequired_charsEndIndex = 1;
  var baseIndexOf = require_baseIndexOf();
  function charsEndIndex(strSymbols, chrSymbols) {
    var index2 = strSymbols.length;
    while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
    }
    return index2;
  }
  _charsEndIndex = charsEndIndex;
  return _charsEndIndex;
}
var _charsStartIndex;
var hasRequired_charsStartIndex;
function require_charsStartIndex() {
  if (hasRequired_charsStartIndex) return _charsStartIndex;
  hasRequired_charsStartIndex = 1;
  var baseIndexOf = require_baseIndexOf();
  function charsStartIndex(strSymbols, chrSymbols) {
    var index2 = -1, length2 = strSymbols.length;
    while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
    }
    return index2;
  }
  _charsStartIndex = charsStartIndex;
  return _charsStartIndex;
}
var _asciiToArray;
var hasRequired_asciiToArray;
function require_asciiToArray() {
  if (hasRequired_asciiToArray) return _asciiToArray;
  hasRequired_asciiToArray = 1;
  function asciiToArray(string) {
    return string.split("");
  }
  _asciiToArray = asciiToArray;
  return _asciiToArray;
}
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode) return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsZWJ = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  _hasUnicode = hasUnicode;
  return _hasUnicode;
}
var _unicodeToArray;
var hasRequired_unicodeToArray;
function require_unicodeToArray() {
  if (hasRequired_unicodeToArray) return _unicodeToArray;
  hasRequired_unicodeToArray = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  _unicodeToArray = unicodeToArray;
  return _unicodeToArray;
}
var _stringToArray;
var hasRequired_stringToArray;
function require_stringToArray() {
  if (hasRequired_stringToArray) return _stringToArray;
  hasRequired_stringToArray = 1;
  var asciiToArray = require_asciiToArray(), hasUnicode = require_hasUnicode(), unicodeToArray = require_unicodeToArray();
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  _stringToArray = stringToArray;
  return _stringToArray;
}
var trim_1;
var hasRequiredTrim;
function requireTrim() {
  if (hasRequiredTrim) return trim_1;
  hasRequiredTrim = 1;
  var baseToString = require_baseToString(), baseTrim = require_baseTrim(), castSlice = require_castSlice(), charsEndIndex = require_charsEndIndex(), charsStartIndex = require_charsStartIndex(), stringToArray = require_stringToArray(), toString2 = requireToString();
  function trim2(string, chars, guard) {
    string = toString2(string);
    if (string && (guard || chars === void 0)) {
      return baseTrim(string);
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
    return castSlice(strSymbols, start, end2).join("");
  }
  trim_1 = trim2;
  return trim_1;
}
requireTrim();
var _baseIsDate;
var hasRequired_baseIsDate;
function require_baseIsDate() {
  if (hasRequired_baseIsDate) return _baseIsDate;
  hasRequired_baseIsDate = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var dateTag = "[object Date]";
  function baseIsDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
  }
  _baseIsDate = baseIsDate;
  return _baseIsDate;
}
var isDate_1;
var hasRequiredIsDate;
function requireIsDate() {
  if (hasRequiredIsDate) return isDate_1;
  hasRequiredIsDate = 1;
  var baseIsDate = require_baseIsDate(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsDate = nodeUtil && nodeUtil.isDate;
  var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
  isDate_1 = isDate;
  return isDate_1;
}
requireIsDate();
var _createFind;
var hasRequired_createFind;
function require_createFind() {
  if (hasRequired_createFind) return _createFind;
  hasRequired_createFind = 1;
  var baseIteratee = require_baseIteratee(), isArrayLike = requireIsArrayLike(), keys = requireKeys();
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  _createFind = createFind;
  return _createFind;
}
var findIndex_1;
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex) return findIndex_1;
  hasRequiredFindIndex = 1;
  var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
  var nativeMax = Math.max;
  function findIndex(array, predicate, fromIndex) {
    var length2 = array == null ? 0 : array.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate, 3), index2);
  }
  findIndex_1 = findIndex;
  return findIndex_1;
}
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind) return find_1;
  hasRequiredFind = 1;
  var createFind = require_createFind(), findIndex = requireFindIndex();
  var find2 = createFind(findIndex);
  find_1 = find2;
  return find_1;
}
requireFind();
var indexOf_1;
var hasRequiredIndexOf;
function requireIndexOf() {
  if (hasRequiredIndexOf) return indexOf_1;
  hasRequiredIndexOf = 1;
  var baseIndexOf = require_baseIndexOf(), toInteger = requireToInteger();
  var nativeMax = Math.max;
  function indexOf(array, value, fromIndex) {
    var length2 = array == null ? 0 : array.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseIndexOf(array, value, index2);
  }
  indexOf_1 = indexOf;
  return indexOf_1;
}
requireIndexOf();
const jupUniq = uniq;
const jupDifferenceWith = differenceWith;
const jupMerge = merge;
function getPublicConfiguration(jupEnv) {
  switch (jupEnv) {
    case "p2":
      return jupMerge(base, p2);
    case "alpha":
      return jupMerge(base, alpha);
    case "development":
    default:
      return jupMerge(base, dev);
  }
}
function getJupEnvFromLocationOrigin(origin) {
  const o = `${origin}`;
  if (p2.origins.includes(o)) {
    return "p2";
  }
  if (dev.origins.includes(o)) {
    return "development";
  }
  if (alpha.origins.includes(o)) {
    return "alpha";
  }
}
function getPublicConfigurationFront() {
  const jupEnv = getJupEnvFront();
  return getPublicConfiguration(jupEnv);
}
function getJupEnvFront() {
  const d = getDocumentLocation();
  if (d) {
    const env = getJupEnvFromLocationOrigin(d.origin);
    if (env) {
      return env;
    }
  }
  return "not-set";
}
/*! js-cookie v3.0.5 | MIT */
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name, value, attributes2) {
    if (typeof document === "undefined") {
      return;
    }
    attributes2 = assign({}, defaultAttributes, attributes2);
    if (typeof attributes2.expires === "number") {
      attributes2.expires = new Date(Date.now() + attributes2.expires * 864e5);
    }
    if (attributes2.expires) {
      attributes2.expires = attributes2.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes2) {
      if (!attributes2[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes2[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes2[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
  }
  function get2(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name === found) {
          break;
        }
      } catch (e) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set,
      get: get2,
      remove: function(name, attributes2) {
        set(
          name,
          "",
          assign({}, attributes2, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes2) {
        return init(this.converter, assign({}, this.attributes, attributes2));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });
function getPublicAppVersion() {
  return api.get(versionCookieKeyName) ?? "0.0.0";
}
const supportedLanguages = [
  addLanguage("fr", "Français", frFR$1, "fr", frFR),
  addLanguage("en", "English", enUS$1, "en-gb", enUS, "gb"),
  addLanguage("it", "Italiano", itIT$1, "it", itIT),
  addLanguage("es", "Español", esES$1, "es", esES),
  addLanguage("nl", "Nederlands", nlNL$1, "nl", nlNL)
  // addLanguage('pt', 'Português'),
  // addLanguage('de', 'Deutsche'),
  // addLanguage('iw', 'עברית'),
  // addLanguage('ga', 'Gaeilge', 'IE'),
  // addLanguage('vi', 'Tiếng Việt'),
  // addLanguage('ar', 'عربى'),
  // addLanguage('ja', '日本語'),
  // addLanguage('fa', 'فارسی'),
  // addLanguage('zh', '‎简体中文‎'),
  // addLanguage('ru', '‎Pу́сский‎'),
  // addLanguage('sv', 'Svenska'),
  // addLanguage('ko', '한국어'),
  // addLanguage('fi', 'Suomi'),
  // addLanguage('da', 'Dansk')
];
function addLanguage(code, name, mui, momentCode, muiDatePicker, flagCode) {
  const language = {
    name,
    code,
    mui,
    momentCode,
    muiDatePicker,
    flagCode: flagCode ?? code
  };
  return language;
}
function useTranslation(componentKey) {
  useGlobalTranslationCode();
  const i18nApi = useI18nApi();
  if (componentKey) {
    return (key, data2) => i18nApi.translate(`${componentKey}.${key}`, data2);
  }
  return (key, data2) => i18nApi.translate(key, data2);
}
function fetchLanguageJson(language) {
  const version2 = getPublicAppVersion();
  const config = getPublicConfigurationFront();
  const url = `${config.endpoints.backend}/assets/i18n/${language}.json?v=${version2}`;
  return fetch(url, {
    cache: "default"
  }).then((res) => res.json());
}
async function getNewPolyglotFromFrontConfig(locale) {
  const phrases = await fetchLanguageJson(locale);
  return new Polyglot({ locale, phrases, allowMissing: true });
}
function updateGlobalLanguageSettings(locale) {
  const language = supportedLanguages.find((l) => l.code === locale);
  if (language) {
    language.momentCode;
    gqlbMemory.language = language.code;
  }
}
function cleanUpGuess(word) {
  return toUnderscore(word).split("_").map(capitalizeFirstLetter).join(" ");
}
function guessI18nMissingKey(key) {
  const words = key.split(".").slice(-2);
  const first2 = words[0];
  const last2 = words[1];
  if (["label", "singular"].indexOf(last2) !== -1) {
    return cleanUpGuess(first2);
  }
  if (["views"].indexOf(first2) !== -1) {
    return cleanUpGuess(last2);
  }
  if (last2.endsWith("plural")) {
    return cleanUpGuess(toPlural(first2));
  }
  return words.join(" ");
}
function getBrowserLocal() {
  const navigator2 = getNavigator();
  if (navigator2) {
    const locale = navigator2.language;
    const regexp = new RegExp(/(.*)-(.*)/);
    const match2 = locale.match(regexp);
    if (match2) {
      return match2[1];
    }
  }
  return "fr";
}
let polyglot = void 0;
class PolyglotApi {
  constructor() {
    __publicField(this, "translate", (m, data2) => {
      if (!polyglot) {
        throw new Error("Polyglot not initialized");
      }
      const res = polyglot.t(m, data2);
      if (this.isKey(m, res)) {
        const guess = guessI18nMissingKey(res);
        return `${guess}`;
      }
      return res;
    });
  }
  get locale() {
    if (!polyglot) {
      return "fr";
    }
    const code = polyglot.locale();
    return code;
  }
  async setup(defaultLanguage) {
    const locale = defaultLanguage ?? gqlbMemory.language ?? getBrowserLocal();
    await this.setLocale(locale);
    return this;
  }
  isKey(key, value) {
    return key === value;
  }
  keyExists(key) {
    if (!polyglot) {
      return false;
    }
    const res = polyglot.t(key);
    return !this.isKey(key, res);
  }
  has(key) {
    return (polyglot == null ? void 0 : polyglot.has(key)) ?? false;
  }
  setPolyglot(polyglot_) {
    polyglot = polyglot_;
  }
  async setLocale(locale) {
    const polyglot_ = await getNewPolyglotFromFrontConfig(locale);
    this.setPolyglot(polyglot_);
    updateGlobalLanguageSettings(polyglot_.locale());
  }
}
const fr = {
  "ImportUpdateOption.label": "Mettre à jour",
  "ImportUpdateOption.help": "Effectuer la mise à jour des objets sélectionnés",
  "ImportUpdateEntitiesTable.description": "Liste des objets qui nécessitent une mise à jour",
  "PropertyTypeErrors.title": "Les valeurs suivantes n'existent pas pour la propriété <b>%{propertyTypeLabel}</b> dans <b>%{objectTypeLabel}</b>",
  "ImportDeleteOption.label": "Supprimer",
  "ImportDeleteOption.help": "Effectuer la suppression des objets sélectionnés dans Surfy",
  "ImportDeleteEntitiesTable.description": "Liste des objets qui nécessitent une suppression dans Surfy",
  "ImportCreateOption.label": "Créer",
  "ImportCreateOption.help": "Effectuer la création des objets sélectionnés dans Surfy",
  "ImportCreateEntitiesTable.description": "Liste des objets qui nécessitent une création",
  "ImportCreateEntitiesTable.open.label": "Voir les entités à créer",
  "ImportCreateEntitiesTable.open.help": "Voir le détail des entités à créer car il y a plus de 500 lignes, pour des raisons de perfromance les lignes sont cachés par defaut",
  "ImportCreateAllOption.label": "Tout Créer",
  "ImportCreateAllOption.help": "Effectuer la création de tous les objets sans les sélectionner individuellement",
  "entitiesImportType.date.wrongImportFormat": "Le format de la date %{value} n'est pas correct, le format attendu est %{excelImportDateFormat}",
  "InfoTabContent.description": "Erreurs ou informations notables pendant l'import",
  "InfoTabContent.noChange": "Aucune modification n'a été observée à la comparaison",
  "InfoTabContent.copyIds": "Copier dans le presse-papiers les identifiants des entités",
  "InfoTabContent.equals.multiple": "%{count} objets existants et non modifiés",
  "InfoTabContent.equals.one": "Un seul objet déjà existant et non modifié",
  "InfoTabContent.open.label": "Voir le détail de l'import",
  "InfoTabContent.open.help": "Voir le détail de l'import pour les comparaisons identiques",
  "ImportObjectType.tabs.create.label": "Création",
  "ImportObjectType.tabs.update.label": "Mise à jour",
  "ImportObjectType.tabs.errors.label": "Infos",
  "ImportObjectType.tabs.delete.label": "Suppression",
  "ImportObjectType.usedKeys": "La clé de réconciliation utilisée est :",
  "ImportObjectType.errors.noChange": "Aucune modification n'a été observé à la comparison",
  "CompareEntities.buttons.reset.label": "Recommencer",
  "CompareEntities.buttons.reset.help": "Recommencer l'import",
  "ObjectTypeImportKeys.title": "Les clés disponibles pour réconcilier %{determinants.undefined} dans l'ordre du choix, si vous souhaitez modifier une des propriétés clé vous devez utilisez l'identifiant comme clé",
  "ObjectTypeImportScalarProperties.help": "Copier dans le presse-papier",
  "ImportHelpDrawerIconButton.icon.help": "Voir l'aide sur l'import de données pour %{determinants.defined}",
  "ImportHelpDrawerIconButton.drawer.title": "Aide sur l'import %{determinants.undefined}",
  "ImportHelpDrawerIconButton.drawer.tabLabel": "Aide import",
  "DownloadObjectTypeImportTemplateFileButton.label": "Télécharger le gabarit d'import",
  "DownloadObjectTypeImportTemplateFileButton.help": "Télécharger un gabarit d'import en execl avec les noms des colonnes que vous pouvez choisir",
  "ImportHelpDrawer.tab": "Aide import %{objectTypeLabel}",
  "BelongsToListItem.clipboard": "Copier le titre de la colonne dans le presse papier",
  "BelongsToListItem.noKeys": "Pas de clé unique disponible",
  "BelongsToImportHelp.title": "Les type d'objets associés à %{objectTypeLabel} triés par les clés d'importation disponible",
  "FileDropZone.dropZone": "Deplacer et glisser le fichier d'import dans cette zone ou cliquer dans la zone pour sélectionner votre fichier",
  "EntitiesImporter.tabs.file": "Fichier",
  "EntitiesImporter.tabs.copypaste": "Copier et coller",
  "TextAreaImporter.errors.title": "Les erreurs rencontrés pendant l'import",
  "TextAreaImporter.textarea.placeholder": "Copier et coller vos colonnes depuis excel avec le titre pour permettre de retrouver les propriétés à mettre à jour",
  "TextAreaImporter.help": "Utilisez la tabulation entre chaque colonne en incluant le nom de chaque colonne dans la première ligne ou coller directement depuis excel",
  "ImportOptionsBar.buttons.compare.label": "Comparer",
  "ImportOptionsBar.buttons.compare.help": "Commencer la comparaison avec les données dans surfy afin de détérminer les modifications à importer",
  "ImportErrors.errors.title": "Les erreurs rencontrés pendant l'import",
  "DashboardView.tabs.reports": "Rapports Excel",
  "IconShape.values.circle": "Cercle",
  "IconShape.values.rectangle": "Rectangle",
  "IconShape.values.triangle": "Triangle",
  "EntityDialogSearchList.NoResult": "Aucun résultat n'a été trouvé, merci d'effacer vos filtres ou changer votre recherche",
  "FieldTypeEntity.edit": "Changer %{determinant.defined}",
  "FieldTypeEntity.remove": "Retirer %{determinant.defined}",
  "FieldTypeEntity.add": "Ajouter %{determinant.undefined}",
  "LegendSelector.title": "Sélectionner la legende",
  "LegendSelector.labels.default": "Légende par défaut",
  "HasManyStandaloneNoData.noData": "Il n'y aucun %{targetObjectTypeLabel} d'associé pour %{determinant.defined}",
  "FieldTypeAddress.edit": "Modifier l'adresse",
  "FieldTypeAddress.remove": "Supprimer l'adresse",
  "AutocompleteAddress.autocomplete.placeholder": "Rechercher votre adresse ici",
  "AddressDialog.search": "Rechercher l'adresse",
  "AddressDialog.validate": "Valider",
  "FieldTypePassword.icons.copy": "Copier le contenu du mot de passe dans le presse-papier",
  "FieldTypePassword.icons.generate": "Générer un mot de passe unique",
  "FieldTypeModel3d.Remove": "Retirer le modèle 3D",
  "FieldTypeModel3d.Upload": "Changer le modèle 3D",
  "FieldTypeImage.Remove": "Retirer l'image",
  "FieldTypeImage.Upload": "Changer l'image",
  "FieldTypeIcon.Edit": "Changer d'icone",
  "FieldTypeIcon.Remove": "Retirer l'icone",
  "FieldTypeColor.Remove": "Retirer la couleur",
  "FieldTypeColor.NoColorHelp": "Sélectionner une couleur",
  "FieldTypeColor.NotHexMatchError": "Le champs ne respecte pas le format hexadécimal d'une couleur",
  "CopyImagePathToClipboard.CopyUrl": "Copier l'url",
  "ColorBox.NoColorHelp": "Sélectionner une couleur via la palette",
  "ChangeColor.classic": "Selectionner une couleur avec la platte avancée",
  "weight.kilogram": "Kilogramme",
  "weight.gram": "Gramme",
  "distance.meter": "Métres",
  "distance.centimeter": "Centimètres",
  "FieldTypeIndexBoolean.help": "Modifier la valeur directement",
  "FieldTypeIndexBoolean.values.true": "Oui",
  "FieldTypeIndexBoolean.values.false": "Non",
  "calculatedProperties.properties.workplacesCount.label": "Nombre de postes de travail",
  "calculatedProperties.properties.workplacesCount.description": "Le nombre total de postes de travail dans les espaces",
  "calculatedProperties.properties.workplacesRatio.label": "Ratio postes de travail",
  "calculatedProperties.properties.workplacesRatio.description": "Le ratio postes de travail est le nombre de métres carrés divisé par le nombre de postes de travail",
  "calculatedProperties.properties.peopleCount.label": "Nombre d'affectations",
  "calculatedProperties.properties.peopleCount.description": "Le nombre de personnes affectées, soit directement affécté aux espaces, soit à travers un poste de travail",
  "calculatedProperties.properties.totalPeopleCount.label": "Nombre total d'affectations",
  "calculatedProperties.properties.totalPeopleCount.description": "Le nombre total de personnes affectées, soit directement affécté aux espaces, soit à travers un poste de travail",
  "calculatedProperties.properties.peopleRatio.label": "Ratio d'occupation",
  "calculatedProperties.properties.peopleRatio.description": "Le ratio d'occupation est le nombre de métres carrés divisé par le nombre de personnes affectées soit directement dans les espaces, soit via un poste de travail",
  "calculatedProperties.properties.freeWorkplacesCount.label": "Nombre de postes libres",
  "calculatedProperties.properties.freeWorkplacesCount.description": "Nombre total de postes libres",
  "calculatedProperties.properties.flexWorkplacesCount.label": "Nombre de postes flex",
  "calculatedProperties.properties.flexWorkplacesCount.description": "Nombre total de postes flex",
  "calculatedProperties.properties.occupancyRate.label": "Taux d'occupation",
  "calculatedProperties.properties.occupancyRate.description": "Permet de connaître le taux d'occupation des postes de travail, c'est le nombre de personnes affectées divisés par le nombre de postes de travail",
  "calculatedProperties.properties.expansionRatio.label": "Taux de foisonnement",
  "calculatedProperties.properties.expansionRatio.description": "Permet de connaître le taux d'usage des postes de travail, c'est l'inverse du nombre de personnes affectées divisés par le nombre de postes de travail",
  "calculatedProperties.properties.roomsArea.label": "Surface qualifiée",
  "calculatedProperties.properties.roomsArea.description": "La surface qualifiée est la somme des surfaces des espaces",
  "calculatedProperties.properties.roomsCount.label": "Nombre d'espaces",
  "calculatedProperties.properties.roomsCount.description": "Le nombre total d'espaces",
  "calculatedProperties.properties.sharedWorkplacesCount.label": "Nombre de postes de travail partagés",
  "calculatedProperties.properties.sharedWorkplacesCount.description": "Nombre total de postes de travail partagés par au moins 2 personnes",
  "calculatedProperties.properties.sharedWorkplacesRatio.label": "Taux de postes de travail partagés",
  "calculatedProperties.properties.sharedWorkplacesRatio.description": "Taux de postes de travail partagés par au moins 2 personnes par rapport à l'ensemble des postes de travail",
  "calculatedProperties.properties.flexRatio.label": "Taux de postes de travail en flex",
  "calculatedProperties.properties.flexRatio.description": "Le taux de poste de travail en flex est calculé en divisant le nombre de postes de travail en flex par le nombre total de postes de travail",
  "calculatedProperties.properties.transitWorkplacesCount.label": "Nombre de postes de travail de passage",
  "calculatedProperties.properties.transitWorkplacesCount.description": "Nombre de postes de travail de passage, ces postes ne sont pas comptabilisés dans les postes libres et ne sont pas en flex",
  "calculatedProperties.properties.seatsCount.label": "Nombre de places assises",
  "calculatedProperties.properties.seatsCount.description": "Le nombre total de places assises",
  "calculatedProperties.properties.seatsPeopleRatio.label": "Taux de places assises par affectations",
  "calculatedProperties.properties.seatsPeopleRatio.description": "Le nombre de places assises par personnes affectées",
  "calculatedProperties.properties.carbonFootprint.label": "Empreinte carbone",
  "calculatedProperties.properties.carbonFootprint.description": "L'empreinte carbone est le nombre de CO2 émis",
  "calculatedProperties.properties.totalCapacityCount.label": "Capacité totale",
  "calculatedProperties.properties.totalCapacityCount.description": "La capacité totale de places est la somme du nombre de places assises et de la capacité hors assises au niveau des espaces",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.label": "Taux de places assises par postes de travail",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.description": "Le taux de places par postes de travail est la capacité totale des espaces divisé par le nombre de postes de travail, cela permet de comprendre le taux de places en fonction du nombre de postes de travail",
  "DeleteMultipleDialog.title": "Supprimer %{determinants.undefined}",
  "DeleteMultipleDialog.content": "Vous êtes sur le point de supprimer <b>%{determinants.undefined}</b>, cette action n'est pas réversible et peut avoir des impacts, êtes-vous sûr de vouloir réaliser cette action ?",
  "DeleteMultipleDialog.cancel.label": "Annuler",
  "DeleteMultipleDialog.cancel.help": "Annuler la suppression",
  "DeleteMultipleDialog.delete.label": "Supprimer",
  "DeleteMultipleDialog.delete.help": "Supprimer définitivement %{determinants.defined}",
  "DownloadTableToExcelIconButton.help": "Exporter %{determinants.defined} sélectionnés",
  "DeleteMultipleEntities.help": "Supprimer %{determinants.defined} sélectionné(e)s",
  "EntityCreateModeSelect.open-on-create.text": "Ouvrir après la création",
  "EntityCreateModeSelect.open-on-create.help": "Une fois que votre objet est crée, vous allez être redirgié vers la page de visualisation de l'objet afin de voir ses propriétés et associations",
  "EntityCreateModeSelect.keep-creating.text": "Continuer de créer",
  "EntityCreateModeSelect.keep-creating.help": "Cette option permet de continuer à créer plusieurs objets à la suite en conservant les propriétés de l'ancienne création",
  "EntityCreateModeSelect.edit-on-create.text": "Modifier après la création",
  "EntityCreateModeSelect.edit-on-create.help": "Une fois que votre objet est crée, vous allez être redirgié vers la page de l'édition de l'objet afin de complêter ses propriétés et associations",
  "TableView.options": "Options",
  "ErrorImpossibleToFindTheEntity.text": "Il est impossible de trouver %{determinant.defined} recherchés",
  "ErrorImpossibleToFindTheEntities.text": "Il est impossible de trouver %{determinants.defined} recherché",
  "EntityPropertyTypesMandatoryNotRespected.title": "Les propriétés suivantes sont obligatoire",
  "entity.properties.mandatory": "La propriété %{name} est obligatoire.",
  "entity.properties.calculated": "La propriété %{name} est calculée automatiquement.",
  "entity.properties.readonly-lock": "La propritété %{name} est en lecture seule et ne peut pas être modifiée depuis cette page.",
  "EntityHasManyProperties.associations.others": "Les associations pour %{determinant.defined}",
  "EntityHasManyProperties.associations.reporting": "Les associations de reporting pour %{determinant.defined}",
  "EntityHasManyProperties.associations.security": "Les associations de sécurité pour %{determinant.defined}",
  "EntitiesView.NoItem": "Il n'y a aucun %{objectType}, vous pouvez créer votre premier %{objectType} en utilisant le bouton ci-dessous",
  "DeleteDialog.title": "Supprimer %{determinant.undefined}",
  "DeleteDialog.content": "Vous êtes sur le point de supprimer <b>%{determinant.undefined}</b>, cette action n'est pas réversible et peut avoir des impacts, êtes-vous sûr de vouloir réaliser cette action ?",
  "DeleteDialog.cancel.label": "Annuler",
  "DeleteDialog.cancel.help": "Annuler la suppression",
  "DeleteDialog.delete.label": "Supprimer",
  "DeleteDialog.delete.help": "Supprimer définitivement %{determinant.defined}",
  "ExportQueryNodeToFileButton.help.list": "Télécharger en excel %{determinants.defined}",
  "entity.excel.headers.count": "%{label}:Nombre",
  "entity.properties.externalId.label": "Clé externe",
  "entity.properties.externalId.description": "Ce champs peut être utilisé pour retenir la clé de correspondance dans un autre logiciel",
  "entity.properties.createdAt.label": "Date de création",
  "entity.properties.createdAt.description": "Date de création dans Surfy, permet de connaitre l'historique de la création dans Surfy",
  "entity.properties.userCompanyCreatedBy.label": "Créé par l'utilisateur",
  "entity.properties.userCompanyCreatedBy.description": "Créer par cet utilisateur dans Surfy, permet de connaitre l'historique de la création dans Surfy",
  "entity.properties.userCompanyCreatedById.label": "Identifiant de l'utilisateur qui a créé",
  "entity.properties.userCompanyCreatedById.description": "Créer par l'identifiant de cet utilisateur dans Surfy, permet de connaitre l'historique de la création dans Surfy",
  "entity.properties.userCompanyUpdatedById.label": "Identifiant de l'utilisateur qui a modifié",
  "entity.properties.userCompanyUpdatedById.description": "Mis à jour par l'identifiant de cet utilisateur dans Surfy, permet de connaitre l'historique de la création dans Surfy",
  "entity.properties.userCompanyUpdatedBy.label": "Mis à jour par l'utilisateur",
  "entity.properties.userCompanyUpdatedBy.description": "Mise à jour par cet utilisateur dans Surfy, permet de connaitre l'historique de la modification dans  Surfy",
  "entity.properties.updatedAt.label": "Date de mise à jour",
  "entity.properties.updatedAt.description": "Date de mise à jour dans Surfy, permet de connaitre l'historique des modifications",
  "entity.delete.button.label": "Supprimer",
  "entity.delete.button.help": "Supprimer %{determinant.defined} %{name}",
  "entity.cancel": "Annuler",
  "entity.see.label": "Voir",
  "entity.see.help": "Voir %{determinant.defined} %{name}",
  "entity.views.dataquality.help": "Les rapports et les actions pour la qualité de données pour %{determinants.defined}",
  "entity.views.dataquality.label": "Qualité des données",
  "entity.views.list.help": "Lister %{determinants.defined}",
  "entity.views.list.label": "Lister",
  "entity.views.import.help": "Importer %{determinants.undefined}",
  "entity.views.import.label": "Importer",
  "entity.views.details.help": "Voir %{determinant.defined} %{name}",
  "entity.views.details.label": "Voir",
  "entity.views.create.help": "Créer %{determinant.undefined}",
  "entity.views.create.label": "Créer",
  "entity.views.edit.help": "Modifier %{determinant.defined} %{name}",
  "entity.views.edit.label": "Modifier",
  "entity.views.dashboard.help": "Tableau de bord pour %{determinant.defined} %{name}",
  "entity.views.dashboard.label": "Tableau de bord",
  "entity.create.validate.help": "Valider la création pour %{determinant.defined}",
  "entity.create.validate.label": "Valider la création",
  "entity.create.button.help": "Commencer la création pour %{determinant.defined}",
  "entity.create.button.label": "Créer %{determinant.defined}",
  "entity.create.association.help": "Commencer la création pour %{determinant.undefined}",
  "entity.create.association.label": "Créer %{determinant.undefined}",
  "entity.update.button.label": "Sauvegarder",
  "entity.update.button.help": "Sauvegarder %{determinant.defined} %{name}",
  "entity.createAndAssociate.button.label": "Créer et associer",
  "entity.createAndAssociate.button.help": "Créer et associer %{determinant.undefined}",
  "entity.associate.button.label": "Associer",
  "entity.associate.button.help": "Associer %{determinant.undefined}",
  "entity.back": "Retour",
  "WorkCanvas.Options.ZoomCanvasOption.label.enable": "Activer la loupe autour de la souris",
  "WorkCanvas.Options.ZoomCanvasOption.label.disable": "Désactiver la loupe autour de la souris",
  "WorkCanvas.Options.ZoomCanvasOption.help.enable": "Activer la loupe permet de garder une vue d'ensemble d'une zone ou de l'étage et voir le comportement de la souris de façon précise",
  "WorkCanvas.Options.ZoomCanvasOption.help.disable": "Arrêter la loupe de la souris",
  "WorkCanvas.Options.AddSegmentPointOption.label.enable": "Ajouter un sommet sur un segment",
  "WorkCanvas.Options.AddSegmentPointOption.label.disable": "Arrêter l'ajout d'un sommet sur un segment",
  "WorkCanvas.Options.AddSegmentPointOption.help.enable": "Ajouter un sommet sur un segment permet de mettre un point n'importe ou sans tenir compte des autres points",
  "WorkCanvas.Options.AddSegmentPointOption.help.disable": "Arrêter la création de sommets sur les segments",
  "WorkCanvas.Options.AddSegmentPointOption.description": "Sélectionner un espace pour pouvoir créer un sommet sur un des segments",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.enable": "Activer l'inversion de l'orientation de la création des sommets",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.disable": "Désactiver l'inversion de l'orientation de la création des sommets",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.enable": "Activer l'inversion de l'orientation de la création des sommets permet de changer le sens de création des sommets",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.disable": "Désactiver l'inversion de retrouver le sens initial de création des sommets",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.enable": "Activer l'inversion de l'angle droit pour la création des sommets",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.disable": "Désactiver l'inversion de l'angle droit pour la création des sommets",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.enable": "Activer l'inversion permet d'utiliser l'angle droit pendant la création des sommets sur l'autre ségment",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.disable": "Désactiver l'inversion permet d'utiliser l'angle droit sur le ségment initial",
  "LoadingSvgCircle.pleaseWait": "Veuillez patienter pendant la synchronisation",
  "WorkCanvas.Options.AddRoomPointOption.label.enable": "Ajouter un sommet",
  "WorkCanvas.Options.AddRoomPointOption.label.disable": "Arrêter l'ajout d'un sommet",
  "WorkCanvas.Options.AddRoomPointOption.help.enable": "Ajouter un sommet permet de retravailler avec plus de precisions une forme",
  "WorkCanvas.Options.AddRoomPointOption.help.disable": "Arrêter la création de sommets",
  "WorkCanvas.Options.SplitPolygoneOption.label": "Séparer l'espace",
  "WorkCanvas.Options.SplitPolygoneOption.help": "Créer 2 espaces à partir d'un autre espace en choisissant 2 sommets",
  "WorkCanvas.Options.SplitRoomPointOption.help": "Séparer le sommet permet de réutiliser plusieurs sommets pour chaque ségment et ainsi créer des espaces séparés",
  "WorkCanvas.Options.SplitRoomPointOption.label": "Séparer le sommet",
  "WorkCanvas.Options.MergeRoomPointsOption.help": "Fusionner les sommets permet de réutiliser le même sommet pour des espaces différents",
  "WorkCanvas.Options.MergeRoomPointsOption.label": "Fusionner les sommets",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.help": "Supprimer les sommets de l'espace",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.label": "Supprimer les sommets sélectionnés",
  "WorkCanvas.Options.ZoomOnEdgePoints.help": "Zoomer sur un ou plusieurs points afin de pouvoir travailler tranquillement",
  "WorkCanvas.Options.ZoomOnEdgePoints.label": "Zoomer sur les points",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.enable": "Déplacer le type d'objet",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.disable": "Arrêter le déplacement",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.enable": "Déplacer le type d'objet sur le plan",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.disable": "Arrêter le déplacement du type d'objet",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.help": "Retirer le type d'objet du type de poste de travail",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.label": "Retirer le type d'objet",
  "WorkCanvas.Options.DeleteItemTypePointsOption.help": "Supprimer les sommets du type d'objet",
  "WorkCanvas.Options.DeleteItemTypePointsOption.label": "Supprimer les sommets sélectionnés",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.enable": "Ajouter une forme",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.disable": "Arrêter l'ajout de la forme",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.enable": "Ajouter une forme pour un type d'objet sur le plan",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.disable": "Arrêter la création de la forme",
  "WorkCanvas.Options.AddItemTypeShapeSaveOption.help": "Sauvegarder le type d'objet en cours de création",
  "WorkCanvas.Options.AddItemTypePointOption.label.enable": "Ajouter un sommet",
  "WorkCanvas.Options.AddItemTypePointOption.label.disable": "Arrêter l'ajout d'un sommet",
  "WorkCanvas.Options.AddItemTypePointOption.help.enable": "Ajouter un sommet permet de retravailler avec plus de precisions une forme",
  "WorkCanvas.Options.AddItemTypePointOption.help.disable": "Arrêter la création de sommets",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.enable": "Déplacer les espaces",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.disable": "Arrêter les déplacements",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.enable": "Activer le déplacement des espaces sur le plan",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.disable": "Arrêter le déplacement des espaces",
  "WorkCanvas.Options.ToggleMoveRoomOption.description": "Une fois activé, sélectionner un espace et vous pouvez le déplacer",
  "WorkCanvas.Options.DuplicateShapesOption.label": "Dupliquer les formes",
  "WorkCanvas.Options.DuplicateShapesOption.help": "Dupliquer les formes sans les propriétés pour rapidement créer des objets ou des postes de travail sur le plan",
  "CancelDuplicateShapsToRoomMouse.help": "Annuler la duplication des formes",
  "ToggleWorkplaceFreeConditionTypeIconButton.or": "Voir les postes de travail libre pour tous les jours demandés",
  "ToggleWorkplaceFreeConditionTypeIconButton.and": "Voir les postes de travail libre pour au moins un des jours demandés",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.false": "Colorier les postes libre %{day}",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.true": "Arrêter de colorier les postes libre %{day}",
  "FreeWorkplacesDayList.title": "Voir les places libre %{days}",
  "FreeWorkplacesDayList.conditions.and": "et",
  "FreeWorkplacesDayList.conditions.or": "ou",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.enable": "Colorier les postes de passage",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.disable": "Arrêter de colorier les postes de passage",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.enable": "Voir sur le plan en couleur les postes de travail qui sont de passage",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.disable": "Ne plus voir les postes de travail de passage de façon différente sur le plan",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.enable": "Colorier les postes partagés",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.disable": "Arrêter de colorier les postes partagés",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.enable": "Voir sur le plan en couleur les postes de travail qui sont partagés par au moins 2 personnes",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.disable": "Ne plus voir les postes de travail partagés de façon différente sur le plan",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.enable": "Colorier les objets sans association",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.disable": "Arrêter de colorier les objets sans association",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.enable": "Voir sur le plan les objets libre",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.disable": "Ne plus voir les objets libres de façon différente sur le plan",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.enable": "Colorier les postes réservables",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.disable": "Arrêter de colorier les postes réservables",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.enable": "Voir sur le plan en couleur les postes de travail qui sont réservables",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.disable": "Ne plus voir les postes de travail réservables de façon différente sur le plan",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.enable": "Colorier les postes libres",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.disable": "Arrêter de colorier les postes libres",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.enable": "Voir sur le plan les postes libres",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.disable": "Ne plus voir les postes libres de façon différente sur le plan",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.enable": "Colorier les postes en flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.disable": "Arrêter de colorier les postes en flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.enable": "Voir sur le plan les postes flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.disable": "Ne plus voir les postes flex de façon différente sur le plan",
  "WorkCanvas.Options.CalibrateLayoutOption.help.enable": "Calibrer le plan permet d'agrandir ou de réduire la taille de tous les espaces ou de les déplacer tous sur le plan",
  "WorkCanvas.Options.CalibrateLayoutOption.help.disable": "Arrêter de calibrer le plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.enable": "Calibrer le plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.disable": "Arrêter de calibrer le plan",
  "CalibrateLayoutDrawer.title": "Calibrer le plan",
  "CalibrateLayoutDrawer.options.mapScale.label": "Aligner l'échelle du plan",
  "CalibrateLayoutDrawer.options.mapScale.help": "Applique le facteur d'échelle sur les élements de l'échelle (longeur et taille des textes)",
  "CalibrateLayoutDrawer.options.inputs.scale.label": "Facteur d'échelle",
  "CalibrateLayoutDrawer.options.inputs.step.label": "Valeur de translation",
  "CalibrateLayoutDrawer.options.inputs.translate.x.label": "L'axe X",
  "CalibrateLayoutDrawer.options.inputs.translate.y.label": "L'axe Y",
  "CalibrateLayoutDrawer.options.reduce.label": "Réduire",
  "CalibrateLayoutDrawer.options.save.label": "Enregistrer",
  "CalibrateLayoutDrawer.options.save.help": "Enregister le calibrage sur le plan",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.enable": "Activer l'affichage des icônes sur le plan en 2d",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.disable": "Désactiver l'affichage des icônes sur le plan",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.enable": "Les icônes associés au types d'espaces permettent de visualiser plus facilement les types d'espaces sur le plan",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.disable": "Afficher les informations des espaces",
  "WorkCanvasToggleOptionHelp.shortcut": "Raccourci clavier : <b>%{shortcut}</b>",
  "WorkCanvasShortcutTooltipHelp.help": "Raccourci clavier : <b>%{shortcut}</b>",
  "WorkCanvas.Options.ZoomOutOption.label": "Dézoomer sur le plan",
  "WorkCanvas.Options.ZoomOutOption.help": "Dézoomer sur le plan en centrant sur la position de la souris",
  "WorkCanvas.Options.ZoomOutOption.description": "Vous pouvez utiliser la molette de la souris et votre touchpad pour dézoomer",
  "WorkCanvas.Options.ZoomOnMousePosition.help": "Zoomer sur la position de la souris pour pouvoir travailler plus précisement sur une zone",
  "WorkCanvas.Options.ZoomOnMousePosition.label": "Zoomer sur la position de la souris",
  "WorkCanvasLoadingIcon.title": "Chargement du plan",
  "WorkCanvas.Options.ZoomOnItemsOption.help": "Zoomer sur un ou plusieurs objets afin de pouvoir travailler plus précisement",
  "WorkCanvas.Options.ZoomOnItemsOption.label": "Zoomer sur la sélection",
  "WorkCanvas.Options.ZoomOnDimensionsOption.label": "Zoomer sur les calques d'affectations",
  "WorkCanvas.Options.ZoomOnDimensionsOption.help": "Zoomer directement sur les calques d'affectations dans lesquels vous pouvez réserver sur le plan",
  "WorkCanvas.Options.ZoomInOption.label": "Zoomer sur le plan",
  "WorkCanvas.Options.ZoomInOption.help": "Zoomer sur le plan en centrant vers en haut a gauche de l'écran",
  "WorkCanvas.Options.ZoomInOption.description": "Vous pouvez utiliser la molette de la souris et votre touchpad pour zoomer",
  "WorkCanvas.Options.ToggleSelectModeOption.help.enable": "Obtenir les options du plan pour pouvoir zoomer ou voir le détails des formes et activer les raccourcis clavier, vous pouvez aussi cliquer dans le plan pour activer la manipulation",
  "WorkCanvas.Options.ToggleSelectModeOption.help.disable": "",
  "WorkCanvas.Options.ToggleSelectModeOption.label.enable": "Commencer la manipulation de l'espace de travail",
  "WorkCanvas.Options.ToggleSelectModeOption.label.disable": "Arrêter la manipulation de l'espace de travail",
  "WorkCanvas.Options.ToggleSelectModeOption.description": "Vous pouvez sélectionner plusieurs formes en maintenant <b>SHIFT</b> appuyé et en cliquant sur les formes",
  "WorkCanvas.Options.ToggleEditModeOption.label.enable": "Activer le mode édition du plan",
  "WorkCanvas.Options.ToggleEditModeOption.label.disable": "Désactiver le mode édition du plan",
  "WorkCanvas.Options.ToggleEditModeOption.help.enable": "Activer le mode édition du plan permet de créer et déplacer des formes ou créer des espaces",
  "WorkCanvas.Options.ToggleEditModeOption.help.disable": "Désactiver le mode édition du plan pour revenir dans le mode lecture du plan",
  "WorkCanvas.Options.ToggleEditModeOption.description": "Lors de la rotation des objets et des postes de travail, par defaut un angle de 45° est appliqué, pour le désactiver utilisez la touche du clavier <b>SHIFT</b>",
  "WorkCanvas.Options.FitToViewOption.label": "Centrer le plan pour tout voir",
  "WorkCanvas.Options.FitToViewOption.help": "Permet d'avoir la vision d'ensemble du plan",
  "HeatMapSelection.title": "Colorier les espaces avec une carte des chaleurs pour comprendre les densités, les cartes de chaleurs ne sont pas exportable en image pour le moment",
  "HeatMapSelection.heatmaps.seatsCount.label": "Densité de places assises",
  "HeatMapSelection.heatmaps.seatsCount.description": "Colorier les espaces en fonction du nombre de place assises",
  "HeatMapSelection.heatmaps.workplacesCount.label": "Densité des postes de travail",
  "HeatMapSelection.heatmaps.workplacesCount.description": "Colorier les espaces en fonction du nombre de postes de travail",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.label": "Densité des affectations aux postes de travail",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.description": "Colorier les espaces en fonction du nombre d'affectations aux postes de travail",
  "HeatMapSelection.heatmaps.carbonFootprintCount.label": "Densité d'empreinte carbone du mobilier",
  "HeatMapSelection.heatmaps.carbonFootprintCount.description": "Colorier les espaces en fonction de l'empreinte carbone du mobilier",
  "FurnituresSelectionDragZone.help": "Déplacer le groupe",
  "FurnituresSelection.move": "Déplacer tout le groupe",
  "WorkCanvas.Options.TextAnchorOption.label.enable": "Définir l'emplacement du texte d'affichage",
  "WorkCanvas.Options.TextAnchorOption.label.disable": "Arrêter la gestion du texte d'affichage",
  "WorkCanvas.Options.TextAnchorOption.help.enable": "Déplacer le texte d'affichage",
  "WorkCanvas.Options.TextAnchorOption.help.disable": "Arrêter le déplacement du texte d'affichage",
  "TextAnchorDrawer.title": "Modifier l'emplacement du texte d'affichage pour %{determinant.defined} %{name}",
  "WorkCanvas.Options.TextAnchorDrawer.label.enable": "Déplacer le texte d'affichage",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.label": "Personnaliser la position du texte",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.help": "Permet d'activer la personnalisation de la position du texte du le plan",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.label": "Activer l'affichage de l'ancre",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.help": "Permet d'activer l'affichage du segment et du point d'ancrage pour cet espace",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.label": "Réinitialiser la position du texte",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.help": "Cette option remet la position du texte pour cet espace à son emplacement initiale",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.label": "Réinitialiser la position d'ancrage",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.help": "Cette option remet la position d'ancrage pour cet espace à son emplacement initiale",
  "ShapeTextAnchorDrawer.empty": "Merci de sélectionner une forme compatible afin de déplacer le texte d'affichage",
  "IconsPicker.DisplayAll.text": "Tout afficher",
  "IconsPicker.DisplayAll.help": "Attention le chargement peut être un peu long",
  "IconsPicker.close": "Fermer la sélection d'icone",
  "IconPickerSearch.SearchPlaceholder": "Rechercher une icone avec au moins 3 lettres",
  "EntitiesAutocomplete.searchEmpty.help.false": "Sélectionner %{determinants.defined} sans %{objectTypeName}",
  "EntitiesAutocomplete.searchEmpty.help.true": "Repasser en mode de rechercher standard",
  "SearchFieldString.searchEmpty.help.false": "Rechercher des éléments vide ou sans valeur",
  "SearchFieldString.searchEmpty.help.true": "Réactiver la recherche standard",
  "SearchFilters.buttons.clear.label": "Effacer tous les filtres",
  "SearchFilters.buttons.clear.help": "Effacer tous les filtres et les remettre dans leur état inital afin de vous assurer que vous pouvez voir toutes les entités disponible",
  "RightSearchFilterDrawer.filter": "Filtrer %{determinants.defined}",
  "RightSearchFilterDrawer.tabLabel": "Filtrer",
  "RightSearchFilterDrawer.buttons.clear.label": "Effacer tous les filtres",
  "RightSearchFilterDrawer.buttons.clear.help": "Effacer tous les filtres et les remettre dans leur état inital afin de vous assurer que vous pouvez voir toutes les entités disponible",
  "PropertSelectorDrawer.help": "Sélectionner les propriétés que vous souhaitez afficher dans le tableau",
  "PropertSelectorDrawer.options.reset.label": "Réinitialiser la sélection",
  "PropertSelectorDrawer.options.reset.help": "Remettre la sélection des propriétés à leur état inital",
  "PropertSelectorDrawer.tabLabel": "Propriétés",
  "TableSelectionAllCheckbox.checked.true": "Tout déselectionner",
  "TableSelectionAllCheckbox.checked.false": "Tout sélectionner",
  "TableSelectionAllCheckbox.help": "Sélectionner ou déselectionner toutes les lignes (incluant celles qui ne sont pas visibles dans la liste paginée)",
  "TableOptionsRow.checked.true": "Tout déselectionner",
  "TableOptionsRow.checked.false": "Tout sélectionner",
  "TableOptionsRow.help": "Sélectionner ou déselectionner toutes les lignes",
  "ErrorTextZone.reload": "Recommencer l'opération",
  "ReportErrorSteps.report.title": "Vous venez de rencontrer une erreur",
  "ReportErrorSteps.report.description": "Cette erreur est remontée à nos équipes et nous allons tenter de la corriger au plus vite",
  "ReportErrorSteps.report.steps.title": "Vous pouvez essayer dans l'ordre",
  "ReportErrorSteps.report.steps.reload": "Recharger la page et voir si l'erreur est résolue",
  "ReportErrorSteps.report.steps.logout": "Vous déconnecter et revenir à cette page suite à votre reconnexion",
  "ReportErrorSteps.report.steps.contact": "Nous contacter pour que nous puissons vous proposer une alternative au plus vite",
  "ReportErrorByMailButton.label": "Nous contacter",
  "RefreshPageButton.label": "Recharger la page",
  "Errors.networkError": "Des problèmes de connexion ou de réseau ont été détectés, merci de patienter et de réessayer dans quelques secondes",
  "ShowEntityDrawer.title.show": "Voir %{determinant.defined}",
  "ShowEntityDrawer.title.listItem": "Voir les informations pour %{determinant.defined} dans la barre latérale",
  "EditEntityDrawer.title.edit": "Modifier %{determinant.defined}",
  "RightDrawerContent.close": "Fermer le panneau de droite en cliquant sur la croix.",
  "DropDownOptions.moreOptions": "Voir plus d'options pour %{determinant.defined} %{name}",
  "BuildingFloorsList.title": "Naviguer dans les étages",
  "RefetchEntityButton.refetch": "Recharger les données",
  "RefetchEntitiesButton.refetch": "Recharger les données des objets visibles",
  "RefetchObjectTypeIcon.help": "Recharger les données pour %{determinant.defined}",
  "ImpactButtonReload.help.single": "Mettre à jour les données calculées pour %{determinant.defined}",
  "ImpactButtonReload.help.list": "Mettre à jour les données calculées pour %{determinants.defined}",
  "EditInlineToggleIconButton.edit.label": "Modifier",
  "EditInlineToggleIconButton.edit.help": "Modifier directement sur cette page les propriétés pour %{determinant.defined}",
  "EditInlineToggleIconButton.cancel.help": "Arrêter la modification sans sauvegarder",
  "ConfirmationButtons.confirm": "Confirmer la réalisation de l'action",
  "ConfirmationButtons.cancel": "Annuler",
  "ConfirmationButtons.loading": "L'action est en cours d'execution, merci de patienter",
  "EmailNotVerified.errorMessage": "Merci de valider votre email (%{email}), une fois validé, vous pouvez vous déconnecter puis vous reconnecter pour accéder à Surfy",
  "NoRoleAssociated.noRole": "Aucun rôle ne semble être associé à votre utilisateur pour l'entreprise %{tenant}, merci de vous rapprocher de votre administrateur",
  "NoCompanies.title.whatIsSurfy": "Qu'est ce que Surfy ?",
  "NoCompanies.NoCompanyAssigned": "Vous n'êtes associé à aucune plateforme, vous ne pouvez pas utiliser surfy pour le moment",
  "NoCompanies.whatIsSurfy": "Surfy propose de digitaliser les plans des bâtiments pour faciliter la gestion de l'environnement de travail.<br/>Vous pouvez utiliser l'application Surfy pour <ul><li>aménager les espaces</li><li>affecter les collaborateurs</li><li>refacturer les espaces</li><li>analyser les espaces</li><li>gérer la conformité et la réglementation</li><li>connecter les espaces</li><li>gérer les planning de présence</li><li>réserver les espaces de travail</li></ul>",
  "NoCompanies.whatIsSurfyForTeams": "Surfy propose de digitaliser les plans des bâtiments pour faciliter la gestion de l'environnement de travail. Vous pouvez utiliser l'application Surfy pour <ul><li>gérer votre planning de présence</li><li>déclarer votre présence au bureau</li><li>réserver un espace de travail</li><li>indiquer que vous êtes en télétravail</li><li>voir quels collègues ont réservé un poste de travail sur le plan</li></ul>",
  "NoCompanies.ContactUs.text": "Vous connecter à la plateforme de votre entreprise",
  "NoCompanies.ContactUs.subject": "Accéder à Surfy",
  "NoCompanies.ContactUs.body": "Bonjour, pourriez vous me laisser accéder à l'application Surfy ? Merci.",
  "NoCompanies.accessSurfy.title": "Pourquoi je ne peux pas accéder à Surfy ?",
  "NoCompanies.accessSurfy.alreadyUsing": "Si votre entreprise utilise déjà Surfy, merci de vous rapprocher de votre responsable de l'environnement de travail pour demander un accès ou nous contacter via le lien suivant",
  "NoCompanies.accessSurfy.joinTenant": "Rejoindre la plateforme de votre société",
  "NoCompanies.notUsing.title": "Votre entreprise n'utilise pas encore Surfy ?",
  "NoCompanies.knowMore": "En savoir plus sur Surfy",
  "AuthenticationButton.connections.google-oauth2.label": "Google",
  "AuthenticationButton.connections.google-oauth2.help": "Se connecter avec votre compte Google",
  "AuthenticationButton.connections.AzureADv2.label": "Office 365",
  "AuthenticationButton.connections.AzureADv2.help": "Se connecter avec votre compte professionel Microsoft via Office 365",
  "AuthenticationButton.connections.auth0.label": "Compte Surfy",
  "AuthenticationButton.connections.auth0.help": "Se connecter avec votre compte Surfy",
  "Auth0AuthenticationButton.connections.auth0.label": "Compte Surfy (open id)",
  "Auth0AuthenticationButton.connections.auth0.help": "Se connecter avec votre compte Surfy",
  "EnterpriseConnectionButton.label": "Entreprise",
  "EnterpriseConnectionButton.help": "Se connecter avec le compte de votre entreprise via une authentification dédiée comme OKTA ou DigitalP@ss",
  "EnterpriseConnectionForm.title": "Veuillez saisir votre email afin que nous puissions reconnnaître votre entreprise",
  "EnterpriseConnectionForm.forms.email.placeholder": "e-mail",
  "EnterpriseConnectionForm.error": "Impossible d'identifier votre entreprise avec votre email",
  "EnterpriseConnectionForm.buttons.validate.label": "Valider",
  "EnterpriseConnectionForm.buttons.validate.help": "Valider l'email permet de connaître votre entreprise et de vous orienter vers la bonne plateforme d'authentification",
  "EnterpriseConnectionForm.buttons.back.label": "Retour",
  "EnterpriseConnectionForm.buttons.back.help": "Revenir vers la page d'authentification avec toutes les options",
  "LoginView.loadingPage": "Chargement de la page d'authentification",
  "LoginView.connections.google-oauth2.label": "Google",
  "LoginView.connections.google-oauth2.help": "Se connecter avec votre compte Google",
  "LoginView.connections.AzureADv2.label": "Office 365",
  "LoginView.connections.AzureADv2.help": "Se connecter avec votre compte professionel Microsoft via Office 365",
  "LoginView.connections.Username-Password-Authentication.label": "Compte Surfy",
  "LoginView.connections.Username-Password-Authentication.help": "Se connecter avec votre compte Surfy",
  "LoginView.texts.title": "Connexion",
  "LoginView.texts.description": "Accéder à Surfy",
  "LoginView.helpers.register": "Inscrivez votre entreprise à Surfy",
  "LoginView.helpers.moreInfo": "En savoir plus sur Surfy",
  "LoginView.helpers.privacy": "Politique de confidentialité",
  "CustomUserRegisterForm.tabs.login": "Se connecter",
  "CustomUserRegisterForm.tabs.signup": "S'inscrire",
  "CustomUserRegisterForm.form.email": "E-mail",
  "CustomUserRegisterForm.form.password": "Mot de passe",
  "CustomUserRegisterForm.form.firstName": "Prénom",
  "CustomUserRegisterForm.form.lastName": "Nom de famille",
  "CustomUserRegisterForm.form.confirmPassword": "Confirmation mot de passe",
  "CustomUserRegisterForm.buttons.login.label": "Valider",
  "CustomUserRegisterForm.buttons.login.help": "Connectez-vous si vous avez déjà un compte",
  "CustomUserRegisterForm.buttons.signup.label": "Valider",
  "CustomUserRegisterForm.buttons.signup.help": "Inscrivez vous à Surfy si vous n'avez pas de compte",
  "ReportChart.NoValue": "Sans valeur",
  "ChangeLanguage.title": "Changer la langue",
  "ChangeLanguage.help": "Changer la langue de l'application",
  "DataQualityTable.numberOfLines": "Nombre de lignes",
  "AllTenantsDataQualityTable.enableAllTenants.label": "Inclure toutes les plateformes",
  "SingleNodeQuery.refetch": "Recharger les données",
  "ListRefetchButton.refetch": "Recharger les données des objets visibles",
  "ImpactObjectTypeIconButton.refetch": "Recharger toutes les données sans tenir compte des filtres",
  "CollapseSwitchButton.help.true": "Masquer le détail",
  "CollapseSwitchButton.help.false": "Voir le détail",
  "menu.logout": "Se déconnecter",
  "menu.tenantOperations": "Synchronisation",
  "menu.menuLeft.shoppingCart": "Panier",
  "menu.menuLeft.personCompanies": "Prestataires",
  "menu.menuLeft.workplace": "Postes de travail",
  "menu.menuLeft.security": "Sécurité",
  "menu.menuLeft.globalSecurity": "Sécurité globale",
  "menu.menuLeft.all": "Administration",
  "menu.menuLeft.operations": "Opérations",
  "menu.menuLeft.types": "Typologies",
  "menu.menuLeft.roomTypes": "Typologies d'espaces",
  "menu.menuLeft.inventory": "Inventaires",
  "menu.menuLeft.people": "Personnes",
  "menu.menuLeft.spaces": "Espaces",
  "menu.menuLeft.organizations": "Organisations",
  "menu.menuLeft.dimensions": "Calques d'analyse",
  "menu.menuLeft.api": "API",
  "menu.menuLeft.authentification": "Authentification",
  "menu.menuLeft.globalAdmin": "Administration globale",
  "menu.menuLeft.human": "Collaborateurs",
  "menu.menuLeft.things": "Mobiliers",
  "menu.menuLeft.admin": "Administration",
  "menu.menuLeft.surfy": "Surfy",
  "menu.menuLeft.partnerExportMapping": "Partenaires",
  "menu.menuLeft.personType": "Typologies",
  "menu.menuLeft.personRelations": "Relations",
  "menu.menuLeft.affectations": "Affectations",
  "menu.menuLeft.buildings": "Bâtiments",
  "menu.menuLeft.thingsType": "Typologies",
  "menu.menuLeft.spacePoints": "Points",
  "menu.menuLeft.adminReporting": "Reporting",
  "menu.menuLeft.adminCostCenterReporting": "Centre de coûts",
  "menu.menuLeft.adminDimensionReporting": "Dimensions",
  "menu.menuLeft.adminRoomTypeReporting": "Type d'espaces",
  "menu.menuLeft.adminOrganizationReporting": "Organisations",
  "menu.menuLeft.adminRoomTypeGroupReporting": "Groupes de typologies d'espaces",
  "menu.menuLeft.buildingFacts": "Données horodatées des bâtiments",
  "menu.menuLeft.itemsFact": "Données horodatées des objets",
  "menu.menuLeft.segments": "Segments",
  "menu.menuLeft.connectors": "Connecteurs",
  "menu.menuLeft.planning": "Plannings",
  "menu.menuLeft.bookings": "Réservations",
  "menu.menuLeft.help": "Aide",
  "menu.menuLeft.company": "Plateformes",
  "ReduceMenuSwitch.open.true": "Déplier le menu",
  "ReduceMenuSwitch.open.false": "Reduire le menu pour profiter de l'espace de travail",
  "LogoutMenuLink.logout": "Se déconnecter",
  "HelpPortalListItemLink.label": "Portail d'aide",
  "HelpPortalListItemLink.help": "Découvrez le portail d'aide de Surfy avec tous nos tutoriels et guides d'utilisation",
  "ChangeLogListItemLink.label": "Nouveautés",
  "ChangeLogListItemLink.help": "Connaître les nouveautés et les changements dans Surfy",
  "DisplayRoomTexts.dragOption": "Garder appuyé et changer l'ordre d'affichage des propriétés sur le plan en déplacant le champs vers le haut ou le bas",
  "DisplayRoomTexts.roomPeopleDimensions.label": "Quartier",
  "DisplayRoomTexts.roomPeopleDimensions.help": "Afficher ou non le quartier sur le plan",
  "DisplayRoomTexts.roomSeatsCount.label": "Nombre de places assises",
  "DisplayRoomTexts.roomSeatsCount.help": "Afficher ou non le nombre de places assises sur le plan",
  "DisplayRoomTexts.roomCapacity.label": "Capacité de l'espace",
  "DisplayRoomTexts.roomCapacity.help": "Afficher ou non la capacité de l'espace sur le plan",
  "DisplayRoomTexts.roomCostCenter.label": "Centre de coût",
  "DisplayRoomTexts.roomCostCenter.help": "Afficher ou non le centre de coût de l'espace sur le plan",
  "DisplayRoomTexts.roomMergedName.label": "Nom fusionné",
  "DisplayRoomTexts.roomMergedName.help": "Afficher ou non le nom fusionné de l'espace sur le plan, ce nom regroupe le nom d'affichage et le nom de l'espace",
  "DisplayRoomTexts.roomName.label": "Nom de l'espace",
  "DisplayRoomTexts.roomName.help": "Afficher ou non le nom de l'espace sur le plan",
  "DisplayRoomTexts.roomPrettyName.label": "Nom d'affichage",
  "DisplayRoomTexts.roomPrettyName.help": "Afficher ou non le nom d'affichage l'espace sur le plan",
  "DisplayRoomTexts.roomArea.label": "Surface",
  "DisplayRoomTexts.roomArea.help": "Afficher ou non la surface de l'espace sur le plan",
  "DisplayRoomTexts.roomType.label": "Typologie de l'espace",
  "DisplayRoomTexts.roomType.help": "Afficher ou non la typologie de l'espace",
  "DisplayRoomTexts.roomPerimeter.label": "Périmètre",
  "DisplayRoomTexts.roomPerimeter.help": "Afficher ou non le périmètre de l'espace sur le plan",
  "DisplayRoomTexts.roomOrganizationLevel1.label": "Service",
  "DisplayRoomTexts.roomOrganizationLevel1.help": "Afficher ou non le nom du service de l'espace sur le plan",
  "DisplayRoomTexts.roomOrganizationTopLevel.label": "Direction",
  "DisplayRoomTexts.roomOrganizationTopLevel.help": "Afficher ou non le nom de la direction de l'espace sur le plan",
  "DisplayRoomTexts.roomPeople.label": "Personnes affectées aux espaces",
  "DisplayRoomTexts.roomPeople.help": "Afficher ou non le nom des personnes affectées à cet espace sur le plan",
  "DisplayRoomTexts.roomWorkplaceAffectations.label": "Personnes affectées aux postes de travail",
  "DisplayRoomTexts.roomWorkplaceAffectations.help": "Afficher ou non le nom des personnes affectées aux postes de travail de cet espace sur le plan",
  "DisplayRoomTexts.roomPeopleCount.label": "Nombre d'affectations",
  "DisplayRoomTexts.roomPeopleCount.help": "Afficher ou non le nombre de personnes affectées à cet espace sur le plan",
  "DisplayRoomTexts.roomPeopleRatio.label": "Ratio d'occupation",
  "DisplayRoomTexts.roomPeopleRatio.help": "Afficher ou non le ratio d'occupation de l'espace sur le plan",
  "DisplayRoomTexts.roomWorkplacesCount.label": "Nombre de postes de travail",
  "DisplayRoomTexts.roomWorkplacesCount.help": "Afficher ou non le nombre de postes de travail de l'espace sur le plan",
  "DisplayRoomTexts.roomWorkplacesRatio.label": "Ratio postes de travail",
  "DisplayRoomTexts.roomWorkplacesRatio.help": "Afficher ou non le ratio des postes de travail de l'espace sur le plan",
  "DisplayRoomTexts.roomOccupancyRate.label": "Taux d'occupation",
  "DisplayRoomTexts.roomOccupancyRate.help": "Afficher ou non le taux d'occupation de l'espace sur le plan",
  "DisplayRoomTexts.roomExpansionRatio.label": "Taux de foisonnement",
  "DisplayRoomTexts.roomExpansionRatio.help": "Afficher ou non le taux de foisonnement de l'espace sur le plan",
  "DisplayRoomTexts.roomFreeWorkplacesCount.label": "Nombre de postes libres",
  "DisplayRoomTexts.roomFreeWorkplacesCount.help": "Afficher ou non le nombre de postes libres sur le plan",
  "DisplayRoomTexts.roomFlexWorkplacesCount.label": "Nombre de postes flex",
  "DisplayRoomTexts.roomFlexWorkplacesCount.help": "Afficher ou non le nombre de postes flex sur le plan",
  "DisplayRoomOptions.roomSeatsCount.one": "%{value} place assise",
  "DisplayRoomOptions.roomSeatsCount.more": "%{value} places assises",
  "DisplayRoomOptions.roomCapacity.one": "Capacité : %{value} place",
  "DisplayRoomOptions.roomCapacity.more": "Capacité : %{value} places",
  "DisplayRoomOptions.roomFreeWorkplacesCount.one": "%{value} poste libre",
  "DisplayRoomOptions.roomFreeWorkplacesCount.more": "%{value} postes libres",
  "DisplayRoomOptions.roomFlexWorkplacesCount.one": "%{value} poste flex",
  "DisplayRoomOptions.roomFlexWorkplacesCount.more": "%{value} postes flex",
  "DisplayRoomOptions.roomWorkplacesCount.one": "%{value} poste de travail",
  "DisplayRoomOptions.roomWorkplacesCount.more": "%{value} postes de travail",
  "DisplayRoomOptions.roomPeopleCount.one": "%{value} personne affectée",
  "DisplayRoomOptions.roomPeopleCount.more": "%{value} personnes affectées",
  "DisplayRoomOptions.roomOccupancyRate": "Occupation : %{value}",
  "DisplayRoomOptions.roomExpansionRatio": "Foisonnement : %{value}",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.enable": "Gérer les textes d'affichage des espaces",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.disable": "Fermer la gestion des textes d'affichage",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.enable": "Permet de configurer les textes qui vont s'afficher sur le plan pour chaque espace",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.disable": "Revenir dans le mode normal de l'édition du plan.",
  "DisplayRoomTextsDrawer.tabs.map": "Plan",
  "DisplayRoomTextsDrawer.tabs.tooltip": "Infobulle",
  "DisplayRoomTextsDrawer.tabs.base.tabs.rooms": "Espaces",
  "DisplayRoomTextsDrawer.tabs.base.tabs.people": "Personnes",
  "DisplayRoomTextsDrawer.tabs.base.people.description": "Pour définir les propriétés des personnes à afficher sur le plan, veuillez choisir dans l'onglet des espaces les personnes affectés aux espaces ou aux postes de travail puis choisir les propriétés dans cet onglet",
  "DisplayWorkplaceTexts.workplaceName.label": "Nom du poste de travail",
  "DisplayWorkplaceTexts.workplaceName.help": "Afficher ou non le nom du poste de travail sur le plan",
  "DisplayWorkplaceTexts.workplaceCostCenter.label": "Centre de coût",
  "DisplayWorkplaceTexts.workplaceCostCenter.help": "Afficher ou non le centre de coût du poste de travail sur le plan",
  "DisplayWorkplaceTexts.people.label": "Afficher les personnes",
  "DisplayWorkplaceTexts.people.help": "Afficher ou non les personnes affectées au poste de travail sur le plan",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.label": "Direction",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.help": "Afficher ou non les directions des postes de travail sur le plan",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.label": "Service",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.help": "Afficher ou non les services des postes de travail sur le plan",
  "DisplayPersonTexts.personPicture.label": "Photo des personnes",
  "DisplayPersonTexts.personPicture.help": "Afficher ou non la photo des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personName.label": "Nom des personnes",
  "DisplayPersonTexts.personName.help": "Afficher ou non le nom des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personSecurityProfile.label": "Profil de sécurité",
  "DisplayPersonTexts.personSecurityProfile.help": "Afficher ou non le profil de sécurité des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personOrganizationLevel0.label": "Direction",
  "DisplayPersonTexts.personOrganizationLevel0.help": "Afficher ou non la direction des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personOrganizationLevel1.label": "Service",
  "DisplayPersonTexts.personOrganizationLevel1.help": "Afficher ou non le service des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personOrganizationHierarchy.label": "Hiérarchie de l'organisation",
  "DisplayPersonTexts.personOrganizationHierarchy.help": "Afficher ou non le service et la direction des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personCostCenter.label": "Centre de coûts",
  "DisplayPersonTexts.personCostCenter.help": "Afficher ou non le centre de coûts des personnes affectées aux postes de travail sur le plan",
  "DisplayPersonTexts.personCode.label": "Matricule",
  "DisplayPersonTexts.personCode.help": "Afficher ou non le matricule des personnes affectées aus postes de travail sur le plan",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.enable": "Gérer les textes d'affichage des postes de travail",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.disable": "Fermer la gestion des textes d'affichage",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.enable": "Permet de configurer les textes qui vont s'afficher sur le plan pour chaque poste de travail",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.disable": "Revenir dans le mode normal de l'édition du plan.",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.enable": "Activer la transparence des couleurs de fond des espaces",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.disable": "Désactiver la transparence des couleurs",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.enable": "Activer la transparence des couleurs permet de voir le fond de plan à travers les espaces",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.disable": "Désactiver la transparence des couleurs remet les couleurs des espaces",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.description": "La transparence des couleurs des espaces permet de voir le fond de plan",
  "WorkCanvas.Options.MapScaleOption.label.enable": "Gérer l'échelle",
  "WorkCanvas.Options.MapScaleOption.label.disable": "Fermer la gestion de l'échelle",
  "WorkCanvas.Options.MapScaleOption.help.enable": "Configurer obligatoirement l'échelle sur votre plan afin d'avoir les espaces et objets dans la bonne échelle",
  "WorkCanvas.Options.MapScaleOption.help.disable": "Revenir dans le mode normal de l'édition du plan.",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.label": "Supprimer l'échelle",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.help": "Supprimer l'échelle revient à retirer l'échelle du plan et le supprimer de la base, il ne sera plus accessible via d'autres plan, Il n'est pas possible de supprimer une échelle qui se trouve sur plusieurs étages.",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.label": "Dissocier l'échelle",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.help": "Dissocier l'échelle de ce plan le retire du plan, mais conserve l'échelle dans la base de données pour de futurs utilisations",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.label": "Zoomer sur l'échelle",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.help": "Zoomer permet de retrouver facilement l'échelle sur le plan.",
  "WorkCanvas.Options.DrawMapScaleOption.help": "Vous devez configurer l'echelle sur votre plan, cliquer sur le début et la fin de l'échelle sur le plan afin de le calibrer",
  "ToggleCopilotEnable.label.false": "Activer Surfy Copilot",
  "ToggleCopilotEnable.label.true": "Désactiver Surfy Copilot",
  "ToggleCopilotEnable.help.false": "Activer Surfy Copilot pour permettre la reconnaissance automatique des portes",
  "ToggleCopilotEnable.help.true": "Désactiver Surfy Copilot et revenir en modélisation manuelle",
  "WorkCanvas.Options.CopilotOption.label.enable": "Surfy Copilot",
  "WorkCanvas.Options.CopilotOption.label.disable": "Fermer les options de Surfy Copilot ",
  "WorkCanvas.Options.CopilotOption.help.enable": "Activer et régler les options de Surfy Copilot",
  "WorkCanvas.Options.CopilotOption.help.disable": "Revenir dans le mode normal du plan.",
  "WorkCanvas.Options.AddRoomShapeOption.label.enable": "Ajouter un espace",
  "WorkCanvas.Options.AddRoomShapeOption.label.disable": "Annuler l'ajout d'un espace",
  "WorkCanvas.Options.AddRoomShapeOption.help.enable": "Ajouter un espace sur le plan",
  "WorkCanvas.Options.AddRoomShapeOption.help.disable": "Annuler la création de l'espace",
  "WorkCanvas.Options.AddRoomShapeOption.description": "Les angles de création sont bloqués à 45°, pour les débloquer gardez appuyé sur la touche du clavier <b>SHIFT</b> et continuez la création, pour créer votre sommet positionnez la souris dans le cercle à l'intersection du triangle, Pour commencer un espace en réutilisant un sommet existant, gardez la touche du clavier <b>ALT</b> appuyé et cliquez sur le sommet.",
  "WorkCanvas.Options.AddRoomShapeSaveOption.label": "Sauvegarder l'espace en cours de modélisation",
  "WorkCanvas.Options.AddRoomShapeSaveOption.help": "Sauvegarder l'espace va automatiquement fermer l'espace et l'enregistrer vous permettant d'y rajouter des objets ou des postes de travail",
  "WorkCanvas.Options.ViewLegendOption.label.enable": "Prévisualiser la légende",
  "WorkCanvas.Options.ViewLegendOption.label.disable": "Fermer la légende de sauvegarde en image du plan",
  "WorkCanvas.Options.ViewLegendOption.help.enable": "Voir à quoi correspond la section de légende du plan",
  "WorkCanvas.Options.ViewLegendOption.help.disable": "Revenir dans le mode normal du plan.",
  "DownloadImageQualitySlider.label": "Qualité de l'image exportée",
  "DownloadImagePdfButton.label": "Télécharger le plan sans legende (PDF)",
  "DownloadImagePdfButton.help": "Télécharger le plan en PDF sans légende, cette fonctionnalité est en beta",
  "WorkCanvas.Options.DownloadImageOption.label.enable": "Sauvegarder en image",
  "WorkCanvas.Options.DownloadImageOption.label.disable": "Fermer les options de sauvegarde en image du plan",
  "WorkCanvas.Options.DownloadImageOption.help.enable": "Enregistrer le plan en image via cette option",
  "WorkCanvas.Options.DownloadImageOption.help.disable": "Revenir dans le mode normal du plan.",
  "DownloadImageDrawer.ViewImage.text": "Télécharger le plan avec legende (PNG)",
  "DownloadImageDrawer.ViewImage.help": "Télécharger tout le plan en bonne qualité avec la légende, l'export peut prendre plus de temps.",
  "DownloadImageDrawer.ViewImageNoLegend.text": "Télécharger le plan sans legende (PNG)",
  "DownloadImageDrawer.ViewImageNoLegend.help": "Télécharger tout le plan en bonne qualité sans la légende, l'export peut prendre plus de temps.",
  "DownloadImageDrawer.ScreenshotNoLegend.text": "Copie d'écran sans legende",
  "DownloadImageDrawer.ScreenshotNoLegend.help": "Télécharger l'image de ce que vous voyez sur l'écran sans legende, la sortie sera rapide mais la qualité de l'export ne sera pas optimale",
  "DownloadBuildingImagesAccordion.accordion.title": "Exporter les images de tout le bâtiment",
  "DownloadBuildingImagesAccordion.buttons.download.help": "Télécharger tous les plans de tous les étages du bâtiment au format png dans un zip, le temps d'attente de cette extraction peut être long",
  "DownloadBuildingImagesAccordion.buttons.download.label": "Télécharger le ZIP",
  "DisplayTexts.dragOption": "Vous pouvez trier et choisir l'affichage des propriétés sur le plan en déplacant les petites barres sur le champs vers le haut ou le bas",
  "DisplayRoomTextsPeople.roomPeopleFullName.label": "Nom complet des personnes",
  "DisplayRoomTextsPeople.roomPeopleFullName.help": "Afficher ou non le nom complet de la personne sur le plan",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.label": "Profil de sécurité",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.help": "Afficher ou non le profil de sécurité des personnes affectées aux espaces sur le plan",
  "NumberOfPeoplePerRowField.label": "Nombre de personnes par ligne pour les affectations aux espaces",
  "WorkCanvas.Options.BackgroundLayoutOption.label.enable": "Gérer le fond de plan",
  "WorkCanvas.Options.BackgroundLayoutOption.label.disable": "Fermer la gestion de l'image de fond",
  "WorkCanvas.Options.BackgroundLayoutOption.help.enable": "Permet de gérer le fond de plan",
  "WorkCanvas.Options.BackgroundLayoutOption.help.disable": "Revenir dans le mode normal de l'édition du plan.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.label": "Supprimer l'échelle",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.help": "Supprimer l'échelle revient à retirer l'échelle du plan et le supprimer de la base, il ne sera plus accessible via d'autres plan, Il n'est pas possible de supprimer une échelle qui se trouve sur plusieurs étages.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.label": "Dissocier l'échelle",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.help": "Dissocier l'échelle de ce plan le retire du plan, mais conserve l'échelle dans la base de donnée pour de futurs utilisations",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.label": "Zoomer sur l'échelle",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.help": "Zoomer permet de retrouver facilement l'échelle sur le plan.",
  "WorkplaceCanvasItem.workplace.free": "Le poste de travail n'est pas occupé",
  "WorkplaceCanvasItem.workplace.isFlex": "Le poste de travail est en flex",
  "WorkplaceCanvasItem.workplace.isTransit": "Le poste de travail est de passage",
  "WorkplaceCanvasItem.workplace.isBookable": "Le poste de travail est réservable",
  "WrongRoomsTable.table.headers.objectType": "Nature",
  "WrongRoomsTable.table.headers.type": "Type",
  "WrongRoomsTable.table.headers.identity": "Identité",
  "WrongRoomsTable.table.headers.currentRoom": "Espace actuel",
  "WrongRoomsTable.table.headers.newRoom": "Nouvel espace",
  "WrongRoomsTable.SelectAll.checked.true": "Tout déselectionner",
  "WrongRoomsTable.SelectAll.checked.false": "Tout sélectionner",
  "WrongRoomsTable.SelectAll.help": "Sélectionner ou déselectionner toutes les lignes",
  "WrongRoomsListner.dialog.title": "Valider le choix des espaces",
  "WrongRoomsListner.dialog.description": "Il y a des formes qui ne sont pas dans leur espace de départ",
  "WrongRoomsListner.close.label": "Fermer",
  "WrongRoomsListner.close.help": "Fermer cette fenêtre",
  "MoveShapestoNewRoomAsyncButton.label": "Appliquer le changement d'espace",
  "MoveShapestoNewRoomAsyncButton.help": "Changer les espaces des formes sélectionnées pour les mettre dans les espaces dans lesquelles elles sont sur le plan",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.enable": "Déplacer le type d'objet",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.disable": "Arrêter le déplacement du type d'objet",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.enable": "Déplacer un type d'objet sur le plan",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.disable": "Arrêter le déplacement du type d'objet",
  "ResetRotationAngle.resetRotationAngle": "Réinitilaliser à 0 ° l'angle de la rotation qui est actuellement de %{initialRotation}",
  "TenantOperations.sephora-sync-sap-success-factors.label": "Synchronisation MSC",
  "TenantOperations.st-grenoble-import-hr-file.label": "Import du fichier RH",
  "TenantOperations.egis-import-hr-file.label": "Import Fichier RH",
  "TenantOperations.essilor-import-hr-file.label": "Import Fichier RH",
  "TenantOperations.agpm-import-hr-file.label": "Import du fichier RH (STILOG)",
  "ConnectedPartnerContext.title": "Vous êtes connecté à <b>%{label}</b> (%{host})",
  "Operations.talentsoft-import.label": "Import Talentsoft",
  "Operations.zbre-sync.label": "Syncronisation Z#bre",
  "Operations.exportZbre.label": "Export Z#bre",
  "GenericNoChangeTable.open.label": "Voir les données",
  "GenericNoChangeTable.open.help": "Voir le détail des données identiques",
  "Operations.sharingcloud-sync.label": "Syncronisation Sharingcloud",
  "Operations.moffi-sync.label": "Syncronisation Moffi",
  "Operations.lucca-sync.label": "Syncronisation Lucca",
  "CompareObjectTypeUpdateIcon.help": "Cette synchronisation va effectuer une mise à jour des entitiés",
  "CompareObjectTypeDeleteIcon.help": "Cette synchronisation va effectuer une suppression des entitiés qui ne proviennent pas de la source",
  "CompareObjectTypeCreateIcon.help": "Cette synchronisation va effectuer une création des entitiés qui n'existent pas dans la cible",
  "RoomTooltip.roomWorkplaceAffectations": "Affectations des postes de travail",
  "RoomSegmentRoomsList.title": "Les espaces attachés à ce segment",
  "MeetingRoomCard.seats.1": "%{count} place assise",
  "MeetingRoomCard.seats.n": "%{count} places assises",
  "MeetingRoomCard.locateSpace": "Localiser l'espace sur le plan",
  "MeetingRoomCard.viewPicture": "Voir la photo de l'espace",
  "days.monday": "lundi",
  "days.tuesday": "mardi",
  "days.wednesday": "mercredi",
  "days.thursday": "jeudi",
  "days.friday": "vendredi",
  "days.saturday": "samedi",
  "days.sunday": "dimanche",
  "WorkplaceAffectationDailyTitle.all": "Cette personne est affectée tous les jours",
  "WorkplaceAffectationDailyTitle.person.affected": "Cette personne est affectée %{daysText}",
  "WorkplaceAffectationDailyTitle.person.notAffected": "Cette personne n'est pas affectée ",
  "WorkplaceAffectationDailyTitle.calculatedRate": "Le taux d'affectation moyen est de %{calculatedRate}",
  "WorkplaceNestedList.title": "Personnes affectées aux postes de travail",
  "WorkplaceList.workplace.free": "Ce poste de travail est libre",
  "WorkplaceList.workplace.flex": "Ce poste de travail est en flex",
  "WorkplaceList.workplace.transit": "Ce poste de travail est partagé",
  "WorkplaceList.zoomOnWorkplace": "Zoomer sur le poste de travail sur le plan",
  "WorkplaceAffectionPersonListItem.remove.help": "Retirer l'affectation de la personne au poste de travail",
  "WorkplaceAffectations.edit.help": "Affecter une personne à ce poste de travail",
  "WorkplaceAffectationDays.all": "Cette personne est affectée tous les jours",
  "WorkplaceAffectationDays.and": "les %{days} et %{lastDay}",
  "WorkplaceAffectationDays.one": "le %{day}",
  "WorkplaceAffectationDays.person.affected": "Cette personne est affectée %{daysText}",
  "WorkplaceAffectationDays.person.notAffected": "Cette personne n'est pas affectée ",
  "RoomWorkplaceList.EmptyList": "Il n'y a aucun poste de travail dans cet espace",
  "RoomCard.buttons.edit.false": "Modifier les propriétés de l'espace",
  "RoomCard.buttons.edit.true": "Arrêter la modification",
  "RoomCard.tabs.people": "Affectations",
  "RoomCard.tabs.inventory": "Inventaire",
  "RoomCard.tabs.room": "Espace",
  "RoomAffectationsOnlyList.title": "Personnes affectées aux espaces",
  "RoomAffectationsList.title": "Personnes affectées aux espaces",
  "RoomAffectationsList.EmptyList": "Il n'y a personne d'affectée à cet espace",
  "ItemsInventory.EmptyList": "Il n'y a aucun objet dans cet espace",
  "MovePersonFromWorkplaceToRoomListButtonItem.label": "Déplacer cette personne de son poste de travail à l'espace du poste de travail",
  "MovePersonFromWorkplaceToRoomListButtonItem.help": "Cette option nécessite de rafraichir la page pour voir le resultat, il est possible d'enchainer plusieurs mouvements sans rafraichir",
  "CollapseWorkplaceAffectationList.title": "Affecter cette personne pour les jours suivants uniquement",
  "CollapseWorkplaceAffectationList.updateAffectationDay.true": "Affecter cette personne %{day}",
  "CollapseWorkplaceAffectationList.updateAffectationDay.false": "Retier l'affectation de cette personne %{day}",
  "CancelAddWorkplaceToRoom.help": "Annuler l'ajout du poste de travail",
  "CancelAddItemToRoom.help": "Annuler l'ajout de l'objet",
  "AddPersonToRoom.help": "Affecter une personne à l'espace %{name}",
  "SecurityComplianceModeSwitch.label": "Filtrer les personnes avec des profils de sécurité",
  "SecurityComplianceModeSwitch.description": "Voir uniquement sur le plan les personnes avec des profils de sécurité",
  "layoutViewSets.roomType.label": "Typologies des espaces",
  "layoutViewSets.roomType.description": "Voir le plan de l'étage selon la typologie des espaces",
  "layoutViewSets.costCenter.label": "Refacturation",
  "layoutViewSets.costCenter.description": "Analyser les clés de répartition financière des espaces",
  "layoutViewSets.workplaces.label": "Occupations",
  "layoutViewSets.workplaces.description": "Concentrez-vous sur l'occupation des postes de travail",
  "layoutViewSets.organizationLevel0.label": "Directions",
  "layoutViewSets.organizationLevel0.description": "L'occupation par direction",
  "layoutViewSets.flex.label": "Flex",
  "layoutViewSets.flex.description": "L'occupation flex des espaces",
  "layoutViewSets.walls.label": "Cloisons",
  "layoutViewSets.walls.description": "Concentrez-vous sur les espaces et cloisons",
  "layoutViewSets.securityCompliance.label": "Conformité de la sécurité",
  "layoutViewSets.securityCompliance.description": "Analyser la conformité de votre plan de prévention de la sécurité et des profils de securité des personnes affectés",
  "layoutViewSets.peopleDimensionTypes.label": "Quartiers",
  "layoutViewSets.peopleDimensionTypes.description": "Analyser les calques d'affectations et naviguer par quartier ou zone",
  "LayoutViewSwitch.title": "Changer la vision du plan",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.viewSet": "Vision",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.help": "Vous pouvez changer la vision via les menus du plan",
  "SurfyLegendBottomLogo.text": "Plan généré par Surfy",
  "SurfyLegendBottomLogo.caption": "https://www.surfy.pro",
  "MapLegendWorkplace.title": "Poste de travail",
  "MapLegendWorkplace.workplaces.free": "Les postes de travail sont libres",
  "MapLegendWorkplace.workplaces.flex": "Les postes de travail sont en flex",
  "MapLegendRoom.title": "Espaces",
  "MapLegendPersonSecurityProfile.title": "Profils de sécurité",
  "MapLegendFloor.title.building": "Bâtiment",
  "MapLegendFloor.title.floor": "Étage",
  "MapLegend.workplaces": "Postes de travail",
  "MapLegend.rooms": "Espaces",
  "PersonSecurityProfileTabContent.tabs.merged": "Par profils de sécurité",
  "PersonSecurityProfileTabContent.tabs.split": "Par affectations",
  "DimensionInfo.infos.building": "Informations calculées sur le bâtiment",
  "DimensionInfo.infos.impactBuildings": "Recharger les données calculées des bâtiments",
  "DimensionToPeopleList.title": "Personnes affectées à %{name}",
  "DimensionToPeopleList.noDimensionPerson": "Il n'y a personne affecté directement à ce calque d'analyse",
  "DimensionPeople.title": "Personnes affectées aux espaces",
  "AddPersonToDimension.help": "Affecter une personne à %{name}",
  "CubyWallModeSelect.label": "Affichage des cloisons",
  "CubyWallModeSelect.options.no": "Aucun",
  "CubyWallModeSelect.options.half": "Demi-cloisons",
  "CubyWallModeSelect.options.reality": "Réalité",
  "CubyWallModeSelect.options.cuby": "Cuby",
  "CubySaveAsImageButton.label": "Enregistrer l'image",
  "CubySaveAsImageButton.help": "Enregistrer l'image du plan de l'étage",
  "CubyFitToViewIsometricButtonOption.label": "Centrer le plan en vue isometric",
  "CubyFitToViewIsometricButtonOption.help": "Centrer le plan sur les espaces en vue isometric",
  "CubyFitToViewZenithalButtonOption.label": "Centrer le plan en vue zénithale",
  "CubyFitToViewZenithalButtonOption.help": "Centrer le plan sur les espaces en vue zénithale",
  "RefetchFloorLayoutButton.refetch": "Recharger les données du plan",
  "ItemTypesMapFilterZone.tabs.options": "Options",
  "FloorMap.tabs.layout": "Changer la vision du plan. La vision actuelle est <b>%{layoutName}</b>",
  "FloorMap.tabs.floor": "Voir les informations de l'étage",
  "FloorMap.tabs.building": "Voir les informations du bâtiment",
  "FloorMap.tabs.roomTypes": "Colorier les espaces sur le plan en fonction des <b>typologies d'espaces</b>",
  "FloorMap.tabs.roomTypeGroups": "Voir les indicateurs des espaces sur le plan en fonction des <b>groupes de typologies d'espaces</b>",
  "FloorMap.tabs.analyticsDimensionTypes": "Colorier les espaces sur le plan en fonction des <b>calques d'analyse</b>",
  "FloorMap.tabs.itemTypes": "Afficher sur le plan les <b>objets</b> par famille et type d'objets",
  "FloorMap.tabs.workplaceTypes": "Afficher sur le plan les <b>postes de travail</b> par types de postes de travail",
  "FloorMap.tabs.organizations": "Colorier les espaces sur le plan selon les <b>organisations</b>",
  "FloorMap.tabs.costCenters": "Colorier les espaces et postes de travail par rapport aux <b>centres de coûts</b>",
  "FloorMap.tabs.users": "Colorier les postes de travail par rapport aux personnes",
  "FloorMap.tabs.selection": "Voir le détails des éléments sélectionnés sur le plan",
  "FloorMap.tabs.rooms": "Détails des <b>espaces</b> sélectionnés",
  "FloorMap.tabs.items": "Détails des <b>objets</b> sélectionnés",
  "FloorMap.tabs.workplaces": "Détails des <b>postes de travail</b> sélectionné",
  "FloorMap.tabs.all": "Voir toutes les formes sélectionnées en liste",
  "FloorMap.tabs.peopleDimensionTypes": "Colorier les espaces sur le plan en fonction des <b>calques d'affectation</b>",
  "FloorMap.tabs.workplaceUsage": "Colorier les postes de travail par rapport à leur <b>état</b>",
  "FloorMap.tabs.options": "Voir les options du plan",
  "FloorMap.tabs.heatmap": "Colorier avec des cartes de chaleur",
  "FloorMap.tabs.pathFinding": "Trouver son chemin dans les espaces",
  "DateDimensionSelect.options.day": "Jour",
  "DateDimensionSelect.options.week": "Semaine",
  "DateDimensionSelect.options.month": "Mois",
  "DateDimensionSelect.options.year": "Année",
  "DateDimensionSelect.options.quarter": "Trimestre",
  "JupDateRangePicker.chooseRange": "Choisissez une période",
  "WorkpaceBookingPeopleCountByDate.title": "Nombre de personnes ayant réservé par date",
  "WorkpaceBookingPeopleCountByDate.labels.line": "Nombre de personnes",
  "WorkpaceBookingCountByDate.title": "Réservations des postes de travail par date",
  "WorkpaceBookingCountByDate.labels.line": "Nombre de réservations",
  "WorkpaceBookingAverageByWeekDay.title": "Réservation des postes de travail par jour de la semaine",
  "WorkpaceBookingAverageByWeekDay.labels.line": "Moyenne par semaine",
  "WorkpaceBookingAverageByWeekDay.labels.bar": "Nombre de réservations",
  "PersonPanelWorkplaceAffectations.title": "Affectations aux postes de travail",
  "PersonPanelRoomAffectations.title": "Affectations aux espaces",
  "PersonPanelDimensionToPeople.title": "Affectations aux %{dimensionTypeName}",
  "PersonPanelBuildingAffectations.title": "Affectations aux bâtiments",
  "PersonPanelBuildingAffectations.addToPeopleCount.false": "Cette personne n'est pas comptabilité dans le bâtiment",
  "PersonAffectationsPanel.title": "Affectations",
  "PersonAffectationsPanel.description": "Les affectations de la personne",
  "PersonSecurityPanel.title": "Sécurité",
  "PersonSecurityPanel.description": "Informations relatives à la sécurité et aux évacuations",
  "PersonRelationsPanel.title": "Relations",
  "PersonRelationsPanel.description": "Les relations de cette personne",
  "PersonInventoryPanel.title": "Inventaire",
  "PersonInventoryPanel.description": "Informations relatives à l'inventaire",
  "PersonInventoryPanel.items.subheader": "Liste des objets associés",
  "PersonInfoPanel.title": "Informations personnelles",
  "PersonContractPanel.title": "Contrat",
  "PersonContractPanel.description": "Informations relatives au contrat",
  "PersonContactPanel.title": "Contact",
  "PersonContactPanel.description": "Comment contacter cette personne ?",
  "PersonBadgePanel.title": "Divers",
  "PersonBadgePanel.description": "Informations diverses sur la personne",
  "AvatarPersonDrawer.help": "Voir plus d'informations sur %{name}",
  "TopLevelOrganizationFilter.Empty": "Il n'y a aucune organization de associés aux espaces, vous pouvez en ajouter en modifiant un espace et en l'associant à une organiation, puis vous pourrez contrôler leur affichage depuis cette séction",
  "OrganizationTabsFilter.tabs.topLevel": "Directions",
  "OrganizationTabsFilter.tabs.hierarchy": "Hiérarchie",
  "OrganizationTabsFilter.tabs.level1": "Services",
  "OrganizationFloorMapFilter.TooltipTitle.notSelected": "Sélectionner %{organization} pour colorier les espaces sur le plan",
  "OrganizationFloorMapFilter.TooltipTitle.selected": "Désélectionner %{organization} va retirer les couleurs du plan",
  "OrganizationFloorMapFilter.tooltip.true": "Sélectionner tous les types d'objets ci-dessous afin de les colorier sur la carte",
  "OrganizationFloorMapFilter.tooltip.false": "Désélectionner tous organizations ci-dessous",
  "Level1OrganizationFilter.Empty": "Il n'y a aucune organization associée aux espaces, vous pouvez en ajouter en modifiant un espace et en l'associant à une organiation, puis vous pourrez contrôler leur affichage depuis cette séction",
  "HierarchyOrganizationFilter.Empty": "Il n'y a aucune organization associés aux espaces, vous pouvez en ajouter en modifiant un espace et en l'associant à une organiation, puis vous pourrez contrôler leur affichage depuis cette séction",
  "CompanyDashboard.dashboards.workplace": "Tableau de bord des postes de travail",
  "CompanyDashboard.dashboards.area": "Tableau de bord des surfaces",
  "ChangeCompanyMenu.ChangeCompany": "Voir une autre entreprise dans une nouvelle page",
  "WorkplaceTypeDataQualityNotUsed.columns.name": "Nom du type de poste de travail",
  "WorkplaceTypeDataQualityNotUsed.columns.shape": "Forme",
  "workplaceTypeLayoutFilter.Empty": "Il n'y a aucun poste de travail pour le moment dans les espaces, vous pouvez en ajouter en modifiant un espace et en y ajoutant des postes de travail, puis vous pourrez contrôler leur affichage depuis cette séction",
  "WorkplaceTypeInfo.help": "Le nombre de postes de travail est %{count}",
  "CopyWorkplaceTypeToCart.help": "Copier les types de poste de travail dans le panier",
  "WorkCanvas.Options.ZoomOnWorkplaceType.label": "Zoomer sur le type de poste de travail",
  "WorkCanvas.Options.ZoomOnWorkplaceType.help": "Zoomer sur le type de poste de travail permet de le localiser sur la zone de travail",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.enable": "Lister les types d'objets",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.disable": "Fermer la liste des types d'objets",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.enable": "Voir la liste des type d'objets pour ce type de poste de travail",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.disable": "Fermer la liste des types d'objets pour ce type de poste de travail",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.open": "Déplier les options",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.close": "Replier les options",
  "WorkplaceTypeItemTypesDrawer.title": "Liste des types d'objets",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.help": "Ajouter une type d'objet pour pouvoir composer le type de poste de travail",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.label": "Ajouter un type d'objet",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.help": "Annuler l'ajout d'un type d'objet dans ce poste de travail",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.label": "Annuler l'ajout d'un type d'objet",
  "WorkCanvas.Options.DeleteStructureShapeOption.help": "Supprimer totalement la forme de la structure de pouvoir par exemple la redessiner entierement",
  "WorkCanvas.Options.DeleteStructureShapeOption.label": "Supprimer la forme",
  "WorkCanvas.Options.AddStructurePointOption.label.enable": "Ajouter un sommet",
  "WorkCanvas.Options.AddStructurePointOption.label.disable": "Arrêter l'ajout d'un sommet",
  "WorkCanvas.Options.AddStructurePointOption.help.enable": "Ajouter un sommet permet de retravailler avec plus de precisions une forme",
  "WorkCanvas.Options.AddStructurePointOption.help.disable": "Arrêter la création de sommets",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloorButton.label": "Réserver un poste de travail au %{floorName}",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloor": "Réserver un poste de travail au %{floorName} pour la période %{slotString}",
  "BookPersonBuildingWorkplace.availableWorkplaces": "%{freeWorkplaces} places disponibles",
  "BookPersonBuildingWorkplace.help": "%{bookedWorkplaces} réservation(s), %{freeWorkplaces} postes de travail disponibles sur %{totalFloorWorkplacesCount}",
  "booking.snackbar.delete.workplace": "La réservation au poste de travail %{workplaceName} a été annulée pour la période %{slot}",
  "booking.snackbar.delete.room": "La réservation à l'espace %{roomName} a été annulée pour la période %{slot}",
  "BookingWorkplaceTitle.booked": "Ce poste de travail est déjà réservé",
  "BookingWorkplaceTitle.userBooked": "Vous avez réservé ce poste de travail",
  "BookingWorkplaceTitle.free": "Réserver ce poste de travail",
  "PlanningPersonAffectations.alerts.noAffectation.title": "Impossible de réserver un poste de travail",
  "PlanningPersonAffectations.alerts.noAffectation.message": "Vous n'êtes associé à aucun territoire, merci de vous rapprocher de votre responsable d'affectation afin de pouvoir réserver un espace de travail",
  "WorkingLocationToggle.locations.OFFICE": "Bureau",
  "WorkingLocationToggle.locations.REMOTE": "Télétravail",
  "PersonBookingListItem.workplaceBookedOnFloor": "Voir le poste de travail %{workplaceName} sur le plan au %{floorName}",
  "PersonBookingList.noBooking": "Aucun collègue ne sera présent au bureau sur le même créneau pour le moment",
  "PersonBookingList.bookings.one": "Un collègue sera présent sur le même créneau",
  "PersonBookingList.bookings.more": "%{count} collègues seront présents sur le même créneau",
  "ParkingBookIcon.parking.booked": "Votre parking est réservé",
  "ParkingBookIcon.parking.release.help": "Libérer la réservation du parking",
  "ParkingBookIcon.parking.viewOnMap": "Voir sur le plan le parking réservé",
  "ParkingBookIcon.parking.book.label": "Réserver un parking",
  "ParkingBookIcon.parking.book.help": "Réserver un parking qui sera attribué automatiquement sur le créneau",
  "HalfDayWorkingLocationToggle.am.label": "Matin",
  "HalfDayWorkingLocationToggle.am.help": "Les horaires de la matinée sont de 8h00 à 13h30",
  "HalfDayWorkingLocationToggle.pm.label": "Après-midi",
  "HalfDayWorkingLocationToggle.pm.help": "Les horaires de l'après-midi sont de 14h00 à 19h00",
  "DirectBuildingPlanningLabel.youAreAssigned": "Vous êtes affecté sur le bâtiment %{buildingName}",
  "DimensionBuildingPlanningLabel.youAreAssigned": "Vous êtes affecté sur %{dimensionTypeName} %{dimensionName}",
  "BookedBuildingWorkplaceList.noWorkplaceBooked": "Aucun poste de travail réservé",
  "BookedBuildingWorkplaceList.workplaceIsBooked": "Votre poste de travail est reservé",
  "BookedBuildingWorkplaceList.viewBookedWorkplaceOnMap": "Voir le poste de travail %{workplaceName} qui est reservé sur le plan",
  "BookedBuildingWorkplaceList.freeWorkplaceBooking": "Libérer cette réservation",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.noFloor": "La dimension n'est sur aucun étage impossible de réserver pour le moment depuis le plan",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.moreThanOneFloor": "La dimension est sur plusieurs étages impossible de réserver pour le moment depuis le plan",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.drawer.title": "Réserver un poste de travail spécifique pour la période %{slotString}",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.help": "Réserver sur le plan un poste de travail spécifique pour ce créneau",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.label": "Réserver un poste de travail dans %{dimensionName}",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.peopleCount": "Il y a %{count} personne(s) avec le profil de sécurité %{name} affecté aux postes de travail",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.workplaceCount": "Il y a %{count} poste(s) de travail avec au moins une personne avec profil de sécurité %{name}",
  "PersonSecurityProfileWorkplaceFilter.Empty": "Vos personnes n'ont pas de profil de sécurité ou ne sont pas affectées à des postes de travail, il n'est pas possible de colorier les postes de travail en fonction des profils de sécurité des personnes",
  "PersonSecurityProfileWorkplaceFilter.title": "Les profils de sécurité des personnes affectées aux postes de travail",
  "PersonSecurityProfileMerged.title": "Liste des profils de sécurité regroupé par type de profils",
  "PersonSecurityProfileMerged.empty": "Aucun profil n'est associé aux espaces ou postes de travail",
  "PersonSecurityProfileInRooms.title": "Les profils de sécurité des personnes affectées aux espaces",
  "PersonSecurityProfileInRoomListItem.peopleCount": "Il y a %{count} personne(s) avec le profil de sécurité %{name} affectée(s) aux espaces",
  "PersonSecurityProfileInRoomListItem.roomsCount": "Il y a %{count} espace(s) avec au moins une personne avec profil de sécurité %{name}",
  "ToggleAllOpenInfoState.true": "Fermer tous les détails et indicateurs",
  "ToggleAllOpenInfoState.false": "Ouvrir tous les détails et indicateurs",
  "MapFiltersNodesToggleAll.help.true": "Tout sélectionner",
  "MapFiltersNodesToggleAll.help.false": "Tout désélectionner",
  "MapFiltersNode.info.open": "Voir le détail et les indicateurs pour %{label}",
  "MapFiltersNode.info.close": "Fermer les informations supplémentaires",
  "MapFiltersCategory.CategoryHasChildrenSelected": "Des éléments sont sélectionnés",
  "MapFilterNodeToggleAll.action.true": "Tout sélectionner",
  "MapFilterNodeToggleAll.action.false": "Tout désélectionner",
  "MapFilterNodeIsAllSelected.help": "Toute la sélection ci dessous sera chargé, même si des nouveaux objets sont crées",
  "JupRoleToObjectTypeMatrix.views.help.true": "Cacher la vue d'interface",
  "JupRoleToObjectTypeMatrix.views.help.false": "Afficher la vue d'interface",
  "JupRoleToObjectTypeMatrix.objectTypes.help.checkbox": "Mettre à jour la propriété (%{name})",
  "GlobalOptions.CartCopyItemTypeOption.help": "Copier les types d'objets dans le panier",
  "GlobalOptions.CartCopyWorkplaceTypeOption.help": "Copier les types de poste de travail dans le panier",
  "GlobalOptions.CartCopyBuildingOption.help": "Copier les bâtiments dans le panier",
  "CheckAllDefaultViews.shortcuts.title": "Raccourcis de configuration",
  "CheckAllDefaultViews.shortcuts.views.title": "Raccourcis pour les vues d'interface par defaut",
  "CheckAllDefaultViews.shortcuts.views.buttonsHelp": "Cocher cette vue pour tous les types d'entités",
  "CheckAllDefaultViews.shortcuts.objectTypes.title": "Raccourcis pour les types d'entités",
  "CheckAllDefaultViews.shortcuts.objectTypes.buttonsHelp": "Cocher cette règle pour tous les types d'objets",
  "RemoveItemColorsOption.label": "Ne pas colorier les objets",
  "RemoveItemColorsOption.help": "Colorier les objets en blanc afin de pouvoir se concentrer sur d'autres éléments sur la carte",
  "ItemTypeOptions.help": "Le nombre d'objets est %{count}",
  "ItemTypeMapFilter.TooltipTitle.notSelected": "Sélectionner %{itemType} pour voir les objets sur le plan",
  "ItemTypeMapFilter.TooltipTitle.selected": "Désélectionner %{itemType} va retirer la couleur associée du plan",
  "ItemTypeMapFilter.tooltip.true": "Sélectionner tous les types d'objets ci-dessous afin de les afficher sur la carte",
  "ItemTypeMapFilter.tooltip.false": "Désélectionner tous les types d'objets ci-dessous",
  "ItemTypeMapFilter.NoNode": "Il n'y a aucun objet pour le moment dans les espaces, vous pouvez en ajouter en modifiant un espace et en y ajoutant des objets, puis vous pourrez contrôler leur affichage depuis cette séction",
  "ItemTypeMapFilter.NoCategory": "Il n'y a aucun objet pour le moment dans les espaces, vous pouvez en ajouter en modifiant un espace et en y ajoutant des objets, puis vous pourrez contrôler leur affichage depuis cette séction",
  "ItemTypeDataQualityNotUsed.columns.name": "Nom du type d'objet",
  "ItemTypeDataQualityNotUsed.columns.shape": "Forme",
  "ItemTypeDataQualityNotUsed.columns.workplaceTypeCount": "Nombre de type de poste de travail",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.help": "Choisir un plan de référence pour créer la forme afin de pouvoir dessiner votre type d'objet en se repérant sur un plan et avoir la bonne échelle",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.label": "Choisir un plan de référence pour créer la forme",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.help": "Choisir un plan de référence pour composer le type de poste de travail avec des types d'objets existants en se repérant sur un plan et avoir la bonne échelle et correctement positionner les types d'objets",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.label": "Choisir un plan de référence pour composer la forme du type de poste de travail",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.help": "Choisir un plan de référence pour créer la forme afin de pouvoir dessiner la structure en se repérant sur un plan et avoir la bonne échelle",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.label": "Choisir un plan de référence pour créer la structure",
  "ItemTypeAvatarSingleView.copy": "Copier les points dans le presse-papier",
  "ItemTypeAvatarSingleView.debug.label": "Activer le mode avancé pour la 3d",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.help": "Supprimer totalement la forme du type d'objet afin de pouvoir par exemple la redessiner entierement ou la transformer en icone",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.label": "Supprimer la forme",
  "CopyItemTypesToCart.help": "Copier les types d'objets dans le panier",
  "PhysicalItemNotInsideWorkplaceRoom.alignRooms": "Changer les espaces des objets par celui du poste de travail",
  "AddPersonToItem.text": "Associer une personne à cet objet",
  "AddPersonToItem.help": "Associer une personne à cet objet, vous pouvez ajouter plusieurs personnes pour le même objet",
  "DimensionTypeDescription.NoDescription": "Il n'y a pas de description pour ce type de calque d'analyse, vous pouvez en rajouter en le modifiant",
  "dimensionTypes.room_ground_type.one": "Nature des sols",
  "dimensionTypes.room_ground_type.description": "Permet de connaitre quel est la composition du sol de l'espace",
  "dimensionTypes.room_usage.one": "Nature des espaces",
  "dimensionTypes.room_usage.description": "Permet d'identifier les espaces selon leur usages",
  "dimensionTypes.frequency.one": "Fréquence",
  "dimensionTypes.frequency.description": "Permet de connaitre la fréquence de passage dans l'espace",
  "dimensionTypes.evacuation_zone.one": "Sécurité",
  "dimensionTypes.evacuation_zone.description": "Permet de gérer les zones de sécurité et d'évacuations",
  "dimensionTypes.referent.one": "Référent",
  "dimensionTypes.referent.description": "Permet de connaitre qui est affecté à la maintenance de cet espace",
  "DimensionTypesByTab.action.true": "Tout sélectionner",
  "DimensionTypesByTab.action.false": "Tout désélectionner",
  "DimensionTypesByTab.ListItemHasChildrenSelected": "Des dimensions sont sélectionnés",
  "DimensionListItem.notSelected": "Sélectionner %{dimension} pour voir les espaces sur le plan avec la couleur associée",
  "DimensionListItem.selected": "Désélectionner %{dimension}",
  "DimensionInfo.roomsArea.help": "La surface pour %{dimensionType} %{dimension} est de %{value} m²",
  "DimensionInfo.roomsCount.help": "Il y a %{value} espace(s) pour %{dimensionType} %{dimension}",
  "DimensionInfo.peopleCount.help": "Il y a %{value} personne(s) affectées pour %{dimensionType} %{dimension}",
  "DimensionInfo.totalPeopleCount.help": "Il y a %{value} personne(s) affectées au totale pour %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesCount.help": "Il y a %{value} poste(s) de travail pour %{dimensionType} %{dimension}",
  "DimensionInfo.peopleRatio.help": "Il y a %{value} m² par personnes affectées pour %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesRatio.help": "Il y a %{value} m² par postes de travail pour %{dimensionType} %{dimension}",
  "DimensionInfo.occupancyRate.help": "Le taux d'occupation est de %{value}% pour %{dimensionType} %{dimension}",
  "DimensionInfo.expansionRatio.help": "Le taux de foisonnement est de %{value} pour %{dimensionType} %{dimension}",
  "DimensionInfo.freeWorkplacesCount.help": "Il y a %{value} poste(s) de travail libres pour %{dimensionType} %{dimension}",
  "DimensionInfo.flexWorkplacesCount.help": "Il y a %{value} poste(s) de travail en flex pour %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesCount.help": "Il y a %{value} poste(s) de travail partagés pour %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesRatio.help": "Le taux de postes de travail partagés est de %{value} pour %{dimensionType} %{dimension}",
  "DimensionInfo.flexRatio.help": "Le taux de postes de travail en flex",
  "DimensionInfo.transitWorkplacesCount.help": "Il y a %{value} poste(s) de travail de passage pour %{dimensionType} %{dimension}",
  "DimensionInfo.dimensionPeopleCount.help": "Il y a %{value} personne(s) affectées dans %{dimensionType} %{dimension}",
  "DimensionInfo.seatsCount.help": "Il y a %{value} places assises pour %{dimensionType} %{dimension}",
  "DimensionInfo.seatsPeopleRatio.help": "Le taux de places assises est de %{value} places disponibles par personnes pour %{dimensionType} %{dimension}",
  "DimensionInfo.carbonFootprint.help": "L'empreinte carbone est de %{value} de CO2 emis pour %{dimensionType} %{dimension}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.peopleCount": "Il y a %{count} personnes avec le centre de coût %{costCenterName}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.workplaceCount": "Il y a %{count} postes de travail avec au moins une personne avec le centre de coût %{costCenterName}",
  "PersonCostCenterWorkplaceFilter.Empty": "Il n'y a aucun centre de coûts associé aux personnes",
  "NoDataOnBuildingInfo.noData": "Merci de sélectionner tous les étages dans les options du plan pour avoir des données, il ne doit pas y avoir de données pour les étages que vous avez sélectionné",
  "CostCenterWorkplaceMapFilter.nodeInfo.workplacesCount": "Il y a %{count} postes de travail avec le centre de coût %{name}",
  "CostCenterMapFilterTabs.tabs.rooms": "Espaces",
  "CostCenterMapFilterTabs.tabs.workplaces": "Postes de travail",
  "CostCenterMapFilterTabs.tabs.people": "Personnes",
  "CostCenterMapFilter.Empty": "Il n'y a aucun centre de coût pour le moment associé aux espaces, vous pouvez en ajouter en modifiant un espace et en y associant un centre de coût, puis vous pourrez contrôler leur affichage depuis cette séction",
  "CostCenterWorkplaceMapFilter.Empty": "Il n'y a aucun centre de coût pour le moment associé aux postes de travail, vous pouvez en ajouter en modifiant un poste de travail et en y associant un centre de coût, puis vous pourrez contrôler leur affichage depuis cette séction",
  "BuildingReports.items.sheets.physicals": "Objets Physiques",
  "BuildingReports.items.sheets.virtuals": "Objets Virtuels",
  "BuildingReports.items.sheets.merged": "Fusion",
  "BuildingInventory.floor": "Étage",
  "BuildingInventory.quantity": "Quantité",
  "BuildingInventory.price": "Prix",
  "BuildingInventory.manufacturer": "Fabricant",
  "BuildingInventory.quantityTotal": "Total",
  "BuildingInventory.title": "L'inventaire du bâtiment %{building.name}",
  "BuildingInventory.buttons.viewPDF.help": "Télécharger le fichier en PDF afin de pouvoir le télécharger ou le partager",
  "BuildingInventory.buttons.viewPDF.label": "Télécharger la version PDF",
  "BuildingInventory.itemTypesFamilySectionTitle": "Categories de l'inventaire",
  "BuildingInventory.fileNamePrefix": "inventaire",
  "BuildingLabel.scenario": "Ce bâtiment est un scenario du bâtiment %{name}",
  "CopyBuildingToCart.help": "Copier la structure du bâtiment",
  "BuildingClonePropertiesSelector.properties.clone.workplaces": "Copier les postes de travail",
  "BuildingClonePropertiesSelector.properties.clone.items": "Copier les objets",
  "BuildingDistributionCost.floors.excel.tabs.floors": "Clés de répartition par étage",
  "BuildingDistributionCost.floors.excel.tabs.building": "Clés de répartition pour le bâtiment",
  "BuildingDistributionCost.floors.excel.tabs.buildingDetailed": "Détails du bâtiment par centre de coût",
  "BuildingDistributionCost.floors.excel.download.label": "Télécharger le fichier excel avec les ventilations",
  "BuildingDistributionCost.floors.excel.download.help": "Télécharger le fichier excel pour pourvoir partager et exporter les clés de répartition et surfaces qualifiées par centre de coût et par étage, l'export inclut la distribution par étage ou par bâtiment des centres de coûts",
  "BuildingDistributionCost.floors.excel.headers.floors.floorName": "Nom de l'étage",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterName": "Centre de coût",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterArea": "Surface des espaces incluant les distributions de l'étage",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterRoomsArea": "Surface des espaces du centre de coût",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterDistributedFloorRatio": "Ratio d'usage dans l'étage",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterFloorDistributedArea": "Surface totale des espaces à distribuer de l'étage pour ce centre de coût",
  "BuildingDistributionCost.floors.excel.headers.floors.floorArea": "Surface totale l'étage incluant les distributions de l'étage",
  "BuildingDistributionCost.floors.excel.headers.floors.totalFloorDistributedArea": "Surface à distribuer dans l'étage",
  "BuildingDistributionCost.floors.excel.headers.floors.totalBuildingDistributedArea": "Surface de l'étage à distribuer dans le bâtiment",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterName": "Centre de coût",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterArea": "Surface totale du centre de coût",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterBuildingRatio": "Ratio d'usage du bâtiment",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterDistributedBuildingArea": "Surface totale des espaces distribué du bâtiment",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterRoomsArea": "Surface des espaces du centre de coût",
  "BuildingDistributionCost.floors.excel.headers.building.buildingArea": "Surface totale des espaces du bâtiment",
  "BuildingDistributionCost.floors.excel.headers.building.buildingDistributedArea": "Surface à distribuer dans le bâtiment",
  "BuildingDistributionCost.floors.excel.headers.building.totalBuildingArea": "Surface totale du bâtiment",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.buildingName": "Bâtiment",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterName": "Centre de coût",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterArea": "Surface du centre de coût",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterBuildingRatio": "Clé de répartition dans le bâtiment",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.distributedCostCenterArea": "Répartition du centre de coût %{costCenterName}",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterTotalArea": "Surface totale à refacturer",
  "BuildingDistributionCost.excel.tabs.distributionCost": "Clés de répartition",
  "BuildingDistributionCost.excel.tabs.distributionCostDetails": "Détails",
  "BuildingDistributionCost.excel.download.label": "Télécharger le fichier excel sans les ventilations",
  "BuildingDistributionCost.excel.download.help": "Télécharger le fichier excel pour pourvoir partager et exporter les clés de répartition et surfaces qualifiées par centre de coût",
  "BuildingDistributionCost.Title": "Clés de répartition et surfaces qualifiées par centre de coût sans ventilations",
  "BuildingDistributionCost.table.type": "Type",
  "BuildingDistributionCost.table.distributionKey": "Clé de répartition",
  "BuildingDistributionCost.table.costCenterDistributionKey": "Clé de répartition pour le centre de coût",
  "BuildingDistributionCost.table.workplacesCount": "Nombre de postes de travail",
  "BuildingDistributionCost.table.workplaceTotalCount": "Nombre total des postes de travail",
  "BuildingFloorSelection.title": "Les étages à dupliquer dans votre scénario",
  "BuildingFloorSelection.all.select": "Sélectionner tous les étages",
  "BuildingFloorSelection.all.unselect": "Déselectionner tous les étages",
  "BuildingCloneFloorSelection.title": "Les étages à dupliquer dans votre scénario",
  "BuildingCloneFloorSelection.all.select": "Sélectionner tous les étages",
  "BuildingCloneFloorSelection.all.unselect": "Déselectionner tous les étages",
  "BuildingClone.noClone": "Aucun scénario n'a été créé pour le moment, vous pouvez créer votre premier scénario pour ce bâtiment",
  "BuildingClone.buttons.CreateClone.label": "Créer un scénario",
  "BuildingClone.buttons.CreateClone.help": "Le scénario va dupliquer le bâtiment avec les propriétés cochés",
  "BuildingClone.accordion.title": "Créer un nouveau scénario",
  "BuildingClone.properties.clone.people": "Dupliquer les affectations",
  "BuildingClone.properties.clone.workplaces": "Dupliquer les postes de travail",
  "BuildingClone.properties.clone.items": "Dupliquer les objets",
  "BuildingClone.properties.clone.dimensions": "Associer les calques d'analyses et d'affectations aux espaces",
  "BuildingClone.properties.clone.organization": "Associer les organisations aux espaces",
  "BuildingDashboard.dashboards.workplace": "Tableau de bord des postes de travail",
  "BuildingDashboard.dashboards.area": "Tableau de bord des surfaces",
  "CampusBuildingsAccordion.buildingCount": "Le nombre de bâtiments",
  "CalculatedPropertiesAccordions.mesures": "Mesures",
  "CalculatedPropertiesAccordions.kpi": "Indicateurs",
  "DimensionMapFilter.TooltipTitle.notSelected": "Sélectionner %{dimension} pour voir les espaces sur le plan avec la couleur associée",
  "DimensionMapFilter.TooltipTitle.selected": "Désélectionner %{dimension} va retirer la couleur associée du plan",
  "DimensionMapFilter.tooltip.true": "Sélectionner toutes les filtres ci-dessous afin de les colorier sur la carte",
  "DimensionMapFilter.tooltip.false": "Désélectionner toutes les filtres ci-dessous",
  "DimensionMapFilter.NoNode": "Il n'y a aucun calque d'analyse pour le moment, vous pouvez en ajouter en modifiant un espace et en y ajoutant des calques d'analyse",
  "DimensionMapFilter.NoCategory": "Il n'y a aucun calque d'analyse disponible, vous devez d'abord en associer aux espaces",
  "SelectDimensionTypeNavigationLayoutIcon.select": "Sélectionner ce type de calque pour la navigation",
  "SelectDimensionTypeNavigationLayoutIcon.unselect": "Retirer la navigation par calque d'analyse et revenir à la navigation par espaces",
  "SelectDimensionTypeNavigationLayoutIcon.help": "La navigation par calque d'analyse permet de cliquer sur un espace, sélectionner le calque correspondant et voir les personnes affectées à ce calque ou les postes de travail et les objets associés à ce calque à travers les espaces",
  "DimensionTypeNavigationWarning.message": "Vous êtes en navigation par %{name}, les espaces seront regroupés ensemble lors de la sélection. Cliquez pour annuler et revenir à la navigation par espace",
  "RoomCardSelectDimensions.needSave": "Merci de sauvegarder ou d'annuler vos changements avant de pouvoir modifier les calques d'analyses de cet espace",
  "AssignPersonToWorkplaceCheckListDialogTitle.title": "Vous avez affecté %{personName} sur le poste de travail %{workplaceName}",
  "AssignPersonToRoomCheckListDialogTitle.title": "Vous avez affecté %{personName} sur l'espace %{roomName}",
  "WorkplaceFullName.noName": "Poste de travail sans nom",
  "RoomFullName.noName": "Espace sans nom",
  "AssignPersonCheckListWorkplaceTransit.title": "Le poste de travail %{workplaceName} est un poste de passage",
  "AssignPersonCheckListWorkplaceTransit.RemoveIsTransit": 'Retirer le type "est de passage" du poste de travail',
  "AssignPersonCheckListWorkplaceAffectations.title": "Cette personne est déjà affectée sur d'autres postes de travail, voulez-vous supprimer les affectations suivantes pour %{personFullname}",
  "AssignPersonCheckListRoomAffectations.title": "Cette personne est déjà directement affectée à d'autres espaces, voulez-vous supprimer les affectations suivantes pour %{personFullname}",
  "AssignPersonCheckListDialogApplyButton.help": "Supprimer les affectations sélectionnées qui peuvent correspondre aux anciennes affectations de la personne",
  "AssignPersonCheckListDialogApplyButton.label": "Supprimer les affectations sélectionnées",
  "AssignPersonCheckListDialog.actions.close.label": "Fermer",
  "AssignPersonCheckListDialog.actions.close.help": "Fermer et ne supprimer aucune autre affectation",
  "AssignPersonCheckListBuildingAffectations.title": "Cette personne est déjà directement affectée sur d'autres bâtiments, voulez-vous supprimer les affectations suivantes pour %{personFullname}",
  "WorkplaceVirtualInventory.title": "Inventaire virtuel du poste de travail",
  "WorkplacePhysicalInventory.title": "Inventaire physique du poste de travail",
  "WorkplaceTypeSeatsCount.label": "Nombre de places assises",
  "WorkplaceTypeSeatsCount.help": "Le nombre de place assise comptabilisé pour ce type de poste de travail",
  "WorkplaceTypeCarbonFootprintCount.label": "Empreinte Carbone",
  "WorkplaceTypeCarbonFootprintCount.help": "L'empreinte carbone est la quantité de gaz à effet de serre émise par les objets du mobilier de ce type de poste de travail",
  "DeleteWorkplace.help": "Supprimer le poste de travail : [ %{name} ], les affectations seront aussi supprimées",
  "AddPersonToWorkplace.text": "Affecter une personne",
  "AddPersonToWorkplace.help": "Ajouter une affectation à ce poste de travail, vous pouvez ajouter plusieurs affectations pour le même poste de travail",
  "MouvementMatrixImport.errors.noSheet": "Impossible de trouver la feuille excel avec le nom %{name} [%{objectTypeName}]",
  "RoomTypeGroupMapFilter.Empty": "Il n'y a aucun groupe de type d'espace associé aux espaces via les type d'espaces, vous pouvez en ajouter en modifiant un groupe de type d'espace et en y ajoutant associant un type d'espace, puis vous pourrez contrôler leur affichage depuis cette section",
  "RoomTypeGroupLabel.exclude.tooltip": "Le groupe de typologie d'espace exclue les types d'espaces associés",
  "RoomTypeGroupHelpTitle.exclude": "Le groupement de type d'espaces %{name} est de type exclusion. Il regroupe tous les espaces à l'exception des typologies d'espaces suivantes :",
  "RoomTypeGroupHelpTitle.include": "Le groupement de type d'espaces %{name} regroupe les typologies d'espaces suivantes :",
  "RoomTypeGroupToRoomTypeLabel.exclude.tooltip": "La typologie d'espace est exclue",
  "RoomMapFilter.Empty": "Il n'y a aucun type d'espace associé aux espaces, vous pouvez en ajouter en modifiant un espace et en y ajoutant associant un type, puis vous pourrez contrôler leur affichage depuis cette séction",
  "LayoutFiltersTabZone.collapse.help": "Le menu est fermé, vous pouvez l'ouvrir en cliquant sur le premier icône afin de l'ouvrir et voir le détail des éléments du plan",
  "LayoutFiltersTabOpenToggleIcon.open.true": "Fermer le menu du plan pour optimiser l'espace de l'affichage du plan",
  "LayoutFiltersTabOpenToggleIcon.open.false": "Ouvrir le menu du plan pour voir le détail des informations en rapport avec le plan",
  "CompanyTypeLabel.notClassified": "Plateforme non classifiée",
  "BuildingMenuItem.menu.scenario": "Scenarios (%{count})",
  "SearchMenuItem.icon.tooltip": "Rechercher",
  "RemoveFromCartIconButton.help": "Retirer du panier",
  "CopyCartContentIntoTenant.buttons.single.paste.help": "Importer dans cette entreprise",
  "IndexContextMenuItem.navigation": "Navigation",
  "GlobalSearchIncludeScenarios.label": "Inclure les scénarios dans la recherche",
  "GlobalSearch.Input.placeholder": "Rechercher",
  "GlobalSearch.Start": "Vous pouvez rechercher par exemple des personnes, des espaces, des postes de travail, des objets ou d'autres entités, la recherche commencera à partir du 2eme caractère",
  "GlobalSearch.NoResult": "Aucun résultat n'a été trouvé pour votre recherche",
  "GlobalSearch.close.help": "Effacer la recherche",
  "models.PartnerExportMappingConfigurationToFloor.singular": "Etage inclus dans la configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfigurationToFloor.plural": "Etages inclus dans la configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfigurationToFloor.determinant.defined": "l'étage inclus dans la configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfigurationToFloor.determinant.undefined": "un étage inclus dans la configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfigurationToFloor.determinants.defined": "les étages inclus dans la configurations des transformations des exports partenaires",
  "models.PartnerExportMappingConfigurationToFloor.determinants.undefined": "des étages inclus dans la configurations des transformations des exports partenaires",
  "models.PartnerExportMappingToRoomType.singular": "Transformation des exports partenaires pour les types d'espaces",
  "models.PartnerExportMappingToRoomType.plural": "Transformations des exports partenaires pour les types d'espaces",
  "models.PartnerExportMappingToRoomType.determinant.defined": "la transformation des exports partenaires pour les types d'espaces",
  "models.PartnerExportMappingToRoomType.determinant.undefined": "une transformation des exports partenaires pour les types d'espaces",
  "models.PartnerExportMappingToRoomType.determinants.defined": "les transformations des exports partenaires pour les types d'espaces",
  "models.PartnerExportMappingToRoomType.determinants.undefined": "des transformations des exports partenaires pour les types d'espaces",
  "models.PartnerExportMappingConfiguration.singular": "Configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfiguration.plural": "Configurations des transformations des exports partenaires",
  "models.PartnerExportMappingConfiguration.determinant.defined": "la configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfiguration.determinant.undefined": "une configuration de la transformation des exports partenaires",
  "models.PartnerExportMappingConfiguration.determinants.defined": "les configurations des transformations des exports partenaires",
  "models.PartnerExportMappingConfiguration.determinants.undefined": "des configurations des transformations des exports partenaires",
  "models.PartnerExportMapping.singular": "Transformation des exports partenaires",
  "models.PartnerExportMapping.plural": "Transformations des exports partenaires",
  "models.PartnerExportMapping.determinant.defined": "la transformation des exports partenaires",
  "models.PartnerExportMapping.determinant.undefined": "une transformation des exports partenaires",
  "models.PartnerExportMapping.determinants.defined": "les transformations des exports partenaires",
  "models.PartnerExportMapping.determinants.undefined": "des transformations des exports partenaires",
  "models.WorkplaceTypeItemType.singular": "type d'objet dans type de poste de travail",
  "models.WorkplaceTypeItemType.plural": "types d'objet dans type de poste de travail",
  "models.WorkplaceTypeItemType.determinant.defined": "le type d'objet dans le type de poste de travail",
  "models.WorkplaceTypeItemType.determinant.undefined": "un type d'objet dans un type de poste de travail",
  "models.WorkplaceTypeItemType.determinants.defined": "les types d'objet dans les types de poste de travail",
  "models.WorkplaceTypeItemType.determinants.undefined": "des types d'objet dans des types de poste de travail",
  "models.WorkplaceTypeItemType.properties.id.label": "Identifiant du type d'objet dans le type de poste de travail",
  "models.WorkplaceTypeItemType.properties.zIndex.label": "Indice de hauteur",
  "models.WorkplaceTypeItemType.properties.zIndex.description": "L'indice de hauteur permet de définir l'ordre d'affichage des types d'objets, plus l'indice est grand plus l'objet sera au dessus des autres",
  "models.WorkplaceTypeItemType.properties.physicalInventory.label": "Inventaire physique",
  "models.WorkplaceTypeItemType.properties.physicalInventory.description": "Si cette option est cochée pour chaque poste de travail un objet physique sera créé dans Surfy, cet objet pourra avoir une référence unique, dans tous les cas l'inventaire du bâtiment sera à jour",
  "models.WorkplaceTypeItemType.properties.seatsCount.label": "Nombre de places assise",
  "models.WorkplaceTypeItemType.properties.seatsCount.description": "Permet de définir le nombre de places assises disponibles dans le type de poste de travail pour ce type d'objet",
  "models.WorkplaceType.singular": "type de poste de travail",
  "models.WorkplaceType.plural": "types de poste de travail",
  "models.WorkplaceType.determinant.defined": "le type de poste de travail",
  "models.WorkplaceType.determinant.undefined": "un type de poste de travail",
  "models.WorkplaceType.determinants.defined": "les types de poste de travail",
  "models.WorkplaceType.determinants.undefined": "des types de poste de travail",
  "models.WorkplaceType.properties.id.label": "Identifiant de la typologie du poste de travail",
  "models.WorkplaceType.properties.id.description": "",
  "models.WorkplaceType.properties.name.label": "Nom du type de poste de travail",
  "models.WorkplaceType.properties.name.description": "",
  "models.WorkplaceType.views.editor.help": "Editer les formes et l'emplacement des types d'objet pour le type de poste de travail %{name}",
  "models.WorkplaceType.views.editor.label": "Editer les formes",
  "models.WorkplaceType.views.avatar.help": "Voir la forme du type de poste de travail %{name}",
  "models.WorkplaceType.views.avatar.label": "Voir la forme",
  "models.WorkplaceType.views.dq-not-used.label": "Non utilisés",
  "models.WorkplaceType.views.dq-not-used.help": "Lister tous les types de poste de travail non utilisés via des postes de travail",
  "models.WorkplaceAffectation.singular": "Affectation au poste de travail",
  "models.WorkplaceAffectation.plural": "Affectations au poste de travail",
  "models.WorkplaceAffectation.description": "Permet d'attribuer un poste de travail fixe à une personne",
  "models.WorkplaceAffectation.determinant.defined": "l'affectation au poste de travail",
  "models.WorkplaceAffectation.determinant.undefined": "une affectation au poste de travail",
  "models.WorkplaceAffectation.determinants.defined": "les affectations au poste de travail",
  "models.WorkplaceAffectation.determinants.undefined": "des affectations au poste de travail",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.help": "Importer les matrices de transfert des postes de travail",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.label": "Import matrice de transfert",
  "models.Workplace.singular": "poste de travail",
  "models.Workplace.plural": "postes de travail",
  "models.Workplace.determinant.defined": "le poste de travail",
  "models.Workplace.determinant.undefined": "un poste de travail",
  "models.Workplace.determinants.defined": "les postes de travail",
  "models.Workplace.determinants.undefined": "des postes de travail",
  "models.Workplace.views.assign-current-user.label": "Occuper le poste de travail",
  "models.Workplace.views.assign-current-user.help": "Occuper le poste de travail %{name}",
  "models.Workplace.properties.id.label": "Identifiant du poste de travail",
  "models.Workplace.properties.id.description": "",
  "models.Workplace.properties.color.label": "Couleur",
  "models.Workplace.properties.color.description": "La couleur que prendra le type de poste de travail sur le plan",
  "models.Workplace.properties.name.label": "Nom du poste de travail",
  "models.Workplace.properties.name.description": "Le nom du poste de travail est utilisé pour l'identifier plus simplement",
  "models.Workplace.properties.isFlex.label": "Est en flex ?",
  "models.Workplace.properties.isFlex.description": "Si ce poste est utilisé en mode Flex",
  "models.Workplace.properties.isShared.label": "Est partagé ?",
  "models.Workplace.properties.isShared.description": "Si ce poste est partagé par plusieurs personnes, ce champ automatique est validé dès qu'il y a au moins 2 affectations sur le poste de travail",
  "models.Workplace.properties.isTransit.label": "Est de passage ?",
  "models.Workplace.properties.isTransit.description": "Si ce poste est de passage, ce poste sera exclu des postes de travail libres sans être réservable en flex, un poste de passage permet d'avoir un poste de travail disponible pour tout ceux qui souhaitent l'utiliser sans être inclus dans un système de réservation",
  "models.Workplace.properties.isBookable.label": "Est réservable ?",
  "models.Workplace.properties.isBookable.description": "Si ce poste de travail est reservable dans un système de réservation",
  "models.Workplace.properties.position.label": "Position",
  "models.Workplace.properties.position.description": "La position du poste de travail dans l'espace",
  "models.Workplace.properties.rotation.label": "Rotation",
  "models.Workplace.properties.rotation.description": "L'angle de rotation du poste de travail dans l'espace",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.label": "Taux d'affectation moyen",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.description": "Taux d'affectation moyen du poste de travail en fonction de l'affectation des jours de présence des personnes",
  "models.Workplace.properties.workplaceAffectationsCount.label": "Nombre d'affectations",
  "models.Workplace.properties.workplaceAffectationsCount.description": "Nombre d'affectations sur le poste de travail",
  "models.Workplace.properties.comment.label": "Commentaire",
  "models.Workplace.properties.comment.description": "Une information supplémentaire sur le poste de travail",
  "models.Workplace.properties.room.label": "Espace du poste de travail",
  "models.UserRegistrationTenantRuleToJupRole.singular": "Association de règle d'authentification à rôle",
  "models.UserRegistrationTenantRuleToJupRole.plural": "Associations de règle d'authentification à rôle",
  "models.UserRegistrationTenantRuleToJupRole.determinant.defined": "l'association de règle d'authentification à rôle",
  "models.UserRegistrationTenantRuleToJupRole.determinant.undefined": "une association de règle d'authentification à rôle",
  "models.UserRegistrationTenantRuleToJupRole.determinants.defined": "les associations de règle d'authentification à rôle",
  "models.UserRegistrationTenantRuleToJupRole.determinants.undefined": "des associations de règle d'authentification à rôle",
  "models.UserRegistrationTenantRuleToContentRole.singular": "Association de règle d'authentification à rôle de contenu",
  "models.UserRegistrationTenantRuleToContentRole.plural": "Associations de règle d'authentification à rôle de contenu",
  "models.UserRegistrationTenantRuleToContentRole.determinant.defined": "l'association de règle d'authentification à rôle de contenu",
  "models.UserRegistrationTenantRuleToContentRole.determinant.undefined": "une association de règle d'authentification à rôle de contenu",
  "models.UserRegistrationTenantRuleToContentRole.determinants.defined": "les associations de règle d'authentification à rôle de contenu",
  "models.UserRegistrationTenantRuleToContentRole.determinants.undefined": "des associations de règle d'authentification à rôle de contenu",
  "models.UserRegistrationTenantRule.singular": "Règle d'authentification",
  "models.UserRegistrationTenantRule.plural": "Règles d'authentification",
  "models.UserRegistrationTenantRule.determinant.defined": "la règle d'authentification",
  "models.UserRegistrationTenantRule.determinant.undefined": "une règle d'authentification",
  "models.UserRegistrationTenantRule.determinants.defined": "les règles d'authentification",
  "models.UserRegistrationTenantRule.determinants.undefined": "des règles d'authentification",
  "models.UserRegistrationTenantRule.properties.domains.label": "Domaines",
  "models.UserRegistrationTenantRule.properties.domains.description": "Séparer les domaines avec des espaces et inclure l'arobase",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.label": "Associer automatiquement les rôles",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.description": "Associer automatiquement les rôles et les rôles de contenu aux utilisateurs qui respectent cette règle",
  "models.UserCompany.singular": "utilisateur de l'entreprise",
  "models.UserCompany.plural": "utilisateurs de l'entreprise",
  "models.UserCompany.description": "Les utilisateurs de l'entreprise ont accès à la plateforme Surfy de leur entreprise",
  "models.UserCompany.determinant.defined": "l'utilisateur de l'entreprise",
  "models.UserCompany.determinant.undefined": "un utilisateur de l'entreprise",
  "models.UserCompany.determinants.defined": "les utilisateurs de l'entreprise",
  "models.UserCompany.determinants.undefined": "des utilisateurs de l'entreprise",
  "models.UserCompany.properties.id.label": "Identifiant de l'utilisateur de l'entreprise",
  "models.UserCompany.properties.buildingOwners.label": "Bâtiments propriétaires",
  "models.UserCompany.properties.buildingOwners.description": "Bâtiments dont l'utilisateur est le propriétaire",
  "models.User.singular": "utilisateur",
  "models.User.plural": "utilisateurs",
  "models.User.determinant.defined": "l'utilisateur",
  "models.User.determinant.undefined": "un utilisateur",
  "models.User.determinants.defined": "les utilisateurs",
  "models.User.determinants.undefined": "des utilisateurs",
  "models.User.properties.id.label": "Identifiant de l'utilisateur",
  "models.User.properties.id.description": "",
  "models.User.properties.firstname.label": "Prénom",
  "models.User.properties.firstname.description": "Le prénom de l'utilisateur",
  "models.User.properties.lastname.label": "Nom de famille",
  "models.User.properties.lastname.description": "Le nom de famille de l'utilisateur",
  "models.User.properties.email.label": "Email",
  "models.User.properties.email.description": "Le courriel utilisé par l'utilisateur pour les correspondances ou pour l'authentification",
  "models.Structure.singular": "structure",
  "models.Structure.plural": "structures",
  "models.Structure.determinant.defined": "la structure",
  "models.Structure.determinant.undefined": "une structure",
  "models.Structure.determinants.defined": "les structures",
  "models.Structure.determinants.undefined": "des structures",
  "models.Structure.properties.nom.label": "Nom de la structure",
  "models.Structure.properties.nom.description": "Pour retrouver et réutiliser la structure facilement",
  "models.Structure.properties.transform.label": "Transformation",
  "models.Structure.properties.transform.description": "Transformation de la structure pour la calibrer sur une carte",
  "models.Structure.views.editor.label": "Editer la forme",
  "models.Structure.views.editor.help": "Modifier la forme de la structure",
  "models.Structure.views.gmap-calibrate.label": "Calibrer la structure sur une carte",
  "models.Structure.views.gmap-calibrate.help": "Calibrer la structure sur une carte afin d'associer des coordonnées géographiques",
  "models.RoomTypeGroupToRoomType.singular": "association groupe de typologie d'espace à typologie d'espace",
  "models.RoomTypeGroupToRoomType.plural": "associations groupes de typologies d'espace à typologies d'espace",
  "models.RoomTypeGroupToRoomType.determinant.defined": "l'association groupe de typologie d'espace à typologie d'espace",
  "models.RoomTypeGroupToRoomType.determinant.undefined": "une association groupe de typologie d'espace à typologie d'espace",
  "models.RoomTypeGroupToRoomType.determinants.defined": "les associations groupes de typologies d'espace à typologies d'espace",
  "models.RoomTypeGroupToRoomType.determinants.undefined": "des associations groupes de typologies d'espace à typologies d'espace",
  "models.RoomTypeGroupFloor.singular": "groupe de typologie d'espace des étages",
  "models.RoomTypeGroupFloor.plural": "groupes de typologies d'espace des étages",
  "models.RoomTypeGroupFloor.determinant.defined": "le groupe de typologie d'espace des étages",
  "models.RoomTypeGroupFloor.determinant.undefined": "un groupe de typologie d'espace des étages",
  "models.RoomTypeGroupFloor.determinants.defined": "le groupe de typologie d'espace des étages",
  "models.RoomTypeGroupFloor.determinants.undefined": "des groupes de typologies d'espace des étages",
  "models.RoomTypeGroupBuilding.singular": "groupe de typologie d'espace des bâtiments",
  "models.RoomTypeGroupBuilding.plural": "groupes de typologies d'espace des bâtiments",
  "models.RoomTypeGroupBuilding.determinant.defined": "le groupe de typologie d'espace des bâtiments",
  "models.RoomTypeGroupBuilding.determinant.undefined": "un groupe de typologie d'espace des bâtiments",
  "models.RoomTypeGroupBuilding.determinants.defined": "le groupe de typologie d'espace des bâtiments",
  "models.RoomTypeGroupBuilding.determinants.undefined": "des groupes de typologies d'espace des bâtiments",
  "models.RoomTypeGroup.singular": "groupe de typologie d'espace",
  "models.RoomTypeGroup.plural": "groupes de typologie d'espace",
  "models.RoomTypeGroup.determinant.defined": "le groupe de typologie d'espace",
  "models.RoomTypeGroup.determinant.undefined": "un groupe de typologie d'espace",
  "models.RoomTypeGroup.determinants.defined": "les groupes de typologies d'espace",
  "models.RoomTypeGroup.determinants.undefined": "des groupes de typologies d'espace",
  "models.RoomTypeGroup.properties.id.label": "Identifiant du groupe de typologie d'espace",
  "models.RoomTypeGroup.properties.name.label": "Nom du groupe de typologie d'espace",
  "models.RoomTypeGroup.properties.code.label": "Code",
  "models.RoomTypeGroup.properties.color.label": "Couleur",
  "models.RoomTypeGroup.properties.exclude.label": "Exclure",
  "models.RoomTypeGroup.properties.exclude.description": "Exclure les typologies d'espace de ce groupe",
  "models.RoomTypeFloor.singular": "typologie d'espace des étages",
  "models.RoomTypeFloor.plural": "typologies d'espace des étages",
  "models.RoomTypeFloor.determinant.defined": "la typologie d'espace des étages",
  "models.RoomTypeFloor.determinant.undefined": "une typologie d'espace des étages",
  "models.RoomTypeFloor.determinants.defined": "les typologie d'espace des étages",
  "models.RoomTypeFloor.determinants.undefined": "des typologies d'espace des étages",
  "models.RoomTypeBuilding.singular": "typologie d'espace des bâtiments",
  "models.RoomTypeBuilding.plural": "typologies d'espace des bâtiments",
  "models.RoomTypeBuilding.determinant.defined": "la typologie d'espace des bâtiments",
  "models.RoomTypeBuilding.determinant.undefined": "une typologie d'espace des bâtiments",
  "models.RoomTypeBuilding.determinants.defined": "les typologie d'espace des bâtiments",
  "models.RoomTypeBuilding.determinants.undefined": "des typologies d'espace des bâtiments",
  "models.RoomType.singular": "typologie d'espace",
  "models.RoomType.plural": "typologies d'espace",
  "models.RoomType.determinant.defined": "la typologie d'espace",
  "models.RoomType.determinant.undefined": "une typologie d'espace",
  "models.RoomType.determinants.defined": "les typologies d'espace",
  "models.RoomType.determinants.undefined": "des typologies d'espace",
  "models.RoomType.properties.id.label": "Identifiant de la typologie d'espace",
  "models.RoomType.properties.name.label": "Nom de la typologie d'espace",
  "models.RoomType.properties.color.label": "Couleur en 2d",
  "models.RoomType.properties.color.description": "La couleur du type d'espace permet de differencier chaque type sur le plan en 2d",
  "models.RoomType.properties.color3d.label": "Couleur en 3d",
  "models.RoomType.properties.color3d.description": "Permet de gérer la couleur du type d'espace en 3d, cette option est uniquement applicable à la vision 3d de l'étage",
  "models.RoomType.properties.displayWallsOn3d.label": "Afficher les murs",
  "models.RoomType.properties.displayWallsOn3d.description": "Permet d'afficher ou non les murs de l'espace dans le plan 3d de l'étage, les murs non affichés sont en pointillés en 2d, cela permet d'avoir une vue plus agréable notament pour les open spaces",
  "models.RoomType.properties.icon.label": "Icône",
  "models.RoomType.properties.icon.description": "L'icône pour le type d'espace permet d'afficher pour ce type d'espace une icône dans les plans en 2d et en 3d à la place des informations classiques sur le plan, associé à la couleur de fond cela permet de rendre la lecture du plan plus agréable",
  "models.RoomType.properties.cadence.label": "Cadence",
  "models.RoomType.properties.cadence.description": "La cadence est une valeur numérique permettant d'indiquer la difficulté de nettoyage de la typologie de l'espace. Elle est égale au nombre de m² pouvant être traités en une heure dans cette typologie (circulation, laboratoire, ...)",
  "models.RoomType.properties.isBookable.label": "Est réservable ?",
  "models.RoomType.properties.isBookable.description": "Cocher cette case si ce type d'espace est réservable",
  "models.RoomPointSegmentType.singular": "Type de segment",
  "models.RoomPointSegmentType.plural": "Types de segment",
  "models.RoomPointSegmentType.determinant.defined": "le type de segment",
  "models.RoomPointSegmentType.determinant.undefined": "un type de segment",
  "models.RoomPointSegmentType.determinants.defined": "les types de segment",
  "models.RoomPointSegmentType.determinants.undefined": "des types de segment",
  "models.RoomPointSegment.singular": "qualification de segment",
  "models.RoomPointSegment.plural": "qualifications de segments",
  "models.RoomPointSegment.determinant.defined": "la qualification de segment",
  "models.RoomPointSegment.determinant.undefined": "une qualification de segment",
  "models.RoomPointSegment.determinants.defined": "les qualifications de segment",
  "models.RoomPointSegment.determinants.undefined": "des qualifications de segment",
  "models.RoomPointSegment.properties.reversePoints.label": "Inverser les points",
  "models.RoomPointSegment.properties.reversePoints.description": "Inverser les points du segment afin d'avoir l'affichage par exemple des portes dans le bon sens",
  "models.RoomPointSegment.properties.displayBothSides.label": "Afficher des deux côtés",
  "models.RoomPointSegment.properties.displayBothSides.description": "Afficher le segment des deux côtés du segment",
  "models.RoomPointSegment.views.dq-not-uniq.label": "Segments des points non uniques",
  "models.RoomPointSegment.views.dq-not-uniq.help": "Permet de vérifier qu'il n'y a pas de doublon exact de segment sur les mêmes points",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.label": "Les points des segments sont sur 2 étages différents",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.help": "Permet de vérifier que les points des segments sont sur le même étage",
  "models.RoomPointRoom.singular": "Association entre un point et un espace",
  "models.RoomPointRoom.plural": "Associations entre un point et un espace",
  "models.RoomPointRoom.determinant.defined": "l'association entre un point et un espace",
  "models.RoomPointRoom.determinant.undefined": "un point",
  "models.RoomPointRoom.description": "L'association entre un point et un espace permet de conserver l'ordre des points dans un espace afin de constituer un polyon",
  "models.RoomPointRoom.properties.id.label": "Identifiant de l'association entre un point et un espace",
  "models.RoomPointRoom.properties.id.description": "",
  "models.RoomPointRoom.properties.roomId.label": "Identifiant de l'espace",
  "models.RoomPointRoom.properties.roomId.description": "",
  "models.RoomPointRoom.properties.externalId.label": "Identifiant externe",
  "models.RoomPointRoom.properties.externalId.description": "",
  "models.RoomPointRoom.properties.sortIndex.label": "Index de tri",
  "models.RoomPointRoom.properties.sortIndex.description": "",
  "models.RoomPointRoom.properties.roomPointId.label": "Identifiant du point",
  "models.RoomPointRoom.properties.roomPointId.description": "",
  "models.RoomPoint.singular": "point des espaces",
  "models.RoomPoint.plural": "points des espaces",
  "models.RoomPoint.determinant.defined": "le point des espaces",
  "models.RoomPoint.determinant.undefined": "un point des espaces",
  "models.RoomPoint.properties.id.label": "Identifiant du point des espaces",
  "models.RoomPoint.properties.x.label": "x",
  "models.RoomPoint.properties.x.description": "Coordonnée sur l'axe X",
  "models.RoomPoint.properties.y.label": "y",
  "models.RoomPoint.properties.y.description": "Coordonnée sur l'axe Y",
  "models.RoomPoint.properties.sort_index.label": "Ordre",
  "models.RoomPoint.properties.sort_index.description": "L'index utilisé pour le tri",
  "models.RoomPoint.properties.room.description": "",
  "models.RoomPoint.properties.externalId.label": "Identifiant externe",
  "models.RoomPoint.properties.externalId.description": "",
  "models.RoomPoint.views.dq-uniq-position.label": "Position unique des points",
  "models.RoomPoint.views.dq-uniq-position.help": "Permet de vérifier qu'il n'y a pas de doublon exact de position sur les points",
  "models.RoomPoint.views.dq-not-used.label": "Points non utilisés",
  "models.RoomPoint.views.dq-not-used.help": "Permet de voir les points qui ne sont pas utilisés dans les espaces",
  "models.RoomConnector.singular": "Connecteur d'espace",
  "models.RoomConnector.plural": "Connecteurs d'espace",
  "models.RoomConnector.determinant.defined": "le connecteur d'espace",
  "models.RoomConnector.determinant.undefined": "un connecteur d'espace",
  "models.RoomConnector.determinants.defined": "les connecteurs d'espace",
  "models.RoomConnector.determinants.undefined": "des connecteurs d'espace",
  "models.RoomConnector.description": "Les connecteurs d'espaces permettent de créer un lien entre plusieurs espaces dans des étages différents",
  "models.RoomConnector.properties.id.label": "Identifiant du connecteur d'espace",
  "models.RoomConnector.properties.name.label": "Nom du connecteur d'espace",
  "models.RoomConnector.properties.waitTime.label": "Temps d'attente moyen",
  "models.RoomConnector.properties.waitTime.description": "Le temps d'attente moyenne avant que le connecteur d'espace soit disponible",
  "models.RoomConnector.properties.timePerFloor.label": "Temps entre chaque étage",
  "models.RoomConnector.properties.timePerFloor.description": "Le temps nécessaire pour pouvoir passer de chaque étage au prochain",
  "models.RoomAffectation.singular": "Affectation d'espace",
  "models.RoomAffectation.plural": "Affectations d'espace",
  "models.RoomAffectation.description": "Permet d'affecter une personne à un espace simple",
  "models.RoomAffectation.determinant.defined": "l'affectation d'espace",
  "models.RoomAffectation.determinant.undefined": "une affectation d'espace",
  "models.RoomAffectation.determinants.defined": "les affectations d'espace",
  "models.RoomAffectation.determinants.undefined": "des affectations d'espace",
  "models.RoomAffectation.views.room-mouvement-matrix-import.help": "Importer les matrices de transfert des espaces",
  "models.RoomAffectation.views.room-mouvement-matrix-import.label": "Import matrice de transfert",
  "models.Room.singular": "espace",
  "models.Room.plural": "espaces",
  "models.Room.determinant.defined": "l'espace",
  "models.Room.determinant.undefined": "un espace",
  "models.Room.determinants.defined": "les espaces",
  "models.Room.determinants.undefined": "des espaces",
  "models.Room.description": "Les espaces sont des lieux de travail ou des zones afin de découper un étage en sous espaces",
  "models.Room.views.map.help": "Voir le plan de l'espace %{name}",
  "models.Room.views.map.label": "Plan",
  "models.Room.views.dq-uniq-name.help": "Propose des noms pour les espaces qui n'ont pas de nom ou le nom n'est pas unique dans un même étage",
  "models.Room.views.dq-uniq-name.label": "Proposition de noms pour les espaces",
  "models.Room.views.dq-no-point.help": "Les espaces qui ont 0, 1 ou 2 points et qui devraient donc avoir une superficie nulle",
  "models.Room.views.dq-no-point.label": "Les espaces sans assez de points",
  "models.Room.views.dq-capacity-equals-seats-count.help": "Les espaces qui ont une capacité hors assises égale au nombre de places assises et qui ont une capacité totale doublée",
  "models.Room.views.dq-capacity-equals-seats-count.label": "Les espaces avec une capacité hors assises égale au nombre de places assises",
  "models.Room.views.dq-capacity-gt-0.help": "Permet de voir s'il y a des incohérénce dans les capacités des espaces ou détécter par exemple le mobilier qui n'a pas encore de place assises",
  "models.Room.views.dq-capacity-gt-0.label": "Les espaces qui ont une capacité hors assises différent de 0",
  "models.Room.views.meeting-rooms.help": "Voir et naviguer dans les salles de réunion",
  "models.Room.views.meeting-rooms.label": "Salles de réunion",
  "models.Room.properties.prettyName.label": "Nom d'affichage",
  "models.Room.properties.prettyName.description": "Permet d'avoir un nom d'affichage en plus du nom technique de l'espace, par exemple pour les salles de réunions",
  "models.Room.properties.id.label": "Identifiant de l'espace",
  "models.Room.properties.livePeopleCount.label": "Nombre de personnes dans l'espace en temps réel",
  "models.Room.properties.livePeopleCount.description": "Cette valeur est mise à jour par les capteurs de comptage des personnes présent dans l'espace et fournit le nombre de personnes présent en temps réel dans l'espace",
  "models.Room.properties.picture.label": "Photo de l'espace",
  "models.Room.properties.picture.description": "La photo de l'espace permet de le visualiser facilement",
  "models.Room.properties.capacity.label": "Capacité hors assises",
  "models.Room.properties.capacity.description": "La capacité declarée peut être utilisé pour définir le nombre de places disponibles dans un espace ou pour connaître le maximum de personnes qu'on peut mettre dans un espace, ce chiffre s'ajoute au nombre de places assises pour donner la capacité totale",
  "models.Room.properties.workplacesCount.label": "Nombre de postes de travail",
  "models.Room.properties.workplacesCount.description": "Le nombre de postes de travail dans l'espace est calculé automatiquement",
  "models.Room.properties.workplacesRatio.label": "Ratio par poste de travail",
  "models.Room.properties.workplacesRatio.description": "Le ratio par poste de travail est le nombre de métres carrés de l'espace divisé par le nombre de postes de travail, cette valeur est calculée automatiquement",
  "models.Room.properties.peopleCount.label": "Nombre d'affectations",
  "models.Room.properties.peopleCount.description": "Le nombre de personnes affectées dans l'espace, soit directement, soit à travers un poste de travail",
  "models.Room.properties.peopleRatio.label": "Ratio d'occupation",
  "models.Room.properties.peopleRatio.description": "Le ratio d'occupation est le nombre de métres carrés de l'espace divisé par le nombre de personnes affectées aux espaces, soit directement, soit via un poste de travail , cette valeur est calculée",
  "models.Room.properties.freeWorkplacesCount.label": "Nombre de postes libres",
  "models.Room.properties.freeWorkplacesCount.description": "Nombre de postes libres dans l'espace",
  "models.Room.properties.flexWorkplacesCount.label": "Nombre de postes flex",
  "models.Room.properties.flexWorkplacesCount.description": "Nombre de postes flex dans l'espace",
  "models.Room.properties.sharedWorkplacesCount.label": "Nombre de postes de travail partagés",
  "models.Room.properties.sharedWorkplacesCount.description": "Nombre de postes de travail partagés par au moins 2 personnes",
  "models.Room.properties.transitWorkplacesCount.label": "Nombre de postes de travail de passage",
  "models.Room.properties.transitWorkplacesCount.description": "Nombre de postes de travail de passage, ces postes ne sont pas comptabilisés dans les postes libres et ne sont pas en flex",
  "models.Room.properties.sharedWorkplacesRatio.label": "Taux de postes de travail partagés",
  "models.Room.properties.sharedWorkplacesRatio.description": "Taux de postes de travail partagés par au moins 2 personnes par rapport à l'ensemble des postes de travail de l'espace",
  "models.Room.properties.flexRatio.label": "Taux de postes de travail en flex",
  "models.Room.properties.flexRatio.description": "Le taux de poste de travail en flex est calculé en divisant le nombre de postes de travail en flex par le nombre total de postes de travail",
  "models.Room.properties.name.label": "Nom de l'espace",
  "models.Room.properties.name.description": "Le nom d'espace est utilisé pour le définir et le retrouver facilement.",
  "models.Room.properties.area.label": "Surface",
  "models.Room.properties.area.description": "La surface qualifiée au sol pour cet espace",
  "models.Room.properties.perimeter.label": "Périmètre",
  "models.Room.properties.perimeter.description": "Le périmètre d'espace représente son contour",
  "models.Room.properties.costCenter.description": "Permet de connaitre à quel centre de coût associer l'espace quand il s'agit de gérer la refacturation au centre de coût par espace",
  "models.Room.properties.distributionCostType.description": "Permet de déterminer le mode de calcul de la clé de répartition des coûts",
  "models.Room.properties.info.label": "Information supplémentaire",
  "models.Room.properties.info.description": "Permet de conserver des informations supplémentaires de type texte sur l'espace",
  "models.Room.properties.bookingEmail.label": "Email utilisé pour la réservation de cet espace",
  "models.Room.properties.bookingEmail.description": "Ce courriel permet de réserver cette salle via le système de messagerie",
  "models.Room.properties.keyCylinderCode.label": "Numéro de cylindre",
  "models.Room.properties.keyCylinderCode.description": "Le numéro de cylindre permet de définir le numéro de cylindre de la serrure de la porte de l'espace ou un élement en relation avec l'accès physique de l'espace",
  "models.Room.reports.mouvementMatrix.fileName": "Matrice de transfert",
  "models.Room.reports.mouvementMatrix.help": "Créer une matrice de transfert dans excel permettant de réaliser facilement les déplacements de vos collaborateurs",
  "models.PersonWorkingLocation.singular": "Emplacement de travail des personnes",
  "models.PersonWorkingLocation.plural": "Emplacements de travail des personnes",
  "models.PersonWorkingLocation.determinant.defined": "l'emplacement de travail des personnes'",
  "models.PersonWorkingLocation.determinant.undefined": "un emplacement de travail des personnes",
  "models.PersonWorkingLocation.determinants.defined": "les emplacements de travail des personnes",
  "models.PersonWorkingLocation.determinants.undefined": "des emplacements de travail des personnes",
  "models.PersonWorkingLocation.description": "Un emplacement de travail des personnes définie le lieu de travail des personnes",
  "models.PersonWorkingLocation.views.my-planning.help": "Gérer mon planning des prochaines semaines",
  "models.PersonWorkingLocation.views.my-planning.label": "Gérer mon planning",
  "models.PersonToWorkplaceBooking.singular": "Réservation au poste de travail des personnes",
  "models.PersonToWorkplaceBooking.plural": "Réservations au poste de travail des personnes",
  "models.PersonToWorkplaceBooking.description": "Les réservations des postes de travail des personnes sont enregistrées et disponibles avec les dates de début et de fin de réservation",
  "models.PersonToWorkplaceBooking.determinant.defined": "la réservation au poste de travail des personnes",
  "models.PersonToWorkplaceBooking.determinant.undefined": "une réservation au poste de travail des personnes",
  "models.PersonToWorkplaceBooking.determinants.defined": "les réservations au poste de travail des personnes",
  "models.PersonToWorkplaceBooking.determinants.undefined": "des réservations au poste de travail des personnes",
  "models.PersonToWorkplaceBooking.properties.startDatetime.label": "Début de la réservation",
  "models.PersonToWorkplaceBooking.properties.startDatetime.description": "La date et l'heure de début de la réservation",
  "models.PersonToWorkplaceBooking.properties.endDatetime.label": "Fin de la réservation",
  "models.PersonToWorkplaceBooking.properties.endDatetime.description": "La date et l'heure de fin de la réservation",
  "models.PersonToWorkplaceBooking.views.dashboard-index.label": "Tableau de bord",
  "models.PersonToWorkplaceBooking.views.dashboard-index.help": "Tableau de bord des réservations au poste de travail des personnes",
  "models.PersonToRoomBooking.singular": "Réservation à l'espace des personnes",
  "models.PersonToRoomBooking.plural": "Réservations à l'espace des personnes",
  "models.PersonToRoomBooking.description": "Les réservations aux espaces des personnes sont enregistrées et disponibles avec les dates de début et de fin de réservation",
  "models.PersonToRoomBooking.determinant.defined": "la réservation à l'espace des personnes",
  "models.PersonToRoomBooking.determinant.undefined": "une réservation à l'espace des personnes",
  "models.PersonToRoomBooking.determinants.defined": "les réservations à l'espace des personnes",
  "models.PersonToRoomBooking.determinants.undefined": "des réservations à l'espace des personnes",
  "models.PersonToRoomBooking.properties.startDatetime.label": "Début de la réservation",
  "models.PersonToRoomBooking.properties.startDatetime.description": "La date et l'heure de début de la réservation",
  "models.PersonToRoomBooking.properties.endDatetime.label": "Fin de la réservation",
  "models.PersonToRoomBooking.properties.endDatetime.description": "La date et l'heure de fin de la réservation",
  "models.PersonToPersonType.singular": "Type de relation entre personnes",
  "models.PersonToPersonType.plural": "Types de relation entre personnes",
  "models.PersonToPersonType.determinant.defined": "le type de relation entre personnes",
  "models.PersonToPersonType.determinant.undefined": "un type de relation entre personnes",
  "models.PersonToPersonType.determinants.defined": "les types de relation entre personnes",
  "models.PersonToPersonType.determinants.undefined": "des types de relation entre personnes",
  "models.PersonToPersonType.properties.labelForward.label": "Relation naturelle [en avant]",
  "models.PersonToPersonType.properties.labelForward.description": "La définition de la relation dans le sens naturel, par exemple entre un père et son fils, la définition naturelle est 'est le père de'",
  "models.PersonToPersonType.properties.labelBackward.label": "Relation inverse",
  "models.PersonToPersonType.properties.labelBackward.description": "La définition de la relation dans le sens inverse du sens naturel, par exemple entre un père et son fils, la définition inverse du sens naturel est 'est le fils de'",
  "models.PersonToPerson.singular": "Relation personne à personne",
  "models.PersonToPerson.plural": "Relations personne à personne",
  "models.PersonToPerson.determinant.defined": "la relation de personne à personne",
  "models.PersonToPerson.determinant.undefined": "une relation de personne à personne",
  "models.PersonToPerson.determinants.defined": "les relations de personne à personne",
  "models.PersonToPerson.determinants.undefined": "des relations de personne à personne",
  "models.PersonToPerson.properties.personSource.label": "Personne source",
  "models.PersonToPerson.properties.personTarget.label": "Personne destination",
  "models.PersonToDimensionBooking.singular": "Réservation au calque d'affectation des personnes",
  "models.PersonToDimensionBooking.plural": "Réservations au calque d'affectation des personnes",
  "models.PersonToDimensionBooking.description": "Les réservations aux calques d'affectation des personnes sont enregistrées et disponibles avec les dates de début et de fin de réservation",
  "models.PersonToDimensionBooking.determinant.defined": "la réservation au calque d'affectation des personnes",
  "models.PersonToDimensionBooking.determinant.undefined": "une réservation au calque d'affectation des personnes",
  "models.PersonToDimensionBooking.determinants.defined": "les réservations au calque d'affectation des personnes",
  "models.PersonToDimensionBooking.determinants.undefined": "des réservations au calque d'affectation des personnes",
  "models.PersonToDimensionBooking.properties.startDatetime.label": "Début de la réservation",
  "models.PersonToDimensionBooking.properties.startDatetime.description": "La date et l'heure de début de la réservation",
  "models.PersonToDimensionBooking.properties.endDatetime.label": "Fin de la réservation",
  "models.PersonToDimensionBooking.properties.endDatetime.description": "La date et l'heure de fin de la réservation",
  "models.PersonState.singular": "statut des personnes",
  "models.PersonState.plural": "statut des personnes",
  "models.PersonState.description": "Permet de définir tous les types de contrat des personnes vis à vis de l'entreprise",
  "models.PersonState.determinant.defined": "le statut des personnes",
  "models.PersonState.determinant.undefined": "un statut des personnes",
  "models.PersonState.determinants.defined": "les statuts des personnes",
  "models.PersonState.determinants.undefined": "des statuts des personnes",
  "models.PersonState.properties.id.label": "Identifiant du statut des personnes",
  "models.PersonState.properties.name.label": "Nom du statut de la personne",
  "models.PersonToBuilding.singular": "Affection au bâtiment",
  "models.PersonToBuilding.plural": "affectations au bâtiment",
  "models.PersonToBuilding.description": "Permet d'attribuer une personne à un bâtiment, sans information supplémentaire. L'affectation peut être comptabilisée, ou non.",
  "models.PersonToBuilding.determinant.defined": "l'affection au bâtiment",
  "models.PersonToBuilding.determinant.undefined": "une affection au bâtiment",
  "models.PersonToBuilding.determinants.defined": "les affections au bâtiment",
  "models.PersonToBuilding.determinants.undefined": "des affections au bâtiment",
  "models.PersonToBuilding.properties.addToPeopleCount.label": "Comptabiliser l'affectation",
  "models.PersonToBuilding.properties.addToPeopleCount.description": "Ajouter cette affectation au nombre total des personnes affectées au bâtiment",
  "models.PersonSecurityProfile.singular": "profil de sécurité des personnes",
  "models.PersonSecurityProfile.plural": "profils de sécurité des personnes",
  "models.PersonSecurityProfile.description": "Permet de définir les différents profils sécurité associables à des personnes",
  "models.PersonSecurityProfile.determinant.defined": "le profil de sécurité des personnes",
  "models.PersonSecurityProfile.determinant.undefined": "un profil de sécurité des personnes",
  "models.PersonSecurityProfile.determinants.defined": "les profils de sécurité des personnes",
  "models.PersonSecurityProfile.determinants.undefined": "des profils de sécurité des personnes",
  "models.PersonSecurityProfile.properties.id.label": "Identifiant du profil de sécurité des personnes",
  "models.PersonSecurityProfile.properties.name.label": "Nom du profil de sécurité",
  "models.PersonSecurityProfile.properties.name.description": "Permet de définir les différents profils sécurité associables à des personnes",
  "models.PersonSecurityProfile.properties.color.label": "Couleur du profil de sécurité",
  "models.PersonSecurityProfile.properties.color.description": "Permet de colorier le poste de travail d'affectation et l'icône sécurité de la personne en fonction de son profil sécurité",
  "models.PersonSecurityProfile.properties.icon.label": "Icône du profil de sécurité",
  "models.PersonSecurityProfile.properties.icon.description": "Permet d'attribuer une icône à un profil sécurité afin de visualiser clairement les profils sécurité sur le plan ou dans les listes",
  "models.PersonCompanyToRoomType.singular": "Type d'espace du prestataire",
  "models.PersonCompanyToRoomType.plural": "Types d'espaces des prestataires",
  "models.PersonCompanyToRoomType.description": "Les types d'espaces des prestataires permettent de définir une relation entre un type d'espaces et le prestataire et d'y définir une mission",
  "models.PersonCompanyToRoomType.determinant.defined": "le type d'espace du prestataire",
  "models.PersonCompanyToRoomType.determinant.undefined": "un type d'espace du prestataire",
  "models.PersonCompanyToRoomType.determinants.defined": "les types d'espaces des prestataires",
  "models.PersonCompanyToRoomType.determinants.undefined": "des types d'espaces des prestataires",
  "models.PersonGender.singular": "Genre de la personne",
  "models.PersonGender.plural": "Genres des personnes",
  "models.PersonGender.description": "Permet de dénombrer chaque genre, par exemple pour la gestion des sanitaires",
  "models.PersonGender.determinant.defined": "le genre de la personne",
  "models.PersonGender.determinant.undefined": "un genre de personne",
  "models.PersonGender.determinants.defined": "les genres de personnes",
  "models.PersonGender.determinants.undefined": "des genres de personnes",
  "models.PersonGender.properties.name.label": "Nom",
  "models.PersonGender.properties.name.description": "Le nom du genre de la personne",
  "models.PersonCompanyToItemType.singular": "Type d'objet du prestataire",
  "models.PersonCompanyToItemType.plural": "Types d'objets des prestataires",
  "models.PersonCompanyToItemType.description": "Les types d'objets des prestataires permettent de définir une relation entre le type d'objet et le prestataires et d'y définir la mission",
  "models.PersonCompanyToItemType.determinant.defined": "le type d'objet du prestataire",
  "models.PersonCompanyToItemType.determinant.undefined": "un type d'objet du prestataire",
  "models.PersonCompanyToItemType.determinants.defined": "les types d'objets des prestataires",
  "models.PersonCompanyToItemType.determinants.undefined": "des types d'objets des prestataires",
  "models.PersonCompanyToItem.singular": "Intervention sur un objet",
  "models.PersonCompanyToItem.plural": "Interventions sur des objet",
  "models.PersonCompanyToItem.description": "Les interventions des prestataires sur des objets permettent de définir par exemple la date d'une visite sur un extincteur",
  "models.PersonCompanyToItem.determinant.defined": "l'intervention sur un objet",
  "models.PersonCompanyToItem.determinant.undefined": "une intervention sur un objet",
  "models.PersonCompanyToItem.determinants.defined": "les interventions sur des objets",
  "models.PersonCompanyToItem.determinants.undefined": "des interventions sur des objets",
  "models.PersonCompanyToItem.properties.datetime.label": "Date et heure de l'intervention",
  "models.PersonCompanyToItem.properties.datetime.description": "Le moment auquel l'intervention a eu lieu",
  "models.PersonCompanyToItem.properties.comment.label": "Commentaire",
  "models.PersonCompanyToItem.properties.comment.description": "Un commentaire sur l'intervention",
  "models.PersonCompanyMission.singular": "mission du prestataire",
  "models.PersonCompanyMission.plural": "missions des prestataires",
  "models.PersonCompanyMission.description": "Les missions des prestataires permettent de connaitre le domaine d'intervention des prestataires",
  "models.PersonCompanyMission.determinant.defined": "la mission du prestataire",
  "models.PersonCompanyMission.determinant.undefined": "une mission du prestataire",
  "models.PersonCompanyMission.determinants.defined": "les missions des prestataires",
  "models.PersonCompanyMission.determinants.undefined": "des missions des prestataires",
  "models.PersonCompanyMission.properties.name.label": "Nom",
  "models.PersonCompanyMission.properties.name.description": "Le nom de la mission du prestataire",
  "models.PersonCompany.singular": "entreprise prestataire",
  "models.PersonCompany.plural": "entreprises prestataires",
  "models.PersonCompany.description": "L'entreprise prestataire permet de gérer le personnel prestataire par entreprise d'appartenance",
  "models.PersonCompany.determinant.defined": "l'entreprise prestataire",
  "models.PersonCompany.determinant.undefined": "une entreprise prestataire",
  "models.PersonCompany.determinants.defined": "les entreprises prestataires",
  "models.PersonCompany.determinants.undefined": "des entreprises prestataires",
  "models.PersonCompany.properties.name.label": "Nom",
  "models.PersonCompany.properties.name.description": "Le nom du prestataire, par exemple le nom de l'entreprise d'un prestataire de service",
  "models.PersonCompany.properties.comment.label": "Informations complémentaires",
  "models.PersonCompany.properties.comment.description": "Des informations complémentaires sur le prestataire, comme sa mission, ses valeurs, la couverture fonctionelle de sa préstation etc",
  "models.PersonCompany.properties.contact.label": "Contact",
  "models.PersonCompany.properties.contact.description": "Les informations de contact du prestataire",
  "models.PersonCompany.properties.documents.label": "Documents associés",
  "models.PersonCompany.properties.documents.description": "Le lien vers les documents associés à ce prestataire",
  "models.Person.singular": "personne",
  "models.Person.plural": "personnes",
  "models.Person.description": "Ce sont les personnes entrées dans la base de données de Surfy",
  "models.Person.determinant.defined": "la personne",
  "models.Person.determinant.undefined": "une personne",
  "models.Person.determinants.defined": "les personnes",
  "models.Person.determinants.undefined": "des personnes",
  "models.Person.properties.id.label": "Identifiant Surfy",
  "models.Person.properties.fullname.label": "Nom complet",
  "models.Person.properties.fullname.description": "Le nom complet de la personne permettant de le retrouver plus facilement",
  "models.Person.properties.personState.label": "Statut",
  "models.Person.properties.personState.description": "Permet d'indiquer le type de contrat de la personne vis à vis de l'entreprise",
  "models.Person.properties.personSecurityProfile.label": "Profil de sécurité",
  "models.Person.properties.personSecurityProfile.description": "Permet d'indiquer le profil de sécurité de la personne pour la gestion de la sécurité",
  "models.Person.properties.firstname.label": "Prénom",
  "models.Person.properties.firstname.description": "Le prénom de la personne",
  "models.Person.properties.lastname.label": "Nom de famille",
  "models.Person.properties.lastname.description": "Le nom de famille de la personne",
  "models.Person.properties.email.label": "Email",
  "models.Person.properties.email.description": "Le courriel de la personne",
  "models.Person.properties.picture.label": "Photo de profil",
  "models.Person.properties.picture.description": "La photo de la personne pour l'avoir en trombinoscope ou dans la recherche",
  "models.Person.properties.monitorReference.label": "Référence écran",
  "models.Person.properties.monitorReference.description": "La référence de l'écran informatique associé à cette personne",
  "models.Person.properties.computerReference.label": "Référence ordinateur",
  "models.Person.properties.computerReference.description": "La référence de l'ordinateur associé à cette personne",
  "models.Person.properties.cellphone.label": "Téléphone portable",
  "models.Person.properties.cellphone.description": "Le téléphone portable de la personne",
  "models.Person.properties.telephone.label": "Téléphone fixe",
  "models.Person.properties.telephone.description": "Le téléphone fixe de la personne",
  "models.Person.properties.title.label": "Titre",
  "models.Person.properties.title.description": "Le titre de la personne",
  "models.Person.properties.badgeNumber.label": "Numéro de badge",
  "models.Person.properties.badgeNumber.description": "Le numéro de badge de la personne",
  "models.Person.properties.boxNumber.label": "Numéro de casier",
  "models.Person.properties.boxNumber.description": "Le numéro de casier de la personne",
  "models.Person.properties.badgeRestaurant.label": "Badge RIE",
  "models.Person.properties.badgeRestaurant.description": "La référence du badge du RIE ou du restaurant d'entreprise",
  "models.Person.properties.registrationNumber.label": "Immatriculation",
  "models.Person.properties.registrationNumber.description": "Le numéro d'immatriculation de la personne",
  "models.Person.properties.startDate.label": "Date d'entrée",
  "models.Person.properties.startDate.description": "La date d'entrée de la personne dans l'entreprise",
  "models.Person.properties.endDate.label": "Date de sortie",
  "models.Person.properties.endDate.description": "La date de sortie de la personne de l'entreprise",
  "models.Person.properties.code.label": "Matricule",
  "models.Person.properties.code.description": "Le matricule RH de la personne",
  "models.Person.properties.personToPersonTargets.label": "Relations vers cette personne",
  "models.Person.properties.personToPersonTargets.description": "Permet de connaitre la relation ascendante entre deux personnes, par exemple la relation hiérarchique",
  "models.Person.properties.personToPersonSources.label": "Relations depuis cette personne",
  "models.Person.properties.personToPersonSources.description": "Permet de connaitre la relation descendante entre deux personnes, par exemple la relation hiérarchique",
  "models.Person.properties.organization.label": "L'organisation de la personne",
  "models.Person.properties.organization.description": "Le Service de rattachement de la personne",
  "models.Person.properties.info.label": "Commentaire",
  "models.Person.properties.info.description": "Commentaire sur la personne permettant de conserver des informations supplémentaires ou diverses",
  "models.Person.properties.notAffectable.label": "Non Affectable",
  "models.Person.properties.notAffectable.description": "La personne ne peut pas être affectée à un poste de travail, un espace, un bâtiment ou un calque d'affectation",
  "models.Person.views.home.help": "Voir la fiche de la personne <b>%{name}</b> avec ses informations et affectations",
  "models.Person.views.home.label": "Fiche de la personne",
  "models.Person.views.relationship-list.help": "Lister les relations entre personnes",
  "models.Person.views.relationship-list.label": "Liste des relations",
  "models.Person.views.dq-only-associated-to-building.help": "Lister les personnes affectables qui sont affectées à un bâtiment et comptabilisées sans être affectées (poste de travail, calque d'affectation, espace)",
  "models.Person.views.dq-only-associated-to-building.label": "Personnes affectées à un bâtiment sans autre affectation",
  "models.Person.views.dq-near-end-date.help": "Lister les personnes qui ont une date de fin de contrat après aujourd'hui et qui sont affectées à un poste de travail",
  "models.Person.views.dq-near-end-date.label": "Personnes quittant l'entreprise",
  "models.Person.views.dq-no-affectations.label": "Personnes sans affectations",
  "models.Person.views.dq-no-affectations.help": "Lister les personnes affectables n'ayant pas d'affectations (bâtiment, poste de travail, calque d'affectation, espace)",
  "models.Person.views.dq-person-duplicate.label": "Personnes en doublon",
  "models.Person.views.dq-person-duplicate.help": "Lister les personnes en doublon",
  "models.PartnerApiCredential.singular": "Clé d'api partenaire",
  "models.PartnerApiCredential.plural": "Clés d'api partenaire",
  "models.PartnerApiCredential.determinant.defined": "la clé d'api partenaire",
  "models.PartnerApiCredential.determinant.undefined": "une clé d'api partenaire",
  "models.PartnerApiCredential.determinants.defined": "les clés d'api partenaire",
  "models.PartnerApiCredential.determinants.undefined": "des clés d'api partenaire",
  "models.PartnerApiCredential.properties.enable.label": "Activé",
  "models.PartnerApiCredential.properties.enable.description": "Il faut activer la clé pour pouvoir l'utiliser",
  "models.OrganizationFloor.singular": "Organisation des étages",
  "models.OrganizationFloor.plural": "Organisations des étages",
  "models.OrganizationFloor.determinant.defined": "l'organisation des étages",
  "models.OrganizationFloor.determinant.undefined": "une organisation des étages",
  "models.OrganizationFloor.determinants.defined": "les organisations des étages",
  "models.OrganizationFloor.determinants.undefined": "des organisations des étages",
  "models.OrganizationBuilding.singular": "Organisation des bâtiments",
  "models.OrganizationBuilding.plural": "Organisations des bâtiments",
  "models.OrganizationBuilding.determinant.defined": "l'organisation des bâtiments",
  "models.OrganizationBuilding.determinant.undefined": "une organisation des bâtiments",
  "models.OrganizationBuilding.determinants.defined": "les organisations des bâtiments",
  "models.OrganizationBuilding.determinants.undefined": "des organisations des bâtiments",
  "models.Organization.singular": "organisation",
  "models.Organization.plural": "organisations",
  "models.Organization.determinant.defined": "l'organisation",
  "models.Organization.determinant.undefined": "une organisation",
  "models.Organization.determinants.defined": "les organisations",
  "models.Organization.determinants.undefined": "des organisations",
  "models.Organization.description": "Les organisations ont deux niveaux hiérarchiques : les directions et les services, et permettent de définir la structure organisationnelle de l'entreprise",
  "models.Organization.properties.id.label": "Identifiant de l'organisation",
  "models.Organization.properties.name.label": "Nom",
  "models.Organization.properties.name.description": "Nom qui va définir l'organisation",
  "models.Organization.properties.code.label": "Code",
  "models.Organization.properties.code.description": "Ce code peut être utilisé pour contenir la codification de l'organisation ou la clé pour l'identification via un logiciel tiers",
  "models.Organization.properties.organizationId.label": "Identifiant de la direction",
  "models.Organization.properties.organizationId.description": "C'est grâce à cet identifiant qu'il est possible de créer la hierarchie organisationnelle",
  "models.Organization.properties.organization.label": "Direction",
  "models.Organization.properties.organizations.label": "Services",
  "models.Organization.views.hierarchy.label": "Hiérarchie",
  "models.Organization.views.hierarchy.help": "Voir la hiérarchie des organisations",
  "models.Organization.views.dq-organization-to-room.label": "Erreurs sur les organisations des espaces",
  "models.Organization.views.dq-organization-to-room.help": "Détecter les associations d'espaces avec les organisations qui ne sont pas valides",
  "models.Organization.views.dq-organization-hierarchy.label": "Erreurs sur la hiérarchie des organisations",
  "models.Organization.views.dq-organization-hierarchy.help": "Détecter les organisations qui ne sont pas dans la bonne hiérarchie",
  "models.OpenerPostMessageHost.singular": "Hôte de message pour fenêtre contextuelle",
  "models.OpenerPostMessageHost.plural": "Hôtes de messages pour fenêtre contextuelle",
  "models.OpenerPostMessageHost.determinant.defined": "l'hôte de message pour fenêtre contextuelle",
  "models.OpenerPostMessageHost.determinant.undefined": "un hôte de message pour fenêtre contextuelle",
  "models.OpenerPostMessageHost.determinants.defined": "les hôtes de message pour fenêtre contextuelle",
  "models.OpenerPostMessageHost.determinants.undefined": "des hôtes de message pour fenêtre contextuelle",
  "models.OpenerPostMessageHost.description": "Un hôte de message pour fenêtre contextuelle est un élément qui permet de communiquer avec une fenêtre contextuelle ouverte sur les actions du plan",
  "models.OccupancyStatus.singular": "état d'occupation",
  "models.OccupancyStatus.plural": "états d'occupation",
  "models.OccupancyStatus.determinant.defined": "l'état d'occupation",
  "models.OccupancyStatus.determinant.undefined": "un état d'occupation",
  "models.OccupancyStatus.determinants.defined": "les états d'occupation",
  "models.OccupancyStatus.determinants.undefined": "des états d'occupation",
  "models.OccupancyStatus.description": "L'état d'occupation permet d'identifier l'état en temps réel d'un espace ou d'un poste de travail, comme par exemple s'il est libre, occupé ou squaté, l'état d'occupation est mis à jour par les objets connectés présent dans l'espace",
  "models.OccupancyStatus.properties.id.label": "Identifiant de l'état d'occupation",
  "models.OccupancyStatus.properties.name.label": "Nom de l'état d'occupation",
  "models.OccupancyStatus.properties.color.label": "Couleur",
  "models.OccupancyStatus.properties.color.description": "La couleur permet de colorier les espaces ou les postes de travail sur les plans en fonction de leur état d'occupation",
  "models.OccupancyStatus.properties.code.label": "Code de l'état d'occupation",
  "models.OccupancyStatus.properties.code.description": "Le code permet d'identifier et de réaliser des opérations techniques sur l'état d'occupation",
  "models.Object3dModel.singular": "Modèle 3d",
  "models.Object3dModel.plural": "Modèles 3d",
  "models.Object3dModel.determinant.defined": "le modèle 3d",
  "models.Object3dModel.determinant.undefined": "un modèle 3d",
  "models.Object3dModel.determinants.defined": "les modèles 3d",
  "models.Object3dModel.determinants.undefined": "des modèles 3d",
  "models.Object3dModel.description": "Le Modèle 3D permet une représentation 3D réaliste des objets placés sur le plan; En absence de modèle 3D les objets sont représentés en forme pleine dans la vue 3D",
  "models.Object3dModel.properties.origin.label": "Orientation",
  "models.Object3dModel.properties.origin.description": "Utiliser X si l'objet est orienté à droite ou Y si l'objet est orienté vers le bas",
  "models.MapScale.singular": "échelle plan",
  "models.MapScale.plural": "échelles plan",
  "models.MapScale.determinant.defined": "l'échelle",
  "models.MapScale.determinant.undefined": "une échelle",
  "models.MapScale.determinants.defined": "les échelles",
  "models.MapScale.determinants.undefined": "des échelles",
  "models.MapScale.properties.id.label": "Identifiant de l'échelle",
  "models.MapScale.properties.p1.description": "Point de départ",
  "models.MapScale.properties.p2.description": "Point d'arrivé",
  "models.MapScale.properties.name.label": "Nom de l'échelle",
  "models.MapScale.properties.name.description": "Pour se rémémorer le nom et le réutiliser sur d'autres étages",
  "models.MapScale.properties.length.label": "Distance",
  "models.MapScale.properties.length.description": "La distance representée sur le plan entre les 2 points en mètre",
  "models.MapScale.properties.roomTextSize.label": "Taille du texte des espaces",
  "models.MapScale.properties.roomTextSize.description": "La taille du texte des espaces sur le plan pour optimiser l'affichage",
  "models.MapScale.properties.workplaceTextSize.label": "Taille du texte sur les objets",
  "models.MapScale.properties.workplaceTextSize.description": "La taille du texte sur les postes de travail et sur les objets sur le plan pour optimiser l'affichage",
  "models.MapScale.properties.segmentDistanceTextSize.label": "Taille du texte des segments",
  "models.MapScale.properties.segmentDistanceTextSize.description": "La taille du texte sur les distances entre les points sur le plan pour optimiser l'affichage",
  "models.MapScale.properties.itemTypeIconSize.label": "Taille des icônes des types d'objet",
  "models.MapScale.properties.itemTypeIconSize.description": "La taille des icones des types d'objet sur le plan, la taille sera limitée par la taille de l'espace",
  "models.MapScale.properties.roomIconSize.label": "Taille des icônes des types d'espace",
  "models.MapScale.properties.roomIconSize.description": "La taille des icones sur le plan dans les espaces par rapport aux types d'espace",
  "models.MapScale.properties.strokeWidth.label": "Epaisseur des lignes",
  "models.MapScale.properties.strokeWidth.description": "Il est possible de réduire l'épaisseur des lignes pour augmenter la lisibilité du plan",
  "models.MapScale.views.dq-not-used.label": "Les échelles non utilisées",
  "models.MapScale.views.dq-not-used.help": "Voir les échelles qui ne sont pas utilisées sur les étages et qui peuvent être supprimées",
  "models.MapScale.views.dq-uniq-name.label": "Proposition de noms pour les échelles",
  "models.MapScale.views.dq-uniq-name.help": "Propose des noms uniques pour les échelles incluant les étages et bâtiments où elles sont utilisées",
  "models.Manufacturer.singular": "Fabricant du type d'objet",
  "models.Manufacturer.plural": "Fabricants du type d'objet",
  "models.Manufacturer.determinant.defined": "le fabricant du type d'objet",
  "models.Manufacturer.determinant.undefined": "un fabricant du type d'objet",
  "models.Manufacturer.determinants.defined": "les fabricants des types d'objet",
  "models.Manufacturer.determinants.undefined": "des fabricants types d'objet",
  "models.Manufacturer.properties.name.label": "Nom du fabricant du type d'objet",
  "models.Manufacturer.properties.name.description": "Permet d'identifier le nom du fabricant ou la marque",
  "models.Manufacturer.properties.website.label": "Site internet",
  "models.Manufacturer.properties.website.description": "L'adresse du site internet du fabricant",
  "models.Legend.singular": "Légende",
  "models.Legend.plural": "Légende",
  "models.Legend.determinant.defined": "la légende",
  "models.Legend.determinant.undefined": "une légende",
  "models.Legend.determinants.defined": "les légendes",
  "models.Legend.determinants.undefined": "des légendes",
  "models.Legend.description": "La légende permet de configurer les propriété visible quand le plan est sauvegardé en image",
  "models.JupUserCompanyToJupRole.singular": "Rôle de l'utilisateur de l'entreprise",
  "models.JupUserCompanyToJupRole.plural": "Rôles de l'utilisateur de l'entreprise",
  "models.JupUserCompanyToJupRole.determinant.defined": "le rôle de l'utilisateur de l'entreprise",
  "models.JupUserCompanyToJupRole.determinant.undefined": "un rôle de l'utilisateur de l'entreprise",
  "models.JupUserCompanyToJupRole.determinants.defined": "les rôles de l'utilisateur de l'entreprise",
  "models.JupUserCompanyToJupRole.determinants.undefined": "des rôles de l'utilisateur de l'entreprise",
  "models.JupUiView.singular": "Vue d'interface",
  "models.JupUiView.plural": "Vues d'interface",
  "models.JupUiView.determinant.defined": "la vue d'interface",
  "models.JupUiView.determinant.undefined": "une vue d'interface",
  "models.JupUiView.determinants.defined": "les vues d'interface",
  "models.JupUiView.determinants.undefined": "des vues d'interface",
  "models.JupUiTenantOperation.singular": "Opération d'interface pour une entreprise",
  "models.JupUiTenantOperation.plural": "Opérations d'interface pour une entreprise",
  "models.JupUiTenantOperation.determinant.defined": "l'opération d'interface pour une entreprise",
  "models.JupUiTenantOperation.determinant.undefined": "une opération d'interface pour une entreprise",
  "models.JupUiTenantOperation.determinants.defined": "les opérations d'interface pour une entreprise",
  "models.JupUiTenantOperation.determinants.undefined": "des opérations d'interface pour une entreprise",
  "models.JupUiOption.singular": "Option d'interface",
  "models.JupUiOption.plural": "Options d'interface",
  "models.JupUiOption.determinant.defined": "l'option d'interface",
  "models.JupUiOption.determinant.undefined": "une option'interface",
  "models.JupUiOption.determinants.defined": "les options d'interface",
  "models.JupUiOption.determinants.undefined": "des options d'interface",
  "models.JupUiOperation.singular": "Opération d'interface",
  "models.JupUiOperation.plural": "Opérations d'interface",
  "models.JupUiOperation.determinant.defined": "l'opération d'interface",
  "models.JupUiOperation.determinant.undefined": "une opération d'interface",
  "models.JupUiOperation.determinants.defined": "les opérations d'interface",
  "models.JupUiOperation.determinants.undefined": "des opérations d'interface",
  "models.JupUiLayout.singular": "Vision du plan",
  "models.JupUiLayout.plural": "Visions du plan",
  "models.JupUiLayout.determinant.defined": "la vision du plan",
  "models.JupUiLayout.determinant.undefined": "une vision du plan",
  "models.JupUiLayout.determinants.defined": "les visions du plan",
  "models.JupUiLayout.determinants.undefined": "des visions du plan",
  "models.JupRoleToJupUiView.singular": "Association rôle aux vues d'interface",
  "models.JupRoleToJupUiView.plural": "Associations rôle aux vues d'interface",
  "models.JupRoleToJupUiView.determinant.defined": "l'association du rôle aux vues d'interface",
  "models.JupRoleToJupUiView.determinant.undefined": "une association du rôle aux vues d'interface",
  "models.JupRoleToJupUiView.determinants.defined": "les associations du rôle aux vues d'interface",
  "models.JupRoleToJupUiView.determinants.undefined": "des associations du rôle aux vues d'interface",
  "models.JupRoleToJupUiView.properties.canSee.label": "Peut voir la vue",
  "models.JupRoleToJupUiView.properties.canSee.description": "Autorise la vue a être vue par le rôle",
  "models.JupRoleToJupUiOption.singular": "Association rôle aux visions du plan",
  "models.JupRoleToJupUiOption.plural": "Associations rôle aux visions du plan",
  "models.JupRoleToJupUiOption.determinant.defined": "l'association du rôle aux visions du plan",
  "models.JupRoleToJupUiOption.determinant.undefined": "une association du rôle aux visions du plan",
  "models.JupRoleToJupUiOption.determinants.defined": "les associations du rôle aux visions du plan",
  "models.JupRoleToJupUiOption.determinants.undefined": "des associations du rôle aux visions du plan",
  "models.JupRoleToJupUiOption.properties.canSee.label": "Peut voir l'option",
  "models.JupRoleToJupUiOption.properties.canSee.description": "Autorise l'option a être vue par le rôle",
  "models.JupRoleToJupUiOperation.singular": "Association rôle aux opérations d'interface",
  "models.JupRoleToJupUiOperation.plural": "Association rôle aux opérations d'interface",
  "models.JupRoleToJupUiOperation.determinant.defined": "l'association du rôle aux opérations d'interface",
  "models.JupRoleToJupUiOperation.determinant.undefined": "une association du rôle aux opérations d'interface",
  "models.JupRoleToJupUiOperation.determinants.defined": "les associations du rôle aux opérations d'interface",
  "models.JupRoleToJupUiOperation.determinants.undefined": "des associations du rôle aux opérations d'interface",
  "models.JupRoleToJupObjectType.singular": "Association rôle à type d'objet",
  "models.JupRoleToJupObjectType.plural": "Associations rôle à type d'objet",
  "models.JupRoleToJupObjectType.determinant.defined": "l'association du rôle au type d'objet",
  "models.JupRoleToJupObjectType.determinant.undefined": "une association du rôle au type d'objet",
  "models.JupRoleToJupObjectType.determinants.defined": "les associations du rôle au type d'objet",
  "models.JupRoleToJupObjectType.determinants.undefined": "des associations du rôle au type d'objet",
  "models.JupRoleToJupObjectType.properties.arCreate.label": "Création (C)",
  "models.JupRoleToJupObjectType.properties.arCreate.description": "Autorise la création d'entité",
  "models.JupRoleToJupObjectType.properties.arRead.label": "Lecture (R)",
  "models.JupRoleToJupObjectType.properties.arRead.description": "Autorise la lecture des entités",
  "models.JupRoleToJupObjectType.properties.arUpdate.label": "Mise à jour (U)",
  "models.JupRoleToJupObjectType.properties.arUpdate.description": "Autorise la mise à jour des entités",
  "models.JupRoleToJupObjectType.properties.arDelete.label": "Suppression (D)",
  "models.JupRoleToJupObjectType.properties.arDelete.description": "Autorise la suppression d'entités",
  "models.JupRole.singular": "Rôle",
  "models.JupRole.plural": "Rôles",
  "models.JupRole.determinant.defined": "le rôle",
  "models.JupRole.determinant.undefined": "un rôle",
  "models.JupRole.determinants.defined": "les rôles",
  "models.JupRole.determinants.undefined": "des rôles",
  "models.JupRole.views.matrix.help": "La matrice de sécurité du rôle %{name}",
  "models.JupRole.views.matrix.label": "Matrice",
  "models.JupRole.views.help.help": "Le résumé des droits des rôles",
  "models.JupRole.views.help.label": "Aide",
  "models.JupObjectType.singular": "Type d'entité",
  "models.JupObjectType.plural": "Types d'entité",
  "models.JupObjectType.determinant.defined": "le type d'entité",
  "models.JupObjectType.determinant.undefined": "un type d'entité",
  "models.JupObjectType.determinants.defined": "les types d'entité",
  "models.JupObjectType.determinants.undefined": "des types d'entité",
  "models.ItemTypePoint.singular": "Point des types d'objet",
  "models.ItemTypePoint.plural": "Points des types d'objet",
  "models.ItemTypePoint.determinant.defined": "le point des types d'objet",
  "models.ItemTypePoint.determinant.undefined": "un point des types d'objet",
  "models.ItemTypePoint.determinants.defined": "les points des types d'objet",
  "models.ItemTypePoint.determinants.undefined": "des points des types d'objet",
  "models.ItemTypePoint.properties.id.label": "Identifiant",
  "models.ItemTypePoint.properties.id.description": "",
  "models.ItemTypePoint.properties.x.label": "x",
  "models.ItemTypePoint.properties.x.description": "",
  "models.ItemTypePoint.properties.y.label": "y",
  "models.ItemTypePoint.properties.y.description": "",
  "models.ItemTypePoint.properties.externalId.label": "Identifiant externe",
  "models.ItemTypePoint.properties.externalId.description": "",
  "models.ItemTypePoint.properties.itemTypeId.label": "Identifiant du type d'objet",
  "models.ItemTypePoint.properties.itemTypeId.description": "",
  "models.ItemTypePoint.properties.sortIndex.label": "Index de tri",
  "models.ItemTypePoint.properties.sortIndex.description": "",
  "models.ItemTypePoint.properties.itemType.label": "Type d'objet",
  "models.ItemTypePoint.properties.itemType.description": "",
  "models.ItemTypeFamily.singular": "famille de types d'objet",
  "models.ItemTypeFamily.plural": "familles de types d'objet",
  "models.ItemTypeFamily.determinant.defined": "la famille de types d'objet",
  "models.ItemTypeFamily.determinant.undefined": "une famille de types d'objet",
  "models.ItemTypeFamily.determinants.defined": "les familles de types d'objet",
  "models.ItemTypeFamily.determinants.undefined": "des familles de types d'objet",
  "models.ItemTypeFamily.description": "Permet d’afficher les objets par Famille sur les plans et dans l’inventaire en pdf",
  "models.ItemTypeFamily.properties.id.label": "Identifiant de la famille de types de l'objet",
  "models.ItemTypeFamily.properties.name.label": "Nom de la famille de types de l'objet",
  "models.ItemTypeFamily.properties.name.description": "Le nom de la famille permet de l'identifier, ce nom est utilisé pour regrouper les types d'objet",
  "models.ItemType.singular": "type d'objet",
  "models.ItemType.plural": "types d'objet",
  "models.ItemType.determinant.defined": "le type d'objet",
  "models.ItemType.determinant.undefined": "un type d'objet",
  "models.ItemType.determinants.defined": "les types d'objet",
  "models.ItemType.determinants.undefined": "des types d'objet",
  "models.ItemType.properties.id.label": "Identifiant du type de l'objet",
  "models.ItemType.properties.id.description": "Identifiant du type de l'objet",
  "models.ItemType.properties.description.label": "Description",
  "models.ItemType.properties.description.description": "Permet d'avoir des informations supplémentaires sur le type d'objet",
  "models.ItemType.properties.name.label": "Nom du type d'objet",
  "models.ItemType.properties.name.description": "Permet d'identifier rapidement le type d'objet avec un nom complet, logique et descriptif; On peut y indiquer les dimensions, par exemple: Table de Réunion 340x120; Conseil: commencer toujours par la dimension la plus grande",
  "models.ItemType.properties.zIndex.label": "Indice de hauteur",
  "models.ItemType.properties.zIndex.description": "Plus l'indice de hauteur est élevé plus l'objet sera positionné au dessus des autres; Il peut être négatif; par exemple pour un siège: -1; Conseil: pour les Icones, fixer l'indice à 9",
  "models.ItemType.properties.picture.label": "Photo",
  "models.ItemType.properties.picture.description": "Permet de charger la photo du type d’objet, qui sera visible dans l’inventaire en pdf et sur la fiche de l’objet sélectionné sur le plan",
  "models.ItemType.properties.iconShape.label": "Forme de l'icone",
  "models.ItemType.properties.iconShape.description": "La forme de l'icone permet d'influencer son affichage sur le plan",
  "models.ItemType.properties.displayItemReferenceInMap.label": "Afficher les informations sur le plan",
  "models.ItemType.properties.displayItemReferenceInMap.description": "Permet d’afficher le champ « Référence » de chaque objet sur le plan",
  "models.ItemType.properties.code.label": "Code",
  "models.ItemType.properties.code.description": "Permet d'avoir accès rapidement au type d’objet en tapant le code dans la recherche lors de la création d’objet",
  "models.ItemType.properties.icon.label": "Icône",
  "models.ItemType.properties.icon.description": "Vous donne accès à trois types d’icône: 1) Les Icones de « Fontawsome », visibles en cochant « tout afficher » ou en recherchant par mot clé en anglais dans la case de recherche; 2) Les Icones « SURFY » destinées aux illustrations ajoutées sur les plans aux endroits stratégiques (Toilettes, Escaliers, Ascenseurs, Points Copie, etc) mais qui peuvent également être utilisées comme des icones classiques; 3) Les Icones « SURFY 2 » listant les icones réglementaires de la norme de Sécurité ISO 7010; Leur forme peut être ronde, carrée ou triangulaire",
  "models.ItemType.properties.color.label": "Couleur",
  "models.ItemType.properties.color.description": "Peut être choisie parmi une pré sélection, ou en sélection avancée par code Hexa ou RGB pour respecter votre charte graphique",
  "models.ItemType.properties.height.label": "Hauteur",
  "models.ItemType.properties.height.description": "Permet de donner la hauteur en centimètres du type d'objet dans la vision en 3d",
  "models.ItemType.properties.price.label": "Prix",
  "models.ItemType.properties.price.description": "Le prix d'achat du type d'objet",
  "models.ItemType.properties.seatsCount.label": "Nombre de places assises",
  "models.ItemType.properties.seatsCount.description": "Le nombre de places assises de ce type d'objet (fauteuil, siège, canapé, etc) est cumulé dans Surfy par espace, étage et bâtiment",
  "models.ItemType.properties.manufacturer.description": "Permet d'identifier le fabricant du type d'objet",
  "models.ItemType.properties.carbonFootprint.label": "Empreinte Carbone",
  "models.ItemType.properties.carbonFootprint.description": "L'empreinte carbone est le poids en Kilogrammes de CO2 émis par chaque objet issu de ce type d'objet; il est donné par le fabricant",
  "models.ItemType.properties.iconBackgroundColor.label": "Couleur de fond de l'icône",
  "models.ItemType.properties.iconBackgroundColor.description": "La couleur de fond permet de configurer correctement les icones multi-couleurs, notamment triangulaires",
  "models.ItemType.properties.iconBorderColor.label": "Couleur de bordure de l'icône",
  "models.ItemType.properties.iconBorderColor.description": "La couleur de bordure permet de configurer correctement les icones multi-couleurs, notamment triangulaires",
  "models.ItemType.properties.isAffectable.label": "Est associable à une personne ?",
  "models.ItemType.properties.isAffectable.description": "Permet de savoir si le type d'objet est associable à une personne",
  "models.ItemType.properties.excludeFromPathfinding.label": "Activer la navigation",
  "models.ItemType.properties.excludeFromPathfinding.description": "Permet d'activer la navigation pour ce type d'objet",
  "models.ItemType.views.shape-editor.help": "Editer la forme du type d'objet %{name}",
  "models.ItemType.views.shape-editor.label": "Editer la forme",
  "models.ItemType.views.avatar.help": "Voir la forme de %{name}",
  "models.ItemType.views.avatar.label": "Forme",
  "models.ItemType.views.dq-not-used.label": "Non utilisés",
  "models.ItemType.views.dq-not-used.help": "Lister tous les types d'objets non utilisés via des objets ou via des types de poste de travail non utilisés",
  "models.ItemToPerson.singular": "Association d'objet à personne",
  "models.ItemToPerson.plural": "Associations d'objet à personne",
  "models.ItemToPerson.description": "Permet d'associer un objet à une personne (siège ergonomique, casier)",
  "models.ItemToPerson.determinant.defined": "l'association d'objet à personne",
  "models.ItemToPerson.determinant.undefined": "une association d'objet à personne",
  "models.ItemToPerson.determinants.defined": "les associations d'objet à personne",
  "models.ItemToPerson.determinants.undefined": "des associations d'objet à personne",
  "models.ItemFact.singular": "Mouvement d'objet",
  "models.ItemFact.plural": "Mouvements d'objet",
  "models.ItemFact.determinant.defined": "le mouvement d'un objet",
  "models.ItemFact.determinant.undefined": "un mouvement d'objet",
  "models.ItemFact.determinants.defined": "les mouvements d'objet",
  "models.ItemFact.determinants.undefined": "des mouvements d'objet",
  "models.Item.singular": "objet",
  "models.Item.plural": "objets",
  "models.Item.determinant.defined": "l'objet",
  "models.Item.determinant.undefined": "un objet",
  "models.Item.determinants.defined": "les objets",
  "models.Item.determinants.undefined": "des objets",
  "models.Item.views.dq-item-not-in-workplace-room.label": "Espaces des objets differents des espaces des postes de travail",
  "models.Item.views.dq-item-not-in-workplace-room.help": "Liste des objets physiques dans des postes de travail qui sont dans des espaces qui sont differents des espaces des postes de travail",
  "models.Item.properties.id.label": "Identifiant de l'objet",
  "models.Item.properties.price.label": "Prix",
  "models.Item.properties.price.description": "Le prix d'achat de l'objet s'il est différent du prix du type d'objet",
  "models.Item.properties.reference.label": "Référence de l'objet",
  "models.Item.properties.reference.description": "La référence de l'objet est utilisé pour le retrouver et pour differencier cet objet des autres",
  "models.Item.properties.code.label": "Code d'immobilisation",
  "models.Item.properties.code.description": "Le numéro d'immobilisation est utilisé pour conserver le numéro comptable",
  "models.Item.properties.purchaseDate.label": "Date d'achat",
  "models.Item.properties.purchaseDate.description": "La date d'achat de l'objet",
  "models.Item.properties.room.label": "Espace de l'objet",
  "models.Item.properties.itemAffectationsCount.label": "Nombre d'associations aux personnes",
  "models.Item.properties.itemAffectationsCount.description": "Le nombre d'associations de cet objet aux personnes",
  "models.Floor.singular": "étage",
  "models.Floor.plural": "étages",
  "models.Floor.determinant.defined": "l'étage",
  "models.Floor.determinant.undefined": "un étage",
  "models.Floor.determinants.defined": "les étages",
  "models.Floor.determinants.undefined": "des étages",
  "models.Floor.description": "Les étages represent un plateau de travail ou un niveau d'un bâtiment",
  "models.Floor.views.map.help": "Le plan de l'étage %{name} en 2d",
  "models.Floor.views.map.label": "Plan 2d",
  "models.Floor.views.3d.help": "Le plan de l'étage %{name} en 3d",
  "models.Floor.views.3d.label": "Plan 3d",
  "models.Floor.views.cuby.help": "Le plan de l'étage %{name} en 3d",
  "models.Floor.views.cuby.label": "3d",
  "models.Floor.views.simple-list.help": "Lister les étages avec peu de détails",
  "models.Floor.views.simple-list.label": "Liste Simple",
  "models.Floor.views.geojson.help": "Voir les infos en GeoJson",
  "models.Floor.views.geojson.label": "Copier les coordonnées GeoJson",
  "models.Floor.views.standalone-2d-map.help": "Le plan de l'étage %{name} en 2d sans menu",
  "models.Floor.views.standalone-2d-map.label": "Plan 2d uniquement",
  "models.Floor.properties.id.label": "Identifiant de l'étage",
  "models.Floor.properties.name.label": "Nom de l'étage",
  "models.Floor.properties.name.description": "Le nom de l'étage est utilisé pour pouvoir le retrouver facilement.",
  "models.Floor.properties.level.label": "Niveau",
  "models.Floor.properties.level.description": "Le niveau de l'étage permet de définir sa position par rapport aux autres étages, par exemple utilisez 0 pour le RDC ou -1 pour les parkings",
  "models.Floor.properties.backgroundLayout.label": "Fond de plan",
  "models.Floor.properties.backgroundLayout.description": "Le fond de plan permet d'avoir un premier niveau de calque afin de pouvoir redessiner les plans, il doit être à l'échelle",
  "models.Floor.properties.backgroundLayoutOpacity.label": "Opacité du fond de plan",
  "models.Floor.properties.backgroundLayoutOpacity.description": "L'opacité permet de voir plus ou moins le fond de plan",
  "models.Floor.properties.regulatoryCapacity.label": "Capacité réglementaire",
  "models.Floor.properties.regulatoryCapacity.description": "La capacité réglementaire du plateau, permet de gérer l'évacuation du public et des employés",
  "models.Floor.properties.pathfindingGraph.label": "Graphe de navigation de l'étage",
  "models.Floor.properties.pathfindingGraph.description": "Le graphe de navigation permet de calculer les chemins les plus courts entre les points de l'étage",
  "models.Floor.properties.workplacesCount.label": "Nombre de postes de travail",
  "models.Floor.properties.workplacesCount.description": "Le nombre de postes de travail dans l'étage est calculé automatiquement",
  "models.Floor.properties.workplacesRatio.label": "Ratio postes de travail",
  "models.Floor.properties.workplacesRatio.description": "Le ratio postes de travail est le nombre de métres carrés dans l'étage divisé par le nombre de postes de travail, cette valeur est calculé automatiquement",
  "models.Floor.properties.peopleCount.label": "Nombre d'affectations",
  "models.Floor.properties.peopleCount.description": "Le nombre de personnes affectées dans la l'étage, soit directement affécté aux espaces, soit à travers un poste de travail",
  "models.Floor.properties.totalPeopleCount.label": "Nombre d'affectations totale",
  "models.Floor.properties.totalPeopleCount.description": "Le nombre de personnes affectées dans la l'étage, soit directement affécté aux espaces, soit à travers un poste de travail",
  "models.Floor.properties.peopleRatio.label": "Ratio d'occupation",
  "models.Floor.properties.peopleRatio.description": "Le ratio d'occupation est le nombre de métres carrés dans l'étage divisé par le nombre de personnes affectées soit directement dans les espaces, soit via un poste de travail, cette valeur est calculée",
  "models.Floor.properties.freeWorkplacesCount.label": "Nombre de postes libres",
  "models.Floor.properties.freeWorkplacesCount.description": "Nombre de postes libres dans l'étage",
  "models.Floor.properties.flexWorkplacesCount.label": "Nombre de postes flex",
  "models.Floor.properties.flexWorkplacesCount.description": "Nombre de postes flex dans l'étage",
  "models.Floor.properties.roomsArea.label": "Surface qualifiée",
  "models.Floor.properties.roomsArea.description": "La surface qualifiée est la somme des surfaces des espaces",
  "models.Floor.properties.roomsCount.label": "Nombre d'espaces",
  "models.Floor.properties.roomsCount.description": "Le nombre d'espaces présent dans cet étage",
  "models.Floor.properties.sharedWorkplacesCount.label": "Nombre de postes de travail partagés",
  "models.Floor.properties.sharedWorkplacesCount.description": "Nombre de postes de travail partagés dans l'étage par au moins 2 personnes",
  "models.Floor.properties.sharedWorkplacesRatio.label": "Taux de postes de travail partagés",
  "models.Floor.properties.sharedWorkplacesRatio.description": "Taux de postes de travail partagés par au moins 2 personnes par rapport à l'ensemble des postes de travail de l'étage",
  "models.Floor.properties.flexRatio.label": "Taux de postes de travail en flex",
  "models.Floor.properties.flexRatio.description": "Le taux de poste de travail en flex est calculé en divisant le nombre de postes de travail en flex par le nombre total de postes de travail",
  "models.Floor.properties.transitWorkplacesCount.label": "Nombre de postes de travail de passage",
  "models.Floor.properties.transitWorkplacesCount.description": "Nombre de postes de travail de passage, ces postes ne sont pas comptabilisés dans les postes libres et ne sont pas en flex",
  "models.Floor.properties.height.label": "Hauteur sous plafond",
  "models.Floor.properties.height.description": "La hauteur sous plafond de l'étage",
  "models.Floor.properties.mapScale.label": "Échelle du plan",
  "models.Floor.properties.mapScale.description": "L'échelle permet de calculer en proportion les surfaces réelles et la taille des objets",
  "models.FactType.singular": "Type de Fait",
  "models.FactType.plural": "Types de Fait",
  "models.FactType.determinant.defined": "le type de fait",
  "models.FactType.determinant.undefined": "un type de fait",
  "models.FactType.determinants.defined": "les types de fait",
  "models.FactType.determinants.undefined": "des types de fait",
  "models.Fact.singular": "Fait",
  "models.Fact.plural": "Faits",
  "models.Fact.determinant.defined": "le fait",
  "models.Fact.determinant.undefined": "un fait",
  "models.Fact.determinants.defined": "les faits",
  "models.Fact.determinants.undefined": "des faits",
  "models.DistributionCostType.singular": "type de distribution des coûts",
  "models.DistributionCostType.plural": "types de distribution des coûts",
  "models.DistributionCostType.determinant.defined": "le type de distribution des coûts",
  "models.DistributionCostType.determinant.undefined": "un type de distribution des coûts",
  "models.DistributionCostType.determinants.defined": "les types de distribution des coûts",
  "models.DistributionCostType.determinants.undefined": "des types de distribution des coûts",
  "models.DistributionCostType.properties.name.label": "Nom du type de distribution des coûts",
  "models.DistributionCostType.properties.code.labe": "Code",
  "models.DistributionCostType.properties.code.description": "Le code est utilisé afin de pouvoir calculer automatiquement les coûts associés",
  "models.DimensionTypeToBuilding.singular": "Type de calque d'affectation du bâtiment",
  "models.DimensionTypeToBuilding.plural": "Types de calques d'affectation du bâtiment",
  "models.DimensionTypeToBuilding.determinant.defined": "le type de calque d'affectation du bâtiment",
  "models.DimensionTypeToBuilding.determinant.undefined": "un type de calque d'affectation du bâtiment",
  "models.DimensionTypeToBuilding.determinants.defined": "les types de calques d'affectation du bâtiment",
  "models.DimensionTypeToBuilding.determinants.undefined": "des types de calques d'affectation du bâtiment",
  "models.DimensionTypeToBuilding.description": "Les types de calques d'affectation du bâtiment permettent de définir les différents types de calques d'affectation du bâtiment. En associant un type de calque d'affectation à un bâtiment, cela permet de transformer un calque d'analyse en calque d'affectation.",
  "models.DimensionType.singular": "Type de calque",
  "models.DimensionType.plural": "Types de calque",
  "models.DimensionType.determinant.defined": "le type de calque",
  "models.DimensionType.determinant.undefined": "un type de calque",
  "models.DimensionType.determinants.defined": "les types de calque",
  "models.DimensionType.determinants.undefined": "des types de calque par étage",
  "models.DimensionType.properties.id.label": "Identifiant du type de dimension",
  "models.DimensionType.properties.order.label": "Ordre d'affichage",
  "models.DimensionType.properties.order.description": "Permet de trier les types de calque pour les afficher",
  "models.DimensionType.properties.name.label": "Nom du type de dimension",
  "models.DimensionType.properties.code.label": "Code du type de dimension",
  "models.DimensionType.properties.code.description": "Le code permet d'identifier le type de dimension, il est utilisé lorsque des calculs spécifiques s'appliquent sur le type de dimension",
  "models.DimensionToPerson.singular": "Affectation au calque d'affectation",
  "models.DimensionToPerson.plural": "Affectations aux calques d'affectation",
  "models.DimensionToPerson.description": "Permet d'affecter une personne à un quartier, territoire ou village",
  "models.DimensionToPerson.determinant.defined": "l'affectation au calque d'affectation",
  "models.DimensionToPerson.determinant.undefined": "une affectation au calque d'affectation ",
  "models.DimensionToPerson.determinants.defined": "les affectations aux calques d'affectation",
  "models.DimensionToPerson.determinants.undefined": "des affectations aux calques d'affectation",
  "models.DimensionRoom.singular": "Calque d'analyse des espaces",
  "models.DimensionRoom.plural": "Calques d'analyse des espaces",
  "models.DimensionRoom.determinant.defined": "le calque d'analyse des espaces",
  "models.DimensionRoom.determinant.undefined": "un calque d'analyse des espaces",
  "models.DimensionRoom.determinants.defined": "les calques d'analyse des espaces",
  "models.DimensionRoom.determinants.undefined": "des calques d'analyse des espaces",
  "models.DimensionRoom.properties.id.label": "Identifiant du calque d'analyse des espaces",
  "models.DimensionFloor.singular": "Calque d'analyse par étage",
  "models.DimensionFloor.plural": "Calques d'analyse par étage",
  "models.DimensionFloor.determinant.defined": "le calque d'analyse par étage",
  "models.DimensionFloor.determinant.undefined": "un calque d'analyse par étage",
  "models.DimensionFloor.determinants.defined": "les calques d'analyse par étage",
  "models.DimensionFloor.determinants.undefined": "des calques d'analyse par étage",
  "models.DimensionFloor.properties.id.label": "Identifiant du calque d'analyse par étage",
  "models.DimensionFloor.properties.peopleCount.label": "Nombre d'affectations",
  "models.DimensionFloor.properties.peopleCount.description": "Le nombre de personnes affectées, soit directement affécté aux espaces, soit à travers un poste de travail pour cet étage",
  "models.DimensionFloor.properties.totalPeopleCount.label": "Nombre total d'affectations indirects sur l'étage",
  "models.DimensionFloor.properties.totalPeopleCount.description": "Le nombre total de personnes affectées indirects sur l'étage, soit directement affécté aux espaces, soit à travers un poste de travail, mais pas via les calques d'affectations qui sont qu'au niveau du bâtiment",
  "models.DimensionBuilding.singular": "Calque d'analyse par bâtiment",
  "models.DimensionBuilding.plural": "Calques d'analyse par bâtiment",
  "models.DimensionBuilding.determinant.defined": "le calque d'analyse par bâtiment",
  "models.DimensionBuilding.determinant.undefined": "un calque d'analyse par bâtiment",
  "models.DimensionBuilding.determinants.defined": "les calques d'analyse par bâtiment",
  "models.DimensionBuilding.determinants.undefined": "des calques d'analyse par bâtiment",
  "models.DimensionBuilding.properties.id.label": "Identifiant du calque d'analyse par bâtiment",
  "models.DimensionBuilding.properties.dimensionPeopleCount.label": "Nombre d'affectations directement à ce calque d'affectation",
  "models.DimensionBuilding.properties.dimensionPeopleCount.description": "Le nombre de personnes qui sont affectées à ce calque d'affectation pour l'ensemble du bâtiment",
  "models.DimensionBuilding.properties.totalPeopleCount.label": "Nombre total d'affectations",
  "models.DimensionBuilding.properties.totalPeopleCount.description": "Le nombre total de personnes affectées, soit directement affécté aux espaces, soit à travers un poste de travail, soit via un calque d'affectation",
  "models.Dimension.singular": "Calque d'analyse",
  "models.Dimension.plural": "Calques d'analyse",
  "models.Dimension.determinant.defined": "le calque d'analyse",
  "models.Dimension.determinant.undefined": "un calque d'analyse",
  "models.Dimension.determinants.defined": "les calques d'analyse",
  "models.Dimension.determinants.undefined": "des calques d'analyse",
  "models.Dimension.properties.id.label": "Identifiant du calque d'analyse",
  "models.Dimension.properties.id.description": "Identifiant interne à Surfy",
  "models.Dimension.properties.name.label": "Nom du calque d'analyse",
  "models.Dimension.properties.name.description": "Utile pour différencier le calque parmis d'autres",
  "models.Dimension.properties.color.label": "Couleur",
  "models.Dimension.properties.color.description": "La couleur de calque d'analyse permet de différencier les espaces sur le plan",
  "models.Dimension.properties.value.label": "Valeur numérique",
  "models.Dimension.properties.value.description": "La valeur peut être utilisé pour associé le calque à une valeur numérique afin de pouvoir réaliser des statisques analytiques",
  "models.Dimension.properties.peopleCount.label": "Nombre d'affectations directes",
  "models.Dimension.properties.peopleCount.description": "Le nombre de personnes qui sont affectées directement à ce calque d'affectation dans le bâtiment",
  "models.Dimension.properties.manualPeopleCount.label": "Nombre d'affectations directes manuelle",
  "models.Dimension.properties.manualPeopleCount.description": "Le nombre de personnes qui sont affectées directement à ce calque d'affectation sans tenir compte des affectations avec des personnes réelles",
  "models.Dimension.properties.totalPeopleCount.label": "Nombre total d'affectations directes",
  "models.Dimension.properties.totalPeopleCount.description": "Le nombre de personnes total qui sont affectées directement à ce calque d'affectation dans le bâtiment, l'addition des personnes réelles affectés et du nombre de personnes affectés manuellement",
  "models.Dimension.properties.carbonFootprintPerMeter.label": "Empreinte carbone par mètre carré",
  "models.Dimension.properties.carbonFootprintPerMeter.description": "L'empreinte carbone par mètre carré permet de calculer l'empreinte carbone en kilogramme de CO2 d'un calque d'analyse par mètres carrés",
  "models.CostCenterFloor.singular": "centre de coût des étages",
  "models.CostCenterFloor.plural": "centres de coût des étages",
  "models.CostCenterFloor.determinant.defined": "le centre de coût des étages ",
  "models.CostCenterFloor.determinant.undefined": "un centre de coût des étages",
  "models.CostCenterFloor.determinants.defined": "les centres de coût des étages",
  "models.CostCenterFloor.determinants.undefined": "des centres de coût des étages",
  "models.CostCenterBuilding.singular": "centre de coût des bâtiments",
  "models.CostCenterBuilding.plural": "centres de coût des bâtiments",
  "models.CostCenterBuilding.determinant.defined": "le centre de coût des bâtiments ",
  "models.CostCenterBuilding.determinant.undefined": "un centre de coût des bâtiments",
  "models.CostCenterBuilding.determinants.defined": "les centres de coût des bâtiments",
  "models.CostCenterBuilding.determinants.undefined": "des centres de coût des bâtiments",
  "models.CostCenter.singular": "centre de coût",
  "models.CostCenter.plural": "centres de coût",
  "models.CostCenter.description": "Le centre de coût permet de répartir les espaces dynamiquement pour la refacturation",
  "models.CostCenter.determinant.defined": "le centre de coût",
  "models.CostCenter.determinant.undefined": "un centre de coût",
  "models.CostCenter.determinants.defined": "les centres de coût",
  "models.CostCenter.determinants.undefined": "des centres de coût",
  "models.CostCenter.properties.id.label": "Identifiant du centre de coût",
  "models.CostCenter.properties.name.label": "Nom du centre de coût",
  "models.CostCenter.properties.color.label": "Couleur",
  "models.CostCenter.properties.distributeByFloor.label": "Distribuer par étage",
  "models.CostCenter.properties.distributeByFloor.description": "Répartir au prorata l'espace utilisé par ce centre de coût sur l'étage sur les autres centres de coût du même l'étage",
  "models.CostCenter.properties.distributeByBuilding.label": "Distribuer par bâtiment",
  "models.CostCenter.properties.distributeByBuilding.description": "Répartir au prorata l'espace utilisé par ce centre de coût dans le bâtiment sur les autres centres de coût dans le bâtiment",
  "models.ContentRoleToUserCompany.singular": "Rôle de contenu de l'utilisateur de l'entreprise",
  "models.ContentRoleToUserCompany.plural": "Rôles de contenu de l'utilisateur de l'entreprise",
  "models.ContentRoleToUserCompany.determinant.defined": "le rôle de contenu de l'utilisateur de l'entreprise",
  "models.ContentRoleToUserCompany.determinant.undefined": "un rôle de contenu de l'utilisateur de l'entreprise",
  "models.ContentRoleToUserCompany.determinants.defined": "les rôles de contenu de l'utilisateur de l'entreprise",
  "models.ContentRoleToUserCompany.determinants.undefined": "des rôles de contenu de l'utilisateur de l'entreprise",
  "models.ContentRoleToJupUiTenantOperation.singular": "Association rôle de contenu aux opérations d'interface pour une entreprise",
  "models.ContentRoleToJupUiTenantOperation.plural": "Association rôle de contenu aux opérations d'interface pour une entreprise",
  "models.ContentRoleToJupUiTenantOperation.determinant.defined": "l'association du rôle de contenu aux opérations d'interface pour une entreprise",
  "models.ContentRoleToJupUiTenantOperation.determinant.undefined": "une association du rôle de contenu aux opérations d'interface pour une entreprise",
  "models.ContentRoleToJupUiTenantOperation.determinants.defined": "les associations du rôle de contenu aux opérations d'interface pour une entreprise",
  "models.ContentRoleToJupUiTenantOperation.determinants.undefined": "des associations du rôle de contenu aux opérations d'interface pour une entreprise",
  "models.ContentRoleToFloor.singular": "Association rôle de contenu aux étages",
  "models.ContentRoleToFloor.plural": "Associations rôle de contenu aux étages",
  "models.ContentRoleToFloor.determinant.defined": "l'association du rôle de contenu aux étages",
  "models.ContentRoleToFloor.determinant.undefined": "une association du rôle de contenu aux étages",
  "models.ContentRoleToFloor.determinants.defined": "les associations du rôle de contenu aux étages",
  "models.ContentRoleToFloor.determinants.undefined": "des associations du rôle de contenu aux étages",
  "models.ContentRoleToBuilding.singular": "Association rôle de contenu aux bâtiments",
  "models.ContentRoleToBuilding.plural": "Associations rôle de contenu aux bâtiments",
  "models.ContentRoleToBuilding.determinant.defined": "l'association du rôle de contenu aux bâtiments",
  "models.ContentRoleToBuilding.determinant.undefined": "une association du rôle de contenu aux bâtiments",
  "models.ContentRoleToBuilding.determinants.defined": "les associations du rôle de contenu aux bâtiments",
  "models.ContentRoleToBuilding.determinants.undefined": "des associations du rôle de contenu aux bâtiments",
  "models.ContentRole.singular": "Rôle de contenu",
  "models.ContentRole.plural": "Rôles de contenu",
  "models.ContentRole.determinant.defined": "le rôle de contenu",
  "models.ContentRole.determinant.undefined": "un rôle de contenu",
  "models.ContentRole.determinants.defined": "les rôles de contenu",
  "models.ContentRole.determinants.undefined": "des rôles de contenu",
  "models.CompanyType.singular": "type d'entreprise",
  "models.CompanyType.plural": "type d'entreprises",
  "models.CompanyType.determinant.defined": "le type d'entreprise",
  "models.CompanyType.determinant.undefined": "un type d'entreprise",
  "models.CompanyType.determinants.defined": "les types d'entreprises",
  "models.CompanyType.determinants.undefined": "des types d'entreprises",
  "models.CompanyType.properties.name.label": "Nom du type d'entreprise",
  "models.Company.singular": "entreprise",
  "models.Company.plural": "entreprises",
  "models.Company.determinant.defined": "l'entreprise",
  "models.Company.determinant.undefined": "une entreprise",
  "models.Company.determinants.defined": "les entreprises",
  "models.Company.determinants.undefined": "des entreprises",
  "models.Company.properties.id.label": "Identifiant de l'entreprise",
  "models.Company.properties.logoPath.label": "Logo",
  "models.Company.properties.logoPath.description": "Le chemin du logo de votre entreprise",
  "models.Company.properties.iconPath.label": "Icon",
  "models.Company.properties.iconPath.description": "Le logo de l'entreprise en carré",
  "models.Company.properties.name.label": "Nom de l'entreprise",
  "models.Company.properties.workingDaysCount.label": "Nombre de jours de travail par semaine",
  "models.Company.properties.workingDaysCount.description": "Le nombre de jours de travail par semaine peut être 5 pour les jours ouvrés, 6 incluant le samedi et 7 incluant le dimanche",
  "models.Company.views.usage.label": "Utilisation des plateformes",
  "models.Company.views.usage.help": "Comprendre l'usage des plateformes disponibles",
  "models.Company.views.cards.help": "Vue des entreprises en tuile",
  "models.Company.views.cards.label": "Tuiles",
  "models.Company.views.dq-fix-inventory.label": "Cohérence de l'inventaire",
  "models.Company.views.dq-fix-inventory.help": "Trouver et réparer les incohérences de l'inventaire physique et virtuel pour les postes de travail",
  "models.Company.views.dq-shapes-position.label": "Emplacement des formes",
  "models.Company.views.dq-shapes-position.help": "Trouver et repositionner les formes qui se trouvent sur le plan dans un autre espace que celui dans la base de données",
  "models.Company.views.people-info.label": "Statistiques sur les créations d'affectations des personnes",
  "models.Company.views.people-info.help": "Voir les statistiques sur les affectations",
  "models.Company.reports.export-all.fileName": "sauvegarde",
  "models.Company.reports.export-all.help": "Sauvegarder toutes les données de Surfy",
  "models.Company.reports.export-all-duplicate.fileName": "duplication",
  "models.Company.reports.export-all-duplicate.help": "Sauvegarder les données de l'entreprise pour faire une copie de la plateforme",
  "models.Campus.singular": "campus",
  "models.Campus.plural": "campus",
  "models.Campus.description": "Le campus est utilisé pour regrouper des bâtiments qui sont au même endroit.",
  "models.Campus.determinant.defined": "le campus",
  "models.Campus.determinant.undefined": "un campus",
  "models.Campus.determinants.defined": "les campus",
  "models.Campus.determinants.undefined": "des campus",
  "models.Campus.views.cards.help": "Vue groupée des bâtiments",
  "models.Campus.views.cards.label": "Infos",
  "models.Campus.properties.id.label": "Identifiant du campus",
  "models.Campus.properties.name.label": "Nom du campus",
  "models.Campus.properties.name.description": "Nom du campus",
  "models.Campus.properties.color.label": "Couleur",
  "models.Campus.properties.color.description": "Couleur du campus",
  "models.Campus.properties.externalId.label": "Identifiant externe",
  "models.BuildingType.singular": "type de bâtiment",
  "models.BuildingType.plural": "types de bâtiments",
  "models.BuildingType.determinant.defined": "le type de bâtiment",
  "models.BuildingType.determinant.undefined": "un type de bâtiment",
  "models.BuildingType.determinants.defined": "les types de bâtiment",
  "models.BuildingType.determinants.undefined": "des types de bâtiment",
  "models.BuildingType.properties.id.label": "Identifiant du type de bâtiment",
  "models.BuildingType.properties.name.label": "Nom du type de bâtiment",
  "models.BuildingType.properties.name.description": "Nom du type de bâtiment",
  "models.BuildingType.properties.code.label": "Code",
  "models.BuildingType.properties.code.description": "",
  "models.BuildingType.properties.externalId.label": "Identifiant externe",
  "models.BuildingType.properties.externalId.description": "",
  "models.Building.singular": "bâtiment",
  "models.Building.plural": "bâtiments",
  "models.Building.determinant.defined": "le bâtiment",
  "models.Building.determinant.undefined": "un bâtiment",
  "models.Building.determinants.defined": "les bâtiments",
  "models.Building.determinants.undefined": "des bâtiments",
  "models.Building.description": "Le bâtiment est utilisé pour regrouper les étages",
  "models.Building.reports.workplaces.fileName": "Postes de travail",
  "models.Building.reports.workplaces.help": "Rapport des postes de travail du bâtiment",
  "models.Building.reports.allWorkplaces.fileName": "Postes de travail avec affectations",
  "models.Building.reports.allWorkplaces.help": "Rapport de tous les postes de travail du bâtiment incluant les affectations",
  "models.Building.reports.workplaceAffectations.fileName": "Affectations de poste de travail",
  "models.Building.reports.workplaceAffectations.help": "Rapport des affectations aux postes de travail du bâtiment",
  "models.Building.reports.buildingPeople.fileName": "Personnes",
  "models.Building.reports.buildingPeople.help": "Rapport des personnes affectées dans le bâtiment",
  "models.Building.reports.organizations.fileName": "Organisations",
  "models.Building.reports.organizations.help": "Rapport des organisations du bâtiment",
  "models.Building.reports.buildingItems.fileName": "Inventaire",
  "models.Building.reports.buildingItems.help": "Rapport de l'inventaire du bâtiment",
  "models.Building.reports.area.fileName": "Espaces",
  "models.Building.reports.area.help": "Rapport des espaces du bâtiment",
  "models.Building.reports.buildingCleaning.fileName": "Prestations",
  "models.Building.reports.buildingCleaning.help": "Rapport des prestations de nettoyage du bâtiment",
  "models.Building.reports.buildingDimensions.fileName": "Calques d'analyse",
  "models.Building.reports.buildingDimensions.help": "Rapport des calques d'analyse des espaces du bâtiment",
  "models.Building.views.cards.help": "Vue des bâtiments en tuile",
  "models.Building.views.cards.label": "Infos",
  "models.Building.views.pictures.help": "Voir les bâtiments avec des photos",
  "models.Building.views.pictures.label": "Photos",
  "models.Building.views.gmap.help": "Voir les bâtiments sur une carte",
  "models.Building.views.gmap.label": "Carte",
  "models.Building.views.cost-distribution-by-cost-center.help": "<b>Clés de répartition</b> et surface qualifiées par centre de coût pour le batiment %{name}",
  "models.Building.views.cost-distribution-by-cost-center.label": "Clés de répartition",
  "models.Building.views.3d-cards.help": "Voir les bâtiments en 3d",
  "models.Building.views.3d-cards.label": "3d",
  "models.Building.views.assets.help": "Les actifs immobiliers",
  "models.Building.views.assets.label": "Immobilier",
  "models.Building.views.cuby.help": "Le plan en <b>3d</b> interactif du bâtiment %{name}",
  "models.Building.views.cuby.label": "Plan 3d",
  "models.Building.views.3d.help": "Le plan en 3d du bâtiment %{name} (cuby)",
  "models.Building.views.3d.label": "Plan 3d",
  "models.Building.views.clone.help": "Les <b>scénarios</b> et projets du bâtiment %{name}",
  "models.Building.views.clone.label": "Scénarios",
  "models.Building.views.building-ifc.help": "Exporter ce bâtiment en IFC pour le BIM",
  "models.Building.views.building-ifc.label": "IFC",
  "models.Building.views.zbre-sync.help": "Synchroniser le bâtiment avec la plateforme Zbre",
  "models.Building.views.zbre-sync.label": "Synchronisation Zbre",
  "models.Building.views.inventory.help": "<b>L'inventaire</b> du bâtiment %{name}",
  "models.Building.views.inventory.label": "Inventaire",
  "models.Building.views.list-simple.help": "Lister les bâtiments avec peu de détails",
  "models.Building.views.list-simple.label": "Liste simple",
  "models.Building.views.building-3d-gmap.label": "Bâtiment 3d sur le plan",
  "models.Building.views.building-3d-gmap.help": "Voir le bâtiment en 3d sur un plan",
  "models.Building.properties.id.label": "Identifiant du bâtiment",
  "models.Building.properties.name.label": "Nom du bâtiment",
  "models.Building.properties.name.description": "Nom du bâtiment ou du scénario",
  "models.Building.properties.picture.label": "Photo du bâtiment",
  "models.Building.properties.picture.description": "Vous pouvez utiliser une photo de votre bâtiment pour le repérer rapidement depuis la page d'accueil (voir les bâtiments avec des photos) ou pour illustrer les vues des collaborateurs",
  "models.Building.properties.documents.label": "Documents associés",
  "models.Building.properties.documents.description": "Conservez un lien vers l'emplacement des documents associés à ce bâtiment dans votre GED",
  "models.Building.properties.securityDeposit.label": "Dépôt de garantie",
  "models.Building.properties.securityDeposit.description": "Montant de la caution déposée à la signature du bail",
  "models.Building.properties.buildings.label": "Bâtiments scénarios",
  "models.Building.properties.buildings.description": "Scénarios générés à partir de ce bâtiment",
  "models.Building.properties.constructionYear.label": "Année de construction de l'immeuble",
  "models.Building.properties.constructionYear.description": "Année de construction de l'immeuble permettant de mesurer sa vétusté",
  "models.Building.properties.parkingSpaceCount.label": "Nombre de places de parking",
  "models.Building.properties.parkingSpaceCount.description": "Nombre de places de parking disponibles",
  "models.Building.properties.yearlyParkingRent.label": "Loyer annuel des parkings",
  "models.Building.properties.yearlyParkingRent.description": "Part du loyer allouée au parking",
  "models.Building.properties.yearlyTaxFees.label": "Montant des taxes annuelles",
  "models.Building.properties.yearlyTaxFees.description": "Montant total des taxes et impôts",
  "models.Building.properties.yearlyExploitationFees.label": "Charges d'exploitation annuelles",
  "models.Building.properties.yearlyExploitationFees.description": "Montant annuel des charges d'exploitations (exemple : eau, éléctricité)",
  "models.Building.properties.rentReferenceIndex.label": "Indice de référence des loyers",
  "models.Building.properties.rentReferenceIndex.description": "L'indice de référence des loyers (IRL) sert de base pour réviser les loyers des logements vides ou meublés",
  "models.Building.properties.color.label": "Couleur",
  "models.Building.properties.color.description": "La couleur du bâtiment est utilisée pour définir la couleur de fond dans les présentations des étages ou du bâtiment et pouvoir distinguer ce bâtiment des autres",
  "models.Building.properties.roomsCount.label": "Nombre d'espaces",
  "models.Building.properties.roomsCount.description": "Le nombre d'espaces créés dans ce bâtiment",
  "models.Building.properties.roomsArea.label": "Surface qualifiée",
  "models.Building.properties.roomsArea.description": "La surface qualifiée représente l'ensemble des zones modélisées dans Surfy",
  "models.Building.properties.workplacesCount.label": "Nombre de postes de travail",
  "models.Building.properties.workplacesCount.description": "Le nombre de postes de travail dans le bâtiment est calculé automatiquement",
  "models.Building.properties.workplacesRatio.label": "Ratio postes de travail",
  "models.Building.properties.workplacesRatio.description": "Le ratio par poste de travail est le nombre de métres carrés dans le bâtiment divisé par le nombre de postes de travail, cette valeur est calculée automatiquement",
  "models.Building.properties.peopleCount.label": "Nombre d'affectations",
  "models.Building.properties.peopleCount.description": "Le nombre de personnes affectées dans le bâtiment, aux quartiers, aux espaces ou aux postes de travail",
  "models.Building.properties.peopleRatio.label": "Ratio d'occupation",
  "models.Building.properties.peopleRatio.description": "Le ratio d'occupation est le nombre de métres carrés dans le bâtiment divisé par le nombre de personnes affectées soit directement dans les quartiers, espaces, ou postes de travail, cette valeur est calculée",
  "models.Building.properties.freeWorkplacesCount.label": "Nombre de postes libres",
  "models.Building.properties.freeWorkplacesCount.description": "Nombre de postes libres dans le bâtiment",
  "models.Building.properties.flexWorkplacesCount.label": "Nombre de postes flex",
  "models.Building.properties.flexWorkplacesCount.description": "Nombre de postes de travail en flex dans le bâtiment",
  "models.Building.properties.address.label": "Adresse",
  "models.Building.properties.address.description": "L'adresse du bâtiment pour le localiser sur la carte",
  "models.Building.properties.yearlyCondominiumFees.label": "Charges annuelles",
  "models.Building.properties.yearlyCondominiumFees.description": "Montant des charges annuelles de gestion ou de copropriété par exemple",
  "models.Building.properties.yearlyRent.label": "Loyer annuel",
  "models.Building.properties.yearlyRent.description": "Montant du loyer annuel pour ce bâtiment",
  "models.Building.properties.leaseStartDate.label": "Date du début du bail",
  "models.Building.properties.leaseStartDate.description": "Date du début du bail",
  "models.Building.properties.leaseEndDate.label": "Date de fin du bail",
  "models.Building.properties.leaseEndDate.description": "Date de fin du bail",
  "models.Building.properties.purchaseDate.label": "Date d'achat du bâtiment",
  "models.Building.properties.purchaseDate.description": "Date d'achat du bâtiment",
  "models.Building.properties.buildingId.label": "Identifiant du bâtiment de référence",
  "models.Building.properties.buildingId.description": "L'identifiant du bâtiment de référence est utilisé dans le cadre de la création de scénarios, l'identifiant permet l'association avec ce bâtiment",
  "models.Building.properties.building.label": "Bâtiment d'origine",
  "models.Building.properties.building.description": "Le bâtiment d'origne ou de référence est utilisé dans le cadre de la création de scénarios, il permet d'identifier le bâtiment d'origine depuis lequel le bâtiment a été crée",
  "models.Building.properties.jupUiLayout.label": "Vision du plan par défaut",
  "models.Building.properties.jupUiLayout.description": "À la première ouverture d'un plan de ce bâtiment, la vision par défaut sera sélectionné, suite à la première ouverture, ce sera la vision encours qui sera appliqué",
  "models.Building.properties.sharedWorkplacesCount.label": "Nombre de postes de travail partagés",
  "models.Building.properties.sharedWorkplacesCount.description": "Nombre de postes de travail partagés dans le bâtiment par au moins 2 personnes",
  "models.Building.properties.sharedWorkplacesRatio.label": "Taux de postes de travail partagés",
  "models.Building.properties.sharedWorkplacesRatio.description": "Taux de postes de travail partagés par au moins 2 personnes par rapport à l'ensemble des postes de travail du bâtiment",
  "models.Building.properties.flexRatio.label": "Taux de postes de travail en flex",
  "models.Building.properties.flexRatio.description": "Le taux de poste de travail en flex est calculé en divisant le nombre de postes de travail en flex par le nombre total de postes de travail",
  "models.Building.properties.transitWorkplacesCount.label": "Nombre de postes de travail de passage",
  "models.Building.properties.transitWorkplacesCount.description": "Nombre de postes de travail de passage, ces postes ne sont pas comptabilisés dans les postes libres et ne sont pas en flex",
  "models.Building.properties.regulatoryCapacity.label": "Capacité réglementaire",
  "models.Building.properties.regulatoryCapacity.description": "La capacité réglementaire du plateau, permet de gérer l'évacuation du public et des employés",
  "models.Building.properties.dimensionPeopleCount.label": "Nombre d'affectations aux calques",
  "models.Building.properties.dimensionPeopleCount.description": "Le nombre de personnes qui sont affectées aux calques d'affectations associé à ce bâtiment",
  "models.Building.properties.userCompanyOwner.label": "Utilisateur propriétaire du bâitment",
  "models.Building.properties.userCompanyOwner.description": "L'utilisateur propriétaire du bâtiment voit toujours le bâtiment même en présence de rôle de contenu, en cas de création de scénario, l'utilisateur qui a crée le scénario devient le propriétaire, le propriétaire peut être changé par la suite",
  "models.AuthentificationConnection.singular": "Connection d'authentification",
  "models.AuthentificationConnection.plural": "Connections d'authentification",
  "models.AuthentificationConnection.determinant.defined": "la connection d'authentification",
  "models.AuthentificationConnection.determinant.undefined": "une connection d'authentification",
  "models.AuthentificationConnection.determinants.defined": "les connections d'authentification",
  "models.AuthentificationConnection.determinants.undefined": "des connections d'authentification",
  "models.ApiUserToJupRole.singular": "Association d'utilisateur d'api au rôle",
  "models.ApiUserToJupRole.plural": "Associations d'utilisateur d'api au rôle",
  "models.ApiUserToJupRole.determinant.defined": "l'association d'utilisateur d'api au rôle",
  "models.ApiUserToJupRole.determinant.undefined": "une association d'utilisateur d'api au rôle",
  "models.ApiUserToJupRole.determinants.defined": "les associations d'utilisateur d'api au rôle",
  "models.ApiUserToJupRole.determinants.undefined": "des associations d'utilisateur d'api au rôle",
  "models.ApiUserToContentRole.singular": "Association d'utilisateur d'api au rôle de contenu",
  "models.ApiUserToContentRole.plural": "Associations d'utilisateur d'api au rôle de contenu",
  "models.ApiUserToContentRole.determinant.defined": "l'association d'utilisateur d'api au rôle de contenu",
  "models.ApiUserToContentRole.determinant.undefined": "une association d'utilisateur d'api au rôle de contenu",
  "models.ApiUserToContentRole.determinants.defined": "les associations d'utilisateur d'api au rôle de contenu",
  "models.ApiUserToContentRole.determinants.undefined": "des associations d'utilisateur d'api au rôle de contenu",
  "models.ApiUser.singular": "Utilisateur d'api",
  "models.ApiUser.plural": "Utilisateurs d'api",
  "models.ApiUser.determinant.defined": "l'utilisateur d'api",
  "models.ApiUser.determinant.undefined": "un utilisateur d'api",
  "models.ApiUser.determinants.defined": "les utilisateurs d'api",
  "models.ApiUser.determinants.undefined": "des utilisateurs d'api",
  "models.ApiUser.properties.clientSecret.label": "Code secret",
  "models.ApiUser.properties.clientSecret.description": "le mot de passe secret de votre compte API peut être généré et ne devrait jamais être communiqué",
  "ToggleZbreSyncCheckbox.label": "Synchroniser avec les occupations temps réel dans Z#bre",
  "ToggleZbreSyncCheckbox.help": "La synchronisation permet de colorier les espaces et les postes de travail en fonction des capteurs placés dans Z#bre",
  "FloorSpaceSlider.title": "Espace entre chaque étage en centimètres",
  "FloorSelector.title": "Sélectionner les étages",
  "FloorSelector.focus": "Sélectionner uniquement cet étage",
  "FloorSelector.selectAll.false": "Sélectionner tous les étages",
  "FloorSelector.selectAll.true": "Désélectionner tous les étages",
  "ToggleEnableMissingFloors.label": "Afficher les étages fantômes",
  "ToggleEnableMissingFloors.help": "Afficher les étages fantômes pour les étages manquantes entre l'étage de niveau 0 et l'étage la plus haute en fonction des niveaux des vraies étages",
  "RoomGraphHandler.buttons.generateGraph.label": "Générer le graphe d'orientation",
  "RoomGraphHandler.buttons.generateGraph.description": "Générer le graphe d'orientation permet de calculer les nœuds par lesquels la recherche de chemin peut trouver les espaces et le mobilier. Si l'espace d'origine peut être sélectionné, le graphe a déjà été généré.",
  "RoomGraphHandler.buttons.selectOriginRoom.label": "Sélectionner l'espace d'origine",
  "RoomGraphHandler.buttons.selectOriginRoom.description": "Veuillez sélectionner un espace puis vous pourrez via cette option le définir comme espace de départ",
  "RoomGraphHandler.icons.displayNodes.description": "Afficher les chemins dans les pièces",
  "RoomGraphHandler.icons.displayBoundingBoxes.description": "Afficher les espaces d'exclusions du mobilier",
  "RoomGraphHandler.icons.enablePathfinding.description": "Activer le tracé du chemin depuis l'espace source avec la forme sous la souris",
  "RoomGraphHandler.rooms.origin": "Espace d'origine",
  "ThemeModeSwitchMenuItem.dark.label": "Passer en mode lumineux",
  "ThemeModeSwitchMenuItem.dark.help": "Utiliser le mode lumineux permet de travailler avec un fond blanc",
  "ThemeModeSwitchMenuItem.light.label": "Passer en mode sombre",
  "ThemeModeSwitchMenuItem.light.help": "Utiliser le mode sombre permet de travailler avec des couleurs sombre en fond pour moins se fatiguer les yeux",
  "copilot.actions.add.door": "Une porte vient d'être ajoutée par Surfy Copilot",
  "generateDocumentation.properties.technicalName": "Nom technique",
  "generateDocumentation.properties.belongsTo": "Entités associées (unique)",
  "generateDocumentation.properties.hasMany": "Entités associées (liste)",
  "generateDocumentation.properties.base": "Propriétés de base",
  "generateDocumentation.properties.mandatory": "Propriétés obligatoires",
  "help.key1": "hello %{name}",
  "help.key2": "bye %{name}"
};
const en = {
  "ImportUpdateOption.label": "Update",
  "ImportUpdateOption.help": "Update selected objects",
  "ImportUpdateEntitiesTable.description": "List of objects that require updating",
  "PropertyTypeErrors.title": "The following values do not exist for property <b>%{propertyTypeLabel}</b> in <b>%{objectTypeLabel}</b>",
  "ImportDeleteOption.label": "Remove",
  "ImportDeleteOption.help": "Delete selected objects in Surfy",
  "ImportDeleteEntitiesTable.description": "List of objects that require deletion in Surfy",
  "ImportCreateOption.label": "Create",
  "ImportCreateOption.help": "Perform creation of selected objects in Surfy",
  "ImportCreateEntitiesTable.description": "List of objects that require creation",
  "ImportCreateEntitiesTable.open.label": "View entities to create",
  "ImportCreateEntitiesTable.open.help": "See the details of the entities to create because there are more than 500 lines, for performance reasons the lines are hidden by default",
  "ImportCreateAllOption.label": "Create All",
  "ImportCreateAllOption.help": "Perform the creation of all objects without selecting them individually",
  "entitiesImportType.date.wrongImportFormat": "The format of the date %{value} is not correct, the expected format is %{excelImportDateFormat}",
  "InfoTabContent.description": "Notable errors or information during import",
  "InfoTabContent.noChange": "No change was observed in comparison",
  "InfoTabContent.copyIds": "Copy entity IDs to clipboard",
  "InfoTabContent.equals.multiple": "%{count} existing and unmodified objects",
  "InfoTabContent.equals.one": "A single object already existing and not modified",
  "InfoTabContent.open.label": "See import details",
  "InfoTabContent.open.help": "See import detail for identical comparisons",
  "ImportObjectType.tabs.create.label": "Creation",
  "ImportObjectType.tabs.update.label": "Update",
  "ImportObjectType.tabs.errors.label": "Info",
  "ImportObjectType.tabs.delete.label": "Deletion",
  "ImportObjectType.usedKeys": "The reconciliation key used is:",
  "ImportObjectType.errors.noChange": "No modification was observed in comparison",
  "CompareEntities.buttons.reset.label": "Restart",
  "CompareEntities.buttons.reset.help": "Restart the import",
  "ObjectTypeImportKeys.title": "The keys available to reconcile %{determinants.undefined} in the order of your choice, if you wish to modify one of the key properties you must use the identifier as key",
  "ObjectTypeImportScalarProperties.help": "Copy to clipboard",
  "ImportHelpDrawerIconButton.icon.help": "See help on importing data for %{determinants.defined}",
  "ImportHelpDrawerIconButton.drawer.title": "Help with import %{determinants.undefined}",
  "ImportHelpDrawerIconButton.drawer.tabLabel": "Import help",
  "DownloadObjectTypeImportTemplateFileButton.label": "Download the import template",
  "DownloadObjectTypeImportTemplateFileButton.help": "Download an import template in execl with the names of the columns that you can choose",
  "ImportHelpDrawer.tab": "Help import %{objectTypeLabel}",
  "BelongsToListItem.clipboard": "Copy column title to clipboard",
  "BelongsToListItem.noKeys": "No unique key available",
  "BelongsToImportHelp.title": "Object types associated with %{objectTypeLabel} sorted by available import keys",
  "FileDropZone.dropZone": "Move and drag the import file into this area or click in the area to select your file",
  "EntitiesImporter.tabs.file": "File",
  "EntitiesImporter.tabs.copypaste": "Copy and paste",
  "TextAreaImporter.errors.title": "Errors encountered during import",
  "TextAreaImporter.textarea.placeholder": "Copy and paste your columns from Excel with the title to find the properties to update",
  "TextAreaImporter.help": "Use tab between each column by including the name of each column in the first row or paste directly from excel",
  "ImportOptionsBar.buttons.compare.label": "Compare",
  "ImportOptionsBar.buttons.compare.help": "Start the comparison with the data in surfy in order to determine the modifications to import",
  "ImportErrors.errors.title": "Errors encountered during import",
  "DashboardView.tabs.reports": "Excel reports",
  "IconShape.values.circle": "Circle",
  "IconShape.values.rectangle": "Rectangle",
  "IconShape.values.triangle": "Triangle",
  "EntityDialogSearchList.NoResult": "No results were found, please clear your filters or change your search",
  "FieldTypeEntity.edit": "Change %{determinant.defined}",
  "FieldTypeEntity.remove": "Remove %{determinant.defined}",
  "FieldTypeEntity.add": "Add %{determinant.undefined}",
  "LegendSelector.title": "Select legend",
  "LegendSelector.labels.default": "Default caption",
  "HasManyStandaloneNoData.noData": "There is no associated %{targetObjectTypeLabel} for %{determinant.defined}",
  "FieldTypeAddress.edit": "Change address",
  "FieldTypeAddress.remove": "Delete address",
  "AutocompleteAddress.autocomplete.placeholder": "Find your address here",
  "AddressDialog.search": "Find address",
  "AddressDialog.validate": "Validate",
  "FieldTypePassword.icons.copy": "Copy the contents of the password to the clipboard",
  "FieldTypePassword.icons.generate": "Generate a unique password",
  "FieldTypeModel3d.Remove": "Remove 3D model",
  "FieldTypeModel3d.Upload": "Change 3D model",
  "FieldTypeImage.Remove": "Remove image",
  "FieldTypeImage.Upload": "Change image",
  "FieldTypeIcon.Edit": "Change icon",
  "FieldTypeIcon.Remove": "Remove the icon",
  "FieldTypeColor.Remove": "Remove color",
  "FieldTypeColor.NoColorHelp": "Select a color",
  "FieldTypeColor.NotHexMatchError": "The field does not respect the hexadecimal format of a color",
  "CopyImagePathToClipboard.CopyUrl": "Copy url",
  "ColorBox.NoColorHelp": "Select a color via the palette",
  "ChangeColor.classic": "Select a color with the advanced plate",
  "weight.kilogram": "Kilogram",
  "weight.gram": "Gram",
  "distance.meter": "Meters",
  "distance.centimeter": "Centimeters",
  "FieldTypeIndexBoolean.help": "Modify the value directly",
  "FieldTypeIndexBoolean.values.true": "Yes",
  "FieldTypeIndexBoolean.values.false": "No",
  "calculatedProperties.properties.workplacesCount.label": "Number of workstations",
  "calculatedProperties.properties.workplacesCount.description": "The total number of workstations in the spaces",
  "calculatedProperties.properties.workplacesRatio.label": "Workstation ratio",
  "calculatedProperties.properties.workplacesRatio.description": "The workstation ratio is the number of square meters divided by the number of workstations",
  "calculatedProperties.properties.peopleCount.label": "Number of assignments",
  "calculatedProperties.properties.peopleCount.description": "The number of people affected, either directly assigned to the spaces or through a workstation",
  "calculatedProperties.properties.totalPeopleCount.label": "Total number of assignments",
  "calculatedProperties.properties.totalPeopleCount.description": "The total number of people assigned, either directly assigned to spaces or through a workstation",
  "calculatedProperties.properties.peopleRatio.label": "Occupancy ratio",
  "calculatedProperties.properties.peopleRatio.description": "The occupancy ratio is the number of square meters divided by the number of people assigned either directly to the spaces or via a workstation",
  "calculatedProperties.properties.freeWorkplacesCount.label": "Number of vacancies",
  "calculatedProperties.properties.freeWorkplacesCount.description": "Total number of vacancies",
  "calculatedProperties.properties.flexWorkplacesCount.label": "Number of flex positions",
  "calculatedProperties.properties.flexWorkplacesCount.description": "Total number of flex positions",
  "calculatedProperties.properties.occupancyRate.label": "Occupancy rate",
  "calculatedProperties.properties.occupancyRate.description": "Allows you to know the occupancy rate of workstations, it is the number of people assigned divided by the number of workstations",
  "calculatedProperties.properties.expansionRatio.label": "Expansion rate",
  "calculatedProperties.properties.expansionRatio.description": "Allows to know the rate of use of workstations, it is the inverse of the number of people affected divided by the number of workstations",
  "calculatedProperties.properties.roomsArea.label": "Qualified surface",
  "calculatedProperties.properties.roomsArea.description": "The qualified surface is the sum of the surfaces of the spaces",
  "calculatedProperties.properties.roomsCount.label": "Number of spaces",
  "calculatedProperties.properties.roomsCount.description": "The total number of spaces",
  "calculatedProperties.properties.sharedWorkplacesCount.label": "Number of shared workstations",
  "calculatedProperties.properties.sharedWorkplacesCount.description": "Total number of workstations shared by at least 2 people",
  "calculatedProperties.properties.sharedWorkplacesRatio.label": "Rate of shared workstations",
  "calculatedProperties.properties.sharedWorkplacesRatio.description": "Percentage of workstations shared by at least 2 people compared to all workstations",
  "calculatedProperties.properties.flexRatio.label": "Rate of flex workstations",
  "calculatedProperties.properties.flexRatio.description": "The flex workstation rate is calculated by dividing the number of flex workstations by the total number of workstations",
  "calculatedProperties.properties.transitWorkplacesCount.label": "Number of transit workstations",
  "calculatedProperties.properties.transitWorkplacesCount.description": "Number of temporary workstations, these positions are not counted in free positions and are not flex",
  "calculatedProperties.properties.seatsCount.label": "Number of seats",
  "calculatedProperties.properties.seatsCount.description": "The total number of seats",
  "calculatedProperties.properties.seatsPeopleRatio.label": "Seating rate by assignment",
  "calculatedProperties.properties.seatsPeopleRatio.description": "The number of seats per person affected",
  "calculatedProperties.properties.carbonFootprint.label": "Carbon footprint",
  "calculatedProperties.properties.carbonFootprint.description": "The carbon footprint is the number of CO2 emitted",
  "calculatedProperties.properties.totalCapacityCount.label": "Total capacity",
  "calculatedProperties.properties.totalCapacityCount.description": "The total seat capacity is the sum of the number of seats and the non-seated capacity at the space level.",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.label": "Rate of seats per workstation",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.description": "The rate of places per workstation is the total capacity of the spaces divided by the number of workstations, this allows us to understand the rate of places according to the number of workstations",
  "DeleteMultipleDialog.title": "Remove %{determinants.undefined}",
  "DeleteMultipleDialog.content": "You are about to delete <b>%{determinants.undefined}</b> , this action is not reversible and may have impacts, are you sure you want to perform this action?",
  "DeleteMultipleDialog.cancel.label": "Cancel",
  "DeleteMultipleDialog.cancel.help": "Undelete",
  "DeleteMultipleDialog.delete.label": "Remove",
  "DeleteMultipleDialog.delete.help": "Permanently delete %{determinants.defined}",
  "DownloadTableToExcelIconButton.help": "Export %{determinants.defined} selected",
  "DeleteMultipleEntities.help": "Delete selected %{determinants.defined}",
  "EntityCreateModeSelect.open-on-create.text": "Open after creation",
  "EntityCreateModeSelect.open-on-create.help": "Once your object is created, you will be redirected to the object's view page to see its properties and associations.",
  "EntityCreateModeSelect.keep-creating.text": "Continue to create",
  "EntityCreateModeSelect.keep-creating.help": "This option allows you to continue creating several objects in succession while retaining the properties of the old creation",
  "EntityCreateModeSelect.edit-on-create.text": "Edit after creation",
  "EntityCreateModeSelect.edit-on-create.help": "Once your object is created, you will be redirected to the object's edition page in order to complete its properties and associations",
  "TableView.options": "options",
  "ErrorImpossibleToFindTheEntity.text": "It is not possible to find %{determinant.defined} wanted",
  "ErrorImpossibleToFindTheEntities.text": "Cannot find the %{determinants.defined}",
  "EntityPropertyTypesMandatoryNotRespected.title": "The following properties are required",
  "entity.properties.mandatory": "The property %{name} is required.",
  "entity.properties.calculated": "The %{name} is calculated automatically.",
  "entity.properties.readonly-lock": "The %{name} is read-only and can not be modified from this page.",
  "EntityHasManyProperties.associations.others": "Associations for %{determinant.defined}",
  "EntityHasManyProperties.associations.reporting": "Reporting associations for %{determinant.defined}",
  "EntityHasManyProperties.associations.security": "Security associations for %{determinant.defined}",
  "EntitiesView.NoItem": "There is no %{objectType} , you can create your first %{objectType} using the button below",
  "DeleteDialog.title": "Remove %{determinant.undefined}",
  "DeleteDialog.content": "You are about to delete <b>%{determinant.undefined}</b> , this action is not reversible and may have impacts, are you sure you want to perform this action?",
  "DeleteDialog.cancel.label": "Cancel",
  "DeleteDialog.cancel.help": "Undelete",
  "DeleteDialog.delete.label": "Remove",
  "DeleteDialog.delete.help": "Permanently delete %{determinant.defined}",
  "ExportQueryNodeToFileButton.help.list": "Download in excel %{determinants.defined}",
  "entity.excel.headers.count": "%{label} : Number",
  "entity.properties.externalId.label": "External key",
  "entity.properties.externalId.description": "This field can be used to remember the correspondence key in another software",
  "entity.properties.createdAt.label": "Creation date",
  "entity.properties.createdAt.description": "Date of creation in Surfy, allows you to know the history of creation in Surfy",
  "entity.properties.userCompanyCreatedBy.label": "Created by user",
  "entity.properties.userCompanyCreatedBy.description": "Create by this user in Surfy, allows you to know the history of the creation in Surfy",
  "entity.properties.userCompanyCreatedById.label": "ID of the user who created",
  "entity.properties.userCompanyCreatedById.description": "Create by the identifier of this user in Surfy, allows you to know the history of the creation in Surfy",
  "entity.properties.userCompanyUpdatedById.label": "ID of the user who modified",
  "entity.properties.userCompanyUpdatedById.description": "Updated by the identifier of this user in Surfy, allows you to know the history of the creation in Surfy",
  "entity.properties.userCompanyUpdatedBy.label": "Updated by user",
  "entity.properties.userCompanyUpdatedBy.description": "Updated by this user in Surfy, allows to know the history of the modification in Surfy",
  "entity.properties.updatedAt.label": "Date of update",
  "entity.properties.updatedAt.description": "Update date in Surfy, allows you to know the history of modifications",
  "entity.delete.button.label": "Remove",
  "entity.delete.button.help": "Delete %{determinant.defined} %{name}",
  "entity.cancel": "Cancel",
  "entity.see.label": "See",
  "entity.see.help": "See %{determinant.defined} %{name}",
  "entity.views.dataquality.help": "Reports and actions for data quality for %{determinants.defined}",
  "entity.views.dataquality.label": "Data quality",
  "entity.views.list.help": "List %{determinants.defined}",
  "entity.views.list.label": "List",
  "entity.views.import.help": "Import %{determinants.undefined}",
  "entity.views.import.label": "Import",
  "entity.views.details.help": "See %{determinant.defined} %{name}",
  "entity.views.details.label": "See",
  "entity.views.create.help": "Create %{determinant.undefined}",
  "entity.views.create.label": "Create",
  "entity.views.edit.help": "Edit %{determinant.defined} %{name}",
  "entity.views.edit.label": "Edit",
  "entity.views.dashboard.help": "Dashboard for %{determinant.defined} %{name}",
  "entity.views.dashboard.label": "Dashboard",
  "entity.create.validate.help": "Validate creative for %{determinant.defined}",
  "entity.create.validate.label": "Validate the creation",
  "entity.create.button.help": "Start creation for %{determinant.defined}",
  "entity.create.button.label": "Create %{determinant.defined}",
  "entity.create.association.help": "Start creation for %{determinant.undefined}",
  "entity.create.association.label": "Create %{determinant.undefined}",
  "entity.update.button.label": "Save",
  "entity.update.button.help": "Save %{determinant.defined} %{name}",
  "entity.createAndAssociate.button.label": "Create and associate",
  "entity.createAndAssociate.button.help": "Create and associate %{determinant.undefined}",
  "entity.associate.button.label": "Associate",
  "entity.associate.button.help": "Associate %{determinant.undefined}",
  "entity.back": "Return",
  "WorkCanvas.Options.ZoomCanvasOption.label.enable": "Enable magnifier around mouse",
  "WorkCanvas.Options.ZoomCanvasOption.label.disable": "Disable magnifier around mouse",
  "WorkCanvas.Options.ZoomCanvasOption.help.enable": "Activating the magnifying glass allows you to keep an overview of an area or floor and see the behavior of the mouse in a precise way",
  "WorkCanvas.Options.ZoomCanvasOption.help.disable": "Stop mouse magnifier",
  "WorkCanvas.Options.AddSegmentPointOption.label.enable": "Add a vertex on a segment",
  "WorkCanvas.Options.AddSegmentPointOption.label.disable": "Stop adding a vertex on a segment",
  "WorkCanvas.Options.AddSegmentPointOption.help.enable": "Adding a vertex on a segment allows you to put a point anywhere without taking into account the other points",
  "WorkCanvas.Options.AddSegmentPointOption.help.disable": "Stop creating vertices on segments",
  "WorkCanvas.Options.AddSegmentPointOption.description": "Select a space to be able to create a vertex on one of the segments",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.enable": "Activate the inversion of the orientation of the creation of the vertices",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.disable": "Disable the inversion of the orientation of the creation of the vertices",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.enable": "Activating the inversion of the orientation of the creation of the vertices allows to change the direction of creation of the vertices",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.disable": "Deactivate the inversion to find the initial direction of creation of the vertices",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.enable": "Activate the inversion of the right angle for the creation of the vertices",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.disable": "Disable inversion of the right angle for the creation of vertices",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.enable": "Activate the inversion allows to use the right angle during the creation of the vertices on the other segment",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.disable": "Disable inversion allows to use the right angle on the initial segment",
  "LoadingSvgCircle.pleaseWait": "Please wait while syncing",
  "WorkCanvas.Options.AddRoomPointOption.label.enable": "Add a summit",
  "WorkCanvas.Options.AddRoomPointOption.label.disable": "Stop adding a vertex",
  "WorkCanvas.Options.AddRoomPointOption.help.enable": "Adding a vertex makes it possible to rework with more precision a form",
  "WorkCanvas.Options.AddRoomPointOption.help.disable": "Stop creating summits",
  "WorkCanvas.Options.SplitPolygoneOption.label": "Separate space",
  "WorkCanvas.Options.SplitPolygoneOption.help": "Create 2 spaces from another space by choosing 2 vertices",
  "WorkCanvas.Options.SplitRoomPointOption.help": "Split vertex allows multiple vertices to be reused for each segment and thus create separate spaces",
  "WorkCanvas.Options.SplitRoomPointOption.label": "Separate vertex",
  "WorkCanvas.Options.MergeRoomPointsOption.help": "Merge vertices allows to reuse the same vertex for different spaces",
  "WorkCanvas.Options.MergeRoomPointsOption.label": "Merge vertices",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.help": "Remove vertices from space",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.label": "Remove selected vertices",
  "WorkCanvas.Options.ZoomOnEdgePoints.help": "Focus on one or more points so you can work quietly",
  "WorkCanvas.Options.ZoomOnEdgePoints.label": "Focus on points",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.enable": "Move object type",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.disable": "Stop moving",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.enable": "Move the object type on the plane",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.disable": "Stop moving object type",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.help": "Remove object type from workstation type",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.label": "Remove object type",
  "WorkCanvas.Options.DeleteItemTypePointsOption.help": "Remove vertices from object type",
  "WorkCanvas.Options.DeleteItemTypePointsOption.label": "Remove selected vertices",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.enable": "Add a shape",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.disable": "Stop adding the shape",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.enable": "Add a shape for an object type on the plan",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.disable": "Stop creating the shape",
  "WorkCanvas.Options.AddItemTypeShapeSaveOption.help": "Save the type of object being created",
  "WorkCanvas.Options.AddItemTypePointOption.label.enable": "Add a summit",
  "WorkCanvas.Options.AddItemTypePointOption.label.disable": "Stop adding a vertex",
  "WorkCanvas.Options.AddItemTypePointOption.help.enable": "Adding a vertex makes it possible to rework with more precision a form",
  "WorkCanvas.Options.AddItemTypePointOption.help.disable": "Stop creating summits",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.enable": "Move spaces",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.disable": "Stop travel",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.enable": "Enable moving spaces on the plan",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.disable": "Stop Moving Spaces",
  "WorkCanvas.Options.ToggleMoveRoomOption.description": "Once activated, select a space and you can move it",
  "WorkCanvas.Options.DuplicateShapesOption.label": "Duplicate shapes",
  "WorkCanvas.Options.DuplicateShapesOption.help": "Duplicate shapes without properties to quickly create objects or workstations on the plan",
  "CancelDuplicateShapsToRoomMouse.help": "Undo duplicate shapes",
  "ToggleWorkplaceFreeConditionTypeIconButton.or": "See free workstations for all requested days",
  "ToggleWorkplaceFreeConditionTypeIconButton.and": "See free workstations for at least one of the requested days",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.false": "Color free posts %{day}",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.true": "Stop coloring free posts %{day}",
  "FreeWorkplacesDayList.title": "See free places %{days}",
  "FreeWorkplacesDayList.conditions.and": "And",
  "FreeWorkplacesDayList.conditions.or": "Or",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.enable": "Color the checkpoints",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.disable": "Stop coloring crossing posts",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.enable": "See on the color map the workstations that are passing through",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.disable": "No longer seeing passing workstations in a different way on the map",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.enable": "Color shared posts",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.disable": "Stop coloring shared posts",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.enable": "See on the color plan the workstations that are shared by at least 2 people",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.disable": "No longer see shared workstations in a different way on the map",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.enable": "Color the objects without association",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.disable": "Stop coloring objects without association",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.enable": "See free objects on the map",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.disable": "No longer see free objects differently on the map",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.enable": "Color the reservable positions",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.disable": "Stop coloring reservable positions",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.enable": "See on the color plan the workstations that are reservable",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.disable": "No longer see reservable workstations differently in terms of",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.enable": "Coloring free positions",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.disable": "Stop coloring free posts",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.enable": "See the free positions on the map",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.disable": "No longer see free positions differently on the plan",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.enable": "Color the posts in flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.disable": "Stop coloring posts in flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.enable": "See the flex positions on the map",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.disable": "No longer see flex positions differently on the plan",
  "WorkCanvas.Options.CalibrateLayoutOption.help.enable": "Calibrate the map allows you to enlarge or reduce the size of all spaces or move them all on the map",
  "WorkCanvas.Options.CalibrateLayoutOption.help.disable": "Stop calibrating the plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.enable": "Calibrate the plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.disable": "Stop calibrating the plan",
  "CalibrateLayoutDrawer.title": "Calibrate the plan",
  "CalibrateLayoutDrawer.options.mapScale.label": "Align plan scale",
  "CalibrateLayoutDrawer.options.mapScale.help": "Apply the scale factor to the elements of the scale (length and size of texts)",
  "CalibrateLayoutDrawer.options.inputs.scale.label": "Scale factor",
  "CalibrateLayoutDrawer.options.inputs.step.label": "Translation value",
  "CalibrateLayoutDrawer.options.inputs.translate.x.label": "The X axis",
  "CalibrateLayoutDrawer.options.inputs.translate.y.label": "Y axis",
  "CalibrateLayoutDrawer.options.reduce.label": "Reduce",
  "CalibrateLayoutDrawer.options.save.label": "To register",
  "CalibrateLayoutDrawer.options.save.help": "Save the calibration on the plan",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.enable": "Activate the display of icons on the plan in 2d",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.disable": "Disable the display of icons on the map",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.enable": "The icons associated with the types of spaces make it easier to visualize the types of spaces on the plan",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.disable": "View space information",
  "WorkCanvasToggleOptionHelp.shortcut": "Keyboard shortcut: <b>%{shortcut}</b>",
  "WorkCanvasShortcutTooltipHelp.help": "Keyboard shortcut: <b>%{shortcut}</b>",
  "WorkCanvas.Options.ZoomOutOption.label": "Zoom out on the map",
  "WorkCanvas.Options.ZoomOutOption.help": "Zoom out on the map by centering on the position of the mouse",
  "WorkCanvas.Options.ZoomOutOption.description": "You can use the mouse wheel and your touchpad to zoom out",
  "WorkCanvas.Options.ZoomOnMousePosition.help": "Zoom in on the mouse position to be able to work more precisely on an area",
  "WorkCanvas.Options.ZoomOnMousePosition.label": "Zoom in on the mouse position",
  "WorkCanvasLoadingIcon.title": "Loading the plan",
  "WorkCanvas.Options.ZoomOnItemsOption.help": "Zoom in on one or more objects in order to be able to work more precisely",
  "WorkCanvas.Options.ZoomOnItemsOption.label": "Zoom in on the selection",
  "WorkCanvas.Options.ZoomOnDimensionsOption.label": "Zoom into assignment layers",
  "WorkCanvas.Options.ZoomOnDimensionsOption.help": "Zoom directly to the assignment layers in which you can reserve on the plan",
  "WorkCanvas.Options.ZoomInOption.label": "Zoom in on the map",
  "WorkCanvas.Options.ZoomInOption.help": "Zoom in on the map by centering towards the top left of the screen",
  "WorkCanvas.Options.ZoomInOption.description": "You can use the mouse wheel and your touchpad to zoom",
  "WorkCanvas.Options.ToggleSelectModeOption.help.enable": "Get the plan options to be able to zoom or see the details of the shapes and activate the keyboard shortcuts, you can also click in the plan to activate the manipulation",
  "WorkCanvas.Options.ToggleSelectModeOption.help.disable": "???",
  "WorkCanvas.Options.ToggleSelectModeOption.label.enable": "Start working with the workspace",
  "WorkCanvas.Options.ToggleSelectModeOption.label.disable": "Stop the manipulation of the workspace",
  "WorkCanvas.Options.ToggleSelectModeOption.description": "You can select multiple shapes by holding <b>SHIFT</b> and clicking on the shapes",
  "WorkCanvas.Options.ToggleEditModeOption.label.enable": "Enable plan edit mode",
  "WorkCanvas.Options.ToggleEditModeOption.label.disable": "Disable plan edit mode",
  "WorkCanvas.Options.ToggleEditModeOption.help.enable": "Activate the editing mode of the plan allows you to create and move shapes or create spaces",
  "WorkCanvas.Options.ToggleEditModeOption.help.disable": "Deactivate plan editing mode to return to plan reading mode",
  "WorkCanvas.Options.ToggleEditModeOption.description": "When rotating objects and workstations, by default an angle of 45 ° is applied, to deactivate it use the keyboard key <b>SHIFT</b>",
  "WorkCanvas.Options.FitToViewOption.label": "Center the map to see everything",
  "WorkCanvas.Options.FitToViewOption.help": "Allows you to have an overview of the plan",
  "HeatMapSelection.title": "Color the spaces with a heat map to understand the densities, the heat maps are not exportable in image for the moment",
  "HeatMapSelection.heatmaps.seatsCount.label": "Seating density",
  "HeatMapSelection.heatmaps.seatsCount.description": "Color the spaces according to the number of seats",
  "HeatMapSelection.heatmaps.workplacesCount.label": "Workstation density",
  "HeatMapSelection.heatmaps.workplacesCount.description": "Color the spaces according to the number of workstations",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.label": "Density of assignments to workstations",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.description": "Color the spaces according to the number of workstation assignments",
  "HeatMapSelection.heatmaps.carbonFootprintCount.label": "Furniture Carbon Footprint Density",
  "HeatMapSelection.heatmaps.carbonFootprintCount.description": "Color the spaces according to the carbon footprint of the furniture",
  "FurnituresSelectionDragZone.help": "Move group",
  "FurnituresSelection.move": "Move the whole group",
  "WorkCanvas.Options.TextAnchorOption.label.enable": "Set display text location",
  "WorkCanvas.Options.TextAnchorOption.label.disable": "Stop display text management",
  "WorkCanvas.Options.TextAnchorOption.help.enable": "Move display text",
  "WorkCanvas.Options.TextAnchorOption.help.disable": "Stop moving display text",
  "TextAnchorDrawer.title": "Change display text location for %{determinant.defined} %{name}",
  "WorkCanvas.Options.TextAnchorDrawer.label.enable": "Move display text",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.label": "Customize text position",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.help": "Allows you to activate the customization of the text position of the map",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.label": "Activate anchor display",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.help": "Allows you to activate the display of the segment and the anchor point for this space",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.label": "Reset text position",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.help": "This option returns the text position for this space to its original location",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.label": "Reset anchor position",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.help": "This option returns the anchor position for this space to its original location",
  "ShapeTextAnchorDrawer.empty": "Please select a compatible shape to move the display text",
  "IconsPicker.DisplayAll.text": "Show all",
  "IconsPicker.DisplayAll.help": "Attention loading can be a bit long",
  "IconsPicker.close": "Close icon selection",
  "IconPickerSearch.SearchPlaceholder": "Look for an icon with at least 3 letters",
  "EntitiesAutocomplete.searchEmpty.help.false": "Select %{determinants.defined} without %{objectTypeName}",
  "EntitiesAutocomplete.searchEmpty.help.true": "Return to standard search mode",
  "SearchFieldString.searchEmpty.help.false": "Search for empty or worthless elements",
  "SearchFieldString.searchEmpty.help.true": "Re-enable standard search",
  "SearchFilters.buttons.clear.label": "Clear all filters",
  "SearchFilters.buttons.clear.help": "Clear all filters and reset them to their initial state to ensure you can see all available entities",
  "RightSearchFilterDrawer.filter": "Filter %{determinants.defined}",
  "RightSearchFilterDrawer.tabLabel": "Filter",
  "RightSearchFilterDrawer.buttons.clear.label": "Clear all filters",
  "RightSearchFilterDrawer.buttons.clear.help": "Clear all filters and reset them to their initial state to ensure you can see all available entities",
  "PropertSelectorDrawer.help": "Select the properties you want to display in the table",
  "PropertSelectorDrawer.options.reset.label": "Reset selection",
  "PropertSelectorDrawer.options.reset.help": "Return the selection of properties to their initial state",
  "PropertSelectorDrawer.tabLabel": "Properties",
  "TableSelectionAllCheckbox.checked.true": "Unselect all",
  "TableSelectionAllCheckbox.checked.false": "Select all",
  "TableSelectionAllCheckbox.help": "Select or deselect all rows (including those not visible in the paginated list)",
  "TableOptionsRow.checked.true": "Unselect all",
  "TableOptionsRow.checked.false": "Select all",
  "TableOptionsRow.help": "Select or deselect all lines",
  "ErrorTextZone.reload": "Redo the operation",
  "ReportErrorSteps.report.title": "You have just encountered an error",
  "ReportErrorSteps.report.description": "This error has been reported to our teams and we will try to correct it as quickly as possible.",
  "ReportErrorSteps.report.steps.title": "You can try in order",
  "ReportErrorSteps.report.steps.reload": "Reload the page and see if the error is resolved",
  "ReportErrorSteps.report.steps.logout": "Disconnect and return to this page after reconnecting",
  "ReportErrorSteps.report.steps.contact": "Contact us so that we can offer you an alternative as quickly as possible",
  "ReportErrorByMailButton.label": "Contact us",
  "RefreshPageButton.label": "Reload page",
  "Errors.networkError": "Connection or network issues have been detected, please wait and try again in a few seconds",
  "ShowEntityDrawer.title.show": "See %{determinant.defined}",
  "ShowEntityDrawer.title.listItem": "See information for %{determinant.defined} in the sidebar",
  "EditEntityDrawer.title.edit": "Edit %{determinant.defined}",
  "RightDrawerContent.close": "Close the right panel by clicking on the cross.",
  "DropDownOptions.moreOptions": "See more options for %{determinant.defined} %{name}",
  "BuildingFloorsList.title": "Navigate the floors",
  "RefetchEntityButton.refetch": "Reload data",
  "RefetchEntitiesButton.refetch": "Reload visible object data",
  "RefetchObjectTypeIcon.help": "Reload data for %{determinant.defined}",
  "ImpactButtonReload.help.single": "Update calculated data for %{determinant.defined}",
  "ImpactButtonReload.help.list": "Update calculated data for %{determinants.defined}",
  "EditInlineToggleIconButton.edit.label": "Edit",
  "EditInlineToggleIconButton.edit.help": "Edit the properties for %{determinant.defined} directly on this page",
  "EditInlineToggleIconButton.cancel.help": "Stop editing without saving",
  "ConfirmationButtons.confirm": "Confirm the completion of the action",
  "ConfirmationButtons.cancel": "Cancel",
  "ConfirmationButtons.loading": "The action is running, please wait",
  "EmailNotVerified.errorMessage": "Please validate your email ( %{email} ), once validated, you can log out and then log back in to access Surfy",
  "NoRoleAssociated.noRole": "No role seems to be associated with your user for the company %{tenant} , please contact your administrator",
  "NoCompanies.title.whatIsSurfy": "What is Surfy?",
  "NoCompanies.NoCompanyAssigned": "You are not associated with any platform, you can not use surfy for the moment",
  "NoCompanies.whatIsSurfy": "Surfy offers to digitize building plans to facilitate management of the work environment.<br/> You can use the Surfy app to<ul><li> arrange spaces</li><li> assign employees</li><li> rebill spaces</li><li> analyze spaces</li><li> manage compliance and regulations</li><li> connect spaces</li><li> manage attendance schedules</li><li> reserve workspaces</li></ul>",
  "NoCompanies.whatIsSurfyForTeams": "Surfy offers to digitize building plans to facilitate management of the work environment. You can use the Surfy app to<ul><li> manage your presence schedule</li><li> declare your presence at the office</li><li> reserve a workspace</li><li> indicate that you are teleworking</li><li> see which colleagues have reserved a workstation on the plan</li></ul>",
  "NoCompanies.ContactUs.text": "Log in to your company platform",
  "NoCompanies.ContactUs.subject": "Access Surfy",
  "NoCompanies.ContactUs.body": "Hello, could you let me access the Surfy app? Thank you.",
  "NoCompanies.accessSurfy.title": "Why can't I access Surfy?",
  "NoCompanies.accessSurfy.alreadyUsing": "If your company already uses Surfy, please contact your work environment manager to request access or contact us via the following link",
  "NoCompanies.accessSurfy.joinTenant": "Join your company's platform",
  "NoCompanies.notUsing.title": "Your company doesn't use Surfy yet?",
  "NoCompanies.knowMore": "Learn more about Surfy",
  "AuthenticationButton.connections.google-oauth2.label": "Google",
  "AuthenticationButton.connections.google-oauth2.help": "Log in with your Google account",
  "AuthenticationButton.connections.AzureADv2.label": "Office 365",
  "AuthenticationButton.connections.AzureADv2.help": "Connect with your Microsoft professional account via Office 365",
  "AuthenticationButton.connections.auth0.label": "Surfy Account",
  "AuthenticationButton.connections.auth0.help": "Log in with your Surfy account",
  "Auth0AuthenticationButton.connections.auth0.label": "Surfy account (open id)",
  "Auth0AuthenticationButton.connections.auth0.help": "Log in with your Surfy account",
  "EnterpriseConnectionButton.label": "Business",
  "EnterpriseConnectionButton.help": "Log in with your company account via a dedicated authentication like OKTA or DigitalP@ss",
  "EnterpriseConnectionForm.title": "Please enter your email so we can recognize your business",
  "EnterpriseConnectionForm.forms.email.placeholder": "E-mail",
  "EnterpriseConnectionForm.error": "Unable to identify your company with your email",
  "EnterpriseConnectionForm.buttons.validate.label": "Validate",
  "EnterpriseConnectionForm.buttons.validate.help": "Validate the email allows you to know your company and direct you to the right authentication platform",
  "EnterpriseConnectionForm.buttons.back.label": "Return",
  "EnterpriseConnectionForm.buttons.back.help": "Return to the authentication page with all options",
  "LoginView.loadingPage": "Loading the authentication page",
  "LoginView.connections.google-oauth2.label": "Google",
  "LoginView.connections.google-oauth2.help": "Log in with your Google account",
  "LoginView.connections.AzureADv2.label": "Office 365",
  "LoginView.connections.AzureADv2.help": "Connect with your Microsoft professional account via Office 365",
  "LoginView.connections.Username-Password-Authentication.label": "Surfy Account",
  "LoginView.connections.Username-Password-Authentication.help": "Log in with your Surfy account",
  "LoginView.texts.title": "Log in",
  "LoginView.texts.description": "Access Surfy",
  "LoginView.helpers.register": "Register your business with Surfy",
  "LoginView.helpers.moreInfo": "Learn more about Surfy",
  "LoginView.helpers.privacy": "Privacy Policy",
  "CustomUserRegisterForm.tabs.login": "To log in",
  "CustomUserRegisterForm.tabs.signup": "Register",
  "CustomUserRegisterForm.form.email": "E-mail",
  "CustomUserRegisterForm.form.password": "Password",
  "CustomUserRegisterForm.form.firstName": "First name",
  "CustomUserRegisterForm.form.lastName": "Last name",
  "CustomUserRegisterForm.form.confirmPassword": "Password confirmation",
  "CustomUserRegisterForm.buttons.login.label": "Validate",
  "CustomUserRegisterForm.buttons.login.help": "Log in if you already have an account",
  "CustomUserRegisterForm.buttons.signup.label": "Validate",
  "CustomUserRegisterForm.buttons.signup.help": "Subscribe to Surfy if you don't have an account",
  "ReportChart.NoValue": "Without value",
  "ChangeLanguage.title": "Change the language",
  "ChangeLanguage.help": "Change the language of the application",
  "DataQualityTable.numberOfLines": "Number of lines",
  "AllTenantsDataQualityTable.enableAllTenants.label": "Include all platforms",
  "SingleNodeQuery.refetch": "Reload data",
  "ListRefetchButton.refetch": "Reload visible object data",
  "ImpactObjectTypeIconButton.refetch": "Reload all data regardless of filters",
  "CollapseSwitchButton.help.true": "Hide the detail",
  "CollapseSwitchButton.help.false": "See the detail",
  "menu.logout": "Sign out",
  "menu.tenantOperations": "Synchronization",
  "menu.menuLeft.shoppingCart": "Shopping Cart",
  "menu.menuLeft.personCompanies": "Providers",
  "menu.menuLeft.workplace": "Personal work places",
  "menu.menuLeft.security": "security",
  "menu.menuLeft.globalSecurity": "Global security",
  "menu.menuLeft.all": "Administration",
  "menu.menuLeft.operations": "operations",
  "menu.menuLeft.types": "types",
  "menu.menuLeft.roomTypes": "Space typologies",
  "menu.menuLeft.inventory": "inventories",
  "menu.menuLeft.people": "People",
  "menu.menuLeft.spaces": "Spaces",
  "menu.menuLeft.organizations": "Organizations",
  "menu.menuLeft.dimensions": "Analysis layers",
  "menu.menuLeft.api": "API",
  "menu.menuLeft.authentification": "Authentication",
  "menu.menuLeft.globalAdmin": "Global administration",
  "menu.menuLeft.human": "People",
  "menu.menuLeft.things": "Furniture",
  "menu.menuLeft.admin": "Administration",
  "menu.menuLeft.surfy": "Surfy",
  "menu.menuLeft.partnerExportMapping": "Partners",
  "menu.menuLeft.personType": "types",
  "menu.menuLeft.personRelations": "Relationships",
  "menu.menuLeft.affectations": "assignments",
  "menu.menuLeft.buildings": "Buildings",
  "menu.menuLeft.thingsType": "types",
  "menu.menuLeft.spacePoints": "Points",
  "menu.menuLeft.adminReporting": "Reporting",
  "menu.menuLeft.adminCostCenterReporting": "Cost center",
  "menu.menuLeft.adminDimensionReporting": "Dimensions",
  "menu.menuLeft.adminRoomTypeReporting": "Type of spaces",
  "menu.menuLeft.adminOrganizationReporting": "Organizations",
  "menu.menuLeft.adminRoomTypeGroupReporting": "Space typology groups",
  "menu.menuLeft.buildingFacts": "Time-stamped building data",
  "menu.menuLeft.itemsFact": "Time-stamped object data",
  "menu.menuLeft.segments": "Segments",
  "menu.menuLeft.connectors": "Connectors",
  "menu.menuLeft.planning": "Schedules",
  "menu.menuLeft.bookings": "Reservations",
  "menu.menuLeft.help": "Assistance",
  "menu.menuLeft.company": "Platforms",
  "ReduceMenuSwitch.open.true": "Expand menu",
  "ReduceMenuSwitch.open.false": "Collapse the menu to take advantage of the workspace",
  "LogoutMenuLink.logout": "Sign out",
  "HelpPortalListItemLink.label": "Help portal",
  "HelpPortalListItemLink.help": "Discover the Surfy help portal with all our tutorials and user guides",
  "ChangeLogListItemLink.label": "News",
  "ChangeLogListItemLink.help": "Know what's new and changed in Surfy",
  "DisplayRoomTexts.dragOption": "Hold down and change the order in which properties are displayed on the map by moving the field up or down",
  "DisplayRoomTexts.roomPeopleDimensions.label": "Neighborhood",
  "DisplayRoomTexts.roomPeopleDimensions.help": "Show or hide the neighborhood on the map",
  "DisplayRoomTexts.roomSeatsCount.label": "Number of seats",
  "DisplayRoomTexts.roomSeatsCount.help": "Display or not the number of seats on the map",
  "DisplayRoomTexts.roomCapacity.label": "Space Capacity",
  "DisplayRoomTexts.roomCapacity.help": "Show or not the space capacity on the plan",
  "DisplayRoomTexts.roomCostCenter.label": "Cost center",
  "DisplayRoomTexts.roomCostCenter.help": "Show or not the space cost center on the plan",
  "DisplayRoomTexts.roomMergedName.label": "Merged name",
  "DisplayRoomTexts.roomMergedName.help": "Display or not the merged name of the space on the plan, this name groups the display name and the name of the space",
  "DisplayRoomTexts.roomName.label": "Space name",
  "DisplayRoomTexts.roomName.help": "Show or not the name of the space on the plan",
  "DisplayRoomTexts.roomPrettyName.label": "Display name",
  "DisplayRoomTexts.roomPrettyName.help": "Whether or not to display the display name of the space on the map",
  "DisplayRoomTexts.roomArea.label": "Area",
  "DisplayRoomTexts.roomArea.help": "Show or not the surface area of ​​the space on the plan",
  "DisplayRoomTexts.roomType.label": "Space typology",
  "DisplayRoomTexts.roomType.help": "Display or not the space typology",
  "DisplayRoomTexts.roomPerimeter.label": "Perimeter",
  "DisplayRoomTexts.roomPerimeter.help": "Show or not the perimeter of the space on the plan",
  "DisplayRoomTexts.roomOrganizationLevel1.label": "Service",
  "DisplayRoomTexts.roomOrganizationLevel1.help": "Display or not the name of the space service on the plan",
  "DisplayRoomTexts.roomOrganizationTopLevel.label": "Direction",
  "DisplayRoomTexts.roomOrganizationTopLevel.help": "Show or not the name of the direction of the space on the plan",
  "DisplayRoomTexts.roomPeople.label": "People assigned to spaces",
  "DisplayRoomTexts.roomPeople.help": "Display or not the names of the people assigned to this space on the plan",
  "DisplayRoomTexts.roomWorkplaceAffectations.label": "People assigned to workstations",
  "DisplayRoomTexts.roomWorkplaceAffectations.help": "Display or not the names of people assigned to workstations in this space on the plan",
  "DisplayRoomTexts.roomPeopleCount.label": "Number of assignments",
  "DisplayRoomTexts.roomPeopleCount.help": "Display or not the number of people assigned to this space on the plan",
  "DisplayRoomTexts.roomPeopleRatio.label": "Occupancy ratio",
  "DisplayRoomTexts.roomPeopleRatio.help": "Show or not the space occupancy ratio on the plan",
  "DisplayRoomTexts.roomWorkplacesCount.label": "Number of workstations",
  "DisplayRoomTexts.roomWorkplacesCount.help": "Show or not the number of workstations in the space on the plan",
  "DisplayRoomTexts.roomWorkplacesRatio.label": "Workstation ratio",
  "DisplayRoomTexts.roomWorkplacesRatio.help": "Show or not the ratio of workstations of the space on the plan",
  "DisplayRoomTexts.roomOccupancyRate.label": "Occupancy rate",
  "DisplayRoomTexts.roomOccupancyRate.help": "Display or not the space occupancy rate on the plan",
  "DisplayRoomTexts.roomExpansionRatio.label": "Expansion rate",
  "DisplayRoomTexts.roomExpansionRatio.help": "Show or not the space expansion rate on the plan",
  "DisplayRoomTexts.roomFreeWorkplacesCount.label": "Number of vacancies",
  "DisplayRoomTexts.roomFreeWorkplacesCount.help": "Display or not the number of free positions on the plan",
  "DisplayRoomTexts.roomFlexWorkplacesCount.label": "Number of flex positions",
  "DisplayRoomTexts.roomFlexWorkplacesCount.help": "Display or not the number of flex positions on the plan",
  "DisplayRoomOptions.roomSeatsCount.one": "%{value} seat",
  "DisplayRoomOptions.roomSeatsCount.more": "%{value} seats",
  "DisplayRoomOptions.roomCapacity.one": "Capacity: %{value} place",
  "DisplayRoomOptions.roomCapacity.more": "Capacity: %{value} places",
  "DisplayRoomOptions.roomFreeWorkplacesCount.one": "%{value} free position",
  "DisplayRoomOptions.roomFreeWorkplacesCount.more": "%{value} vacancies",
  "DisplayRoomOptions.roomFlexWorkplacesCount.one": "%{value} flex position",
  "DisplayRoomOptions.roomFlexWorkplacesCount.more": "%{value} flex positions",
  "DisplayRoomOptions.roomWorkplacesCount.one": "%{value} workstation",
  "DisplayRoomOptions.roomWorkplacesCount.more": "%{value} workstations",
  "DisplayRoomOptions.roomPeopleCount.one": "%{value} affected person",
  "DisplayRoomOptions.roomPeopleCount.more": "%{value} people affected",
  "DisplayRoomOptions.roomOccupancyRate": "Occupation: %{value}",
  "DisplayRoomOptions.roomExpansionRatio": "Expansion: %{value}",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.enable": "Manage space display texts",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.disable": "Close display text management",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.enable": "Allows you to configure the texts that will be displayed on the plan for each space",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.disable": "Return to the normal mode of editing the plan.",
  "DisplayRoomTextsDrawer.tabs.map": "Plan",
  "DisplayRoomTextsDrawer.tabs.tooltip": "Tooltip",
  "DisplayRoomTextsDrawer.tabs.base.tabs.rooms": "Spaces",
  "DisplayRoomTextsDrawer.tabs.base.tabs.people": "People",
  "DisplayRoomTextsDrawer.tabs.base.people.description": "To define the properties of the people to display on the plan, please choose in the spaces tab the people assigned to the spaces or to the workstations then choose the properties in this tab",
  "DisplayWorkplaceTexts.workplaceName.label": "Workstation name",
  "DisplayWorkplaceTexts.workplaceName.help": "Display or not the name of the workstation on the map",
  "DisplayWorkplaceTexts.workplaceCostCenter.label": "Cost center",
  "DisplayWorkplaceTexts.workplaceCostCenter.help": "Display or not the cost center of the workstation on the plan",
  "DisplayWorkplaceTexts.people.label": "Show people",
  "DisplayWorkplaceTexts.people.help": "Display or not the people assigned to the workstation on the plan",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.label": "Direction",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.help": "Display or not the directions of the workstations on the plan",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.label": "Service",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.help": "Display or not the services of the workstations on the plan",
  "DisplayPersonTexts.personPicture.label": "People photo",
  "DisplayPersonTexts.personPicture.help": "Display or not the photo of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personName.label": "Name of persons",
  "DisplayPersonTexts.personName.help": "Display or not the name of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personSecurityProfile.label": "Security profile",
  "DisplayPersonTexts.personSecurityProfile.help": "Display or not the security profile of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personOrganizationLevel0.label": "Direction",
  "DisplayPersonTexts.personOrganizationLevel0.help": "Display or not the direction of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personOrganizationLevel1.label": "Service",
  "DisplayPersonTexts.personOrganizationLevel1.help": "Display or not the service of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personOrganizationHierarchy.label": "Organization hierarchy",
  "DisplayPersonTexts.personOrganizationHierarchy.help": "Display or not the department and the direction of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personCostCenter.label": "Cost center",
  "DisplayPersonTexts.personCostCenter.help": "Display or not the cost center of the people assigned to the workstations on the plan",
  "DisplayPersonTexts.personCode.label": "Registration number",
  "DisplayPersonTexts.personCode.help": "Whether or not to display the number of the people assigned to the workstations on the plan",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.enable": "Manage workstation display texts",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.disable": "Close display text management",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.enable": "Allows you to configure the texts that will be displayed on the map for each workstation",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.disable": "Return to the normal mode of editing the plan.",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.enable": "Activate the transparency of the background colors of the spaces",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.disable": "Turn off color transparency",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.enable": "Enabling color transparency allows the background to be seen through spaces",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.disable": "Turning off color transparency resets the colors of spaces",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.description": "The transparency of the colors of the spaces makes it possible to see the background of the plan",
  "WorkCanvas.Options.MapScaleOption.label.enable": "Manage the scale",
  "WorkCanvas.Options.MapScaleOption.label.disable": "Close scale management",
  "WorkCanvas.Options.MapScaleOption.help.enable": "Mandatory configure the scale on your plan in order to have the spaces and objects in the correct scale",
  "WorkCanvas.Options.MapScaleOption.help.disable": "Return to the normal mode of editing the plan.",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.label": "Delete scale",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.help": "Deleting the scale is the same as removing the scale from the plan and deleting it from the base, it will no longer be accessible via other plans. It is not possible to delete a scale that is on multiple floors.",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.label": "Dissociate the scale",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.help": "Unlinking the scale from this plane removes it from the plane, but keeps the scale in the database for future use",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.label": "Zoom in on the scale",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.help": "Zooming makes it easy to find the scale on the map.",
  "WorkCanvas.Options.DrawMapScaleOption.help": "You must configure the scale on your plan, click on the start and end of the scale on the plan in order to calibrate it",
  "ToggleCopilotEnable.label.false": "Activate Surfy Copilot",
  "ToggleCopilotEnable.label.true": "Disable Surfy Copilot",
  "ToggleCopilotEnable.help.false": "Enable Surfy Copilot to enable automatic door recognition",
  "ToggleCopilotEnable.help.true": "Disable Surfy Copilot and return to manual modeling",
  "WorkCanvas.Options.CopilotOption.label.enable": "Surfy Copilot",
  "WorkCanvas.Options.CopilotOption.label.disable": "Close Surfy Copilot options ",
  "WorkCanvas.Options.CopilotOption.help.enable": "Enable and adjust Surfy Copilot options",
  "WorkCanvas.Options.CopilotOption.help.disable": "Return to the plan's normal mode.",
  "WorkCanvas.Options.AddRoomShapeOption.label.enable": "Add a space",
  "WorkCanvas.Options.AddRoomShapeOption.label.disable": "Cancel adding a space",
  "WorkCanvas.Options.AddRoomShapeOption.help.enable": "Add a space on the plan",
  "WorkCanvas.Options.AddRoomShapeOption.help.disable": "Cancel space creation",
  "WorkCanvas.Options.AddRoomShapeOption.description": "The angles of creation are locked at 45°, to unlock them keep pressed the <b>SHIFT</b> keyboard key and continue the creation, to create your vertex position the mouse in the circle at the intersection of the triangle, To start a space by reusing a existing vertex, keep the <b>ALT</b> keyboard key pressed and click on the vertex.",
  "WorkCanvas.Options.AddRoomShapeSaveOption.label": "Save the space currently being modeled",
  "WorkCanvas.Options.AddRoomShapeSaveOption.help": "Save space will automatically close the space and save it allowing you to add objects or workstations to it",
  "WorkCanvas.Options.ViewLegendOption.label.enable": "Preview Legend",
  "WorkCanvas.Options.ViewLegendOption.label.disable": "Close the save legend in the plan image",
  "WorkCanvas.Options.ViewLegendOption.help.enable": "See what the legend section of the plan corresponds to",
  "WorkCanvas.Options.ViewLegendOption.help.disable": "Return to the plan's normal mode.",
  "DownloadImageQualitySlider.label": "Quality of the exported image",
  "DownloadImagePdfButton.label": "Download the plan without legend (PDF)",
  "DownloadImagePdfButton.help": "Download the plan in PDF without legend, this functionality is in beta",
  "WorkCanvas.Options.DownloadImageOption.label.enable": "Save as image",
  "WorkCanvas.Options.DownloadImageOption.label.disable": "Close the plan image save options",
  "WorkCanvas.Options.DownloadImageOption.help.enable": "Save the plan as an image via this option",
  "WorkCanvas.Options.DownloadImageOption.help.disable": "Return to the plan's normal mode.",
  "DownloadImageDrawer.ViewImage.text": "Download the plan with legend (PNG)",
  "DownloadImageDrawer.ViewImage.help": "Download the whole plan in good quality with the legend, the export may take longer.",
  "DownloadImageDrawer.ViewImageNoLegend.text": "Download the plan without legend (PNG)",
  "DownloadImageDrawer.ViewImageNoLegend.help": "Download the whole plan in good quality without the caption, the export may take longer.",
  "DownloadImageDrawer.ScreenshotNoLegend.text": "Screenshot without caption",
  "DownloadImageDrawer.ScreenshotNoLegend.help": "Download the image of what you see on the screen without caption, the output will be fast but the quality of the export will not be optimal",
  "DownloadBuildingImagesAccordion.accordion.title": "Export images of the whole building",
  "DownloadBuildingImagesAccordion.buttons.download.help": "Download all the plans of all the floors of the building in png format in a zip, the waiting time for this extraction can be long",
  "DownloadBuildingImagesAccordion.buttons.download.label": "Download ZIP",
  "DisplayTexts.dragOption": "You can sort and choose the display of properties on the map by moving the small bars on the field up or down",
  "DisplayRoomTextsPeople.roomPeopleFullName.label": "Persons full name",
  "DisplayRoomTextsPeople.roomPeopleFullName.help": "Whether or not to show the person's full name on the map",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.label": "Security profile",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.help": "Display or not the security profile of the people assigned to the spaces on the plan",
  "NumberOfPeoplePerRowField.label": "Number of people per line for space assignments",
  "WorkCanvas.Options.BackgroundLayoutOption.label.enable": "Manage the background map",
  "WorkCanvas.Options.BackgroundLayoutOption.label.disable": "Close background image management",
  "WorkCanvas.Options.BackgroundLayoutOption.help.enable": "Used to manage the background map",
  "WorkCanvas.Options.BackgroundLayoutOption.help.disable": "Return to the normal mode of editing the plan.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.label": "Delete scale",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.help": "Deleting the scale is the same as removing the scale from the plan and deleting it from the base, it will no longer be accessible via other plans. It is not possible to delete a scale that is on multiple floors.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.label": "Dissociate the scale",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.help": "Ungrouping the scale from this plan removes it from the plan, but keeps the scale in the database for future use",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.label": "Zoom in on the scale",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.help": "Zooming makes it easy to find the scale on the map.",
  "WorkplaceCanvasItem.workplace.free": "The workstation is not busy",
  "WorkplaceCanvasItem.workplace.isFlex": "The workstation is in flex",
  "WorkplaceCanvasItem.workplace.isTransit": "The workstation is passing through",
  "WorkplaceCanvasItem.workplace.isBookable": "The workstation is reservable",
  "WrongRoomsTable.table.headers.objectType": "Nature",
  "WrongRoomsTable.table.headers.type": "Type",
  "WrongRoomsTable.table.headers.identity": "Identity",
  "WrongRoomsTable.table.headers.currentRoom": "current space",
  "WrongRoomsTable.table.headers.newRoom": "new space",
  "WrongRoomsTable.SelectAll.checked.true": "Unselect all",
  "WrongRoomsTable.SelectAll.checked.false": "Select all",
  "WrongRoomsTable.SelectAll.help": "Select or deselect all lines",
  "WrongRoomsListner.dialog.title": "Validate the choice of spaces",
  "WrongRoomsListner.dialog.description": "There are shapes that are not in their starting space",
  "WrongRoomsListner.close.label": "To close",
  "WrongRoomsListner.close.help": "close this window",
  "MoveShapestoNewRoomAsyncButton.label": "Apply Space Change",
  "MoveShapestoNewRoomAsyncButton.help": "Change the spaces of the selected shapes to put them in the spaces they are in on the plan",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.enable": "Move object type",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.disable": "Stop moving object type",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.enable": "Move an object type on the plane",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.disable": "Stop moving object type",
  "ResetRotationAngle.resetRotationAngle": "Reset to 0° the angle of the rotation which is currently %{initialRotation}",
  "TenantOperations.sephora-sync-sap-success-factors.label": "MSC synchronization",
  "TenantOperations.st-grenoble-import-hr-file.label": "Importing the HR file",
  "TenantOperations.egis-import-hr-file.label": "Import HR File",
  "TenantOperations.essilor-import-hr-file.label": "Import HR File",
  "TenantOperations.agpm-import-hr-file.label": "Import of the HR file (STILOG)",
  "ConnectedPartnerContext.title": "You are connected to <b>%{label}</b> ( %{host} )",
  "Operations.talentsoft-import.label": "Talentsoft import",
  "Operations.zbre-sync.label": "Z#ber synchronization",
  "Operations.exportZbre.label": "Export Z # bre",
  "GenericNoChangeTable.open.label": "View data",
  "GenericNoChangeTable.open.help": "See the detail of the identical data",
  "Operations.sharingcloud-sync.label": "Sharingcloud synchronization",
  "Operations.moffi-sync.label": "Moffi synchronization",
  "Operations.lucca-sync.label": "Lucca Synchronization",
  "CompareObjectTypeUpdateIcon.help": "This synchronization will perform an update of the entities",
  "CompareObjectTypeDeleteIcon.help": "This synchronization will perform a deletion of entities that do not come from the source",
  "CompareObjectTypeCreateIcon.help": "This synchronization will perform a creation of entities that do not exist in the target",
  "RoomTooltip.roomWorkplaceAffectations": "Workstation assignments",
  "RoomSegmentRoomsList.title": "The spaces attached to this segment",
  "MeetingRoomCard.seats.1": "%{count} seat",
  "MeetingRoomCard.seats.n": "%{count} seats",
  "MeetingRoomCard.locateSpace": "Locate the space on the plan",
  "MeetingRoomCard.viewPicture": "See the photo from space",
  "days.monday": "Monday",
  "days.tuesday": "Tuesday",
  "days.wednesday": "Wednesday",
  "days.thursday": "THURSDAY",
  "days.friday": "Friday",
  "days.saturday": "SATURDAY",
  "days.sunday": "Sunday",
  "WorkplaceAffectationDailyTitle.all": "This person is affected every day",
  "WorkplaceAffectationDailyTitle.person.affected": "This person is assigned %{daysText}",
  "WorkplaceAffectationDailyTitle.person.notAffected": "This person is unaffected",
  "WorkplaceAffectationDailyTitle.calculatedRate": "The average assignment rate is %{calculatedRate}",
  "WorkplaceNestedList.title": "People assigned to workstations",
  "WorkplaceList.workplace.free": "This workstation is free",
  "WorkplaceList.workplace.flex": "This workstation is in flex",
  "WorkplaceList.workplace.transit": "This workstation is shared",
  "WorkplaceList.zoomOnWorkplace": "Zoom to the workstation on the plan",
  "WorkplaceAffectionPersonListItem.remove.help": "Remove the person's assignment to the workstation",
  "WorkplaceAffectations.edit.help": "Assign a person to this workstation",
  "WorkplaceAffectationDays.all": "This person is affected every day",
  "WorkplaceAffectationDays.and": "%{days} and %{lastDay}",
  "WorkplaceAffectationDays.one": "on %{day}",
  "WorkplaceAffectationDays.person.affected": "This person is assigned %{daysText}",
  "WorkplaceAffectationDays.person.notAffected": "This person is unaffected",
  "RoomWorkplaceList.EmptyList": "There are no workstations in this space",
  "RoomCard.buttons.edit.false": "Edit space properties",
  "RoomCard.buttons.edit.true": "Stop editing",
  "RoomCard.tabs.people": "assignments",
  "RoomCard.tabs.inventory": "Inventory",
  "RoomCard.tabs.room": "Space",
  "RoomAffectationsOnlyList.title": "People assigned to spaces",
  "RoomAffectationsList.title": "People assigned to spaces",
  "RoomAffectationsList.EmptyList": "There is no one assigned to this space",
  "ItemsInventory.EmptyList": "There are no objects in this space",
  "MovePersonFromWorkplaceToRoomListButtonItem.label": "Move this person from their workstation to the workstation space",
  "MovePersonFromWorkplaceToRoomListButtonItem.help": "This option requires refreshing the page to see the result, it is possible to chain several movements without refreshing",
  "CollapseWorkplaceAffectationList.title": "Assign this person for the following days only",
  "CollapseWorkplaceAffectationList.updateAffectationDay.true": "Affect this person %{day}",
  "CollapseWorkplaceAffectationList.updateAffectationDay.false": "Remove this person's assignment %{day}",
  "CancelAddWorkplaceToRoom.help": "Cancel the addition of the workstation",
  "CancelAddItemToRoom.help": "Cancel adding the object",
  "AddPersonToRoom.help": "Assign a person to space %{name}",
  "SecurityComplianceModeSwitch.label": "Filter people with security profiles",
  "SecurityComplianceModeSwitch.description": "See only people with security profiles on the map",
  "layoutViewSets.roomType.label": "Typologies of spaces",
  "layoutViewSets.roomType.description": "See the floor plan according to the typology of spaces",
  "layoutViewSets.costCenter.label": "Re-invoicing",
  "layoutViewSets.costCenter.description": "Analyze the keys to the financial distribution of spaces",
  "layoutViewSets.workplaces.label": "Occupations",
  "layoutViewSets.workplaces.description": "Focus on occupying workstations",
  "layoutViewSets.organizationLevel0.label": "Directions",
  "layoutViewSets.organizationLevel0.description": "Occupation by direction",
  "layoutViewSets.flex.label": "Flex",
  "layoutViewSets.flex.description": "Flexible occupancy of spaces",
  "layoutViewSets.walls.label": "Partitions",
  "layoutViewSets.walls.description": "Focus on spaces and partitions",
  "layoutViewSets.securityCompliance.label": "Security Compliance",
  "layoutViewSets.securityCompliance.description": "Analyze the compliance of your security prevention plan and the security profiles of the people affected",
  "layoutViewSets.peopleDimensionTypes.label": "Neighborhoods",
  "layoutViewSets.peopleDimensionTypes.description": "Analyze assignment layers and navigate by neighborhood or zone",
  "LayoutViewSwitch.title": "Changing the vision of the plan",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.viewSet": "Vision",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.help": "You can change the view via the plan menus",
  "SurfyLegendBottomLogo.text": "Plan generated by Surfy",
  "SurfyLegendBottomLogo.caption": "https://www.surfy.pro",
  "MapLegendWorkplace.title": "Workplace",
  "MapLegendWorkplace.workplaces.free": "Workstations are free",
  "MapLegendWorkplace.workplaces.flex": "The workstations are in flex",
  "MapLegendRoom.title": "Spaces",
  "MapLegendPersonSecurityProfile.title": "Security Profiles",
  "MapLegendFloor.title.building": "Building",
  "MapLegendFloor.title.floor": "Floor",
  "MapLegend.workplaces": "Personal work places",
  "MapLegend.rooms": "Spaces",
  "PersonSecurityProfileTabContent.tabs.merged": "By security profiles",
  "PersonSecurityProfileTabContent.tabs.split": "By assignments",
  "DimensionInfo.infos.building": "Calculated Building Information",
  "DimensionInfo.infos.impactBuildings": "Reload calculated building data",
  "DimensionToPeopleList.title": "People assigned to %{name}",
  "DimensionToPeopleList.noDimensionPerson": "There is no one assigned directly to this analysis layer",
  "DimensionPeople.title": "People assigned to spaces",
  "AddPersonToDimension.help": "Assign person to %{name}",
  "CubyWallModeSelect.label": "Partition display",
  "CubyWallModeSelect.options.no": "None",
  "CubyWallModeSelect.options.half": "Half partitions",
  "CubyWallModeSelect.options.reality": "Reality",
  "CubyWallModeSelect.options.cuby": "Cuby",
  "CubySaveAsImageButton.label": "Save Image",
  "CubySaveAsImageButton.help": "Save Floor Plan Image",
  "CubyFitToViewIsometricButtonOption.label": "Center the plane in isometric view",
  "CubyFitToViewIsometricButtonOption.help": "Center plan on spaces in isometric view",
  "CubyFitToViewZenithalButtonOption.label": "Center the plane in zenith view",
  "CubyFitToViewZenithalButtonOption.help": "Center the plan on the spaces in zenithal view",
  "RefetchFloorLayoutButton.refetch": "Reload plan data",
  "ItemTypesMapFilterZone.tabs.options": "options",
  "FloorMap.tabs.layout": "Change the view of the plan. The current view is <b>%{layoutName}</b>",
  "FloorMap.tabs.floor": "View floor information",
  "FloorMap.tabs.building": "View building information",
  "FloorMap.tabs.roomTypes": "Color the spaces on the plan according to the <b>space typologies</b>",
  "FloorMap.tabs.roomTypeGroups": "See the space indicators on the plan according to the <b>groups of space typologies</b>",
  "FloorMap.tabs.analyticsDimensionTypes": "Color the spaces on the plan according to the <b>analysis layers</b>",
  "FloorMap.tabs.itemTypes": "Display on the map the <b> objects </b> by family and type of objects",
  "FloorMap.tabs.workplaceTypes": "Display on the map the <b> workstations </b> by type of workstation",
  "FloorMap.tabs.organizations": "Color the spaces on the plan according to the <b>organizations</b>",
  "FloorMap.tabs.costCenters": "Color spaces and workstations in relation to <b>cost centers</b>",
  "FloorMap.tabs.users": "Color workstations versus people",
  "FloorMap.tabs.selection": "See the details of the elements selected on the plan",
  "FloorMap.tabs.rooms": "Details of selected <b>spaces</b>",
  "FloorMap.tabs.items": "Details of selected <b> objects </b>",
  "FloorMap.tabs.workplaces": "Details of the <b> workstations </b> selected",
  "FloorMap.tabs.all": "See all selected shapes in list",
  "FloorMap.tabs.peopleDimensionTypes": "Color the spaces on the plan according <b>to the assignment layers</b>",
  "FloorMap.tabs.workplaceUsage": "Color the workstations according to their <b>state</b>",
  "FloorMap.tabs.options": "See plan options",
  "FloorMap.tabs.heatmap": "Coloring with heat maps",
  "FloorMap.tabs.pathFinding": "Finding your way in spaces",
  "DateDimensionSelect.options.day": "Day",
  "DateDimensionSelect.options.week": "Week",
  "DateDimensionSelect.options.month": "Month",
  "DateDimensionSelect.options.year": "Year",
  "DateDimensionSelect.options.quarter": "Quarter",
  "JupDateRangePicker.chooseRange": "Choose a period",
  "WorkpaceBookingPeopleCountByDate.title": "Number of people who booked by date",
  "WorkpaceBookingPeopleCountByDate.labels.line": "Number of people",
  "WorkpaceBookingCountByDate.title": "Workstation reservations by date",
  "WorkpaceBookingCountByDate.labels.line": "Number of reservations",
  "WorkpaceBookingAverageByWeekDay.title": "Reservation of workstations by day of the week",
  "WorkpaceBookingAverageByWeekDay.labels.line": "Average per week",
  "WorkpaceBookingAverageByWeekDay.labels.bar": "Number of reservations",
  "PersonPanelWorkplaceAffectations.title": "Workstation assignments",
  "PersonPanelRoomAffectations.title": "Assignments to spaces",
  "PersonPanelDimensionToPeople.title": "Assignments to %{dimensionTypeName}",
  "PersonPanelBuildingAffectations.title": "Allocations to buildings",
  "PersonPanelBuildingAffectations.addToPeopleCount.false": "This person is not accounting in the building",
  "PersonAffectationsPanel.title": "assignments",
  "PersonAffectationsPanel.description": "The person's assignments",
  "PersonSecurityPanel.title": "security",
  "PersonSecurityPanel.description": "Safety and Evacuation Information",
  "PersonRelationsPanel.title": "Relationships",
  "PersonRelationsPanel.description": "This person's relationships",
  "PersonInventoryPanel.title": "Inventory",
  "PersonInventoryPanel.description": "Inventory Information",
  "PersonInventoryPanel.items.subheader": "List of associated objects",
  "PersonInfoPanel.title": "Personal informations",
  "PersonContractPanel.title": "Contract",
  "PersonContractPanel.description": "Contract information",
  "PersonContactPanel.title": "Contact",
  "PersonContactPanel.description": "How to contact this person?",
  "PersonBadgePanel.title": "Various",
  "PersonBadgePanel.description": "Miscellaneous information about the person",
  "AvatarPersonDrawer.help": "See more information about %{name}",
  "TopLevelOrganizationFilter.Empty": "There is no organization associated with spaces, you can add more by modifying a space and associating it with an organization, then you can control their display from this section",
  "OrganizationTabsFilter.tabs.topLevel": "Directions",
  "OrganizationTabsFilter.tabs.hierarchy": "Hierarchy",
  "OrganizationTabsFilter.tabs.level1": "Services",
  "OrganizationFloorMapFilter.TooltipTitle.notSelected": "Select %{organization} to color the spaces on the plan",
  "OrganizationFloorMapFilter.TooltipTitle.selected": "Deselecting %{organization} will remove colors from the plan",
  "OrganizationFloorMapFilter.tooltip.true": "Select all the types of objects below in order to color them on the map",
  "OrganizationFloorMapFilter.tooltip.false": "Deselect all organizations below",
  "Level1OrganizationFilter.Empty": "There is no organization associated with spaces, you can add more by modifying a space and associating it with an organization, then you can control their display from this section",
  "HierarchyOrganizationFilter.Empty": "There is no organization associated with spaces, you can add more by modifying a space and associating it with an organization, then you can control their display from this section",
  "CompanyDashboard.dashboards.workplace": "Desktop Dashboard",
  "CompanyDashboard.dashboards.area": "Surfaces Dashboard",
  "ChangeCompanyMenu.ChangeCompany": "See another company in a new page",
  "WorkplaceTypeDataQualityNotUsed.columns.name": "Workstation type name",
  "WorkplaceTypeDataQualityNotUsed.columns.shape": "Form",
  "workplaceTypeLayoutFilter.Empty": "There are no workstations at the moment in spaces, you can add more by modifying a space and adding workstations to it, then you can control their display from this section",
  "WorkplaceTypeInfo.help": "The number of workstations is %{count}",
  "CopyWorkplaceTypeToCart.help": "Copy workstation types to cart",
  "WorkCanvas.Options.ZoomOnWorkplaceType.label": "Zoom in on the type of workstation",
  "WorkCanvas.Options.ZoomOnWorkplaceType.help": "Zooming in on the type of workstation allows you to locate it in the work area",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.enable": "List the types of objects",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.disable": "Close the list of object types",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.enable": "See the list of object types for this type of workstation",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.disable": "Close the list of object types for this type of workstation",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.open": "Unfold options",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.close": "Fold options",
  "WorkplaceTypeItemTypesDrawer.title": "List of object types",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.help": "Add an object type to be able to compose the type of workstation",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.label": "Add an object type",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.help": "Cancel the addition of an object type in this workstation",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.label": "Cancel adding an object type",
  "WorkCanvas.Options.DeleteStructureShapeOption.help": "Completely remove the shape of the power structure, for example redraw it entirely",
  "WorkCanvas.Options.DeleteStructureShapeOption.label": "Delete shape",
  "WorkCanvas.Options.AddStructurePointOption.label.enable": "Add a summit",
  "WorkCanvas.Options.AddStructurePointOption.label.disable": "Stop adding a vertex",
  "WorkCanvas.Options.AddStructurePointOption.help.enable": "Adding a vertex makes it possible to rework with more precision a form",
  "WorkCanvas.Options.AddStructurePointOption.help.disable": "Stop creating summits",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloorButton.label": "Reserve a workstation at %{floorName}",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloor": "Reserve a workstation at %{floorName} for the period %{slotString}",
  "BookPersonBuildingWorkplace.availableWorkplaces": "%{freeWorkplaces} places available",
  "BookPersonBuildingWorkplace.help": "%{bookedWorkplaces} reservation(s), %{freeWorkplaces} workstations available on %{totalFloorWorkplacesCount}",
  "booking.snackbar.delete.workplace": "The reservation at workstation %{workplaceName} has been cancelled for the period %{slot}",
  "booking.snackbar.delete.room": "The reservation at space %{roomName} has been cancelled for the period %{slot}",
  "BookingWorkplaceTitle.booked": "This workstation is already reserved",
  "BookingWorkplaceTitle.userBooked": "You have reserved this workstation",
  "BookingWorkplaceTitle.free": "Reserve this workstation",
  "PlanningPersonAffectations.alerts.noAffectation.title": "Unable to reserve a workstation",
  "PlanningPersonAffectations.alerts.noAffectation.message": "You are not associated with any territory, please contact your assignment manager to be able to reserve a workspace",
  "WorkingLocationToggle.locations.OFFICE": "Office",
  "WorkingLocationToggle.locations.REMOTE": "Remote",
  "PersonBookingListItem.workplaceBookedOnFloor": "View the %{workplaceName} workstation on the floor plan at %{floorName}",
  "PersonBookingList.noBooking": "No colleague will be present in the office on the same slot for the moment",
  "PersonBookingList.bookings.one": "A colleague will be present on the same slot",
  "PersonBookingList.bookings.more": "%{count} colleagues will be present on the same slot",
  "ParkingBookIcon.parking.booked": "Your parking is reserved",
  "ParkingBookIcon.parking.release.help": "Release parking reservation",
  "ParkingBookIcon.parking.viewOnMap": "See the reserved parking on the map",
  "ParkingBookIcon.parking.book.label": "Reserve a parking space",
  "ParkingBookIcon.parking.book.help": "Reserve a parking space which will be automatically allocated to the slot",
  "HalfDayWorkingLocationToggle.am.label": "Morning",
  "HalfDayWorkingLocationToggle.am.help": "Morning hours are from 8:00 a.m. to 1:30 p.m.",
  "HalfDayWorkingLocationToggle.pm.label": "Afternoon",
  "HalfDayWorkingLocationToggle.pm.help": "Afternoon hours are from 2:00 p.m. to 7:00 p.m.",
  "DirectBuildingPlanningLabel.youAreAssigned": "You are assigned to the building %{buildingName}",
  "DimensionBuildingPlanningLabel.youAreAssigned": "You are assigned to %{dimensionTypeName} %{dimensionName}",
  "BookedBuildingWorkplaceList.noWorkplaceBooked": "No reserved workstations",
  "BookedBuildingWorkplaceList.workplaceIsBooked": "Your workstation is reserved",
  "BookedBuildingWorkplaceList.viewBookedWorkplaceOnMap": "View the workstation %{workplaceName} which is reserved on the plan",
  "BookedBuildingWorkplaceList.freeWorkplaceBooking": "Release this reservation",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.noFloor": "The size is not on any floor impossible to book at the moment from the plan",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.moreThanOneFloor": "The size is on several floors impossible to reserve at the moment since the plan",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.drawer.title": "Reserve a specific workstation for the period %{slotString}",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.help": "Reserve a specific workstation on the plan for this slot",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.label": "Reserve a workstation in %{dimensionName}",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.peopleCount": "There are %{count} person(s) with security profile %{name} assigned to workstations",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.workplaceCount": "There are %{count} workstation(s) with at least one person with security profile %{name}",
  "PersonSecurityProfileWorkplaceFilter.Empty": "Your people do not have a security profile or are not assigned to workstations, it is not possible to color the workstations according to the security profiles of the people",
  "PersonSecurityProfileWorkplaceFilter.title": "The security profiles of the people assigned to the workstations",
  "PersonSecurityProfileMerged.title": "List of security profiles grouped by profile type",
  "PersonSecurityProfileMerged.empty": "No profile is associated with spaces or workstations",
  "PersonSecurityProfileInRooms.title": "The security profiles of the people assigned to the spaces",
  "PersonSecurityProfileInRoomListItem.peopleCount": "There are %{count} person(s) with security profile %{name} assigned to spaces",
  "PersonSecurityProfileInRoomListItem.roomsCount": "There is %{count} space(s) with at least one person with security profile %{name}",
  "ToggleAllOpenInfoState.true": "Close all details and indicators",
  "ToggleAllOpenInfoState.false": "Open all details and indicators",
  "MapFiltersNodesToggleAll.help.true": "Select all",
  "MapFiltersNodesToggleAll.help.false": "unselect all",
  "MapFiltersNode.info.open": "See detail and indicators for %{label}",
  "MapFiltersNode.info.close": "Close additional information",
  "MapFiltersCategory.CategoryHasChildrenSelected": "Items are selected",
  "MapFilterNodeToggleAll.action.true": "Select all",
  "MapFilterNodeToggleAll.action.false": "unselect all",
  "MapFilterNodeIsAllSelected.help": "All the selection below will be loaded, even if new objects are created",
  "JupRoleToObjectTypeMatrix.views.help.true": "Hide interface view",
  "JupRoleToObjectTypeMatrix.views.help.false": "Show interface view",
  "JupRoleToObjectTypeMatrix.objectTypes.help.checkbox": "Update property ( %{name} )",
  "GlobalOptions.CartCopyItemTypeOption.help": "Copy item types to cart",
  "GlobalOptions.CartCopyWorkplaceTypeOption.help": "Copy workstation types to cart",
  "GlobalOptions.CartCopyBuildingOption.help": "Copy buildings to cart",
  "CheckAllDefaultViews.shortcuts.title": "Configuration shortcuts",
  "CheckAllDefaultViews.shortcuts.views.title": "Shortcuts for default interface views",
  "CheckAllDefaultViews.shortcuts.views.buttonsHelp": "Check this view for all types of entities",
  "CheckAllDefaultViews.shortcuts.objectTypes.title": "Shortcuts for entity types",
  "CheckAllDefaultViews.shortcuts.objectTypes.buttonsHelp": "Check this rule for all types of objects",
  "RemoveItemColorsOption.label": "Do not color objects",
  "RemoveItemColorsOption.help": "Color objects white so you can focus on other elements on the map",
  "ItemTypeOptions.help": "The number of objects is %{count}",
  "ItemTypeMapFilter.TooltipTitle.notSelected": "Select %{itemType} to see the objects on the map",
  "ItemTypeMapFilter.TooltipTitle.selected": "Deselecting %{itemType} will remove the associated color from the plan",
  "ItemTypeMapFilter.tooltip.true": "Select all the types of objects below in order to display them on the map",
  "ItemTypeMapFilter.tooltip.false": "Deselect all types of objects below",
  "ItemTypeMapFilter.NoNode": "There are no objects at the moment in spaces, you can add more by modifying a space and adding objects to it, then you can control their display from this section",
  "ItemTypeMapFilter.NoCategory": "There are no objects at the moment in spaces, you can add more by modifying a space and adding objects to it, then you can control their display from this section",
  "ItemTypeDataQualityNotUsed.columns.name": "Object type name",
  "ItemTypeDataQualityNotUsed.columns.shape": "Form",
  "ItemTypeDataQualityNotUsed.columns.workplaceTypeCount": "Number of workstation type",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.help": "Choose a reference plane to create the shape in order to be able to draw your type of object by locating itself on a plane and having the right scale",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.label": "Choose a reference plane to create the shape",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.help": "Choose a reference plane to compose the type of workstation with existing types of objects by locating on a plane and have the right scale and correctly position the types of objects",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.label": "Choose a reference plane to compose the shape of the type of workstation",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.help": "Choose a reference plane to create the shape in order to be able to draw the structure by locating yourself on a plan and having the right scale",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.label": "Choose a reference plane to create the structure",
  "ItemTypeAvatarSingleView.copy": "Copy points to clipboard",
  "ItemTypeAvatarSingleView.debug.label": "Enable advanced mode for 3d",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.help": "Completely remove the shape from the object type so that you can, for example, redraw it entirely or transform it into an icon",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.label": "Delete shape",
  "CopyItemTypesToCart.help": "Copy item types to cart",
  "PhysicalItemNotInsideWorkplaceRoom.alignRooms": "Change object spaces to that of the workstation",
  "AddPersonToItem.text": "Associate a person with this object",
  "AddPersonToItem.help": "Associate a person with this object, you can add several people for the same object",
  "DimensionTypeDescription.NoDescription": "There is no description for this type of analysis layer, you can add more by modifying it",
  "dimensionTypes.room_ground_type.one": "Nature of the soil",
  "dimensionTypes.room_ground_type.description": "Allows you to know the composition of the soil in the space",
  "dimensionTypes.room_usage.one": "Nature of spaces",
  "dimensionTypes.room_usage.description": "Allows you to identify spaces according to their uses",
  "dimensionTypes.frequency.one": "Frequency",
  "dimensionTypes.frequency.description": "Allows you to know the frequency of passage in space",
  "dimensionTypes.evacuation_zone.one": "security",
  "dimensionTypes.evacuation_zone.description": "Manage security and evacuation zones",
  "dimensionTypes.referent.one": "Referent",
  "dimensionTypes.referent.description": "Allows you to know who is assigned to the maintenance of this space",
  "DimensionTypesByTab.action.true": "Select all",
  "DimensionTypesByTab.action.false": "unselect all",
  "DimensionTypesByTab.ListItemHasChildrenSelected": "Dimensions are selected",
  "DimensionListItem.notSelected": "Select %{dimension} to see the spaces on the plan with the associated color",
  "DimensionListItem.selected": "Deselect %{dimension}",
  "DimensionInfo.roomsArea.help": "The area for %{dimensionType} %{dimension} is %{value} m²",
  "DimensionInfo.roomsCount.help": "There are %{value} space(s) for %{dimensionType} %{dimension}",
  "DimensionInfo.peopleCount.help": "There are %{value} person(s) affected for %{dimensionType} %{dimension}",
  "DimensionInfo.totalPeopleCount.help": "There are %{value} person(s) affected in total for %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesCount.help": "There is %{value} workstation (s) for %{dimensionType} %{dimension}",
  "DimensionInfo.peopleRatio.help": "There is %{value} m² per affected person for %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesRatio.help": "There are %{value} m² per workstation for %{dimensionType} %{dimension}",
  "DimensionInfo.occupancyRate.help": "The occupancy rate is %{value} % for %{dimensionType} %{dimension}",
  "DimensionInfo.expansionRatio.help": "The sprawl rate is %{value} for %{dimensionType} %{dimension}",
  "DimensionInfo.freeWorkplacesCount.help": "There are %{value} workstation (s) for %{dimensionType} %{dimension}",
  "DimensionInfo.flexWorkplacesCount.help": "There are %{value} flex workstation (s) for %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesCount.help": "There are %{value} shared workstation (s) for %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesRatio.help": "Shared desktop rate is %{value} for %{dimensionType} %{dimension}",
  "DimensionInfo.flexRatio.help": "The rate of flex workstations",
  "DimensionInfo.transitWorkplacesCount.help": "There are %{value} workstation (s) for %{dimensionType} %{dimension}",
  "DimensionInfo.dimensionPeopleCount.help": "There are %{value} affected person(s) in %{dimensionType} %{dimension}",
  "DimensionInfo.seatsCount.help": "There are %{value} seats for %{dimensionType} %{dimension}",
  "DimensionInfo.seatsPeopleRatio.help": "Seating rate is %{value} seats available per person for %{dimensionType} %{dimension}",
  "DimensionInfo.carbonFootprint.help": "The carbon footprint is %{value} of CO2 emitted for %{dimensionType} %{dimension}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.peopleCount": "There are %{count} people with cost center %{costCenterName}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.workplaceCount": "There are %{count} workstations with at least one person with cost center %{costCenterName}",
  "PersonCostCenterWorkplaceFilter.Empty": "There are no cost centers associated with people",
  "NoDataOnBuildingInfo.noData": "Please select all the floors in the plan options to have data, there must not be any data for the floors you have selected",
  "CostCenterWorkplaceMapFilter.nodeInfo.workplacesCount": "There are %{count} workstations with cost center %{name}",
  "CostCenterMapFilterTabs.tabs.rooms": "Spaces",
  "CostCenterMapFilterTabs.tabs.workplaces": "Personal work places",
  "CostCenterMapFilterTabs.tabs.people": "People",
  "CostCenterMapFilter.Empty": "There are no cost centers currently associated with spaces, you can add more by modifying a space and associating a cost center with it, then you can control their display from this section",
  "CostCenterWorkplaceMapFilter.Empty": "There is currently no cost center associated with the workstations, you can add one by modifying a workstation and associating a cost center with it, then you can control their display from this section",
  "BuildingReports.items.sheets.physicals": "Physical Objects",
  "BuildingReports.items.sheets.virtuals": "Virtual Objects",
  "BuildingReports.items.sheets.merged": "Merger",
  "BuildingInventory.floor": "Floor",
  "BuildingInventory.quantity": "Amount",
  "BuildingInventory.price": "Price",
  "BuildingInventory.manufacturer": "Maker",
  "BuildingInventory.quantityTotal": "Total",
  "BuildingInventory.title": "Building inventory %{building.name}",
  "BuildingInventory.buttons.viewPDF.help": "Download the file in PDF so that you can download or share it",
  "BuildingInventory.buttons.viewPDF.label": "Download PDF version",
  "BuildingInventory.itemTypesFamilySectionTitle": "Inventory categories",
  "BuildingInventory.fileNamePrefix": "inventory",
  "BuildingLabel.scenario": "This building is a scenario of the building %{name}",
  "CopyBuildingToCart.help": "Copy building structure",
  "BuildingClonePropertiesSelector.properties.clone.workplaces": "Copy workstations",
  "BuildingClonePropertiesSelector.properties.clone.items": "Copy Objects",
  "BuildingDistributionCost.floors.excel.tabs.floors": "Distribution keys by floor",
  "BuildingDistributionCost.floors.excel.tabs.building": "Distribution keys for the building",
  "BuildingDistributionCost.floors.excel.tabs.buildingDetailed": "Building details by cost center",
  "BuildingDistributionCost.floors.excel.download.label": "Download the excel file with the breakdowns",
  "BuildingDistributionCost.floors.excel.download.help": "Download the excel file to be able to share and export the distribution keys and qualified areas by cost center and by floor, the export includes the distribution by floor or by building of the cost centers",
  "BuildingDistributionCost.floors.excel.headers.floors.floorName": "Name of the floor",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterName": "Cost center",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterArea": "Surface area of spaces including floor distributions",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterRoomsArea": "Area of cost center spaces",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterDistributedFloorRatio": "Usage ratio in the floor",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterFloorDistributedArea": "Total area of the spaces to be distributed on the floor for this cost center",
  "BuildingDistributionCost.floors.excel.headers.floors.floorArea": "Total floor area including the floor distributions",
  "BuildingDistributionCost.floors.excel.headers.floors.totalFloorDistributedArea": "Surface to be distributed in the floor",
  "BuildingDistributionCost.floors.excel.headers.floors.totalBuildingDistributedArea": "Floor area to be distributed in the building",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterName": "Cost center",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterArea": "Total cost center area",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterBuildingRatio": "Building use ratio",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterDistributedBuildingArea": "Total area of distributed building spaces",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterRoomsArea": "Area of cost center spaces",
  "BuildingDistributionCost.floors.excel.headers.building.buildingArea": "Total area of building spaces",
  "BuildingDistributionCost.floors.excel.headers.building.buildingDistributedArea": "Area to be distributed in the building",
  "BuildingDistributionCost.floors.excel.headers.building.totalBuildingArea": "Total building area",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.buildingName": "Building",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterName": "Cost center",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterArea": "Cost center area",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterBuildingRatio": "Distribution key in the building",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.distributedCostCenterArea": "Distribution of cost center %{costCenterName}",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterTotalArea": "Total area to be re-invoiced",
  "BuildingDistributionCost.excel.tabs.distributionCost": "Distribution keys",
  "BuildingDistributionCost.excel.tabs.distributionCostDetails": "Details",
  "BuildingDistributionCost.excel.download.label": "Download the excel file without the breakdowns",
  "BuildingDistributionCost.excel.download.help": "Download the excel file to be able to share and export the distribution keys and qualified areas by cost center",
  "BuildingDistributionCost.Title": "Distribution keys and qualified areas by cost center without breakdowns",
  "BuildingDistributionCost.table.type": "Type",
  "BuildingDistributionCost.table.distributionKey": "Distribution key",
  "BuildingDistributionCost.table.costCenterDistributionKey": "Allocation key for the cost center",
  "BuildingDistributionCost.table.workplacesCount": "Number of workstations",
  "BuildingDistributionCost.table.workplaceTotalCount": "Total number of workstations",
  "BuildingFloorSelection.title": "The floors to duplicate in your scenario",
  "BuildingFloorSelection.all.select": "Select all floors",
  "BuildingFloorSelection.all.unselect": "Deselect all floors",
  "BuildingCloneFloorSelection.title": "The floors to duplicate in your scenario",
  "BuildingCloneFloorSelection.all.select": "Select all floors",
  "BuildingCloneFloorSelection.all.unselect": "Deselect all floors",
  "BuildingClone.noClone": "No scenario has been created yet, you can create your first scenario for this building",
  "BuildingClone.buttons.CreateClone.label": "Create a scenario",
  "BuildingClone.buttons.CreateClone.help": "The scenario will duplicate the building with the properties checked",
  "BuildingClone.accordion.title": "Create a new scenario",
  "BuildingClone.properties.clone.people": "Duplicate assignments",
  "BuildingClone.properties.clone.workplaces": "Duplicate workstations",
  "BuildingClone.properties.clone.items": "Duplicate objects",
  "BuildingClone.properties.clone.dimensions": "Associate analysis and assignment layers with spaces",
  "BuildingClone.properties.clone.organization": "Associate organizations with spaces",
  "BuildingDashboard.dashboards.workplace": "Desktop Dashboard",
  "BuildingDashboard.dashboards.area": "Surfaces Dashboard",
  "CampusBuildingsAccordion.buildingCount": "The number of buildings",
  "CalculatedPropertiesAccordions.mesures": "Measures",
  "CalculatedPropertiesAccordions.kpi": "Indicators",
  "DimensionMapFilter.TooltipTitle.notSelected": "Select %{dimension} to see the spaces on the plan with the associated color",
  "DimensionMapFilter.TooltipTitle.selected": "Deselecting %{dimension} will remove the associated color from the plane",
  "DimensionMapFilter.tooltip.true": "Select all the filters below to color them on the map",
  "DimensionMapFilter.tooltip.false": "Deselect all filters below",
  "DimensionMapFilter.NoNode": "There are no analysis layers at the moment, you can add more by editing a space and adding analysis layers to it",
  "DimensionMapFilter.NoCategory": "There are no analysis layers available, you must first associate some to the spaces",
  "SelectDimensionTypeNavigationLayoutIcon.select": "Select this layer type for navigation",
  "SelectDimensionTypeNavigationLayoutIcon.unselect": "Remove navigation by analysis layer and return to navigation by spaces",
  "SelectDimensionTypeNavigationLayoutIcon.help": "Navigation by analysis layer allows you to click on a space, select the corresponding layer and see the people assigned to this layer or the workstations and objects associated with this layer through the spaces",
  "DimensionTypeNavigationWarning.message": "You are browsing by %{name} , spaces will be grouped together when selected. Click to cancel and return to browsing by space",
  "RoomCardSelectDimensions.needSave": "Please save or cancel your changes before you can modify the analysis layers of this space",
  "AssignPersonToWorkplaceCheckListDialogTitle.title": "You have assigned %{personName} to workstation %{workplaceName}",
  "AssignPersonToRoomCheckListDialogTitle.title": "You assigned %{personName} to space %{roomName}",
  "WorkplaceFullName.noName": "Unnamed workstation",
  "RoomFullName.noName": "unnamed space",
  "AssignPersonCheckListWorkplaceTransit.title": "The workstation %{workplaceName} is a temporary workstation",
  "AssignPersonCheckListWorkplaceTransit.RemoveIsTransit": "Remove the &quot;is passing&quot; type from the workstation",
  "AssignPersonCheckListWorkplaceAffectations.title": "This person is already assigned on other workstations, do you want to remove the following assignments for %{personFullname}",
  "AssignPersonCheckListRoomAffectations.title": "This person is already directly assigned to other spaces, do you want to remove the following assignments for %{personFullname}",
  "AssignPersonCheckListDialogApplyButton.help": "Delete selected assignments that may match the person's old assignments",
  "AssignPersonCheckListDialogApplyButton.label": "Delete selected assignments",
  "AssignPersonCheckListDialog.actions.close.label": "To close",
  "AssignPersonCheckListDialog.actions.close.help": "Close and don't delete any other assignments",
  "AssignPersonCheckListBuildingAffectations.title": "This person is already directly assigned on other buildings, do you want to remove the following assignments for %{personFullname}",
  "WorkplaceVirtualInventory.title": "Virtual workstation inventory",
  "WorkplacePhysicalInventory.title": "Physical inventory of the workstation",
  "WorkplaceTypeSeatsCount.label": "Number of seats",
  "WorkplaceTypeSeatsCount.help": "The number of seats counted for this type of workstation",
  "WorkplaceTypeCarbonFootprintCount.label": "Carbon footprint",
  "WorkplaceTypeCarbonFootprintCount.help": "The carbon footprint is the amount of greenhouse gases emitted by the furniture objects of this type of workstation",
  "DeleteWorkplace.help": "Delete workstation: [ %{name} ], assignments will also be deleted",
  "AddPersonToWorkplace.text": "Assign a person",
  "AddPersonToWorkplace.help": "Add assignment to this workstation, you can add multiple assignments for the same workstation",
  "MouvementMatrixImport.errors.noSheet": "Could not find excel sheet with name %{name} [ %{objectTypeName} ]",
  "RoomTypeGroupMapFilter.Empty": "There is no space type group associated with spaces via space types, you can add more by editing a space type group and adding associating a space type to it, then you can control their display from this section",
  "RoomTypeGroupLabel.exclude.tooltip": "The space typology group excludes associated space types",
  "RoomTypeGroupHelpTitle.exclude": "The %{name} space type grouping is of type exclusion. It groups all spaces except the following space typologies:",
  "RoomTypeGroupHelpTitle.include": "The %{name} space type grouping groups the following space typologies:",
  "RoomTypeGroupToRoomTypeLabel.exclude.tooltip": "The space typology is excluded",
  "RoomMapFilter.Empty": "There is no space type associated with spaces, you can add more by modifying a space and adding an associated type to it, then you can control their display from this section",
  "LayoutFiltersTabZone.collapse.help": "The menu is closed, you can open it by clicking on the first icon to open it and see the details of the elements of the plan",
  "LayoutFiltersTabOpenToggleIcon.open.true": "Close the map menu to optimize the space of the map display",
  "LayoutFiltersTabOpenToggleIcon.open.false": "Open the plan menu to see detailed information related to the plan",
  "CompanyTypeLabel.notClassified": "Unclassified platform",
  "BuildingMenuItem.menu.scenario": "Scenarios ( %{count} )",
  "SearchMenuItem.icon.tooltip": "Search",
  "RemoveFromCartIconButton.help": "Remove from cart",
  "CopyCartContentIntoTenant.buttons.single.paste.help": "Import to this company",
  "IndexContextMenuItem.navigation": "Navigation",
  "GlobalSearchIncludeScenarios.label": "Include scenarios in search",
  "GlobalSearch.Input.placeholder": "Search",
  "GlobalSearch.Start": "You can search for example people, spaces, workstations, objects or other entities, the search will start from the 2nd character",
  "GlobalSearch.NoResult": "No results were found for your search",
  "GlobalSearch.close.help": "Clear search",
  "models.PartnerExportMappingConfigurationToFloor.singular": "Floor included in the configuration of the transformation of partner exports",
  "models.PartnerExportMappingConfigurationToFloor.plural": "Floors included in the configuration of the transformation of partner exports",
  "models.PartnerExportMappingConfigurationToFloor.determinant.defined": "the floor included in the configuration of the transformation of partner exports",
  "models.PartnerExportMappingConfigurationToFloor.determinant.undefined": "a floor included in the configuration of the transformation of partner exports",
  "models.PartnerExportMappingConfigurationToFloor.determinants.defined": "the floors included in the configurations of the transformations of the partner exports",
  "models.PartnerExportMappingConfigurationToFloor.determinants.undefined": "floors included in the configurations of partner export transformations",
  "models.PartnerExportMappingToRoomType.singular": "Transformation of partner exports for space types",
  "models.PartnerExportMappingToRoomType.plural": "Partner export transformations for space types",
  "models.PartnerExportMappingToRoomType.determinant.defined": "transformation of partner exports for space types",
  "models.PartnerExportMappingToRoomType.determinant.undefined": "a transformation of partner exports for space types",
  "models.PartnerExportMappingToRoomType.determinants.defined": "Partner export transformations for space types",
  "models.PartnerExportMappingToRoomType.determinants.undefined": "transformations of partner exports for space types",
  "models.PartnerExportMappingConfiguration.singular": "Configuring Partner Export Transformation",
  "models.PartnerExportMappingConfiguration.plural": "Partner export transformation configurations",
  "models.PartnerExportMappingConfiguration.determinant.defined": "the configuration of the transformation of partner exports",
  "models.PartnerExportMappingConfiguration.determinant.undefined": "a configuration of the transformation of partner exports",
  "models.PartnerExportMappingConfiguration.determinants.defined": "partner export transformation configurations",
  "models.PartnerExportMappingConfiguration.determinants.undefined": "configurations of partner export transformations",
  "models.PartnerExportMapping.singular": "Transformation of partner exports",
  "models.PartnerExportMapping.plural": "Transformations of partner exports",
  "models.PartnerExportMapping.determinant.defined": "the transformation of partner exports",
  "models.PartnerExportMapping.determinant.undefined": "a transformation of partner exports",
  "models.PartnerExportMapping.determinants.defined": "transformations of partner exports",
  "models.PartnerExportMapping.determinants.undefined": "transformations of partner exports",
  "models.WorkplaceTypeItemType.singular": "object type in workstation type",
  "models.WorkplaceTypeItemType.plural": "object types in workstation type",
  "models.WorkplaceTypeItemType.determinant.defined": "the object type in the workstation type",
  "models.WorkplaceTypeItemType.determinant.undefined": "an object type in a workstation type",
  "models.WorkplaceTypeItemType.determinants.defined": "object types in workstation types",
  "models.WorkplaceTypeItemType.determinants.undefined": "object types in workstation types",
  "models.WorkplaceTypeItemType.properties.id.label": "Object type identifier in the workstation type",
  "models.WorkplaceTypeItemType.properties.zIndex.label": "Height index",
  "models.WorkplaceTypeItemType.properties.zIndex.description": "The height index allows you to define the order of display of object types, the larger the index, the more the object will be above the others",
  "models.WorkplaceTypeItemType.properties.physicalInventory.label": "Physical inventory",
  "models.WorkplaceTypeItemType.properties.physicalInventory.description": "If this option is checked for each workstation a physical object will be created in Surfy, this object may have a unique reference, in all cases the building inventory will be up to date",
  "models.WorkplaceTypeItemType.properties.seatsCount.label": "Number of seats",
  "models.WorkplaceTypeItemType.properties.seatsCount.description": "Allows you to define the number of seats available in the workstation type for this object type",
  "models.WorkplaceType.singular": "type of workstation",
  "models.WorkplaceType.plural": "types of workstations",
  "models.WorkplaceType.determinant.defined": "the type of workstation",
  "models.WorkplaceType.determinant.undefined": "a type of workstation",
  "models.WorkplaceType.determinants.defined": "types of workstations",
  "models.WorkplaceType.determinants.undefined": "types of workstations",
  "models.WorkplaceType.properties.id.label": "Workstation typology identifier",
  "models.WorkplaceType.properties.id.description": "???",
  "models.WorkplaceType.properties.name.label": "Workstation type name",
  "models.WorkplaceType.properties.name.description": "???",
  "models.WorkplaceType.views.editor.help": "Edit shapes and locations of object types for workstation type %{name}",
  "models.WorkplaceType.views.editor.label": "Edit shapes",
  "models.WorkplaceType.views.avatar.help": "See the form of the workstation type %{name}",
  "models.WorkplaceType.views.avatar.label": "See the shape",
  "models.WorkplaceType.views.dq-not-used.label": "Not used",
  "models.WorkplaceType.views.dq-not-used.help": "List all types of unused workstations via workstations",
  "models.WorkplaceAffectation.singular": "Work station assignment",
  "models.WorkplaceAffectation.plural": "Workstation assignments",
  "models.WorkplaceAffectation.description": "Allows a fixed workstation to be assigned to a person",
  "models.WorkplaceAffectation.determinant.defined": "job assignment",
  "models.WorkplaceAffectation.determinant.undefined": "job assignment",
  "models.WorkplaceAffectation.determinants.defined": "job assignments",
  "models.WorkplaceAffectation.determinants.undefined": "job assignments",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.help": "Import workstation transfer matrices",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.label": "Import transfer matrix",
  "models.Workplace.singular": "workplace",
  "models.Workplace.plural": "personal work places",
  "models.Workplace.determinant.defined": "desktop",
  "models.Workplace.determinant.undefined": "a workstation",
  "models.Workplace.determinants.defined": "work stations",
  "models.Workplace.determinants.undefined": "work stations",
  "models.Workplace.views.assign-current-user.label": "Occupy the workstation",
  "models.Workplace.views.assign-current-user.help": "Occupy workstation %{name}",
  "models.Workplace.properties.id.label": "Workstation identifier",
  "models.Workplace.properties.id.description": "???",
  "models.Workplace.properties.color.label": "Color",
  "models.Workplace.properties.color.description": "The color that the workstation type will take on the plan",
  "models.Workplace.properties.name.label": "Workstation name",
  "models.Workplace.properties.name.description": "The name of the workstation is used to identify it more simply",
  "models.Workplace.properties.isFlex.label": "Is flex?",
  "models.Workplace.properties.isFlex.description": "If this station is used in Flex mode",
  "models.Workplace.properties.isShared.label": "Is shared ?",
  "models.Workplace.properties.isShared.description": "If this workstation is shared by several people, this automatic field is validated as soon as there are at least 2 assignments on the workstation",
  "models.Workplace.properties.isTransit.label": "Is passing through?",
  "models.Workplace.properties.isTransit.description": "If this position is transient, this position will be excluded from free workstations without being reservable in flex, a transient position makes it possible to have a workstation available for all those who wish to use it without being included in a system of reservation",
  "models.Workplace.properties.isBookable.label": "Is bookable?",
  "models.Workplace.properties.isBookable.description": "If this workstation is reservable in a reservation system",
  "models.Workplace.properties.position.label": "Position",
  "models.Workplace.properties.position.description": "The position of the workstation in space",
  "models.Workplace.properties.rotation.label": "Rotation",
  "models.Workplace.properties.rotation.description": "The angle of rotation of the workstation in space",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.label": "Average assignment rate",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.description": "Average assignment rate of the workstation according to the assignment of the days of presence of the people",
  "models.Workplace.properties.workplaceAffectationsCount.label": "Number of assignments",
  "models.Workplace.properties.workplaceAffectationsCount.description": "Number of assignments on the workstation",
  "models.Workplace.properties.comment.label": "Comment",
  "models.Workplace.properties.comment.description": "Additional information about the workstation",
  "models.Workplace.properties.room.label": "Workstation space",
  "models.UserRegistrationTenantRuleToJupRole.singular": "Association of authentication rule to role",
  "models.UserRegistrationTenantRuleToJupRole.plural": "Authentication rule-to-role associations",
  "models.UserRegistrationTenantRuleToJupRole.determinant.defined": "association of authentication rule to role",
  "models.UserRegistrationTenantRuleToJupRole.determinant.undefined": "an authentication rule-to-role association",
  "models.UserRegistrationTenantRuleToJupRole.determinants.defined": "authentication rule-to-role associations",
  "models.UserRegistrationTenantRuleToJupRole.determinants.undefined": "role-to-role authentication rule associations",
  "models.UserRegistrationTenantRuleToContentRole.singular": "Authentication rule to content role association",
  "models.UserRegistrationTenantRuleToContentRole.plural": "Authentication rule to content role associations",
  "models.UserRegistrationTenantRuleToContentRole.determinant.defined": "Authentication rule to content role association",
  "models.UserRegistrationTenantRuleToContentRole.determinant.undefined": "an authentication rule to content role association",
  "models.UserRegistrationTenantRuleToContentRole.determinants.defined": "authentication rule to content role associations",
  "models.UserRegistrationTenantRuleToContentRole.determinants.undefined": "content role-to-authentication rule associations",
  "models.UserRegistrationTenantRule.singular": "Authentication rule",
  "models.UserRegistrationTenantRule.plural": "Authentication rules",
  "models.UserRegistrationTenantRule.determinant.defined": "the authentication rule",
  "models.UserRegistrationTenantRule.determinant.undefined": "an authentication rule",
  "models.UserRegistrationTenantRule.determinants.defined": "authentication rules",
  "models.UserRegistrationTenantRule.determinants.undefined": "authentication rules",
  "models.UserRegistrationTenantRule.properties.domains.label": "Areas",
  "models.UserRegistrationTenantRule.properties.domains.description": "Separate domains with spaces and include the at sign",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.label": "Automatically associate roles",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.description": "Automatically associate roles and content roles with users who meet this rule",
  "models.UserCompany.singular": "business user",
  "models.UserCompany.plural": "business users",
  "models.UserCompany.description": "Enterprise users have access to their company's Surfy platform",
  "models.UserCompany.determinant.defined": "the business user",
  "models.UserCompany.determinant.undefined": "a business user",
  "models.UserCompany.determinants.defined": "business users",
  "models.UserCompany.determinants.undefined": "enterprise users",
  "models.UserCompany.properties.id.label": "Company user ID",
  "models.UserCompany.properties.buildingOwners.label": "Proprietary buildings",
  "models.UserCompany.properties.buildingOwners.description": "Buildings owned by the user",
  "models.User.singular": "user",
  "models.User.plural": "users",
  "models.User.determinant.defined": "the user",
  "models.User.determinant.undefined": "an user",
  "models.User.determinants.defined": "the users",
  "models.User.determinants.undefined": "users",
  "models.User.properties.id.label": "User ID",
  "models.User.properties.id.description": "???",
  "models.User.properties.firstname.label": "First name",
  "models.User.properties.firstname.description": "The user's first name",
  "models.User.properties.lastname.label": "Last name",
  "models.User.properties.lastname.description": "The user's last name",
  "models.User.properties.email.label": "E-mail",
  "models.User.properties.email.description": "The email used by the user for correspondence or for authentication",
  "models.Structure.singular": "structure",
  "models.Structure.plural": "structures",
  "models.Structure.determinant.defined": "the structure",
  "models.Structure.determinant.undefined": "a structure",
  "models.Structure.determinants.defined": "the structures",
  "models.Structure.determinants.undefined": "structures",
  "models.Structure.properties.nom.label": "Name of the stucture",
  "models.Structure.properties.nom.description": "To find and reuse the structure easily",
  "models.Structure.properties.transform.label": "Transformation",
  "models.Structure.properties.transform.description": "Transformation of the structure to calibrate it on a map",
  "models.Structure.views.editor.label": "Edit shape",
  "models.Structure.views.editor.help": "Modify the shape of the structure",
  "models.Structure.views.gmap-calibrate.label": "Calibrate the structure on a map",
  "models.Structure.views.gmap-calibrate.help": "Calibrate the structure on a map in order to associate geographic coordinates",
  "models.RoomTypeGroupToRoomType.singular": "association of space typology group with space typology",
  "models.RoomTypeGroupToRoomType.plural": "associations groups of space typologies to space typologies",
  "models.RoomTypeGroupToRoomType.determinant.defined": "the association of space typology group with space typology",
  "models.RoomTypeGroupToRoomType.determinant.undefined": "a group association of space typology to space typology",
  "models.RoomTypeGroupToRoomType.determinants.defined": "group associations of space typologies to space typologies",
  "models.RoomTypeGroupToRoomType.determinants.undefined": "group associations of space typologies to space typologies",
  "models.RoomTypeGroupFloor.singular": "floor space typology group",
  "models.RoomTypeGroupFloor.plural": "floor space typology groups",
  "models.RoomTypeGroupFloor.determinant.defined": "the space typology group of floors",
  "models.RoomTypeGroupFloor.determinant.undefined": "a group of floor space typology",
  "models.RoomTypeGroupFloor.determinants.defined": "the space typology group of floors",
  "models.RoomTypeGroupFloor.determinants.undefined": "groups of floor space typologies",
  "models.RoomTypeGroupBuilding.singular": "building space typology group",
  "models.RoomTypeGroupBuilding.plural": "groups of building space typologies",
  "models.RoomTypeGroupBuilding.determinant.defined": "the building space typology group",
  "models.RoomTypeGroupBuilding.determinant.undefined": "a group of building space typology",
  "models.RoomTypeGroupBuilding.determinants.defined": "the building space typology group",
  "models.RoomTypeGroupBuilding.determinants.undefined": "groups of building space typologies",
  "models.RoomTypeGroup.singular": "space typology group",
  "models.RoomTypeGroup.plural": "space typology groups",
  "models.RoomTypeGroup.determinant.defined": "the space typology group",
  "models.RoomTypeGroup.determinant.undefined": "a space typology group",
  "models.RoomTypeGroup.determinants.defined": "space typology groups",
  "models.RoomTypeGroup.determinants.undefined": "groups of space typologies",
  "models.RoomTypeGroup.properties.id.label": "Space typology group identifier",
  "models.RoomTypeGroup.properties.name.label": "Space typology group name",
  "models.RoomTypeGroup.properties.code.label": "Code",
  "models.RoomTypeGroup.properties.color.label": "Color",
  "models.RoomTypeGroup.properties.exclude.label": "Exclude",
  "models.RoomTypeGroup.properties.exclude.description": "Exclude space typologies from this group",
  "models.RoomTypeFloor.singular": "floor space typology",
  "models.RoomTypeFloor.plural": "floor space typologies",
  "models.RoomTypeFloor.determinant.defined": "the typology of floor space",
  "models.RoomTypeFloor.determinant.undefined": "a typology of floor space",
  "models.RoomTypeFloor.determinants.defined": "floor space typologies",
  "models.RoomTypeFloor.determinants.undefined": "floor space typologies",
  "models.RoomTypeBuilding.singular": "building space typology",
  "models.RoomTypeBuilding.plural": "building space typologies",
  "models.RoomTypeBuilding.determinant.defined": "the typology of building space",
  "models.RoomTypeBuilding.determinant.undefined": "a typology of building space",
  "models.RoomTypeBuilding.determinants.defined": "building space typologies",
  "models.RoomTypeBuilding.determinants.undefined": "building space typologies",
  "models.RoomType.singular": "space typology",
  "models.RoomType.plural": "space typologies",
  "models.RoomType.determinant.defined": "space typology",
  "models.RoomType.determinant.undefined": "a typology of space",
  "models.RoomType.determinants.defined": "space typologies",
  "models.RoomType.determinants.undefined": "space typologies",
  "models.RoomType.properties.id.label": "Space typology identifier",
  "models.RoomType.properties.name.label": "Space type name",
  "models.RoomType.properties.color.label": "2d color",
  "models.RoomType.properties.color.description": "The color of the type of space makes it possible to differentiate each type on the 2d plan",
  "models.RoomType.properties.color3d.label": "3d color",
  "models.RoomType.properties.color3d.description": "Allows you to manage the color of the type of space in 3d, this option is only applicable to the 3d vision of the floor",
  "models.RoomType.properties.displayWallsOn3d.label": "Show walls",
  "models.RoomType.properties.displayWallsOn3d.description": "Allows you to display or not the walls of the space in the 3d floor plan, the undisplayed walls are dotted in 2d, this allows you to have a more pleasant view, especially for open spaces",
  "models.RoomType.properties.icon.label": "Icon",
  "models.RoomType.properties.icon.description": "The icon for the type of space makes it possible to display for this type of space an icon in 2d and 3d plans instead of the classic information on the plan, associated with the background color this makes it possible to render the more pleasant reading of the plan",
  "models.RoomType.properties.cadence.label": "Cadence",
  "models.RoomType.properties.cadence.description": "The rate is a numerical value indicating the difficulty of cleaning the type of space. It is equal to the number of m² that can be treated in one hour in this type (circulation, laboratory, etc.)",
  "models.RoomType.properties.isBookable.label": "Is bookable?",
  "models.RoomType.properties.isBookable.description": "Check this box if this type of space can be reserved",
  "models.RoomPointSegmentType.singular": "Segment type",
  "models.RoomPointSegmentType.plural": "Segment types",
  "models.RoomPointSegmentType.determinant.defined": "the type of segment",
  "models.RoomPointSegmentType.determinant.undefined": "a type of segment",
  "models.RoomPointSegmentType.determinants.defined": "segment types",
  "models.RoomPointSegmentType.determinants.undefined": "segment types",
  "models.RoomPointSegment.singular": "segment qualification",
  "models.RoomPointSegment.plural": "segment qualifications",
  "models.RoomPointSegment.determinant.defined": "segment qualification",
  "models.RoomPointSegment.determinant.undefined": "a segment qualification",
  "models.RoomPointSegment.determinants.defined": "segment qualifications",
  "models.RoomPointSegment.determinants.undefined": "segment qualifications",
  "models.RoomPointSegment.properties.reversePoints.label": "Reverse points",
  "models.RoomPointSegment.properties.reversePoints.description": "Reverse the points of the segment in order to have the display, for example, of doors in the right direction",
  "models.RoomPointSegment.properties.displayBothSides.label": "Show on both sides",
  "models.RoomPointSegment.properties.displayBothSides.description": "Show segment on both sides of segment",
  "models.RoomPointSegment.views.dq-not-uniq.label": "Non-unique point segments",
  "models.RoomPointSegment.views.dq-not-uniq.help": "Allows you to check that there is no exact duplicate segment on the same points",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.label": "The points of the segments are on 2 different floors",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.help": "Allows you to check that the points of the segments are on the same floor",
  "models.RoomPointRoom.singular": "Association between a point and a space",
  "models.RoomPointRoom.plural": "Associations between a point and a space",
  "models.RoomPointRoom.determinant.defined": "the association between a point and a space",
  "models.RoomPointRoom.determinant.undefined": "a point",
  "models.RoomPointRoom.description": "The association between a point and a space makes it possible to preserve the order of the points in a space in order to constitute a polyon",
  "models.RoomPointRoom.properties.id.label": "Identifier of the association between a point and a space",
  "models.RoomPointRoom.properties.id.description": "???",
  "models.RoomPointRoom.properties.roomId.label": "Space ID",
  "models.RoomPointRoom.properties.roomId.description": "???",
  "models.RoomPointRoom.properties.externalId.label": "External identifier",
  "models.RoomPointRoom.properties.externalId.description": "???",
  "models.RoomPointRoom.properties.sortIndex.label": "Sort index",
  "models.RoomPointRoom.properties.sortIndex.description": "???",
  "models.RoomPointRoom.properties.roomPointId.label": "Point identifier",
  "models.RoomPointRoom.properties.roomPointId.description": "???",
  "models.RoomPoint.singular": "point of spaces",
  "models.RoomPoint.plural": "points of spaces",
  "models.RoomPoint.determinant.defined": "the point of spaces",
  "models.RoomPoint.determinant.undefined": "a point of spaces",
  "models.RoomPoint.properties.id.label": "Identifier of the point of spaces",
  "models.RoomPoint.properties.x.label": "x",
  "models.RoomPoint.properties.x.description": "Coordinate on the X axis",
  "models.RoomPoint.properties.y.label": "there",
  "models.RoomPoint.properties.y.description": "Y axis coordinate",
  "models.RoomPoint.properties.sort_index.label": "Order",
  "models.RoomPoint.properties.sort_index.description": "The index used for sorting",
  "models.RoomPoint.properties.room.description": "???",
  "models.RoomPoint.properties.externalId.label": "External identifier",
  "models.RoomPoint.properties.externalId.description": "???",
  "models.RoomPoint.views.dq-uniq-position.label": "Single point position",
  "models.RoomPoint.views.dq-uniq-position.help": "Allows you to check that there is no exact duplicate position on the points",
  "models.RoomPoint.views.dq-not-used.label": "Unused points",
  "models.RoomPoint.views.dq-not-used.help": "Allows you to see points that are not used in spaces",
  "models.RoomConnector.singular": "Space connector",
  "models.RoomConnector.plural": "Space connectors",
  "models.RoomConnector.determinant.defined": "the space connector",
  "models.RoomConnector.determinant.undefined": "a space connector",
  "models.RoomConnector.determinants.defined": "space connectors",
  "models.RoomConnector.determinants.undefined": "space connectors",
  "models.RoomConnector.description": "Space connectors allow you to create a link between several spaces on different floors",
  "models.RoomConnector.properties.id.label": "Space Connector ID",
  "models.RoomConnector.properties.name.label": "Space connector name",
  "models.RoomConnector.properties.waitTime.label": "Average waiting time",
  "models.RoomConnector.properties.waitTime.description": "The average wait time before the space connector becomes available",
  "models.RoomConnector.properties.timePerFloor.label": "Time between each floor",
  "models.RoomConnector.properties.timePerFloor.description": "The time required to be able to move from each floor to the next",
  "models.RoomAffectation.singular": "Space allocation",
  "models.RoomAffectation.plural": "Space assignments",
  "models.RoomAffectation.description": "Allows you to assign a person to a single space",
  "models.RoomAffectation.determinant.defined": "space allocation",
  "models.RoomAffectation.determinant.undefined": "a space allocation",
  "models.RoomAffectation.determinants.defined": "space assignments",
  "models.RoomAffectation.determinants.undefined": "space assignments",
  "models.RoomAffectation.views.room-mouvement-matrix-import.help": "Import spaces transfer matrices",
  "models.RoomAffectation.views.room-mouvement-matrix-import.label": "Import transfer matrix",
  "models.Room.singular": "space",
  "models.Room.plural": "spaces",
  "models.Room.determinant.defined": "space",
  "models.Room.determinant.undefined": "an area",
  "models.Room.determinants.defined": "the spaces",
  "models.Room.determinants.undefined": "spaces",
  "models.Room.description": "Spaces are workplaces or areas in order to divide a floor into sub-spaces.",
  "models.Room.views.map.help": "View space plan %{name}",
  "models.Room.views.map.label": "Plan",
  "models.Room.views.dq-uniq-name.help": "Suggests names for spaces that do not have a name or the name is not unique on the same floor",
  "models.Room.views.dq-uniq-name.label": "Proposed names for spaces",
  "models.Room.views.dq-no-point.help": "Spaces that have 0, 1, or 2 points and therefore should have zero area",
  "models.Room.views.dq-no-point.label": "Spaces without enough points",
  "models.Room.views.dq-capacity-equals-seats-count.help": "Spaces which have a capacity excluding seats equal to the number of seats and which have a total capacity doubled",
  "models.Room.views.dq-capacity-equals-seats-count.label": "Spaces with a capacity excluding seats equal to the number of seats",
  "models.Room.views.dq-capacity-gt-0.help": "Allows you to see if there are any inconsistencies in the capacities of spaces or detect, for example, furniture that does not yet have seats",
  "models.Room.views.dq-capacity-gt-0.label": "Spaces which have a capacity excluding seats different from 0",
  "models.Room.views.meeting-rooms.help": "View and navigate meeting rooms",
  "models.Room.views.meeting-rooms.label": "Meeting rooms",
  "models.Room.properties.prettyName.label": "Display name",
  "models.Room.properties.prettyName.description": "Allows to have a display name in addition to the technical name of the space, for example for meeting rooms",
  "models.Room.properties.id.label": "Space ID",
  "models.Room.properties.livePeopleCount.label": "Number of people in space in real time",
  "models.Room.properties.livePeopleCount.description": "This value is updated by the people counting sensors present in the space and provides the number of people present in real time in the space",
  "models.Room.properties.picture.label": "Photo from space",
  "models.Room.properties.picture.description": "The photo of the space makes it easy to visualize",
  "models.Room.properties.capacity.label": "Capacity excluding seats",
  "models.Room.properties.capacity.description": "The declared capacity can be used to define the number of seats available in a space or to know the maximum number of people that can be put in a space, this figure is added to the number of seats to give the total capacity",
  "models.Room.properties.workplacesCount.label": "Number of workstations",
  "models.Room.properties.workplacesCount.description": "The number of workstations in the space is calculated automatically",
  "models.Room.properties.workplacesRatio.label": "Ratio per workstation",
  "models.Room.properties.workplacesRatio.description": "The ratio per workstation is the number of square meters of space divided by the number of workstations, this value is calculated automatically",
  "models.Room.properties.peopleCount.label": "Number of assignments",
  "models.Room.properties.peopleCount.description": "The number of people assigned to the space, either directly or through a workstation",
  "models.Room.properties.peopleRatio.label": "Occupancy ratio",
  "models.Room.properties.peopleRatio.description": "The occupancy ratio is the number of square meters of the space divided by the number of people assigned to the spaces, either directly or via a workstation, this value is calculated",
  "models.Room.properties.freeWorkplacesCount.label": "Number of vacancies",
  "models.Room.properties.freeWorkplacesCount.description": "Number of free positions in the space",
  "models.Room.properties.flexWorkplacesCount.label": "Number of flex positions",
  "models.Room.properties.flexWorkplacesCount.description": "Number of flex positions in the space",
  "models.Room.properties.sharedWorkplacesCount.label": "Number of shared workstations",
  "models.Room.properties.sharedWorkplacesCount.description": "Number of workstations shared by at least 2 people",
  "models.Room.properties.transitWorkplacesCount.label": "Number of transit workstations",
  "models.Room.properties.transitWorkplacesCount.description": "Number of temporary workstations, these positions are not counted in free positions and are not flex",
  "models.Room.properties.sharedWorkplacesRatio.label": "Rate of shared workstations",
  "models.Room.properties.sharedWorkplacesRatio.description": "Rate of workstations shared by at least 2 people compared to all workstations in the space",
  "models.Room.properties.flexRatio.label": "Rate of flex workstations",
  "models.Room.properties.flexRatio.description": "The flex workstation rate is calculated by dividing the number of flex workstations by the total number of workstations",
  "models.Room.properties.name.label": "Space name",
  "models.Room.properties.name.description": "The space name is used to define it and find it easily.",
  "models.Room.properties.area.label": "Area",
  "models.Room.properties.area.description": "The qualified floor space for this space",
  "models.Room.properties.perimeter.label": "Perimeter",
  "models.Room.properties.perimeter.description": "The perimeter of space represents its outline",
  "models.Room.properties.costCenter.description": "Allows you to know which cost center to associate the space with when it comes to managing re-invoicing to the cost center by space",
  "models.Room.properties.distributionCostType.description": "Allows you to determine the method of calculating the cost distribution key",
  "models.Room.properties.info.label": "Additional information",
  "models.Room.properties.info.description": "Allows you to keep additional text-type information on the space",
  "models.Room.properties.bookingEmail.label": "Email used to reserve this space",
  "models.Room.properties.bookingEmail.description": "This email is used to reserve this room via the messaging system",
  "models.Room.properties.keyCylinderCode.label": "Cylinder number",
  "models.Room.properties.keyCylinderCode.description": "The cylinder number allows you to define the cylinder number of the space door lock or an element related to the physical access to the space",
  "models.Room.reports.mouvementMatrix.fileName": "Transfer matrix",
  "models.Room.reports.mouvementMatrix.help": "Create a transfer matrix in Excel allowing you to easily carry out the trips of your employees",
  "models.PersonWorkingLocation.singular": "People's work location",
  "models.PersonWorkingLocation.plural": "People's work locations",
  "models.PersonWorkingLocation.determinant.defined": "people's work location",
  "models.PersonWorkingLocation.determinant.undefined": "a place where people work",
  "models.PersonWorkingLocation.determinants.defined": "people's work locations",
  "models.PersonWorkingLocation.determinants.undefined": "people's work locations",
  "models.PersonWorkingLocation.description": "A workplace of people defines the workplace of people",
  "models.PersonWorkingLocation.views.my-planning.help": "Manage my schedule for the next few weeks",
  "models.PersonWorkingLocation.views.my-planning.label": "Manage my schedule",
  "models.PersonToWorkplaceBooking.singular": "Reservation at people's workstations",
  "models.PersonToWorkplaceBooking.plural": "Reservations at people's workstations",
  "models.PersonToWorkplaceBooking.description": "People's workstation reservations are recorded and available with reservation start and end dates",
  "models.PersonToWorkplaceBooking.determinant.defined": "reservation at people's workstation",
  "models.PersonToWorkplaceBooking.determinant.undefined": "a reservation at the people's workstation",
  "models.PersonToWorkplaceBooking.determinants.defined": "reservations at people's workstations",
  "models.PersonToWorkplaceBooking.determinants.undefined": "reservations at people's workstations",
  "models.PersonToWorkplaceBooking.properties.startDatetime.label": "Start of booking",
  "models.PersonToWorkplaceBooking.properties.startDatetime.description": "The start date and time of the reservation",
  "models.PersonToWorkplaceBooking.properties.endDatetime.label": "End of reservation",
  "models.PersonToWorkplaceBooking.properties.endDatetime.description": "The date and time the reservation ends",
  "models.PersonToWorkplaceBooking.views.dashboard-index.label": "Dashboard",
  "models.PersonToWorkplaceBooking.views.dashboard-index.help": "People Workstation Reservations Dashboard",
  "models.PersonToRoomBooking.singular": "Reservation for the people area",
  "models.PersonToRoomBooking.plural": "Reservations for the people area",
  "models.PersonToRoomBooking.description": "Reservations for people's spaces are recorded and available with the reservation start and end dates",
  "models.PersonToRoomBooking.determinant.defined": "reservation in the people's area",
  "models.PersonToRoomBooking.determinant.undefined": "a reservation for the people area",
  "models.PersonToRoomBooking.determinants.defined": "reservations for the people area",
  "models.PersonToRoomBooking.determinants.undefined": "reservations for the people area",
  "models.PersonToRoomBooking.properties.startDatetime.label": "Start of booking",
  "models.PersonToRoomBooking.properties.startDatetime.description": "The start date and time of the reservation",
  "models.PersonToRoomBooking.properties.endDatetime.label": "End of reservation",
  "models.PersonToRoomBooking.properties.endDatetime.description": "The date and time the reservation ends",
  "models.PersonToPersonType.singular": "Type of relationship between people",
  "models.PersonToPersonType.plural": "Types of relationship between people",
  "models.PersonToPersonType.determinant.defined": "the type of relationship between people",
  "models.PersonToPersonType.determinant.undefined": "a type of relationship between people",
  "models.PersonToPersonType.determinants.defined": "types of relationships between people",
  "models.PersonToPersonType.determinants.undefined": "types of relationships between people",
  "models.PersonToPersonType.properties.labelForward.label": "Natural relationship (forward)",
  "models.PersonToPersonType.properties.labelForward.description": "The definition of relationship in the natural sense, for example between a father and his son, the natural definition is 'is the father of'",
  "models.PersonToPersonType.properties.labelBackward.label": "Inverse relationship",
  "models.PersonToPersonType.properties.labelBackward.description": "The definition of relationship in the reverse of the natural sense, for example between a father and his son, the reverse definition of the natural sense is 'is the son of'",
  "models.PersonToPerson.singular": "Person-to-person relationship",
  "models.PersonToPerson.plural": "Person-to-person relationships",
  "models.PersonToPerson.determinant.defined": "the person-to-person relationship",
  "models.PersonToPerson.determinant.undefined": "a person-to-person relationship",
  "models.PersonToPerson.determinants.defined": "person-to-person relationships",
  "models.PersonToPerson.determinants.undefined": "person-to-person relationships",
  "models.PersonToPerson.properties.personSource.label": "Source person",
  "models.PersonToPerson.properties.personTarget.label": "Destination person",
  "models.PersonToDimensionBooking.singular": "Reservation to the people assignment layer",
  "models.PersonToDimensionBooking.plural": "Reservations on the people assignment layer",
  "models.PersonToDimensionBooking.description": "Reservations to people assignment layers are recorded and available with reservation start and end dates",
  "models.PersonToDimensionBooking.determinant.defined": "reservation at the people assignment layer",
  "models.PersonToDimensionBooking.determinant.undefined": "a reservation on the people assignment layer",
  "models.PersonToDimensionBooking.determinants.defined": "reservations on the people assignment layer",
  "models.PersonToDimensionBooking.determinants.undefined": "reservations to the people assignment layer",
  "models.PersonToDimensionBooking.properties.startDatetime.label": "Start of booking",
  "models.PersonToDimensionBooking.properties.startDatetime.description": "The start date and time of the reservation",
  "models.PersonToDimensionBooking.properties.endDatetime.label": "End of reservation",
  "models.PersonToDimensionBooking.properties.endDatetime.description": "The date and time the reservation ends",
  "models.PersonState.singular": "status of persons",
  "models.PersonState.plural": "status of persons",
  "models.PersonState.description": "Allows you to define all types of contracts between people and the company",
  "models.PersonState.determinant.defined": "the status of people",
  "models.PersonState.determinant.undefined": "a status of persons",
  "models.PersonState.determinants.defined": "the status of persons",
  "models.PersonState.determinants.undefined": "of the statutes of persons",
  "models.PersonState.properties.id.label": "Person status identifier",
  "models.PersonState.properties.name.label": "Person Status Name",
  "models.PersonToBuilding.singular": "Affection to the building",
  "models.PersonToBuilding.plural": "building assignments",
  "models.PersonToBuilding.description": "Allows you to assign a person to a building, without additional information. The assignment can be counted, or not.",
  "models.PersonToBuilding.determinant.defined": "affection for the building",
  "models.PersonToBuilding.determinant.undefined": "an affection for the building",
  "models.PersonToBuilding.determinants.defined": "building affections",
  "models.PersonToBuilding.determinants.undefined": "building ailments",
  "models.PersonToBuilding.properties.addToPeopleCount.label": "Count assignment",
  "models.PersonToBuilding.properties.addToPeopleCount.description": "Add this assignment to the total number of people assigned to the building",
  "models.PersonSecurityProfile.singular": "personal safety profile",
  "models.PersonSecurityProfile.plural": "personal safety profiles",
  "models.PersonSecurityProfile.description": "Allows you to define the different security profiles that can be associated with people",
  "models.PersonSecurityProfile.determinant.defined": "personal safety profile",
  "models.PersonSecurityProfile.determinant.undefined": "a personal safety profile",
  "models.PersonSecurityProfile.determinants.defined": "personal security profiles",
  "models.PersonSecurityProfile.determinants.undefined": "personal security profiles",
  "models.PersonSecurityProfile.properties.id.label": "Personal security profile identifier",
  "models.PersonSecurityProfile.properties.name.label": "Security profile name",
  "models.PersonSecurityProfile.properties.name.description": "Allows you to define the different security profiles that can be associated with people",
  "models.PersonSecurityProfile.properties.color.label": "Security profile color",
  "models.PersonSecurityProfile.properties.color.description": "Allows you to color the person's assigned workstation and security icon according to their security profile",
  "models.PersonSecurityProfile.properties.icon.label": "Security profile icon",
  "models.PersonSecurityProfile.properties.icon.description": "Allows you to assign an icon to a security profile in order to clearly visualize the security profiles on the map or in the lists",
  "models.PersonCompanyToRoomType.singular": "Type of provider space",
  "models.PersonCompanyToRoomType.plural": "Types of provider spaces",
  "models.PersonCompanyToRoomType.description": "The types of spaces of the service providers make it possible to define a relationship between a type of space and the service provider and to define a mission.",
  "models.PersonCompanyToRoomType.determinant.defined": "the type of space of the service provider",
  "models.PersonCompanyToRoomType.determinant.undefined": "a type of space of the service provider",
  "models.PersonCompanyToRoomType.determinants.defined": "the types of service providers’ spaces",
  "models.PersonCompanyToRoomType.determinants.undefined": "types of service providers’ spaces",
  "models.PersonGender.singular": "gender of the person",
  "models.PersonGender.plural": "Kinds of people",
  "models.PersonGender.description": "Allows you to count each gender, for example for managing toilets",
  "models.PersonGender.determinant.defined": "the gender of the person",
  "models.PersonGender.determinant.undefined": "a kind of person",
  "models.PersonGender.determinants.defined": "types of people",
  "models.PersonGender.determinants.undefined": "kinds of people",
  "models.PersonGender.properties.name.label": "Last name",
  "models.PersonGender.properties.name.description": "The gender name of the person",
  "models.PersonCompanyToItemType.singular": "Provider object type",
  "models.PersonCompanyToItemType.plural": "Provider object types",
  "models.PersonCompanyToItemType.description": "The service provider object types make it possible to define a relationship between the object type and the service provider and to define the mission.",
  "models.PersonCompanyToItemType.determinant.defined": "the type of object of the service provider",
  "models.PersonCompanyToItemType.determinant.undefined": "a type of provider object",
  "models.PersonCompanyToItemType.determinants.defined": "the types of service providers’ objects",
  "models.PersonCompanyToItemType.determinants.undefined": "types of service providers’ objects",
  "models.PersonCompanyToItem.singular": "Intervention on an object",
  "models.PersonCompanyToItem.plural": "Interventions on objects",
  "models.PersonCompanyToItem.description": "The interventions of service providers on objects make it possible to define, for example, the date of a visit to a fire extinguisher",
  "models.PersonCompanyToItem.determinant.defined": "intervention on an object",
  "models.PersonCompanyToItem.determinant.undefined": "an intervention on an object",
  "models.PersonCompanyToItem.determinants.defined": "interventions on objects",
  "models.PersonCompanyToItem.determinants.undefined": "interventions on objects",
  "models.PersonCompanyToItem.properties.datetime.label": "Date and time of intervention",
  "models.PersonCompanyToItem.properties.datetime.description": "When the intervention took place",
  "models.PersonCompanyToItem.properties.comment.label": "Comment",
  "models.PersonCompanyToItem.properties.comment.description": "A comment on the intervention",
  "models.PersonCompanyMission.singular": "mission of the service provider",
  "models.PersonCompanyMission.plural": "service provider missions",
  "models.PersonCompanyMission.description": "The missions of the service providers make it possible to know the area of ​​intervention of the service providers",
  "models.PersonCompanyMission.determinant.defined": "the mission of the service provider",
  "models.PersonCompanyMission.determinant.undefined": "a mission of the service provider",
  "models.PersonCompanyMission.determinants.defined": "the missions of the service providers",
  "models.PersonCompanyMission.determinants.undefined": "service providers’ missions",
  "models.PersonCompanyMission.properties.name.label": "Last name",
  "models.PersonCompanyMission.properties.name.description": "The name of the service provider’s mission",
  "models.PersonCompany.singular": "service provider company",
  "models.PersonCompany.plural": "service companies",
  "models.PersonCompany.description": "The service provider company allows you to manage service provider personnel by company to which they belong",
  "models.PersonCompany.determinant.defined": "the service provider company",
  "models.PersonCompany.determinant.undefined": "a service company",
  "models.PersonCompany.determinants.defined": "service companies",
  "models.PersonCompany.determinants.undefined": "service companies",
  "models.PersonCompany.properties.name.label": "Last name",
  "models.PersonCompany.properties.name.description": "The name of the service provider, for example the company name of a service provider",
  "models.PersonCompany.properties.comment.label": "Further information",
  "models.PersonCompany.properties.comment.description": "Additional information on the service provider, such as its mission, its values, the functional coverage of its service, etc.",
  "models.PersonCompany.properties.contact.label": "Contact",
  "models.PersonCompany.properties.contact.description": "Contact information of the service provider",
  "models.PersonCompany.properties.documents.label": "Related documents",
  "models.PersonCompany.properties.documents.description": "The link to the documents associated with this service provider",
  "models.Person.singular": "person",
  "models.Person.plural": "people",
  "models.Person.description": "These are the people entered into Surfy's database",
  "models.Person.determinant.defined": "the person",
  "models.Person.determinant.undefined": "one person",
  "models.Person.determinants.defined": "the people",
  "models.Person.determinants.undefined": "people",
  "models.Person.properties.id.label": "Surfy ID",
  "models.Person.properties.fullname.label": "Full Name",
  "models.Person.properties.fullname.description": "The full name of the person making it easier to find",
  "models.Person.properties.personState.label": "Status",
  "models.Person.properties.personState.description": "Allows you to indicate the type of contract the person has with the company",
  "models.Person.properties.personSecurityProfile.label": "Security profile",
  "models.Person.properties.personSecurityProfile.description": "Allows to indicate the security profile of the person for security management",
  "models.Person.properties.firstname.label": "First name",
  "models.Person.properties.firstname.description": "The first name of the person",
  "models.Person.properties.lastname.label": "Last name",
  "models.Person.properties.lastname.description": "Person's last name",
  "models.Person.properties.email.label": "E-mail",
  "models.Person.properties.email.description": "The person's email",
  "models.Person.properties.picture.label": "Profile picture",
  "models.Person.properties.picture.description": "The photo of the person to have it in the trombinoscope or in research",
  "models.Person.properties.monitorReference.label": "Screen reference",
  "models.Person.properties.monitorReference.description": "The reference of the computer screen associated with this person",
  "models.Person.properties.computerReference.label": "Computer reference",
  "models.Person.properties.computerReference.description": "The reference of the computer associated with this person",
  "models.Person.properties.cellphone.label": "Cellphone",
  "models.Person.properties.cellphone.description": "The person's mobile phone",
  "models.Person.properties.telephone.label": "Phone",
  "models.Person.properties.telephone.description": "The person's landline phone",
  "models.Person.properties.title.label": "title",
  "models.Person.properties.title.description": "The title of the person",
  "models.Person.properties.badgeNumber.label": "Badge number",
  "models.Person.properties.badgeNumber.description": "The person's badge number",
  "models.Person.properties.boxNumber.label": "Locker number",
  "models.Person.properties.boxNumber.description": "The person's locker number",
  "models.Person.properties.badgeRestaurant.label": "RIE badge",
  "models.Person.properties.badgeRestaurant.description": "The reference of the RIE or company restaurant badge",
  "models.Person.properties.registrationNumber.label": "Registration",
  "models.Person.properties.registrationNumber.description": "The person's registration number",
  "models.Person.properties.startDate.label": "Entry date",
  "models.Person.properties.startDate.description": "The date the person joined the company",
  "models.Person.properties.endDate.label": "Release date",
  "models.Person.properties.endDate.description": "The person's exit date from the company",
  "models.Person.properties.code.label": "Registration number",
  "models.Person.properties.code.description": "The person's HR number",
  "models.Person.properties.personToPersonTargets.label": "Relations with this person",
  "models.Person.properties.personToPersonTargets.description": "Allows you to know the ascending relationship between two people, for example the hierarchical relationship",
  "models.Person.properties.personToPersonSources.label": "Relationships from this person",
  "models.Person.properties.personToPersonSources.description": "Allows you to know the descending relationship between two people, for example the hierarchical relationship",
  "models.Person.properties.organization.label": "The organization of the person",
  "models.Person.properties.organization.description": "The person's attachment service",
  "models.Person.properties.info.label": "Comment",
  "models.Person.properties.info.description": "Comment on the person allowing to keep additional or miscellaneous information",
  "models.Person.properties.notAffectable.label": "Not Assignable",
  "models.Person.properties.notAffectable.description": "The person cannot be assigned to a workstation, space, building or assignment layer",
  "models.Person.views.home.help": "See the file of the person <b>%{name}</b> with his information and assignments",
  "models.Person.views.home.label": "Person file",
  "models.Person.views.relationship-list.help": "List the relationships between people",
  "models.Person.views.relationship-list.label": "List of relationships",
  "models.Person.views.dq-only-associated-to-building.help": "List assignable people who are assigned to a building and counted without being assigned (workstation, assignment layer, space)",
  "models.Person.views.dq-only-associated-to-building.label": "Persons assigned to a building without other assignment",
  "models.Person.views.dq-near-end-date.help": "List the people who have a contract end date after today and who are assigned to a workstation",
  "models.Person.views.dq-near-end-date.label": "People leaving the company",
  "models.Person.views.dq-no-affectations.label": "People without assignments",
  "models.Person.views.dq-no-affectations.help": "List assignable people who have no assignments (building, workstation, assignment layer, space)",
  "models.Person.views.dq-person-duplicate.label": "Duplicate people",
  "models.Person.views.dq-person-duplicate.help": "List duplicate people",
  "models.PartnerApiCredential.singular": "Partner API key",
  "models.PartnerApiCredential.plural": "Partner API keys",
  "models.PartnerApiCredential.determinant.defined": "the partner API key",
  "models.PartnerApiCredential.determinant.undefined": "a partner API key",
  "models.PartnerApiCredential.determinants.defined": "partner API keys",
  "models.PartnerApiCredential.determinants.undefined": "partner API keys",
  "models.PartnerApiCredential.properties.enable.label": "Enabled",
  "models.PartnerApiCredential.properties.enable.description": "You must activate the key to use it",
  "models.OrganizationFloor.singular": "Organization of floors",
  "models.OrganizationFloor.plural": "Floor organization",
  "models.OrganizationFloor.determinant.defined": "the organization of floors",
  "models.OrganizationFloor.determinant.undefined": "an organization of floors",
  "models.OrganizationFloor.determinants.defined": "floor organizations",
  "models.OrganizationFloor.determinants.undefined": "floor organizations",
  "models.OrganizationBuilding.singular": "Organization of buildings",
  "models.OrganizationBuilding.plural": "Building organizations",
  "models.OrganizationBuilding.determinant.defined": "organization of buildings",
  "models.OrganizationBuilding.determinant.undefined": "an organization of buildings",
  "models.OrganizationBuilding.determinants.defined": "building organizations",
  "models.OrganizationBuilding.determinants.undefined": "building organizations",
  "models.Organization.singular": "organization",
  "models.Organization.plural": "organizations",
  "models.Organization.determinant.defined": "the organization",
  "models.Organization.determinant.undefined": "an organization",
  "models.Organization.determinants.defined": "organizations",
  "models.Organization.determinants.undefined": "organizations",
  "models.Organization.description": "Organizations have two hierarchical levels: departments and services, and help define the organizational structure of the company.",
  "models.Organization.properties.id.label": "Organization ID",
  "models.Organization.properties.name.label": "Last name",
  "models.Organization.properties.name.description": "Name that will define the organization",
  "models.Organization.properties.code.label": "Code",
  "models.Organization.properties.code.description": "This code can be used to contain the organization coding or the key for identification via third party software",
  "models.Organization.properties.organizationId.label": "Management ID",
  "models.Organization.properties.organizationId.description": "It is thanks to this identifier that it is possible to create the organizational hierarchy",
  "models.Organization.properties.organization.label": "Direction",
  "models.Organization.properties.organizations.label": "Services",
  "models.Organization.views.hierarchy.label": "Hierarchy",
  "models.Organization.views.hierarchy.help": "View Organization Hierarchy",
  "models.Organization.views.dq-organization-to-room.label": "Errors in the organization of spaces",
  "models.Organization.views.dq-organization-to-room.help": "Detect space associations with organizations that are not valid",
  "models.Organization.views.dq-organization-hierarchy.label": "Organization Hierarchy Errors",
  "models.Organization.views.dq-organization-hierarchy.help": "Detect organizations that are not in the correct hierarchy",
  "models.OpenerPostMessageHost.singular": "Message host for pop-up window",
  "models.OpenerPostMessageHost.plural": "Message hosts for pop-up window",
  "models.OpenerPostMessageHost.determinant.defined": "the message host for pop-up window",
  "models.OpenerPostMessageHost.determinant.undefined": "a message host for pop-up window",
  "models.OpenerPostMessageHost.determinants.defined": "pop-up message hosts",
  "models.OpenerPostMessageHost.determinants.undefined": "pop-up message hosts",
  "models.OpenerPostMessageHost.description": "A pop-up message host is an element that allows you to communicate with a pop-up window opened on the actions in the plan.",
  "models.OccupancyStatus.singular": "occupancy status",
  "models.OccupancyStatus.plural": "occupancy states",
  "models.OccupancyStatus.determinant.defined": "the state of occupancy",
  "models.OccupancyStatus.determinant.undefined": "a state of occupation",
  "models.OccupancyStatus.determinants.defined": "occupancy states",
  "models.OccupancyStatus.determinants.undefined": "states of occupation",
  "models.OccupancyStatus.description": "The occupancy status makes it possible to identify the real-time status of a space or workstation, for example if it is free, occupied or squatted, the occupancy status is updated. day by connected objects present in space",
  "models.OccupancyStatus.properties.id.label": "Occupancy status identifier",
  "models.OccupancyStatus.properties.name.label": "Name of occupancy state",
  "models.OccupancyStatus.properties.color.label": "Color",
  "models.OccupancyStatus.properties.color.description": "Color allows you to color spaces or workstations on plans according to their occupancy status",
  "models.OccupancyStatus.properties.code.label": "Occupancy status code",
  "models.OccupancyStatus.properties.code.description": "The code makes it possible to identify and carry out technical operations on the occupancy state",
  "models.Object3dModel.singular": "3d model",
  "models.Object3dModel.plural": "3d models",
  "models.Object3dModel.determinant.defined": "the 3d model",
  "models.Object3dModel.determinant.undefined": "a 3d model",
  "models.Object3dModel.determinants.defined": "3d models",
  "models.Object3dModel.determinants.undefined": "3d models",
  "models.Object3dModel.description": "The 3D Model allows a realistic 3D representation of objects placed on the plan; In the absence of a 3D model, the objects are represented in full form in the 3D view",
  "models.Object3dModel.properties.origin.label": "Orientation",
  "models.Object3dModel.properties.origin.description": "Use X if the object is facing right or Y if the object is facing down",
  "models.MapScale.singular": "plane scale",
  "models.MapScale.plural": "flat scales",
  "models.MapScale.determinant.defined": "the scale",
  "models.MapScale.determinant.undefined": "scale",
  "models.MapScale.determinants.defined": "the scales",
  "models.MapScale.determinants.undefined": "scales",
  "models.MapScale.properties.id.label": "Scale identifier",
  "models.MapScale.properties.p1.description": "Starting point",
  "models.MapScale.properties.p2.description": "Point of arrival",
  "models.MapScale.properties.name.label": "Name of the scale",
  "models.MapScale.properties.name.description": "To remember the name and reuse it on other floors",
  "models.MapScale.properties.length.label": "Distance",
  "models.MapScale.properties.length.description": "The distance shown on the plan between the 2 points in meters",
  "models.MapScale.properties.roomTextSize.label": "Space text size",
  "models.MapScale.properties.roomTextSize.description": "The size of the text of the spaces on the plan to optimize the display",
  "models.MapScale.properties.workplaceTextSize.label": "Text size on objects",
  "models.MapScale.properties.workplaceTextSize.description": "The size of the text on the workstations and on the objects on the map to optimize the display",
  "models.MapScale.properties.segmentDistanceTextSize.label": "Segment text size",
  "models.MapScale.properties.segmentDistanceTextSize.description": "The size of the text on the distances between the points on the map to optimize the display",
  "models.MapScale.properties.itemTypeIconSize.label": "Size of object type icons",
  "models.MapScale.properties.itemTypeIconSize.description": "The size of the object type icons on the map, the size will be limited by the size of the space",
  "models.MapScale.properties.roomIconSize.label": "Size of space type icons",
  "models.MapScale.properties.roomIconSize.description": "The size of icons on the map in spaces relative to space types",
  "models.MapScale.properties.strokeWidth.label": "Line thickness",
  "models.MapScale.properties.strokeWidth.description": "It is possible to reduce the thickness of the lines to increase the readability of the plan",
  "models.MapScale.views.dq-not-used.label": "Unused scales",
  "models.MapScale.views.dq-not-used.help": "See scales that are not used on floors and can be removed",
  "models.MapScale.views.dq-uniq-name.label": "Proposed names for scales",
  "models.MapScale.views.dq-uniq-name.help": "Provides unique names for scales including the floors and buildings where they are used",
  "models.Manufacturer.singular": "Object type manufacturer",
  "models.Manufacturer.plural": "Object type manufacturers",
  "models.Manufacturer.determinant.defined": "the object type manufacturer",
  "models.Manufacturer.determinant.undefined": "a manufacturer of the object type",
  "models.Manufacturer.determinants.defined": "object type manufacturers",
  "models.Manufacturer.determinants.undefined": "typical manufacturers of objects",
  "models.Manufacturer.properties.name.label": "Object type vendor name",
  "models.Manufacturer.properties.name.description": "Identifies the manufacturer's name or brand",
  "models.Manufacturer.properties.website.label": "Website",
  "models.Manufacturer.properties.website.description": "Manufacturer's website address",
  "models.Legend.singular": "Legend",
  "models.Legend.plural": "Legend",
  "models.Legend.determinant.defined": "the legend",
  "models.Legend.determinant.undefined": "a legend",
  "models.Legend.determinants.defined": "the legends",
  "models.Legend.determinants.undefined": "legends",
  "models.Legend.description": "The legend allows you to configure the properties visible when the plan is saved as an image",
  "models.JupUserCompanyToJupRole.singular": "Role of the business user",
  "models.JupUserCompanyToJupRole.plural": "Company user roles",
  "models.JupUserCompanyToJupRole.determinant.defined": "the role of the business user",
  "models.JupUserCompanyToJupRole.determinant.undefined": "a role of the user of the company",
  "models.JupUserCompanyToJupRole.determinants.defined": "company user roles",
  "models.JupUserCompanyToJupRole.determinants.undefined": "company user roles",
  "models.JupUiView.singular": "Interface view",
  "models.JupUiView.plural": "Interface views",
  "models.JupUiView.determinant.defined": "the interface view",
  "models.JupUiView.determinant.undefined": "an interface view",
  "models.JupUiView.determinants.defined": "interface views",
  "models.JupUiView.determinants.undefined": "interface views",
  "models.JupUiTenantOperation.singular": "Interface operation for a company",
  "models.JupUiTenantOperation.plural": "Interface operations for a business",
  "models.JupUiTenantOperation.determinant.defined": "the interface operation for a company",
  "models.JupUiTenantOperation.determinant.undefined": "an interface operation for a company",
  "models.JupUiTenantOperation.determinants.defined": "interface operations for a company",
  "models.JupUiTenantOperation.determinants.undefined": "interface operations for a company",
  "models.JupUiOption.singular": "Interface option",
  "models.JupUiOption.plural": "Interface options",
  "models.JupUiOption.determinant.defined": "interface option",
  "models.JupUiOption.determinant.undefined": "an interface option",
  "models.JupUiOption.determinants.defined": "interface options",
  "models.JupUiOption.determinants.undefined": "interface options",
  "models.JupUiOperation.singular": "Interface operation",
  "models.JupUiOperation.plural": "Interface operations",
  "models.JupUiOperation.determinant.defined": "interface operation",
  "models.JupUiOperation.determinant.undefined": "an interface operation",
  "models.JupUiOperation.determinants.defined": "interface operations",
  "models.JupUiOperation.determinants.undefined": "interface operations",
  "models.JupUiLayout.singular": "View of the plan",
  "models.JupUiLayout.plural": "Visions of the plan",
  "models.JupUiLayout.determinant.defined": "the vision of the plan",
  "models.JupUiLayout.determinant.undefined": "a vision of the plan",
  "models.JupUiLayout.determinants.defined": "the visions of the plan",
  "models.JupUiLayout.determinants.undefined": "visions of the plan",
  "models.JupRoleToJupUiView.singular": "Role association with interface views",
  "models.JupRoleToJupUiView.plural": "Role associations with interface views",
  "models.JupRoleToJupUiView.determinant.defined": "associating the role with interface views",
  "models.JupRoleToJupUiView.determinant.undefined": "an association of the role to the interface views",
  "models.JupRoleToJupUiView.determinants.defined": "role associations with interface views",
  "models.JupRoleToJupUiView.determinants.undefined": "role associations with interface views",
  "models.JupRoleToJupUiView.properties.canSee.label": "Can see the view",
  "models.JupRoleToJupUiView.properties.canSee.description": "Allow the view to be seen by the role",
  "models.JupRoleToJupUiOption.singular": "Association role to visions of the plan",
  "models.JupRoleToJupUiOption.plural": "Role associations to plan visions",
  "models.JupRoleToJupUiOption.determinant.defined": "the association of the role with the visions of the plan",
  "models.JupRoleToJupUiOption.determinant.undefined": "an association of the role with the visions of the plan",
  "models.JupRoleToJupUiOption.determinants.defined": "associations of the role to the visions of the plan",
  "models.JupRoleToJupUiOption.determinants.undefined": "associations of the role to the visions of the plan",
  "models.JupRoleToJupUiOption.properties.canSee.label": "Can see option",
  "models.JupRoleToJupUiOption.properties.canSee.description": "Allow the option to be seen by the role",
  "models.JupRoleToJupUiOperation.singular": "Role association with interface operations",
  "models.JupRoleToJupUiOperation.plural": "Role association with interface operations",
  "models.JupRoleToJupUiOperation.determinant.defined": "association of the role with interface operations",
  "models.JupRoleToJupUiOperation.determinant.undefined": "an association of the role to interface operations",
  "models.JupRoleToJupUiOperation.determinants.defined": "role associations with interface operations",
  "models.JupRoleToJupUiOperation.determinants.undefined": "role associations with interface operations",
  "models.JupRoleToJupObjectType.singular": "Role to object type association",
  "models.JupRoleToJupObjectType.plural": "Role to object type associations",
  "models.JupRoleToJupObjectType.determinant.defined": "the association of the role with the type of object",
  "models.JupRoleToJupObjectType.determinant.undefined": "an association of the role to the type of object",
  "models.JupRoleToJupObjectType.determinants.defined": "the associations of the role to the type of object",
  "models.JupRoleToJupObjectType.determinants.undefined": "associations of the role to the type of object",
  "models.JupRoleToJupObjectType.properties.arCreate.label": "Creation (C)",
  "models.JupRoleToJupObjectType.properties.arCreate.description": "Allows entity creation",
  "models.JupRoleToJupObjectType.properties.arRead.label": "Reading (R)",
  "models.JupRoleToJupObjectType.properties.arRead.description": "Allows reading of entities",
  "models.JupRoleToJupObjectType.properties.arUpdate.label": "Update (U)",
  "models.JupRoleToJupObjectType.properties.arUpdate.description": "Allows updating of entities",
  "models.JupRoleToJupObjectType.properties.arDelete.label": "Suppression (D)",
  "models.JupRoleToJupObjectType.properties.arDelete.description": "Allows deletion of entities",
  "models.JupRole.singular": "Role",
  "models.JupRole.plural": "Roles",
  "models.JupRole.determinant.defined": "the role",
  "models.JupRole.determinant.undefined": "a role",
  "models.JupRole.determinants.defined": "the roles",
  "models.JupRole.determinants.undefined": "roles",
  "models.JupRole.views.matrix.help": "The security matrix of the role %{name}",
  "models.JupRole.views.matrix.label": "Matrix",
  "models.JupRole.views.help.help": "Summary of role permissions",
  "models.JupRole.views.help.label": "Assistance",
  "models.JupObjectType.singular": "Entity type",
  "models.JupObjectType.plural": "Entity Types",
  "models.JupObjectType.determinant.defined": "the type of entity",
  "models.JupObjectType.determinant.undefined": "an entity type",
  "models.JupObjectType.determinants.defined": "entity types",
  "models.JupObjectType.determinants.undefined": "entity types",
  "models.ItemTypePoint.singular": "Point of object types",
  "models.ItemTypePoint.plural": "Points of object types",
  "models.ItemTypePoint.determinant.defined": "point of object types",
  "models.ItemTypePoint.determinant.undefined": "a point of object types",
  "models.ItemTypePoint.determinants.defined": "points of object types",
  "models.ItemTypePoint.determinants.undefined": "points of object types",
  "models.ItemTypePoint.properties.id.label": "login",
  "models.ItemTypePoint.properties.id.description": "???",
  "models.ItemTypePoint.properties.x.label": "x",
  "models.ItemTypePoint.properties.x.description": "???",
  "models.ItemTypePoint.properties.y.label": "there",
  "models.ItemTypePoint.properties.y.description": "???",
  "models.ItemTypePoint.properties.externalId.label": "External identifier",
  "models.ItemTypePoint.properties.externalId.description": "???",
  "models.ItemTypePoint.properties.itemTypeId.label": "Object type identifier",
  "models.ItemTypePoint.properties.itemTypeId.description": "???",
  "models.ItemTypePoint.properties.sortIndex.label": "Sort index",
  "models.ItemTypePoint.properties.sortIndex.description": "???",
  "models.ItemTypePoint.properties.itemType.label": "Type of object",
  "models.ItemTypePoint.properties.itemType.description": "???",
  "models.ItemTypeFamily.singular": "family of object types",
  "models.ItemTypeFamily.plural": "families of object types",
  "models.ItemTypeFamily.determinant.defined": "the family of object types",
  "models.ItemTypeFamily.determinant.undefined": "a family of object types",
  "models.ItemTypeFamily.determinants.defined": "object type families",
  "models.ItemTypeFamily.determinants.undefined": "families of object types",
  "models.ItemTypeFamily.description": "Allows you to display objects by Family on the plans and in the pdf inventory",
  "models.ItemTypeFamily.properties.id.label": "Identifier of the object's type family",
  "models.ItemTypeFamily.properties.name.label": "Name of the object's type family",
  "models.ItemTypeFamily.properties.name.description": "The name of the family allows it to be identified, this name is used to group the types of object",
  "models.ItemType.singular": "object type",
  "models.ItemType.plural": "object types",
  "models.ItemType.determinant.defined": "the type of object",
  "models.ItemType.determinant.undefined": "an object type",
  "models.ItemType.determinants.defined": "object types",
  "models.ItemType.determinants.undefined": "object types",
  "models.ItemType.properties.id.label": "Identifier of the type of the object",
  "models.ItemType.properties.id.description": "Identifier of the type of the object",
  "models.ItemType.properties.description.label": "Description",
  "models.ItemType.properties.description.description": "Allows you to have additional information on the type of object",
  "models.ItemType.properties.name.label": "Object type name",
  "models.ItemType.properties.name.description": "Allows you to quickly identify the type of object with a complete, logical and descriptive name; You can indicate the dimensions, for example: Meeting Table 340x120; Tip: always start with the largest dimension",
  "models.ItemType.properties.zIndex.label": "Height index",
  "models.ItemType.properties.zIndex.description": "The higher the height index, the more the object will be positioned above the others; It can be negative; for example for a seat: -1; Tip: for Icons, set the index to 9",
  "models.ItemType.properties.picture.label": "Photo",
  "models.ItemType.properties.picture.description": "Allows you to load the photo of the type of object, which will be visible in the inventory in PDF and on the sheet of the object selected on the plan",
  "models.ItemType.properties.iconShape.label": "Icon shape",
  "models.ItemType.properties.iconShape.description": "The shape of the icon can influence its display on the plan",
  "models.ItemType.properties.displayItemReferenceInMap.label": "Show plan information",
  "models.ItemType.properties.displayItemReferenceInMap.description": "Allows you to display the “Reference” field of each object on the plan",
  "models.ItemType.properties.code.label": "Code",
  "models.ItemType.properties.code.description": "Allows you to quickly access the object type by typing the code in the search during object creation",
  "models.ItemType.properties.icon.label": "Icon",
  "models.ItemType.properties.icon.description": "Gives you access to three types of icon: 1) “Fontawsome” Icons, visible by checking “show all” or by searching by keyword in English in the search box; 2) “SURFY” Icons intended for illustrations added to plans in strategic locations (Toilets, Stairs, Elevators, Copy Points, etc.) but which can also be used as classic icons; 3) The “SURFY 2” Icons listing the regulatory icons of the ISO 7010 Safety standard; Their shape can be round, square or triangular",
  "models.ItemType.properties.color.label": "Color",
  "models.ItemType.properties.color.description": "Can be chosen from a pre-selection, or in advanced selection by Hexa or RGB code to respect your graphic charter",
  "models.ItemType.properties.height.label": "Height",
  "models.ItemType.properties.height.description": "Allows you to give the height in centimeters of the type of object in 3d vision",
  "models.ItemType.properties.price.label": "Price",
  "models.ItemType.properties.price.description": "The purchase price of the item type",
  "models.ItemType.properties.seatsCount.label": "Number of seats",
  "models.ItemType.properties.seatsCount.description": "The number of seats for this type of object (armchair, seat, sofa, etc.) is accumulated in Surfy by space, floor and building",
  "models.ItemType.properties.manufacturer.description": "Allows you to identify the manufacturer of the object type",
  "models.ItemType.properties.carbonFootprint.label": "Carbon footprint",
  "models.ItemType.properties.carbonFootprint.description": "The carbon footprint is the weight in Kilograms of CO2 emitted by each object from this type of object; it is given by the manufacturer",
  "models.ItemType.properties.iconBackgroundColor.label": "Icon background color",
  "models.ItemType.properties.iconBackgroundColor.description": "The background color allows you to correctly configure multi-color icons, particularly triangular ones.",
  "models.ItemType.properties.iconBorderColor.label": "Icon border color",
  "models.ItemType.properties.iconBorderColor.description": "The border color allows you to correctly configure multi-color icons, especially triangular ones.",
  "models.ItemType.properties.isAffectable.label": "Is it associatable with a person ?",
  "models.ItemType.properties.isAffectable.description": "Allows you to know if the object type is associable with a person",
  "models.ItemType.properties.excludeFromPathfinding.label": "Enable navigation",
  "models.ItemType.properties.excludeFromPathfinding.description": "Enables navigation for this object type",
  "models.ItemType.views.shape-editor.help": "Edit the shape of the object type %{name}",
  "models.ItemType.views.shape-editor.label": "Edit shape",
  "models.ItemType.views.avatar.help": "See the form of %{name}",
  "models.ItemType.views.avatar.label": "Form",
  "models.ItemType.views.dq-not-used.label": "Not used",
  "models.ItemType.views.dq-not-used.help": "List all unused object types via objects or via unused workstation types",
  "models.ItemToPerson.singular": "Object-to-person association",
  "models.ItemToPerson.plural": "Object-to-person associations",
  "models.ItemToPerson.description": "Allows you to associate an object with a person (ergonomic seat, locker)",
  "models.ItemToPerson.determinant.defined": "association of object to person",
  "models.ItemToPerson.determinant.undefined": "an object-to-person association",
  "models.ItemToPerson.determinants.defined": "object-to-person associations",
  "models.ItemToPerson.determinants.undefined": "object-to-person associations",
  "models.ItemFact.singular": "Object movement",
  "models.ItemFact.plural": "Object movements",
  "models.ItemFact.determinant.defined": "the movement of an object",
  "models.ItemFact.determinant.undefined": "an object movement",
  "models.ItemFact.determinants.defined": "object movements",
  "models.ItemFact.determinants.undefined": "object movements",
  "models.Item.singular": "object",
  "models.Item.plural": "objects",
  "models.Item.determinant.defined": "subject",
  "models.Item.determinant.undefined": "an object",
  "models.Item.determinants.defined": "Objects",
  "models.Item.determinants.undefined": "items",
  "models.Item.views.dq-item-not-in-workplace-room.label": "Object spaces different from workstation spaces",
  "models.Item.views.dq-item-not-in-workplace-room.help": "List of physical objects in workstations that are in spaces that are different from the workstation spaces",
  "models.Item.properties.id.label": "Identifier of the object",
  "models.Item.properties.price.label": "Price",
  "models.Item.properties.price.description": "The purchase price of the item if it is different from the price of the item type",
  "models.Item.properties.reference.label": "Object reference",
  "models.Item.properties.reference.description": "The object reference is used to find it and to differentiate this object from others",
  "models.Item.properties.code.label": "Immobilizer code",
  "models.Item.properties.code.description": "The asset number is used to keep the accounting number",
  "models.Item.properties.purchaseDate.label": "Date of purchase",
  "models.Item.properties.purchaseDate.description": "The date of purchase of the object",
  "models.Item.properties.room.label": "Object space",
  "models.Item.properties.itemAffectationsCount.label": "Number of associations to people",
  "models.Item.properties.itemAffectationsCount.description": "The number of associations of this object with people",
  "models.Floor.singular": "floor",
  "models.Floor.plural": "floors",
  "models.Floor.determinant.defined": "upstairs",
  "models.Floor.determinant.undefined": "a floor",
  "models.Floor.determinants.defined": "The floors",
  "models.Floor.determinants.undefined": "floors",
  "models.Floor.description": "Floors represent a work platform or a level of a building.",
  "models.Floor.views.map.help": "Floor plan %{name} in 2d",
  "models.Floor.views.map.label": "Plan 2d",
  "models.Floor.views.3d.help": "Floor plan %{name} in 3d",
  "models.Floor.views.3d.label": "3d plane",
  "models.Floor.views.cuby.help": "Floor plan %{name} in 3d",
  "models.Floor.views.cuby.label": "3d",
  "models.Floor.views.simple-list.help": "List floors with few details",
  "models.Floor.views.simple-list.label": "Simple List",
  "models.Floor.views.geojson.help": "View info in GeoJson",
  "models.Floor.views.geojson.label": "Copy GeoJson Coordinates",
  "models.Floor.views.standalone-2d-map.help": "The floor plan %{name} in 2d without menu",
  "models.Floor.views.standalone-2d-map.label": "2d plan only",
  "models.Floor.properties.id.label": "Identifier of the floor",
  "models.Floor.properties.name.label": "Name of the floor",
  "models.Floor.properties.name.description": "The name of the floor is used to be able to find it easily.",
  "models.Floor.properties.level.label": "Level",
  "models.Floor.properties.level.description": "The level of the floor allows to define its position relative to the other floors, for example use 0 for the ground floor or -1 for the car parks",
  "models.Floor.properties.backgroundLayout.label": "Background",
  "models.Floor.properties.backgroundLayout.description": "The background allows you to have a first layer level in order to redraw the plans, it must be to scale",
  "models.Floor.properties.backgroundLayoutOpacity.label": "Background opacity",
  "models.Floor.properties.backgroundLayoutOpacity.description": "The opacity allows you to see more or less the background",
  "models.Floor.properties.regulatoryCapacity.label": "Regulatory capacity",
  "models.Floor.properties.regulatoryCapacity.description": "The regulatory capacity of the platform, makes it possible to manage the evacuation of the public and employees",
  "models.Floor.properties.pathfindingGraph.label": "Floor navigation graph",
  "models.Floor.properties.pathfindingGraph.description": "The navigation graph allows you to calculate the shortest paths between the points on the floor",
  "models.Floor.properties.workplacesCount.label": "Number of workstations",
  "models.Floor.properties.workplacesCount.description": "The number of workstations in the floor is calculated automatically",
  "models.Floor.properties.workplacesRatio.label": "Workstation ratio",
  "models.Floor.properties.workplacesRatio.description": "The workstation ratio is the number of square meters in the floor divided by the number of workstations, this value is calculated automatically",
  "models.Floor.properties.peopleCount.label": "Number of assignments",
  "models.Floor.properties.peopleCount.description": "The number of people assigned to the floor, either directly assigned to spaces, or through a workstation",
  "models.Floor.properties.totalPeopleCount.label": "Number of total assignments",
  "models.Floor.properties.totalPeopleCount.description": "The number of people assigned to the floor, either directly assigned to spaces, or through a workstation",
  "models.Floor.properties.peopleRatio.label": "Occupancy ratio",
  "models.Floor.properties.peopleRatio.description": "The occupancy ratio is the number of square meters on the floor divided by the number of people assigned either directly to the spaces or via a workstation, this value is calculated",
  "models.Floor.properties.freeWorkplacesCount.label": "Number of vacancies",
  "models.Floor.properties.freeWorkplacesCount.description": "Number of free extensions on the floor",
  "models.Floor.properties.flexWorkplacesCount.label": "Number of flex positions",
  "models.Floor.properties.flexWorkplacesCount.description": "Number of flex posts in the floor",
  "models.Floor.properties.roomsArea.label": "Qualified surface",
  "models.Floor.properties.roomsArea.description": "The qualified surface is the sum of the surfaces of the spaces",
  "models.Floor.properties.roomsCount.label": "Number of spaces",
  "models.Floor.properties.roomsCount.description": "The number of spaces present in this floor",
  "models.Floor.properties.sharedWorkplacesCount.label": "Number of shared workstations",
  "models.Floor.properties.sharedWorkplacesCount.description": "Number of workstations shared on the floor by at least 2 people",
  "models.Floor.properties.sharedWorkplacesRatio.label": "Rate of shared workstations",
  "models.Floor.properties.sharedWorkplacesRatio.description": "Rate of workstations shared by at least 2 people compared to all the workstations on the floor",
  "models.Floor.properties.flexRatio.label": "Rate of flex workstations",
  "models.Floor.properties.flexRatio.description": "The flex workstation rate is calculated by dividing the number of flex workstations by the total number of workstations",
  "models.Floor.properties.transitWorkplacesCount.label": "Number of transit workstations",
  "models.Floor.properties.transitWorkplacesCount.description": "Number of temporary workstations, these positions are not counted in free positions and are not flex",
  "models.Floor.properties.height.label": "Ceiling height",
  "models.Floor.properties.height.description": "The height under the ceiling of the floor",
  "models.Floor.properties.mapScale.label": "Plan scale",
  "models.Floor.properties.mapScale.description": "The scale allows us to calculate in proportion the actual areas and sizes of objects",
  "models.FactType.singular": "Type of Fact",
  "models.FactType.plural": "Types of Fact",
  "models.FactType.determinant.defined": "the type of fact",
  "models.FactType.determinant.undefined": "a type of fact",
  "models.FactType.determinants.defined": "types of fact",
  "models.FactType.determinants.undefined": "types of fact",
  "models.Fact.singular": "Fact",
  "models.Fact.plural": "Facts",
  "models.Fact.determinant.defined": "the fact",
  "models.Fact.determinant.undefined": "a fact",
  "models.Fact.determinants.defined": "facts",
  "models.Fact.determinants.undefined": "facts",
  "models.DistributionCostType.singular": "type of cost distribution",
  "models.DistributionCostType.plural": "types of cost distribution",
  "models.DistributionCostType.determinant.defined": "the type of cost distribution",
  "models.DistributionCostType.determinant.undefined": "a type of cost distribution",
  "models.DistributionCostType.determinants.defined": "types of cost distribution",
  "models.DistributionCostType.determinants.undefined": "types of cost distribution",
  "models.DistributionCostType.properties.name.label": "Name of the cost distribution type",
  "models.DistributionCostType.properties.code.labe": "Code",
  "models.DistributionCostType.properties.code.description": "The code is used in order to be able to automatically calculate the associated costs",
  "models.DimensionTypeToBuilding.singular": "Building assignment layer type",
  "models.DimensionTypeToBuilding.plural": "Types of building assignment layers",
  "models.DimensionTypeToBuilding.determinant.defined": "the type of building assignment layer",
  "models.DimensionTypeToBuilding.determinant.undefined": "a type of building assignment layer",
  "models.DimensionTypeToBuilding.determinants.defined": "building assignment layer types",
  "models.DimensionTypeToBuilding.determinants.undefined": "types of building assignment layers",
  "models.DimensionTypeToBuilding.description": "Building assignment layer types are used to define the different types of building assignment layers. By associating an assignment layer type with a building, this allows an analysis layer to be transformed into an assignment layer.",
  "models.DimensionType.singular": "Layer type",
  "models.DimensionType.plural": "Layer Types",
  "models.DimensionType.determinant.defined": "the type of layer",
  "models.DimensionType.determinant.undefined": "a type of layer",
  "models.DimensionType.determinants.defined": "layer types",
  "models.DimensionType.determinants.undefined": "layer types per floor",
  "models.DimensionType.properties.id.label": "Identifier of the type of dimension",
  "models.DimensionType.properties.order.label": "order of appearance",
  "models.DimensionType.properties.order.description": "Allows you to sort layer types to display them",
  "models.DimensionType.properties.name.label": "Name of the dimension type",
  "models.DimensionType.properties.code.label": "Dimension type code",
  "models.DimensionType.properties.code.description": "The code identifies the type of dimension, it is used when specific calculations apply to the type of dimension",
  "models.DimensionToPerson.singular": "Assignment to Assignment Layer",
  "models.DimensionToPerson.plural": "Assignments to Assignment Layers",
  "models.DimensionToPerson.description": "Allows you to assign a person to a district, territory or village",
  "models.DimensionToPerson.determinant.defined": "the assignment to the assignment layer",
  "models.DimensionToPerson.determinant.undefined": "an assignment to the assignment layer",
  "models.DimensionToPerson.determinants.defined": "assignments to assignment layers",
  "models.DimensionToPerson.determinants.undefined": "assignments to assignment layers",
  "models.DimensionRoom.singular": "Space analysis layer",
  "models.DimensionRoom.plural": "Space analysis layers",
  "models.DimensionRoom.determinant.defined": "the space analysis layer",
  "models.DimensionRoom.determinant.undefined": "a space analysis layer",
  "models.DimensionRoom.determinants.defined": "space analysis layers",
  "models.DimensionRoom.determinants.undefined": "space analysis layers",
  "models.DimensionRoom.properties.id.label": "Identifier of the space analysis layer",
  "models.DimensionFloor.singular": "Analysis layer per floor",
  "models.DimensionFloor.plural": "Analysis layers per floor",
  "models.DimensionFloor.determinant.defined": "the analysis layer per floor",
  "models.DimensionFloor.determinant.undefined": "one analysis layer per floor",
  "models.DimensionFloor.determinants.defined": "analysis layers by floor",
  "models.DimensionFloor.determinants.undefined": "analysis layers per floor",
  "models.DimensionFloor.properties.id.label": "Analysis layer identifier by floor",
  "models.DimensionFloor.properties.peopleCount.label": "Number of assignments",
  "models.DimensionFloor.properties.peopleCount.description": "The number of people assigned, either directly assigned to spaces, or through a workstation for this floor",
  "models.DimensionFloor.properties.totalPeopleCount.label": "Total number of indirect assignments on the floor",
  "models.DimensionFloor.properties.totalPeopleCount.description": "The total number of people indirectly assigned to the floor, either directly assigned to spaces, or through a workstation, but not via the assignment layers which are only at the building level",
  "models.DimensionBuilding.singular": "Analysis layer by building",
  "models.DimensionBuilding.plural": "Analysis layers by building",
  "models.DimensionBuilding.determinant.defined": "the analysis layer by building",
  "models.DimensionBuilding.determinant.undefined": "one analysis layer per building",
  "models.DimensionBuilding.determinants.defined": "analysis layers by building",
  "models.DimensionBuilding.determinants.undefined": "analysis layers by building",
  "models.DimensionBuilding.properties.id.label": "Analysis layer identifier by building",
  "models.DimensionBuilding.properties.dimensionPeopleCount.label": "Number of assignments directly to this assignment layer",
  "models.DimensionBuilding.properties.dimensionPeopleCount.description": "The number of people who are assigned to this assignment layer for the entire building",
  "models.DimensionBuilding.properties.totalPeopleCount.label": "Total number of assignments",
  "models.DimensionBuilding.properties.totalPeopleCount.description": "The total number of people assigned, either directly assigned to spaces, or through a workstation, or via an assignment layer",
  "models.Dimension.singular": "Analysis layer",
  "models.Dimension.plural": "Analysis layers",
  "models.Dimension.determinant.defined": "the analysis layer",
  "models.Dimension.determinant.undefined": "an analysis layer",
  "models.Dimension.determinants.defined": "analysis layers",
  "models.Dimension.determinants.undefined": "analysis layers",
  "models.Dimension.properties.id.label": "Analysis layer identifier",
  "models.Dimension.properties.id.description": "Surfy internal identifier",
  "models.Dimension.properties.name.label": "Name of the analysis layer",
  "models.Dimension.properties.name.description": "Useful to differentiate the layer among others",
  "models.Dimension.properties.color.label": "Color",
  "models.Dimension.properties.color.description": "The analysis layer color allows you to differentiate spaces on the plan",
  "models.Dimension.properties.value.label": "Numerical value",
  "models.Dimension.properties.value.description": "The value can be used to associate the layer with a numerical value in order to be able to carry out analytical statistics",
  "models.Dimension.properties.peopleCount.label": "Number of direct assignments",
  "models.Dimension.properties.peopleCount.description": "The number of people who are directly assigned to this assignment layer in the building",
  "models.Dimension.properties.manualPeopleCount.label": "Number of direct manual assignments",
  "models.Dimension.properties.manualPeopleCount.description": "The number of people who are assigned directly to this assignment layer without considering assignments with real people",
  "models.Dimension.properties.totalPeopleCount.label": "Total number of direct assignments",
  "models.Dimension.properties.totalPeopleCount.description": "The total number of people who are assigned directly to this assignment layer in the building, the addition of the actual people assigned and the number of people assigned manually",
  "models.Dimension.properties.carbonFootprintPerMeter.label": "Carbon footprint per square meter",
  "models.Dimension.properties.carbonFootprintPerMeter.description": "The carbon footprint per square meter calculates the carbon footprint in kilograms of CO2 of an analysis layer per square meters",
  "models.CostCenterFloor.singular": "floor cost center",
  "models.CostCenterFloor.plural": "floor cost centers",
  "models.CostCenterFloor.determinant.defined": "the cost center of floors",
  "models.CostCenterFloor.determinant.undefined": "a floor cost center",
  "models.CostCenterFloor.determinants.defined": "floor cost centers",
  "models.CostCenterFloor.determinants.undefined": "floor cost centers",
  "models.CostCenterBuilding.singular": "building cost center",
  "models.CostCenterBuilding.plural": "building cost centers",
  "models.CostCenterBuilding.determinant.defined": "the cost center of buildings",
  "models.CostCenterBuilding.determinant.undefined": "a building cost center",
  "models.CostCenterBuilding.determinants.defined": "building cost centers",
  "models.CostCenterBuilding.determinants.undefined": "building cost centers",
  "models.CostCenter.singular": "cost center",
  "models.CostCenter.plural": "cost centers",
  "models.CostCenter.description": "The cost center allows spaces to be distributed dynamically for re-invoicing",
  "models.CostCenter.determinant.defined": "the cost center",
  "models.CostCenter.determinant.undefined": "a cost center",
  "models.CostCenter.determinants.defined": "cost centers",
  "models.CostCenter.determinants.undefined": "cost centers",
  "models.CostCenter.properties.id.label": "Cost center identifier",
  "models.CostCenter.properties.name.label": "Name of cost center",
  "models.CostCenter.properties.color.label": "Color",
  "models.CostCenter.properties.distributeByFloor.label": "Distribute by floor",
  "models.CostCenter.properties.distributeByFloor.description": "Prorate the space used by this cost center on the floor to other cost centers on the same floor",
  "models.CostCenter.properties.distributeByBuilding.label": "Distribute by building",
  "models.CostCenter.properties.distributeByBuilding.description": "Prorate the space used by this cost center in the building to the other cost centers in the building",
  "models.ContentRoleToUserCompany.singular": "Company user content role",
  "models.ContentRoleToUserCompany.plural": "Company User Content Roles",
  "models.ContentRoleToUserCompany.determinant.defined": "the content role of the business user",
  "models.ContentRoleToUserCompany.determinant.undefined": "a business user content role",
  "models.ContentRoleToUserCompany.determinants.defined": "company user content roles",
  "models.ContentRoleToUserCompany.determinants.undefined": "company user content roles",
  "models.ContentRoleToJupUiTenantOperation.singular": "Associating content role to interface operations for an enterprise",
  "models.ContentRoleToJupUiTenantOperation.plural": "Associating content role to interface operations for an enterprise",
  "models.ContentRoleToJupUiTenantOperation.determinant.defined": "associating the content role with interface operations for an enterprise",
  "models.ContentRoleToJupUiTenantOperation.determinant.undefined": "an association of the content role to interface operations for an enterprise",
  "models.ContentRoleToJupUiTenantOperation.determinants.defined": "content role associations to interface operations for an enterprise",
  "models.ContentRoleToJupUiTenantOperation.determinants.undefined": "content role associations to interface operations for an enterprise",
  "models.ContentRoleToFloor.singular": "Association role of content to floors",
  "models.ContentRoleToFloor.plural": "Role associations of content to floors",
  "models.ContentRoleToFloor.determinant.defined": "the association of the role of content to the floors",
  "models.ContentRoleToFloor.determinant.undefined": "an association of the role of content to floors",
  "models.ContentRoleToFloor.determinants.defined": "the associations of the role of content to floors",
  "models.ContentRoleToFloor.determinants.undefined": "associations of the role of content to floors",
  "models.ContentRoleToBuilding.singular": "Role association of content with buildings",
  "models.ContentRoleToBuilding.plural": "Role associations of content to buildings",
  "models.ContentRoleToBuilding.determinant.defined": "the association of the role of content to buildings",
  "models.ContentRoleToBuilding.determinant.undefined": "an association of the role of content to buildings",
  "models.ContentRoleToBuilding.determinants.defined": "associations of the role of content to buildings",
  "models.ContentRoleToBuilding.determinants.undefined": "associations of the role of content to buildings",
  "models.ContentRole.singular": "Content role",
  "models.ContentRole.plural": "Content roles",
  "models.ContentRole.determinant.defined": "the role of content",
  "models.ContentRole.determinant.undefined": "a content role",
  "models.ContentRole.determinants.defined": "content roles",
  "models.ContentRole.determinants.undefined": "content roles",
  "models.CompanyType.singular": "type of company",
  "models.CompanyType.plural": "type of businesses",
  "models.CompanyType.determinant.defined": "the type of business",
  "models.CompanyType.determinant.undefined": "a type of business",
  "models.CompanyType.determinants.defined": "types of businesses",
  "models.CompanyType.determinants.undefined": "types of businesses",
  "models.CompanyType.properties.name.label": "Business type name",
  "models.Company.singular": "business",
  "models.Company.plural": "business",
  "models.Company.determinant.defined": "the company",
  "models.Company.determinant.undefined": "a company",
  "models.Company.determinants.defined": "businesses",
  "models.Company.determinants.undefined": "enterprises",
  "models.Company.properties.id.label": "Company ID",
  "models.Company.properties.logoPath.label": "Logo",
  "models.Company.properties.logoPath.description": "The path of your company's logo",
  "models.Company.properties.iconPath.label": "icon",
  "models.Company.properties.iconPath.description": "The company logo in square",
  "models.Company.properties.name.label": "Company Name",
  "models.Company.properties.workingDaysCount.label": "Number of working days per week",
  "models.Company.properties.workingDaysCount.description": "The number of working days per week can be 5 for working days, 6 including Saturday and 7 including Sunday",
  "models.Company.views.usage.label": "Use of platforms",
  "models.Company.views.usage.help": "Understanding the use of available platforms",
  "models.Company.views.cards.help": "View of tile businesses",
  "models.Company.views.cards.label": "Roof tiles",
  "models.Company.views.dq-fix-inventory.label": "Inventory Consistency",
  "models.Company.views.dq-fix-inventory.help": "Find and repair physical and virtual inventory inconsistencies for workstations",
  "models.Company.views.dq-shapes-position.label": "Placement of shapes",
  "models.Company.views.dq-shapes-position.help": "Find and reposition shapes that are on the plan in a different space than the one in the database",
  "models.Company.views.people-info.label": "Statistics on people's assignment creations",
  "models.Company.views.people-info.help": "View assignment statistics",
  "models.Company.reports.export-all.fileName": "backup",
  "models.Company.reports.export-all.help": "Back up all Surfy data",
  "models.Company.reports.export-all-duplicate.fileName": "duplication",
  "models.Company.reports.export-all-duplicate.help": "Backup company data to make a copy of the platform",
  "models.Campus.singular": "campus",
  "models.Campus.plural": "campus",
  "models.Campus.description": "The campus is used to group buildings that are in the same location.",
  "models.Campus.determinant.defined": "the campus",
  "models.Campus.determinant.undefined": "a campus",
  "models.Campus.determinants.defined": "the campuses",
  "models.Campus.determinants.undefined": "campuses",
  "models.Campus.views.cards.help": "Grouped view of buildings",
  "models.Campus.views.cards.label": "Info",
  "models.Campus.properties.id.label": "Campus ID",
  "models.Campus.properties.name.label": "Campus Name",
  "models.Campus.properties.name.description": "Campus Name",
  "models.Campus.properties.color.label": "Color",
  "models.Campus.properties.color.description": "Campus Color",
  "models.Campus.properties.externalId.label": "External identifier",
  "models.BuildingType.singular": "type of building",
  "models.BuildingType.plural": "types of buildings",
  "models.BuildingType.determinant.defined": "the type of building",
  "models.BuildingType.determinant.undefined": "a type of building",
  "models.BuildingType.determinants.defined": "building types",
  "models.BuildingType.determinants.undefined": "building types",
  "models.BuildingType.properties.id.label": "Identifier of the type of building",
  "models.BuildingType.properties.name.label": "Name of the type of building",
  "models.BuildingType.properties.name.description": "Name of the type of building",
  "models.BuildingType.properties.code.label": "Code",
  "models.BuildingType.properties.code.description": "???",
  "models.BuildingType.properties.externalId.label": "External identifier",
  "models.BuildingType.properties.externalId.description": "???",
  "models.Building.singular": "building",
  "models.Building.plural": "buildings",
  "models.Building.determinant.defined": "building",
  "models.Building.determinant.undefined": "a building",
  "models.Building.determinants.defined": "the buildings",
  "models.Building.determinants.undefined": "buildings",
  "models.Building.description": "The building is used to group the floors",
  "models.Building.reports.workplaces.fileName": "Personal work places",
  "models.Building.reports.workplaces.help": "Building workstation report",
  "models.Building.reports.allWorkplaces.fileName": "Workstations with assignments",
  "models.Building.reports.allWorkplaces.help": "Report of all workstations in the building including assignments",
  "models.Building.reports.workplaceAffectations.fileName": "Workstation assignments",
  "models.Building.reports.workplaceAffectations.help": "Building Workstation Assignment Report",
  "models.Building.reports.buildingPeople.fileName": "People",
  "models.Building.reports.buildingPeople.help": "Report of persons affected in the building",
  "models.Building.reports.organizations.fileName": "Organizations",
  "models.Building.reports.organizations.help": "Building organizations report",
  "models.Building.reports.buildingItems.fileName": "Inventory",
  "models.Building.reports.buildingItems.help": "Building inventory report",
  "models.Building.reports.area.fileName": "Spaces",
  "models.Building.reports.area.help": "Building spaces report",
  "models.Building.reports.buildingCleaning.fileName": "Benefits",
  "models.Building.reports.buildingCleaning.help": "Building cleaning services report",
  "models.Building.reports.buildingDimensions.fileName": "Analysis layers",
  "models.Building.reports.buildingDimensions.help": "Building Space Analysis Layers Report",
  "models.Building.views.cards.help": "View of tiled buildings",
  "models.Building.views.cards.label": "Info",
  "models.Building.views.pictures.help": "See the buildings with photos",
  "models.Building.views.pictures.label": "Pictures",
  "models.Building.views.gmap.help": "See the buildings on a map",
  "models.Building.views.gmap.label": "Map",
  "models.Building.views.cost-distribution-by-cost-center.help": "<b>Distribution keys</b> and qualified surface area by cost center for the building %{name}",
  "models.Building.views.cost-distribution-by-cost-center.label": "Distribution keys",
  "models.Building.views.3d-cards.help": "See 3d buildings",
  "models.Building.views.3d-cards.label": "3d",
  "models.Building.views.assets.help": "Real estate assets",
  "models.Building.views.assets.label": "Immovable",
  "models.Building.views.cuby.help": "The interactive <b>3d</b> plan of the building %{name}",
  "models.Building.views.cuby.label": "3d plane",
  "models.Building.views.3d.help": "The 3d plan of the building %{name} (cuby)",
  "models.Building.views.3d.label": "3d plane",
  "models.Building.views.clone.help": "Building <b>scenarios</b> and projects %{name}",
  "models.Building.views.clone.label": "Scenarios",
  "models.Building.views.building-ifc.help": "Export this building to IFC for BIM",
  "models.Building.views.building-ifc.label": "IFC",
  "models.Building.views.zbre-sync.help": "Synchronize the building with the Zbre platform",
  "models.Building.views.zbre-sync.label": "Zbre synchronization",
  "models.Building.views.inventory.help": "Building <b>inventory</b> %{name}",
  "models.Building.views.inventory.label": "Inventory",
  "models.Building.views.list-simple.help": "List buildings with few details",
  "models.Building.views.list-simple.label": "Simple list",
  "models.Building.views.building-3d-gmap.label": "3d building on the plan",
  "models.Building.views.building-3d-gmap.help": "See the building in 3d on a plan",
  "models.Building.properties.id.label": "Building identifier",
  "models.Building.properties.name.label": "Name of Building",
  "models.Building.properties.name.description": "Name of building or scenario",
  "models.Building.properties.picture.label": "Photo of the building",
  "models.Building.properties.picture.description": "You can use a photo of your building to quickly find it from the home page (see buildings with photos) or to illustrate collaborators' views",
  "models.Building.properties.documents.label": "Related documents",
  "models.Building.properties.documents.description": "Maintain a link to the location of documents associated with this building in your GED",
  "models.Building.properties.securityDeposit.label": "Security deposit",
  "models.Building.properties.securityDeposit.description": "Amount of the deposit deposited upon signing the lease",
  "models.Building.properties.buildings.label": "Buildings scenarios",
  "models.Building.properties.buildings.description": "Scenarios generated from this building",
  "models.Building.properties.constructionYear.label": "Year of construction of the building",
  "models.Building.properties.constructionYear.description": "Year of construction of the building allowing its obsolescence to be measured",
  "models.Building.properties.parkingSpaceCount.label": "Number of parking spaces",
  "models.Building.properties.parkingSpaceCount.description": "Number of parking spaces available",
  "models.Building.properties.yearlyParkingRent.label": "Annual rent for car parks",
  "models.Building.properties.yearlyParkingRent.description": "Share of rent allocated to parking",
  "models.Building.properties.yearlyTaxFees.label": "Amount of annual fees",
  "models.Building.properties.yearlyTaxFees.description": "Total amount of taxes",
  "models.Building.properties.yearlyExploitationFees.label": "Annual operating expenses",
  "models.Building.properties.yearlyExploitationFees.description": "Annual amount of operating expenses (example: water, electricity)",
  "models.Building.properties.rentReferenceIndex.label": "Rent benchmark",
  "models.Building.properties.rentReferenceIndex.description": "The Rent Reference Index (RRI) is used as the basis for revising the rents for empty or furnished dwellings",
  "models.Building.properties.color.label": "Color",
  "models.Building.properties.color.description": "The color of the building is used to define the background color in the presentations of the floors or the building and to be able to distinguish this building from the others",
  "models.Building.properties.roomsCount.label": "Number of spaces",
  "models.Building.properties.roomsCount.description": "The number of spaces created in this building",
  "models.Building.properties.roomsArea.label": "Qualified surface",
  "models.Building.properties.roomsArea.description": "The qualified surface represents all of the areas modeled in Surfy",
  "models.Building.properties.workplacesCount.label": "Number of workstations",
  "models.Building.properties.workplacesCount.description": "The number of workstations in the building is calculated automatically",
  "models.Building.properties.workplacesRatio.label": "Workstation ratio",
  "models.Building.properties.workplacesRatio.description": "The ratio per workstation is the number of square meters in the building divided by the number of workstations, this value is calculated automatically",
  "models.Building.properties.peopleCount.label": "Number of assignments",
  "models.Building.properties.peopleCount.description": "The number of people assigned to the building, neighborhoods, spaces or workstations",
  "models.Building.properties.peopleRatio.label": "Occupancy ratio",
  "models.Building.properties.peopleRatio.description": "The occupancy ratio is the number of square meters in the building divided by the number of people assigned either directly to the neighborhoods, spaces, or workstations, this value is calculated",
  "models.Building.properties.freeWorkplacesCount.label": "Number of vacancies",
  "models.Building.properties.freeWorkplacesCount.description": "Number of free positions in the building",
  "models.Building.properties.flexWorkplacesCount.label": "Number of flex positions",
  "models.Building.properties.flexWorkplacesCount.description": "Number of flex workstations in the building",
  "models.Building.properties.address.label": "Address",
  "models.Building.properties.address.description": "The address of the building to locate it on the map",
  "models.Building.properties.yearlyCondominiumFees.label": "Annual charges",
  "models.Building.properties.yearlyCondominiumFees.description": "Amount of annual management or co-ownership charges, for example",
  "models.Building.properties.yearlyRent.label": "Annual rent",
  "models.Building.properties.yearlyRent.description": "Annual rent amount for this building",
  "models.Building.properties.leaseStartDate.label": "Lease start date",
  "models.Building.properties.leaseStartDate.description": "Lease start date",
  "models.Building.properties.leaseEndDate.label": "End date of the lease",
  "models.Building.properties.leaseEndDate.description": "End date of the lease",
  "models.Building.properties.purchaseDate.label": "Building purchase date",
  "models.Building.properties.purchaseDate.description": "Building purchase date",
  "models.Building.properties.buildingId.label": "Reference building identifier",
  "models.Building.properties.buildingId.description": "The identifier of the reference building is used in the context of the creation of scenarios, the identifier allows the association with this building",
  "models.Building.properties.building.label": "Original building",
  "models.Building.properties.building.description": "The original or reference building is used in the creation of scenarios, it allows you to identify the original building from which the building was created",
  "models.Building.properties.jupUiLayout.label": "Vision of the default plan",
  "models.Building.properties.jupUiLayout.description": "When a plan of this building is first opened, the default vision will be selected, following the first opening, it will be the current vision which will be applied",
  "models.Building.properties.sharedWorkplacesCount.label": "Number of shared workstations",
  "models.Building.properties.sharedWorkplacesCount.description": "Number of workstations shared in the building by at least 2 people",
  "models.Building.properties.sharedWorkplacesRatio.label": "Rate of shared workstations",
  "models.Building.properties.sharedWorkplacesRatio.description": "Rate of workstations shared by at least 2 people compared to all workstations in the building",
  "models.Building.properties.flexRatio.label": "Rate of flex workstations",
  "models.Building.properties.flexRatio.description": "The flex workstation rate is calculated by dividing the number of flex workstations by the total number of workstations",
  "models.Building.properties.transitWorkplacesCount.label": "Number of transit workstations",
  "models.Building.properties.transitWorkplacesCount.description": "Number of temporary workstations, these positions are not counted in free positions and are not flex",
  "models.Building.properties.regulatoryCapacity.label": "Regulatory capacity",
  "models.Building.properties.regulatoryCapacity.description": "The regulatory capacity of the platform, makes it possible to manage the evacuation of the public and employees",
  "models.Building.properties.dimensionPeopleCount.label": "Number of layer assignments",
  "models.Building.properties.dimensionPeopleCount.description": "The number of people who are assigned to the assignment layers associated with this building",
  "models.Building.properties.userCompanyOwner.label": "Building owner user",
  "models.Building.properties.userCompanyOwner.description": "The user who owns the building always sees the building even in the presence of a content role, in the event of a scenario creation, the user who created the scenario becomes the owner, the owner can be changed later",
  "models.AuthentificationConnection.singular": "Authentication login",
  "models.AuthentificationConnection.plural": "Authentication connections",
  "models.AuthentificationConnection.determinant.defined": "the authentication connection",
  "models.AuthentificationConnection.determinant.undefined": "an authentication connection",
  "models.AuthentificationConnection.determinants.defined": "authentication connections",
  "models.AuthentificationConnection.determinants.undefined": "authentication connections",
  "models.ApiUserToJupRole.singular": "Association of API user to role",
  "models.ApiUserToJupRole.plural": "API user associations to role",
  "models.ApiUserToJupRole.determinant.defined": "API user association with role",
  "models.ApiUserToJupRole.determinant.undefined": "an association of API user to the role",
  "models.ApiUserToJupRole.determinants.defined": "API user associations to role",
  "models.ApiUserToJupRole.determinants.undefined": "API user associations to role",
  "models.ApiUserToContentRole.singular": "Associating API user with the content role",
  "models.ApiUserToContentRole.plural": "API user associations to content role",
  "models.ApiUserToContentRole.determinant.defined": "API user association with content role",
  "models.ApiUserToContentRole.determinant.undefined": "an API user association with the content role",
  "models.ApiUserToContentRole.determinants.defined": "API user associations to the content role",
  "models.ApiUserToContentRole.determinants.undefined": "API user associations to the content role",
  "models.ApiUser.singular": "API user",
  "models.ApiUser.plural": "API users",
  "models.ApiUser.determinant.defined": "API user",
  "models.ApiUser.determinant.undefined": "an API user",
  "models.ApiUser.determinants.defined": "API users",
  "models.ApiUser.determinants.undefined": "API users",
  "models.ApiUser.properties.clientSecret.label": "Secret code",
  "models.ApiUser.properties.clientSecret.description": "the secret password for your API account can be generated and should never be disclosed",
  "ToggleZbreSyncCheckbox.label": "Synchronize with real-time occupations in Z#ber",
  "ToggleZbreSyncCheckbox.help": "Synchronization allows spaces and workstations to be colored according to the sensors placed in Z#ber",
  "FloorSpaceSlider.title": "Space between each floor in centimeters",
  "FloorSelector.title": "Select floors",
  "FloorSelector.focus": "Select only this floor",
  "FloorSelector.selectAll.false": "Select all floors",
  "FloorSelector.selectAll.true": "Deselect all floors",
  "ToggleEnableMissingFloors.label": "Show ghost floors",
  "ToggleEnableMissingFloors.help": "Show ghost floors for missing floors between level 0 floor and highest floor based on real floor levels",
  "RoomGraphHandler.buttons.generateGraph.label": "Generate the orientation graph",
  "RoomGraphHandler.buttons.generateGraph.description": "Generating the orientation graph calculates the nodes through which the path search can find spaces and furniture. If the original space can be selected, the graph has already been generated.",
  "RoomGraphHandler.buttons.selectOriginRoom.label": "Select the original space",
  "RoomGraphHandler.buttons.selectOriginRoom.description": "Please select a space and then you can use this option to set it as the starting space.",
  "RoomGraphHandler.icons.displayNodes.description": "Show paths in rooms",
  "RoomGraphHandler.icons.displayBoundingBoxes.description": "Show furniture exclusion areas",
  "RoomGraphHandler.icons.enablePathfinding.description": "Enable path tracing from source space with shape under mouse",
  "RoomGraphHandler.rooms.origin": "Original space",
  "ThemeModeSwitchMenuItem.dark.label": "Switch to light mode",
  "ThemeModeSwitchMenuItem.dark.help": "Using the bright mode allows you to work with a white background",
  "ThemeModeSwitchMenuItem.light.label": "Switch to dark mode",
  "ThemeModeSwitchMenuItem.light.help": "Using dark mode allows you to work with dark colors in the background for less eye strain",
  "copilot.actions.add.door": "A door has just been added by Surfy Copilot",
  "generateDocumentation.properties.technicalName": "Technical name",
  "generateDocumentation.properties.belongsTo": "Associated entities (unique)",
  "generateDocumentation.properties.hasMany": "Associated entities (list)",
  "generateDocumentation.properties.base": "Basic properties",
  "generateDocumentation.properties.mandatory": "Required Properties",
  "help.key1": "hello %{name}",
  "help.key2": "bye %{name}"
};
const es = {
  "ImportUpdateOption.label": "Poner al día",
  "ImportUpdateOption.help": "Actualizar objetos seleccionados",
  "ImportUpdateEntitiesTable.description": "Lista de objetos que requieren actualización",
  "PropertyTypeErrors.title": "Los siguientes valores no existen para la propiedad <b>%{propertyTypeLabel}</b> en <b>%{objectTypeLabel}</b>",
  "ImportDeleteOption.label": "eliminar",
  "ImportDeleteOption.help": "Eliminar objetos seleccionados en Surfy",
  "ImportDeleteEntitiesTable.description": "Lista de objetos que requieren eliminación en Surfy",
  "ImportCreateOption.label": "crear",
  "ImportCreateOption.help": "Realizar la creación de objetos seleccionados en Surfy",
  "ImportCreateEntitiesTable.description": "Lista de objetos que requieren creación",
  "ImportCreateEntitiesTable.open.label": "Ver entidades para crear",
  "ImportCreateEntitiesTable.open.help": "Ver el detalle de las entidades a crear porque hay más de 500 líneas, por motivos de rendimiento las líneas están ocultas por defecto",
  "ImportCreateAllOption.label": "Crear todo",
  "ImportCreateAllOption.help": "Realiza la creación de todos los objetos sin seleccionarlos individualmente",
  "entitiesImportType.date.wrongImportFormat": "El formato de la fecha %{value} no es correcto, el formato esperado es %{excelImportDateFormat}",
  "InfoTabContent.description": "Errores notables o información durante la importación",
  "InfoTabContent.noChange": "No se observó ningún cambio en comparación",
  "InfoTabContent.copyIds": "Copiar ID de entidad al portapapeles",
  "InfoTabContent.equals.multiple": "%{count} objetos existentes y sin modificar",
  "InfoTabContent.equals.one": "Un solo objeto ya existente y no modificado",
  "InfoTabContent.open.label": "Ver detalles de importación",
  "InfoTabContent.open.help": "Ver detalles de importación para comparaciones idénticas",
  "ImportObjectType.tabs.create.label": "Creación",
  "ImportObjectType.tabs.update.label": "Actualización",
  "ImportObjectType.tabs.errors.label": "Info",
  "ImportObjectType.tabs.delete.label": "Supresión",
  "ImportObjectType.usedKeys": "La clave de conciliación utilizada es:",
  "ImportObjectType.errors.noChange": "No se observó ninguna modificación en comparación",
  "CompareEntities.buttons.reset.label": "Reiniciar",
  "CompareEntities.buttons.reset.help": "Reinicie la importación",
  "ObjectTypeImportKeys.title": "Las claves disponibles para conciliar %{determinants.undefined} en el orden de su elección, si desea modificar una de las propiedades de la clave debe utilizar el identificador como clave",
  "ObjectTypeImportScalarProperties.help": "Copiar al portapapeles",
  "ImportHelpDrawerIconButton.icon.help": "Ver ayuda sobre la importación de datos para %{determinants.defined}",
  "ImportHelpDrawerIconButton.drawer.title": "Ayuda con la importación %{determinants.undefined}",
  "ImportHelpDrawerIconButton.drawer.tabLabel": "Ayuda para importar",
  "DownloadObjectTypeImportTemplateFileButton.label": "Descargue la plantilla de importación",
  "DownloadObjectTypeImportTemplateFileButton.help": "Descarga una plantilla de importación en execl con los nombres de las columnas que puedes elegir",
  "ImportHelpDrawer.tab": "Ayuda a importar %{objectTypeLabel}",
  "BelongsToListItem.clipboard": "Copiar el título de la columna al portapapeles",
  "BelongsToListItem.noKeys": "No hay clave única disponible",
  "BelongsToImportHelp.title": "Tipos de objetos asociados con %{objectTypeLabel} ordenados por claves de importación disponibles",
  "FileDropZone.dropZone": "Mueva y arrastre el archivo de importación a esta área o haga clic en el área para seleccionar su archivo",
  "EntitiesImporter.tabs.file": "Archivo",
  "EntitiesImporter.tabs.copypaste": "Copiar y pegar",
  "TextAreaImporter.errors.title": "Errores encontrados durante la importación",
  "TextAreaImporter.textarea.placeholder": "Copie y pegue sus columnas de Excel con el título para encontrar las propiedades para actualizar",
  "TextAreaImporter.help": "Utilice la tabulación entre cada columna incluyendo el nombre de cada columna en la primera fila o péguela directamente desde Excel",
  "ImportOptionsBar.buttons.compare.label": "Comparar",
  "ImportOptionsBar.buttons.compare.help": "Iniciar la comparación con los datos en surfy para determinar las modificaciones a importar",
  "ImportErrors.errors.title": "Errores encontrados durante la importación",
  "DashboardView.tabs.reports": "informes de excel",
  "IconShape.values.circle": "Círculo",
  "IconShape.values.rectangle": "Rectángulo",
  "IconShape.values.triangle": "Triángulo",
  "EntityDialogSearchList.NoResult": "No se encontraron resultados, borre sus filtros o cambie su búsqueda",
  "FieldTypeEntity.edit": "Cambiar %{determinant.defined}",
  "FieldTypeEntity.remove": "Eliminar %{determinant.defined}",
  "FieldTypeEntity.add": "Añadir %{determinant.undefined}",
  "LegendSelector.title": "Seleccionar leyenda",
  "LegendSelector.labels.default": "Leyenda predeterminada",
  "HasManyStandaloneNoData.noData": "No hay ningún %{targetObjectTypeLabel} asociado para %{determinant.defined}",
  "FieldTypeAddress.edit": "Cambiar dirección",
  "FieldTypeAddress.remove": "Eliminar dirección",
  "AutocompleteAddress.autocomplete.placeholder": "Encuentra tu dirección aquí",
  "AddressDialog.search": "Encuentra la dirección",
  "AddressDialog.validate": "Validar",
  "FieldTypePassword.icons.copy": "Copie el contenido de la contraseña al portapapeles",
  "FieldTypePassword.icons.generate": "Genera una contraseña única",
  "FieldTypeModel3d.Remove": "Eliminar modelo 3D",
  "FieldTypeModel3d.Upload": "Cambiar modelo 3D",
  "FieldTypeImage.Remove": "Quita la imagen",
  "FieldTypeImage.Upload": "Cambiar imagen",
  "FieldTypeIcon.Edit": "Cambiar icono",
  "FieldTypeIcon.Remove": "Eliminar el ícono",
  "FieldTypeColor.Remove": "Quitar color",
  "FieldTypeColor.NoColorHelp": "Selecciona un color",
  "FieldTypeColor.NotHexMatchError": "El campo no respeta el formato hexadecimal de un color.",
  "CopyImagePathToClipboard.CopyUrl": "Copiar URL",
  "ColorBox.NoColorHelp": "Seleccione un color a través de la paleta",
  "ChangeColor.classic": "Selecciona un color con la placa avanzada",
  "weight.kilogram": "Kilogramo",
  "weight.gram": "Gramo",
  "distance.meter": "Metros",
  "distance.centimeter": "Centímetros",
  "FieldTypeIndexBoolean.help": "Modificar el valor directamente",
  "FieldTypeIndexBoolean.values.true": "Sí",
  "FieldTypeIndexBoolean.values.false": "No",
  "calculatedProperties.properties.workplacesCount.label": "Cantidad de estaciones de trabajo",
  "calculatedProperties.properties.workplacesCount.description": "El número total de estaciones de trabajo en los espacios.",
  "calculatedProperties.properties.workplacesRatio.label": "Proporción de la estación de trabajo",
  "calculatedProperties.properties.workplacesRatio.description": "La relación de puestos de trabajo es el número de metros cuadrados dividido por el número de puestos de trabajo",
  "calculatedProperties.properties.peopleCount.label": "Numero de asignaciones",
  "calculatedProperties.properties.peopleCount.description": "El número de personas afectadas, ya sea directamente asignadas a los espacios o a través de una estación de trabajo",
  "calculatedProperties.properties.totalPeopleCount.label": "Número total de asignaciones",
  "calculatedProperties.properties.totalPeopleCount.description": "El número total de personas asignadas, ya sea directamente asignadas a los espacios o a través de una estación de trabajo.",
  "calculatedProperties.properties.peopleRatio.label": "Ratio de ocupación",
  "calculatedProperties.properties.peopleRatio.description": "El índice de ocupación es el número de metros cuadrados dividido por el número de personas asignadas directamente a los espacios o a través de una estación de trabajo",
  "calculatedProperties.properties.freeWorkplacesCount.label": "Numero de vacantes",
  "calculatedProperties.properties.freeWorkplacesCount.description": "Número total de vacantes",
  "calculatedProperties.properties.flexWorkplacesCount.label": "Número de posiciones de flexión",
  "calculatedProperties.properties.flexWorkplacesCount.description": "Número total de posiciones flexibles",
  "calculatedProperties.properties.occupancyRate.label": "Tasa de ocupación",
  "calculatedProperties.properties.occupancyRate.description": "Permite conocer el índice de ocupación de los puestos de trabajo, es el número de personas afectadas dividido por el número de puestos de trabajo.",
  "calculatedProperties.properties.expansionRatio.label": "Tasa de crecimiento excesivo",
  "calculatedProperties.properties.expansionRatio.description": "Se utiliza para averiguar la tasa de uso de las estaciones de trabajo, es la inversa del número de personas afectadas dividido por el número de estaciones de trabajo.",
  "calculatedProperties.properties.roomsArea.label": "Superficie calificada",
  "calculatedProperties.properties.roomsArea.description": "La superficie calificada es la suma de las superficies de los espacios",
  "calculatedProperties.properties.roomsCount.label": "Número de espacios",
  "calculatedProperties.properties.roomsCount.description": "El número total de espacios",
  "calculatedProperties.properties.sharedWorkplacesCount.label": "Número de estaciones de trabajo compartidas",
  "calculatedProperties.properties.sharedWorkplacesCount.description": "Número total de estaciones de trabajo compartidas por al menos 2 personas",
  "calculatedProperties.properties.sharedWorkplacesRatio.label": "Tasa de puestos de trabajo compartidos",
  "calculatedProperties.properties.sharedWorkplacesRatio.description": "Porcentaje de estaciones de trabajo compartidas por al menos 2 personas en comparación con todas las estaciones de trabajo",
  "calculatedProperties.properties.flexRatio.label": "Tasa de estaciones de trabajo flexibles",
  "calculatedProperties.properties.flexRatio.description": "La tasa de estaciones de trabajo flexibles se calcula dividiendo el número de estaciones de trabajo flexibles por el número total de estaciones de trabajo",
  "calculatedProperties.properties.transitWorkplacesCount.label": "Número de estaciones de trabajo de tránsito",
  "calculatedProperties.properties.transitWorkplacesCount.description": "Número de puestos de trabajo temporales, estos puestos no se cuentan en puestos libres y no son flexibles",
  "calculatedProperties.properties.seatsCount.label": "Numero de asientos",
  "calculatedProperties.properties.seatsCount.description": "El número total de asientos",
  "calculatedProperties.properties.seatsPeopleRatio.label": "Tarifa de asientos por asignación",
  "calculatedProperties.properties.seatsPeopleRatio.description": "El número de asientos por persona afectada",
  "calculatedProperties.properties.carbonFootprint.label": "Huella de carbono",
  "calculatedProperties.properties.carbonFootprint.description": "La huella de carbono es la cantidad de CO2 emitido",
  "calculatedProperties.properties.totalCapacityCount.label": "Capacidad total",
  "calculatedProperties.properties.totalCapacityCount.description": "La capacidad total de asientos es la suma del número de asientos y la capacidad de no asientos a nivel de espacio.",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.label": "Tarifa de plazas por puesto de trabajo",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.description": "La tarifa de plazas por puesto de trabajo es la capacidad total de los espacios dividida por el número de puestos de trabajo, esto nos permite entender la tarifa de plazas según el número de puestos de trabajo.",
  "DeleteMultipleDialog.title": "Eliminar %{determinants.undefined}",
  "DeleteMultipleDialog.content": "Está a punto de eliminar <b>%{determinants.undefined}</b> , esta acción no es reversible y puede tener impactos, ¿está seguro de que desea realizar esta acción?",
  "DeleteMultipleDialog.cancel.label": "anular",
  "DeleteMultipleDialog.cancel.help": "recuperar",
  "DeleteMultipleDialog.delete.label": "eliminar",
  "DeleteMultipleDialog.delete.help": "Eliminar permanentemente %{determinants.defined}",
  "DownloadTableToExcelIconButton.help": "Exportar %{determinants.defined} seleccionados",
  "DeleteMultipleEntities.help": "Eliminar %{determinants.defined} seleccionados",
  "EntityCreateModeSelect.open-on-create.text": "Abierto después de la creación",
  "EntityCreateModeSelect.open-on-create.help": "Una vez creado su objeto, será redirigido a la página de visualización del objeto para ver sus propiedades y asociaciones.",
  "EntityCreateModeSelect.keep-creating.text": "Continuar creando",
  "EntityCreateModeSelect.keep-creating.help": "Esta opción le permite continuar creando varios objetos en sucesión manteniendo las propiedades de la creación anterior.",
  "EntityCreateModeSelect.edit-on-create.text": "Editar después de la creación",
  "EntityCreateModeSelect.edit-on-create.help": "Una vez creado su objeto, será redirigido a la página de edición del objeto para completar sus propiedades y asociaciones.",
  "TableView.options": "opciones",
  "ErrorImpossibleToFindTheEntity.text": "No es posible encontrar %{determinant.defined} deseado",
  "ErrorImpossibleToFindTheEntities.text": "No se puede encontrar el %{determinants.defined}",
  "EntityPropertyTypesMandatoryNotRespected.title": "Se requieren las siguientes propiedades",
  "entity.properties.mandatory": "La propiedad %{name} es obligatoria.",
  "entity.properties.calculated": "La %{name} se calcula automáticamente.",
  "entity.properties.readonly-lock": "La %{name} es de solo lectura y no se puede modificar desde esta página.",
  "EntityHasManyProperties.associations.others": "Asociaciones para %{determinant.defined}",
  "EntityHasManyProperties.associations.reporting": "Asociaciones de informes para %{determinant.defined}",
  "EntityHasManyProperties.associations.security": "Asociaciones de seguridad para %{determinant.defined}",
  "EntitiesView.NoItem": "No existe %{objectType} , puedes crear tu primer %{objectType} usando el botón a continuación",
  "DeleteDialog.title": "Eliminar %{determinant.undefined}",
  "DeleteDialog.content": "Está a punto de eliminar <b>%{determinant.undefined}</b> , esta acción no es reversible y puede tener impactos, ¿está seguro de que desea realizar esta acción?",
  "DeleteDialog.cancel.label": "anular",
  "DeleteDialog.cancel.help": "recuperar",
  "DeleteDialog.delete.label": "eliminar",
  "DeleteDialog.delete.help": "Eliminar permanentemente %{determinant.defined}",
  "ExportQueryNodeToFileButton.help.list": "Descargar en excel %{determinants.defined}",
  "entity.excel.headers.count": "%{label} : número",
  "entity.properties.externalId.label": "Llave externa",
  "entity.properties.externalId.description": "Este campo se puede utilizar para recordar la clave de correspondencia en otro software",
  "entity.properties.createdAt.label": "Fecha de creación",
  "entity.properties.createdAt.description": "Fecha de creación en Surfy, permite conocer la historia de creación en Surfy",
  "entity.properties.userCompanyCreatedBy.label": "Creado por el usuario",
  "entity.properties.userCompanyCreatedBy.description": "Crear por este usuario en Surfy, permite conocer la historia de la creación en Surfy",
  "entity.properties.userCompanyCreatedById.label": "ID del usuario que creó",
  "entity.properties.userCompanyCreatedById.description": "Crear por el identificador de este usuario en Surfy, permite conocer el historial de la creación en Surfy",
  "entity.properties.userCompanyUpdatedById.label": "ID del usuario que modificó",
  "entity.properties.userCompanyUpdatedById.description": "Actualizado por el identificador de este usuario en Surfy, permite conocer el historial de creación en Surfy",
  "entity.properties.userCompanyUpdatedBy.label": "Actualizado por el usuario",
  "entity.properties.userCompanyUpdatedBy.description": "Actualizado por este usuario en Surfy, permite conocer el historial de la modificación en Surfy",
  "entity.properties.updatedAt.label": "Fecha de actualización",
  "entity.properties.updatedAt.description": "Fecha de actualización en Surfy, permite conocer el historial de modificaciones",
  "entity.delete.button.label": "eliminar",
  "entity.delete.button.help": "Eliminar %{determinant.defined} %{name}",
  "entity.cancel": "anular",
  "entity.see.label": "Ver",
  "entity.see.help": "Ver %{determinant.defined} %{name}",
  "entity.views.dataquality.help": "Informes y acciones para la calidad de los datos de %{determinants.defined}",
  "entity.views.dataquality.label": "Calidad de los datos",
  "entity.views.list.help": "Lista %{determinants.defined}",
  "entity.views.list.label": "Lister",
  "entity.views.import.help": "Importar %{determinants.undefined}",
  "entity.views.import.label": "importación",
  "entity.views.details.help": "Ver %{determinant.defined} %{name}",
  "entity.views.details.label": "Ver",
  "entity.views.create.help": "Crear %{determinant.undefined}",
  "entity.views.create.label": "crear",
  "entity.views.edit.help": "Editar %{determinant.defined} %{name}",
  "entity.views.edit.label": "Editar",
  "entity.views.dashboard.help": "Panel de %{determinant.defined} %{name}",
  "entity.views.dashboard.label": "Salpicadero",
  "entity.create.validate.help": "Validar creatividad para %{determinant.defined}",
  "entity.create.validate.label": "Validar la creación",
  "entity.create.button.help": "Iniciar la creación de %{determinant.defined}",
  "entity.create.button.label": "Crear %{determinant.defined}",
  "entity.create.association.help": "Iniciar la creación de %{determinant.undefined}",
  "entity.create.association.label": "Crear %{determinant.undefined}",
  "entity.update.button.label": "Salvar",
  "entity.update.button.help": "Ahorre %{determinant.defined} %{name}",
  "entity.createAndAssociate.button.label": "Crear y asociar",
  "entity.createAndAssociate.button.help": "Crear y asociar %{determinant.undefined}",
  "entity.associate.button.label": "asociado",
  "entity.associate.button.help": "Asociado %{determinant.undefined}",
  "entity.back": "regreso",
  "WorkCanvas.Options.ZoomCanvasOption.label.enable": "Habilitar lupa alrededor del mouse",
  "WorkCanvas.Options.ZoomCanvasOption.label.disable": "Deshabilitar la lupa alrededor del mouse",
  "WorkCanvas.Options.ZoomCanvasOption.help.enable": "Activar la lupa te permite tener una visión general de un área o piso y ver el comportamiento del mouse de manera precisa",
  "WorkCanvas.Options.ZoomCanvasOption.help.disable": "Detener la lupa del ratón",
  "WorkCanvas.Options.AddSegmentPointOption.label.enable": "Agregar un vértice en un segmento",
  "WorkCanvas.Options.AddSegmentPointOption.label.disable": "Dejar de agregar un vértice en un segmento",
  "WorkCanvas.Options.AddSegmentPointOption.help.enable": "Agregar un vértice en un segmento le permite colocar un punto en cualquier lugar sin tener en cuenta los otros puntos",
  "WorkCanvas.Options.AddSegmentPointOption.help.disable": "Deja de crear vértices en segmentos",
  "WorkCanvas.Options.AddSegmentPointOption.description": "Seleccione un espacio para poder crear un vértice en uno de los segmentos",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.enable": "Activar la inversión de la orientación de la creación de los vértices",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.disable": "Deshabilitar la inversión de la orientación de la creación de los vértices",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.enable": "Activar la inversión de la orientación de la creación de los vértices permite cambiar la dirección de creación de los vértices",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.disable": "Desactive la inversión para encontrar la dirección inicial de creación de los vértices.",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.enable": "Activar la inversión del ángulo recto para la creación de los vértices",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.disable": "Deshabilitar la inversión del ángulo recto para la creación de vértices",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.enable": "Activar la inversión permite utilizar el ángulo recto durante la creación de los vértices en el otro segmento",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.disable": "Desactivar la inversión permite usar el ángulo recto en el segmento inicial",
  "LoadingSvgCircle.pleaseWait": "Espere mientras se sincroniza",
  "WorkCanvas.Options.AddRoomPointOption.label.enable": "Agregar una cumbre",
  "WorkCanvas.Options.AddRoomPointOption.label.disable": "Deja de agregar un vértice",
  "WorkCanvas.Options.AddRoomPointOption.help.enable": "Agregar un vértice permite volver a trabajar con mayor precisión un formulario",
  "WorkCanvas.Options.AddRoomPointOption.help.disable": "Deja de crear cumbres",
  "WorkCanvas.Options.SplitPolygoneOption.label": "espacio separado",
  "WorkCanvas.Options.SplitPolygoneOption.help": "Crea 2 espacios a partir de otro espacio eligiendo 2 vértices",
  "WorkCanvas.Options.SplitRoomPointOption.help": "El vértice dividido permite reutilizar múltiples vértices para cada segmento y así crear espacios separados",
  "WorkCanvas.Options.SplitRoomPointOption.label": "vértice separado",
  "WorkCanvas.Options.MergeRoomPointsOption.help": "Fusionar vértices permite reutilizar el mismo vértice para diferentes espacios",
  "WorkCanvas.Options.MergeRoomPointsOption.label": "Fusionar vértices",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.help": "Quitar vértices del espacio",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.label": "Eliminar vértices seleccionados",
  "WorkCanvas.Options.ZoomOnEdgePoints.help": "Concéntrese en uno o más puntos para poder trabajar en silencio.",
  "WorkCanvas.Options.ZoomOnEdgePoints.label": "Centrarse en puntos",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.enable": "Mover tipo de objeto",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.disable": "Deja de moverte",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.enable": "Mover el tipo de objeto en el avión",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.disable": "Dejar de mover el tipo de objeto",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.help": "Eliminar el tipo de objeto del tipo de estación de trabajo",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.label": "Eliminar tipo de objeto",
  "WorkCanvas.Options.DeleteItemTypePointsOption.help": "Eliminar vértices del tipo de objeto",
  "WorkCanvas.Options.DeleteItemTypePointsOption.label": "Eliminar vértices seleccionados",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.enable": "Añade una forma",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.disable": "Deja de agregar la forma",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.enable": "Agregar una forma para un tipo de objeto en el plano",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.disable": "Deja de crear la forma",
  "WorkCanvas.Options.AddItemTypeShapeSaveOption.help": "Guardar el tipo de objeto que se está creando",
  "WorkCanvas.Options.AddItemTypePointOption.label.enable": "Agregar una cumbre",
  "WorkCanvas.Options.AddItemTypePointOption.label.disable": "Deja de agregar un vértice",
  "WorkCanvas.Options.AddItemTypePointOption.help.enable": "Agregar un vértice permite volver a trabajar con mayor precisión un formulario",
  "WorkCanvas.Options.AddItemTypePointOption.help.disable": "Deja de crear cumbres",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.enable": "Mover espacios",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.disable": "dejar de viajar",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.enable": "Habilitar espacios móviles en el plano.",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.disable": "Deja de mover espacios",
  "WorkCanvas.Options.ToggleMoveRoomOption.description": "Una vez activado, selecciona un espacio y podrás moverlo.",
  "WorkCanvas.Options.DuplicateShapesOption.label": "Formas duplicadas",
  "WorkCanvas.Options.DuplicateShapesOption.help": "Duplique formas sin propiedades para crear rápidamente objetos o estaciones de trabajo en el plano",
  "CancelDuplicateShapsToRoomMouse.help": "Deshacer formas duplicadas",
  "ToggleWorkplaceFreeConditionTypeIconButton.or": "Ver estaciones de trabajo gratuitas para todos los días solicitados",
  "ToggleWorkplaceFreeConditionTypeIconButton.and": "Ver puestos de trabajo libres durante al menos uno de los días solicitados",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.false": "Publicaciones sin color %{day}",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.true": "Deja de colorear publicaciones gratuitas %{day}",
  "FreeWorkplacesDayList.title": "Ver lugares libres %{days}",
  "FreeWorkplacesDayList.conditions.and": "Y",
  "FreeWorkplacesDayList.conditions.or": "O",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.enable": "Colorea los puntos de control",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.disable": "Deja de colorear los postes de cruce",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.enable": "Vea en el mapa de colores las estaciones de trabajo que están pasando",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.disable": "Ya no se ven las estaciones de trabajo que pasan de manera diferente en el mapa",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.enable": "Colorea las publicaciones compartidas",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.disable": "Deja de colorear las publicaciones compartidas",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.enable": "Vea en el plano de color las estaciones de trabajo que comparten al menos 2 personas",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.disable": "Ya no ver las estaciones de trabajo compartidas de forma diferente en el mapa",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.enable": "Objetos de color sin asociación.",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.disable": "Deja de colorear objetos sin asociación",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.enable": "Ver los objetos gratuitos en el mapa.",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.disable": "Ya no veo los objetos gratuitos de forma diferente en el mapa.",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.enable": "Colorea las posiciones reservables.",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.disable": "Dejar de colorear posiciones reservables",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.enable": "Vea en el plan de colores los puestos de trabajo reservables",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.disable": "Ya no vemos las estaciones de trabajo reservables de manera diferente en términos de",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.enable": "Colorear posiciones libres",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.disable": "Deja de colorear publicaciones gratuitas",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.enable": "Ver las posiciones libres en el mapa",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.disable": "Ya no verá las posiciones libres de manera diferente en el plan",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.enable": "Colorea las publicaciones en flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.disable": "Deja de colorear publicaciones en flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.enable": "Ver las posiciones de los flex en el mapa",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.disable": "Ya no verá las posiciones flexibles de manera diferente en el plan",
  "WorkCanvas.Options.CalibrateLayoutOption.help.enable": "Calibrar el mapa le permite ampliar o reducir el tamaño de todos los espacios o moverlos todos en el mapa",
  "WorkCanvas.Options.CalibrateLayoutOption.help.disable": "Deja de calibrar el plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.enable": "Calibrar el plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.disable": "Deja de calibrar el plan",
  "CalibrateLayoutDrawer.title": "Calibrar el plan",
  "CalibrateLayoutDrawer.options.mapScale.label": "Alinear la escala del plan",
  "CalibrateLayoutDrawer.options.mapScale.help": "Aplicar el factor de escala a los elementos de la escala (longitud y tamaño de los textos)",
  "CalibrateLayoutDrawer.options.inputs.scale.label": "Factor de escala",
  "CalibrateLayoutDrawer.options.inputs.step.label": "Valor de traducción",
  "CalibrateLayoutDrawer.options.inputs.translate.x.label": "El eje X",
  "CalibrateLayoutDrawer.options.inputs.translate.y.label": "Eje Y",
  "CalibrateLayoutDrawer.options.reduce.label": "Reducir",
  "CalibrateLayoutDrawer.options.save.label": "Para registrarse",
  "CalibrateLayoutDrawer.options.save.help": "Guarde la calibración en el plan",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.enable": "Activar la visualización de iconos en el plano en 2d",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.disable": "Desactivar la visualización de iconos en el mapa",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.enable": "Los iconos asociados a los tipos de espacios facilitan la visualización de los tipos de espacios en el plano",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.disable": "Ver información del espacio",
  "WorkCanvasToggleOptionHelp.shortcut": "Atajo de teclado: <b>%{shortcut}</b>",
  "WorkCanvasShortcutTooltipHelp.help": "Atajo de teclado: <b>%{shortcut}</b>",
  "WorkCanvas.Options.ZoomOutOption.label": "Alejar en el mapa",
  "WorkCanvas.Options.ZoomOutOption.help": "Aleje el mapa centrándose en la posición del mouse",
  "WorkCanvas.Options.ZoomOutOption.description": "Puede usar la rueda del mouse y el panel táctil para alejar",
  "WorkCanvas.Options.ZoomOnMousePosition.help": "Amplíe la posición del mouse para poder trabajar con mayor precisión en un área",
  "WorkCanvas.Options.ZoomOnMousePosition.label": "Acercar la posición del mouse",
  "WorkCanvasLoadingIcon.title": "Cargando el plan",
  "WorkCanvas.Options.ZoomOnItemsOption.help": "Amplíe uno o más objetos para poder trabajar con mayor precisión",
  "WorkCanvas.Options.ZoomOnItemsOption.label": "Acercar la selección",
  "WorkCanvas.Options.ZoomOnDimensionsOption.label": "Ampliar las capas de tareas",
  "WorkCanvas.Options.ZoomOnDimensionsOption.help": "Haga zoom directamente a las capas de asignación en las que puede reservar en el plan",
  "WorkCanvas.Options.ZoomInOption.label": "Acercar el mapa",
  "WorkCanvas.Options.ZoomInOption.help": "Amplíe el mapa centrándose hacia la parte superior izquierda de la pantalla",
  "WorkCanvas.Options.ZoomInOption.description": "Puede usar la rueda del mouse y el panel táctil para hacer zoom",
  "WorkCanvas.Options.ToggleSelectModeOption.help.enable": "Obtenga las opciones del plan para poder hacer zoom o ver los detalles de las formas y activar los atajos de teclado, también puede hacer clic en el plan para activar la manipulación.",
  "WorkCanvas.Options.ToggleSelectModeOption.help.disable": "???",
  "WorkCanvas.Options.ToggleSelectModeOption.label.enable": "Empiece a trabajar con el espacio de trabajo",
  "WorkCanvas.Options.ToggleSelectModeOption.label.disable": "Detener la manipulación del espacio de trabajo.",
  "WorkCanvas.Options.ToggleSelectModeOption.description": "Puede seleccionar varias formas manteniendo presionada la <b>tecla MAYÚS</b> y haciendo clic en las formas",
  "WorkCanvas.Options.ToggleEditModeOption.label.enable": "Habilitar el modo de edición de plan",
  "WorkCanvas.Options.ToggleEditModeOption.label.disable": "Deshabilitar el modo de edición del plan",
  "WorkCanvas.Options.ToggleEditModeOption.help.enable": "Activar el modo de edición del plano te permite crear y mover formas o crear espacios",
  "WorkCanvas.Options.ToggleEditModeOption.help.disable": "Desactivar el modo de edición de planos para volver al modo de lectura de planos",
  "WorkCanvas.Options.ToggleEditModeOption.description": "Al rotar objetos y estaciones de trabajo, por defecto se aplica un ángulo de 45 °, para desactivarlo use la tecla <b>SHIFT</b> del teclado",
  "WorkCanvas.Options.FitToViewOption.label": "Centra el mapa para verlo todo",
  "WorkCanvas.Options.FitToViewOption.help": "Le permite tener una visión general del plan",
  "HeatMapSelection.title": "Colorea los espacios con un mapa de calor para entender las densidades, los mapas de calor no son exportables en imagen por el momento",
  "HeatMapSelection.heatmaps.seatsCount.label": "Densidad de asientos",
  "HeatMapSelection.heatmaps.seatsCount.description": "Colorea los espacios según el número de asientos",
  "HeatMapSelection.heatmaps.workplacesCount.label": "Densidad de estaciones de trabajo",
  "HeatMapSelection.heatmaps.workplacesCount.description": "Colorea los espacios según el número de estaciones de trabajo",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.label": "Densidad de asignaciones a estaciones de trabajo",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.description": "Colorea los espacios según el número de asignaciones de estaciones de trabajo",
  "HeatMapSelection.heatmaps.carbonFootprintCount.label": "Mobiliario Densidad Huella de Carbono",
  "HeatMapSelection.heatmaps.carbonFootprintCount.description": "Colorea los espacios según la huella de carbono del mobiliario",
  "FurnituresSelectionDragZone.help": "Mover grupo",
  "FurnituresSelection.move": "Mover a todo el grupo",
  "WorkCanvas.Options.TextAnchorOption.label.enable": "Establecer la ubicación del texto mostrado",
  "WorkCanvas.Options.TextAnchorOption.label.disable": "Detener visualización de gestión de texto",
  "WorkCanvas.Options.TextAnchorOption.help.enable": "Mover texto de visualización",
  "WorkCanvas.Options.TextAnchorOption.help.disable": "Dejar de mover el texto de la pantalla",
  "TextAnchorDrawer.title": "Cambiar la ubicación del texto mostrado para %{determinant.defined} %{name}",
  "WorkCanvas.Options.TextAnchorDrawer.label.enable": "Mover texto de visualización",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.label": "Personaliza la posición del texto",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.help": "Le permite activar la personalización de la posición del texto del mapa.",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.label": "Activar pantalla de anclaje",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.help": "Le permite activar la visualización del segmento y el punto de anclaje de este espacio.",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.label": "Restablecer posición de texto",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.help": "Esta opción devuelve la posición del texto de este espacio a su ubicación original.",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.label": "Restablecer posición de anclaje",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.help": "Esta opción devuelve la posición de anclaje de este espacio a su ubicación original.",
  "ShapeTextAnchorDrawer.empty": "Seleccione una forma compatible para mover el texto mostrado",
  "IconsPicker.DisplayAll.text": "Ver todo",
  "IconsPicker.DisplayAll.help": "Atención, la carga puede ser un poco larga",
  "IconsPicker.close": "Cerrar selección de iconos",
  "IconPickerSearch.SearchPlaceholder": "Busque un ícono con al menos 3 letras",
  "EntitiesAutocomplete.searchEmpty.help.false": "Seleccione %{determinants.defined} sin %{objectTypeName}",
  "EntitiesAutocomplete.searchEmpty.help.true": "Volver al modo de búsqueda estándar",
  "SearchFieldString.searchEmpty.help.false": "Buscar elementos vacíos o sin valor",
  "SearchFieldString.searchEmpty.help.true": "Volver a habilitar la búsqueda estándar",
  "SearchFilters.buttons.clear.label": "Borrar todos los filtros",
  "SearchFilters.buttons.clear.help": "Borre todos los filtros y reinícielos a su estado inicial para asegurarse de que puede ver todas las entidades disponibles",
  "RightSearchFilterDrawer.filter": "Filtro %{determinants.defined}",
  "RightSearchFilterDrawer.tabLabel": "Filtrar",
  "RightSearchFilterDrawer.buttons.clear.label": "Borrar todos los filtros",
  "RightSearchFilterDrawer.buttons.clear.help": "Borre todos los filtros y reinícielos a su estado inicial para asegurarse de que puede ver todas las entidades disponibles",
  "PropertSelectorDrawer.help": "Seleccione las propiedades que desea mostrar en la tabla",
  "PropertSelectorDrawer.options.reset.label": "Restablecer selección",
  "PropertSelectorDrawer.options.reset.help": "Restablecer la selección de propiedades a su estado inicial",
  "PropertSelectorDrawer.tabLabel": "Propiedades",
  "TableSelectionAllCheckbox.checked.true": "Deselecciona todo",
  "TableSelectionAllCheckbox.checked.false": "Seleccionar todo",
  "TableSelectionAllCheckbox.help": "Seleccionar o anular la selección de todas las filas (incluidas las que no son visibles en la lista paginada)",
  "TableOptionsRow.checked.true": "Deselecciona todo",
  "TableOptionsRow.checked.false": "Seleccionar todo",
  "TableOptionsRow.help": "Seleccionar o anular la selección de todas las líneas",
  "ErrorTextZone.reload": "Rehacer la operación",
  "ReportErrorSteps.report.title": "Acabas de encontrar un error",
  "ReportErrorSteps.report.description": "Este error ha sido informado a nuestros equipos e intentaremos corregirlo lo más rápido posible.",
  "ReportErrorSteps.report.steps.title": "Puedes probar en orden",
  "ReportErrorSteps.report.steps.reload": "Vuelva a cargar la página y vea si el error se resuelve.",
  "ReportErrorSteps.report.steps.logout": "Desconéctese y regrese a esta página después de volver a conectarse",
  "ReportErrorSteps.report.steps.contact": "Contáctanos para que podamos ofrecerte una alternativa lo más rápido posible",
  "ReportErrorByMailButton.label": "Contáctenos",
  "RefreshPageButton.label": "Recargar página",
  "Errors.networkError": "Se han detectado problemas de conexión o de red. Espere y vuelva a intentarlo en unos segundos.",
  "ShowEntityDrawer.title.show": "Ver %{determinant.defined}",
  "ShowEntityDrawer.title.listItem": "Ver información para %{determinant.defined} en la barra lateral",
  "EditEntityDrawer.title.edit": "Editar %{determinant.defined}",
  "RightDrawerContent.close": "Cierre el panel derecho haciendo clic en la cruz.",
  "DropDownOptions.moreOptions": "Ver más opciones para %{determinant.defined} %{name}",
  "BuildingFloorsList.title": "Navegar por los pisos",
  "RefetchEntityButton.refetch": "Recargar datos",
  "RefetchEntitiesButton.refetch": "Recargar datos de objetos visibles",
  "RefetchObjectTypeIcon.help": "Recargar datos para %{determinant.defined}",
  "ImpactButtonReload.help.single": "Actualizar datos calculados para %{determinant.defined}",
  "ImpactButtonReload.help.list": "Actualizar datos calculados para %{determinants.defined}",
  "EditInlineToggleIconButton.edit.label": "Editar",
  "EditInlineToggleIconButton.edit.help": "Edite las propiedades de %{determinant.defined} directamente en esta página",
  "EditInlineToggleIconButton.cancel.help": "Dejar de editar sin guardar",
  "ConfirmationButtons.confirm": "Confirmar la finalización de la acción.",
  "ConfirmationButtons.cancel": "anular",
  "ConfirmationButtons.loading": "La acción se está ejecutando, espera",
  "EmailNotVerified.errorMessage": "Por favor valide su correo electrónico ( %{email} ), una vez validado, puede desconectarse y volver a conectarse para acceder a Surfy",
  "NoRoleAssociated.noRole": "No parece haber ningún rol asociado con su usuario para la empresa %{tenant} , comuníquese con su administrador",
  "NoCompanies.title.whatIsSurfy": "¿Qué es Surfy?",
  "NoCompanies.NoCompanyAssigned": "No estás asociado a ninguna plataforma, por el momento no puedes usar surfy",
  "NoCompanies.whatIsSurfy": "Surfy ofrece digitalizar planos de construcción para facilitar la gestión del entorno laboral.<br/> Puedes usar la aplicación Surfy para<ul><li> organizar espacios</li><li> asignar empleados</li><li> espacios de recarga</li><li> analizar espacios</li><li> gestionar el cumplimiento y las regulaciones</li><li> conectar espacios</li><li> gestionar horarios de asistencia</li><li> reservar espacios de trabajo</li></ul>",
  "NoCompanies.whatIsSurfyForTeams": "Surfy ofrece digitalizar planos de edificación para facilitar la gestión del entorno laboral. Puedes usar la aplicación Surfy para<ul><li> gestiona tu agenda de presencia</li><li> declarar su presencia en la oficina</li><li> reservar un espacio de trabajo</li><li> indicar que estás teletrabajando</li><li> ver qué colegas han reservado una estación de trabajo en el plan</li></ul>",
  "NoCompanies.ContactUs.text": "Inicie sesión en la plataforma de su empresa",
  "NoCompanies.ContactUs.subject": "Acceder a Surfy",
  "NoCompanies.ContactUs.body": "Hola, ¿podrías dejarme acceder a la aplicación Surfy? Gracias.",
  "NoCompanies.accessSurfy.title": "¿Por qué no puedo acceder a Surfy?",
  "NoCompanies.accessSurfy.alreadyUsing": "Si su empresa ya utiliza Surfy, por favor contacte con su responsable de entorno laboral para solicitar acceso o contáctenos a través del siguiente enlace",
  "NoCompanies.accessSurfy.joinTenant": "Únase a la plataforma de su empresa",
  "NoCompanies.notUsing.title": "¿Tu empresa aún no utiliza Surfy?",
  "NoCompanies.knowMore": "Más información sobre Surfy",
  "AuthenticationButton.connections.google-oauth2.label": "google",
  "AuthenticationButton.connections.google-oauth2.help": "Inicia sesión con tu cuenta de Google",
  "AuthenticationButton.connections.AzureADv2.label": "Office 365",
  "AuthenticationButton.connections.AzureADv2.help": "Conéctese con su cuenta profesional de Microsoft a través de Office 365",
  "AuthenticationButton.connections.auth0.label": "Cuenta Surfy",
  "AuthenticationButton.connections.auth0.help": "Inicie sesión con su cuenta de Surfy",
  "Auth0AuthenticationButton.connections.auth0.label": "Cuenta Surfy (identificación abierta)",
  "Auth0AuthenticationButton.connections.auth0.help": "Inicie sesión con su cuenta de Surfy",
  "EnterpriseConnectionButton.label": "negocios",
  "EnterpriseConnectionButton.help": "Inicie sesión con su cuenta de empresa a través de una autenticación dedicada como OKTA o DigitalP@ss",
  "EnterpriseConnectionForm.title": "Por favor ingrese su correo electrónico para que podamos reconocer su negocio",
  "EnterpriseConnectionForm.forms.email.placeholder": "Correo electrónico",
  "EnterpriseConnectionForm.error": "No se puede identificar a su empresa con su correo electrónico",
  "EnterpriseConnectionForm.buttons.validate.label": "Validar",
  "EnterpriseConnectionForm.buttons.validate.help": "Validar el correo electrónico le permite conocer su empresa y dirigirlo a la plataforma de autenticación adecuada",
  "EnterpriseConnectionForm.buttons.back.label": "regreso",
  "EnterpriseConnectionForm.buttons.back.help": "Volver a la página de autenticación con todas las opciones",
  "LoginView.loadingPage": "Cargando la página de autenticación",
  "LoginView.connections.google-oauth2.label": "google",
  "LoginView.connections.google-oauth2.help": "Inicia sesión con tu cuenta de Google",
  "LoginView.connections.AzureADv2.label": "Office 365",
  "LoginView.connections.AzureADv2.help": "Conéctese con su cuenta profesional de Microsoft a través de Office 365",
  "LoginView.connections.Username-Password-Authentication.label": "Cuenta Surfy",
  "LoginView.connections.Username-Password-Authentication.help": "Inicie sesión con su cuenta de Surfy",
  "LoginView.texts.title": "acceder",
  "LoginView.texts.description": "Acceder a Surfy",
  "LoginView.helpers.register": "Registra tu negocio en Surfy",
  "LoginView.helpers.moreInfo": "Más información sobre Surfy",
  "LoginView.helpers.privacy": "política de privacidad",
  "CustomUserRegisterForm.tabs.login": "Conectarse",
  "CustomUserRegisterForm.tabs.signup": "Inscribirse",
  "CustomUserRegisterForm.form.email": "Email",
  "CustomUserRegisterForm.form.password": "Contraseña",
  "CustomUserRegisterForm.form.firstName": "primer nombre",
  "CustomUserRegisterForm.form.lastName": "Apellido",
  "CustomUserRegisterForm.form.confirmPassword": "confirmación de contraseña",
  "CustomUserRegisterForm.buttons.login.label": "Validar",
  "CustomUserRegisterForm.buttons.login.help": "Inicie sesión si ya tiene una cuenta",
  "CustomUserRegisterForm.buttons.signup.label": "Validar",
  "CustomUserRegisterForm.buttons.signup.help": "Suscríbete a Surfy si no tienes una cuenta",
  "ReportChart.NoValue": "Sin valor",
  "ChangeLanguage.title": "Cambiar el idioma",
  "ChangeLanguage.help": "Cambiar el idioma de la aplicación",
  "DataQualityTable.numberOfLines": "Número de líneas",
  "AllTenantsDataQualityTable.enableAllTenants.label": "Incluir todas las plataformas",
  "SingleNodeQuery.refetch": "Recargar datos",
  "ListRefetchButton.refetch": "Recargar datos de objetos visibles",
  "ImpactObjectTypeIconButton.refetch": "Recargar todos los datos independientemente de los filtros.",
  "CollapseSwitchButton.help.true": "ocultar el detalle",
  "CollapseSwitchButton.help.false": "Ver el detalle",
  "menu.logout": "Desconectarse",
  "menu.tenantOperations": "Sincronización",
  "menu.menuLeft.shoppingCart": "Cesta",
  "menu.menuLeft.personCompanies": "Proveedores",
  "menu.menuLeft.workplace": "Estaciones de trabajo",
  "menu.menuLeft.security": "seguridad",
  "menu.menuLeft.globalSecurity": "Seguridad global",
  "menu.menuLeft.all": "administración",
  "menu.menuLeft.operations": "operaciones",
  "menu.menuLeft.types": "tipos",
  "menu.menuLeft.roomTypes": "Tipologías espaciales",
  "menu.menuLeft.inventory": "inventarios",
  "menu.menuLeft.people": "Gente",
  "menu.menuLeft.spaces": "Espacios",
  "menu.menuLeft.organizations": "Organizaciones",
  "menu.menuLeft.dimensions": "Capas de análisis",
  "menu.menuLeft.api": "API",
  "menu.menuLeft.authentification": "Autenticación",
  "menu.menuLeft.globalAdmin": "administración global",
  "menu.menuLeft.human": "Colaboradores",
  "menu.menuLeft.things": "Muebles",
  "menu.menuLeft.admin": "administración",
  "menu.menuLeft.surfy": "surfista",
  "menu.menuLeft.partnerExportMapping": "Socios",
  "menu.menuLeft.personType": "tipos",
  "menu.menuLeft.personRelations": "Relaciones",
  "menu.menuLeft.affectations": "asignaciones",
  "menu.menuLeft.buildings": "Edificios",
  "menu.menuLeft.thingsType": "tipos",
  "menu.menuLeft.spacePoints": "Puntos",
  "menu.menuLeft.adminReporting": "Informes",
  "menu.menuLeft.adminCostCenterReporting": "Centro de costos",
  "menu.menuLeft.adminDimensionReporting": "dimensiones",
  "menu.menuLeft.adminRoomTypeReporting": "tipo de espacios",
  "menu.menuLeft.adminOrganizationReporting": "Organizaciones",
  "menu.menuLeft.adminRoomTypeGroupReporting": "Grupos de tipología espacial.",
  "menu.menuLeft.buildingFacts": "Datos de construcción con marca de tiempo",
  "menu.menuLeft.itemsFact": "Datos de objeto con marca de tiempo",
  "menu.menuLeft.segments": "Segmentos",
  "menu.menuLeft.connectors": "Conectores",
  "menu.menuLeft.planning": "Horarios",
  "menu.menuLeft.bookings": "Reservas",
  "menu.menuLeft.help": "Ayuda",
  "menu.menuLeft.company": "Plataformas",
  "ReduceMenuSwitch.open.true": "Expandir menú",
  "ReduceMenuSwitch.open.false": "Contraer el menú para aprovechar el espacio de trabajo",
  "LogoutMenuLink.logout": "Desconectarse",
  "HelpPortalListItemLink.label": "portal de ayuda",
  "HelpPortalListItemLink.help": "Descubre el portal de ayuda de Surfy con todos nuestros tutoriales y guías de usuario",
  "ChangeLogListItemLink.label": "Noticias",
  "ChangeLogListItemLink.help": "Conoce las novedades y cambios en Surfy",
  "DisplayRoomTexts.dragOption": "Mantenga presionado y cambie el orden en que se muestran las propiedades en el mapa moviendo el campo hacia arriba o hacia abajo",
  "DisplayRoomTexts.roomPeopleDimensions.label": "Vecindario",
  "DisplayRoomTexts.roomPeopleDimensions.help": "Mostrar o no el barrio en el mapa",
  "DisplayRoomTexts.roomSeatsCount.label": "Numero de asientos",
  "DisplayRoomTexts.roomSeatsCount.help": "Mostrar o no el número de asientos en el mapa",
  "DisplayRoomTexts.roomCapacity.label": "Capacidad de espacio",
  "DisplayRoomTexts.roomCapacity.help": "Mostrar o no la capacidad del espacio en el plano.",
  "DisplayRoomTexts.roomCostCenter.label": "Centro de coste",
  "DisplayRoomTexts.roomCostCenter.help": "Mostrar o no el centro de costo del espacio en el plano.",
  "DisplayRoomTexts.roomMergedName.label": "Nombre fusionado",
  "DisplayRoomTexts.roomMergedName.help": "Mostrar o no el nombre combinado del espacio en el plano, este nombre combina el nombre para mostrar y el nombre del espacio.",
  "DisplayRoomTexts.roomName.label": "Nombre del espacio",
  "DisplayRoomTexts.roomName.help": "Mostrar o no el nombre del espacio en el plano",
  "DisplayRoomTexts.roomPrettyName.label": "Nombre para mostrar",
  "DisplayRoomTexts.roomPrettyName.help": "Mostrar o no el nombre para mostrar del espacio en el plano",
  "DisplayRoomTexts.roomArea.label": "superficie",
  "DisplayRoomTexts.roomArea.help": "Mostrar o no la superficie del espacio en el plano",
  "DisplayRoomTexts.roomType.label": "Tipología espacial",
  "DisplayRoomTexts.roomType.help": "Mostrar o no la tipología del espacio.",
  "DisplayRoomTexts.roomPerimeter.label": "perímetro",
  "DisplayRoomTexts.roomPerimeter.help": "Mostrar o no el perímetro del espacio en el plano.",
  "DisplayRoomTexts.roomOrganizationLevel1.label": "Servicio",
  "DisplayRoomTexts.roomOrganizationLevel1.help": "Mostrar o no el nombre del servicio espacial en el plano",
  "DisplayRoomTexts.roomOrganizationTopLevel.label": "Dirección",
  "DisplayRoomTexts.roomOrganizationTopLevel.help": "Mostrar o no el nombre de la dirección del espacio en el plano.",
  "DisplayRoomTexts.roomPeople.label": "Personas asignadas a espacios",
  "DisplayRoomTexts.roomPeople.help": "Mostrar o no los nombres de las personas asignadas a este espacio en el plano",
  "DisplayRoomTexts.roomWorkplaceAffectations.label": "Personas asignadas a estaciones de trabajo",
  "DisplayRoomTexts.roomWorkplaceAffectations.help": "Mostrar o no los nombres de las personas asignadas a las estaciones de trabajo en este espacio del plano",
  "DisplayRoomTexts.roomPeopleCount.label": "Numero de asignaciones",
  "DisplayRoomTexts.roomPeopleCount.help": "Mostrar o no el número de personas asignadas a este espacio en el plano",
  "DisplayRoomTexts.roomPeopleRatio.label": "Ratio de ocupación",
  "DisplayRoomTexts.roomPeopleRatio.help": "Mostrar o no el ratio de ocupación del espacio en el plano.",
  "DisplayRoomTexts.roomWorkplacesCount.label": "Cantidad de estaciones de trabajo",
  "DisplayRoomTexts.roomWorkplacesCount.help": "Mostrar o no el número de estaciones de trabajo en el espacio del plano.",
  "DisplayRoomTexts.roomWorkplacesRatio.label": "Proporción de la estación de trabajo",
  "DisplayRoomTexts.roomWorkplacesRatio.help": "Mostrar o no la proporción de estaciones de trabajo del espacio en el plano.",
  "DisplayRoomTexts.roomOccupancyRate.label": "Tasa de ocupación",
  "DisplayRoomTexts.roomOccupancyRate.help": "Mostrar o no la tasa de ocupación del espacio en el plano.",
  "DisplayRoomTexts.roomExpansionRatio.label": "Tasa de crecimiento excesivo",
  "DisplayRoomTexts.roomExpansionRatio.help": "Mostrar o no la tasa de expansión del espacio en el plano.",
  "DisplayRoomTexts.roomFreeWorkplacesCount.label": "Numero de vacantes",
  "DisplayRoomTexts.roomFreeWorkplacesCount.help": "Mostrar o no el número de posiciones libres en el plan",
  "DisplayRoomTexts.roomFlexWorkplacesCount.label": "Número de posiciones de flexión",
  "DisplayRoomTexts.roomFlexWorkplacesCount.help": "Mostrar o no el número de posiciones flexibles en el plan",
  "DisplayRoomOptions.roomSeatsCount.one": "%{value} asiento",
  "DisplayRoomOptions.roomSeatsCount.more": "%{value} asientos",
  "DisplayRoomOptions.roomCapacity.one": "Capacidad: %{value} place",
  "DisplayRoomOptions.roomCapacity.more": "Capacidad: %{value} lugares",
  "DisplayRoomOptions.roomFreeWorkplacesCount.one": "%{value} posición libre",
  "DisplayRoomOptions.roomFreeWorkplacesCount.more": "%{value} vacantes",
  "DisplayRoomOptions.roomFlexWorkplacesCount.one": "%{value} elemento flexible",
  "DisplayRoomOptions.roomFlexWorkplacesCount.more": "%{value} posiciones flexibles",
  "DisplayRoomOptions.roomWorkplacesCount.one": "estación de trabajo %{value}",
  "DisplayRoomOptions.roomWorkplacesCount.more": "%{value} estaciones de trabajo",
  "DisplayRoomOptions.roomPeopleCount.one": "%{value} persona afectada",
  "DisplayRoomOptions.roomPeopleCount.more": "%{value} personas afectadas",
  "DisplayRoomOptions.roomOccupancyRate": "Ocupación: %{value}",
  "DisplayRoomOptions.roomExpansionRatio": "Expansión: %{value}",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.enable": "Administrar textos de visualización de espacios",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.disable": "Cerrar pantalla de gestión de texto",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.enable": "Permite configurar los textos que se mostrarán en el plano para cada espacio",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.disable": "Regrese al modo normal de edición del plan.",
  "DisplayRoomTextsDrawer.tabs.map": "plan",
  "DisplayRoomTextsDrawer.tabs.tooltip": "Descripción emergente",
  "DisplayRoomTextsDrawer.tabs.base.tabs.rooms": "Espacios",
  "DisplayRoomTextsDrawer.tabs.base.tabs.people": "Gente",
  "DisplayRoomTextsDrawer.tabs.base.people.description": "Para definir las propiedades de las personas que se mostrarán en el plan, elija en la pestaña de espacios las personas asignadas a los espacios o a las estaciones de trabajo y luego elija las propiedades en esta pestaña",
  "DisplayWorkplaceTexts.workplaceName.label": "Nombre de la estación de trabajo",
  "DisplayWorkplaceTexts.workplaceName.help": "Mostrar o no el nombre de la estación de trabajo en el mapa",
  "DisplayWorkplaceTexts.workplaceCostCenter.label": "Centro de coste",
  "DisplayWorkplaceTexts.workplaceCostCenter.help": "Mostrar o no el centro de costos de la estación de trabajo en el plan",
  "DisplayWorkplaceTexts.people.label": "mostrar personas",
  "DisplayWorkplaceTexts.people.help": "Mostrar o no las personas asignadas a la estación de trabajo en el plan",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.label": "Dirección",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.help": "Mostrar o no las direcciones de las estaciones de trabajo en el plano",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.label": "Servicio",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.help": "Mostrar o no los servicios de las estaciones de trabajo en el plan",
  "DisplayPersonTexts.personPicture.label": "Foto de personas",
  "DisplayPersonTexts.personPicture.help": "Mostrar o no la foto de las personas asignadas a los puestos de trabajo del plan",
  "DisplayPersonTexts.personName.label": "Nombre de las personas",
  "DisplayPersonTexts.personName.help": "Mostrar o no el nombre de las personas asignadas a los puestos de trabajo del plan",
  "DisplayPersonTexts.personSecurityProfile.label": "Perfil de seguridad",
  "DisplayPersonTexts.personSecurityProfile.help": "Mostrar o no el perfil de seguridad de las personas asignadas a los puestos de trabajo del plan",
  "DisplayPersonTexts.personOrganizationLevel0.label": "Dirección",
  "DisplayPersonTexts.personOrganizationLevel0.help": "Mostrar o no la dirección de las personas asignadas a las estaciones de trabajo en el plan",
  "DisplayPersonTexts.personOrganizationLevel1.label": "Servicio",
  "DisplayPersonTexts.personOrganizationLevel1.help": "Mostrar o no el servicio de las personas asignadas a los puestos de trabajo del plan",
  "DisplayPersonTexts.personOrganizationHierarchy.label": "jerarquía de la organización",
  "DisplayPersonTexts.personOrganizationHierarchy.help": "Mostrar o no el departamento y la dirección de las personas asignadas a las estaciones de trabajo en el plan",
  "DisplayPersonTexts.personCostCenter.label": "Centro de costos",
  "DisplayPersonTexts.personCostCenter.help": "Visualizar o no el centro de coste de las personas asignadas a los puestos de trabajo del plan",
  "DisplayPersonTexts.personCode.label": "Número de registro",
  "DisplayPersonTexts.personCode.help": "Mostrar o no el número de personas asignadas a las estaciones de trabajo en el plan",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.enable": "Gestionar textos de visualización de la estación de trabajo",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.disable": "Cerrar pantalla de gestión de texto",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.enable": "Le permite configurar los textos que se mostrarán en el mapa para cada estación de trabajo",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.disable": "Regrese al modo normal de edición del plan.",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.enable": "Activar la transparencia de los colores de fondo de los espacios",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.disable": "Desactivar la transparencia de color",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.enable": "Habilitar la transparencia del color permite que el fondo se vea a través de los espacios",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.disable": "Desactivar la transparencia de color restablece los colores de los espacios",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.description": "La transparencia de los colores de los espacios permite ver el fondo del plano",
  "WorkCanvas.Options.MapScaleOption.label.enable": "Administrar escala",
  "WorkCanvas.Options.MapScaleOption.label.disable": "Gestión cercana de escala",
  "WorkCanvas.Options.MapScaleOption.help.enable": "Obligatorio configurar la escala en tu plano para tener los espacios y objetos en la escala correcta",
  "WorkCanvas.Options.MapScaleOption.help.disable": "Regrese al modo normal de edición del plan.",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.label": "Eliminar escala",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.help": "Eliminar la escala equivale a quitar la escala del plano y eliminarla de la base, ya no será accesible a través de otros planos. No es posible eliminar una escala que esté en varios pisos.",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.label": "Escala de desagrupación",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.help": "Desvincular la escala de este plano la elimina del plano, pero mantiene la escala en la base de datos para uso futuro",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.label": "Acercar la escala",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.help": "El zoom hace que sea fácil encontrar la escala en el mapa.",
  "WorkCanvas.Options.DrawMapScaleOption.help": "Debe configurar la báscula en su plan, haga clic en el inicio y el final de la báscula en el plan para calibrarla",
  "ToggleCopilotEnable.label.false": "Activar Surfy Copiloto",
  "ToggleCopilotEnable.label.true": "Desactivar Surfy Copilot",
  "ToggleCopilotEnable.help.false": "Activa Surfy Copilot para habilitar el reconocimiento automático de puertas",
  "ToggleCopilotEnable.help.true": "Desactiva Surfy Copilot y vuelve al modelado manual",
  "WorkCanvas.Options.CopilotOption.label.enable": "Copiloto surfy",
  "WorkCanvas.Options.CopilotOption.label.disable": "Cerrar opciones de Surfy Copilot ",
  "WorkCanvas.Options.CopilotOption.help.enable": "Activar y ajustar las opciones de Surfy Copilot",
  "WorkCanvas.Options.CopilotOption.help.disable": "Regrese al modo normal del plan.",
  "WorkCanvas.Options.AddRoomShapeOption.label.enable": "Añadir un espacio",
  "WorkCanvas.Options.AddRoomShapeOption.label.disable": "Deshacer la adición de un espacio",
  "WorkCanvas.Options.AddRoomShapeOption.help.enable": "Añadir un espacio en el plano",
  "WorkCanvas.Options.AddRoomShapeOption.help.disable": "Deshacer la creación de espacio",
  "WorkCanvas.Options.AddRoomShapeOption.description": "Los ángulos de creación están bloqueados a 45°, para desbloquearlos mantenga presionada la tecla <b>SHIFT</b> del teclado y continúe con la creación, para crear su vértice coloque el mouse en el círculo en la intersección del triángulo, para iniciar un espacio reutilizando un vértice existente , mantenga presionada la tecla <b>ALT</b> del teclado y haga clic en el vértice.",
  "WorkCanvas.Options.AddRoomShapeSaveOption.label": "Guarde el espacio que se está modelando actualmente.",
  "WorkCanvas.Options.AddRoomShapeSaveOption.help": "Guardar espacio cerrará automáticamente el espacio y lo guardará, permitiéndole agregarle objetos o estaciones de trabajo.",
  "WorkCanvas.Options.ViewLegendOption.label.enable": "Vista previa de la leyenda",
  "WorkCanvas.Options.ViewLegendOption.label.disable": "Cierra el título de la imagen para guardar del plan.",
  "WorkCanvas.Options.ViewLegendOption.help.enable": "Vea para qué sirve la sección de leyenda del mapa",
  "WorkCanvas.Options.ViewLegendOption.help.disable": "Regrese al modo normal del plan.",
  "DownloadImageQualitySlider.label": "Calidad de la imagen exportada",
  "DownloadImagePdfButton.label": "Descarga el plano sin leyenda (PDF)",
  "DownloadImagePdfButton.help": "Descarga el plano en PDF sin leyenda, esta funcionalidad está en beta",
  "WorkCanvas.Options.DownloadImageOption.label.enable": "Guardar como imagen",
  "WorkCanvas.Options.DownloadImageOption.label.disable": "Cierra las opciones para guardar la imagen del plano.",
  "WorkCanvas.Options.DownloadImageOption.help.enable": "Guarde el plan como una imagen a través de esta opción",
  "WorkCanvas.Options.DownloadImageOption.help.disable": "Regrese al modo normal del plan.",
  "DownloadImageDrawer.ViewImage.text": "Descarga el plano con leyenda (PNG)",
  "DownloadImageDrawer.ViewImage.help": "Descargue el plan completo en buena calidad con la leyenda, la exportación puede demorar más.",
  "DownloadImageDrawer.ViewImageNoLegend.text": "Descarga el plano sin leyenda (PNG)",
  "DownloadImageDrawer.ViewImageNoLegend.help": "Descargue el plan completo en buena calidad sin el título, la exportación puede demorar más.",
  "DownloadImageDrawer.ScreenshotNoLegend.text": "Captura de pantalla sin título",
  "DownloadImageDrawer.ScreenshotNoLegend.help": "Descargue la imagen de lo que ve en la pantalla sin título, la salida será rápida pero la calidad de la exportación no será óptima",
  "DownloadBuildingImagesAccordion.accordion.title": "Exportar imágenes de todo el edificio",
  "DownloadBuildingImagesAccordion.buttons.download.help": "Descarga todos los planos de todas las plantas del edificio en formato png en un zip, el tiempo de espera para esta extracción puede ser largo",
  "DownloadBuildingImagesAccordion.buttons.download.label": "Descargar ZIP",
  "DisplayTexts.dragOption": "Puede ordenar y elegir la visualización de propiedades en el mapa moviendo las barras pequeñas en el campo hacia arriba o hacia abajo",
  "DisplayRoomTextsPeople.roomPeopleFullName.label": "Nombre completo de las personas",
  "DisplayRoomTextsPeople.roomPeopleFullName.help": "Mostrar o no el nombre completo de la persona en el mapa",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.label": "Perfil de seguridad",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.help": "Mostrar o no el perfil de seguridad de las personas asignadas a los espacios del plano",
  "NumberOfPeoplePerRowField.label": "Número de personas por línea para asignaciones de espacio",
  "WorkCanvas.Options.BackgroundLayoutOption.label.enable": "Administrar el mapa de fondo",
  "WorkCanvas.Options.BackgroundLayoutOption.label.disable": "Cerrar gestión de imagen de fondo",
  "WorkCanvas.Options.BackgroundLayoutOption.help.enable": "Se usa para administrar el mapa de fondo",
  "WorkCanvas.Options.BackgroundLayoutOption.help.disable": "Regrese al modo normal de edición del plan.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.label": "Eliminar escala",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.help": "Eliminar la escala equivale a quitar la escala del plano y eliminarla de la base, ya no será accesible a través de otros planos. No es posible eliminar una escala que esté en varios pisos.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.label": "Escala de desagrupación",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.help": "Desagrupar la escala de este plan la elimina del plan, pero mantiene la escala en la base de datos para uso futuro",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.label": "Acercar la escala",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.help": "El zoom hace que sea fácil encontrar la escala en el mapa.",
  "WorkplaceCanvasItem.workplace.free": "La estación de trabajo no está ocupada.",
  "WorkplaceCanvasItem.workplace.isFlex": "La estación de trabajo está en flex",
  "WorkplaceCanvasItem.workplace.isTransit": "La estación de trabajo está pasando",
  "WorkplaceCanvasItem.workplace.isBookable": "La estación de trabajo se puede reservar.",
  "WrongRoomsTable.table.headers.objectType": "Naturaleza",
  "WrongRoomsTable.table.headers.type": "Tipo",
  "WrongRoomsTable.table.headers.identity": "Identidad",
  "WrongRoomsTable.table.headers.currentRoom": "espacio actual",
  "WrongRoomsTable.table.headers.newRoom": "nuevo espacio",
  "WrongRoomsTable.SelectAll.checked.true": "Deselecciona todo",
  "WrongRoomsTable.SelectAll.checked.false": "Seleccionar todo",
  "WrongRoomsTable.SelectAll.help": "Seleccionar o anular la selección de todas las líneas",
  "WrongRoomsListner.dialog.title": "Validar la elección de espacios",
  "WrongRoomsListner.dialog.description": "Hay formas que no están en su espacio inicial",
  "WrongRoomsListner.close.label": "cerca",
  "WrongRoomsListner.close.help": "cierra esta ventana",
  "MoveShapestoNewRoomAsyncButton.label": "Aplicar cambio de espacio",
  "MoveShapestoNewRoomAsyncButton.help": "Cambie los espacios de las formas seleccionadas para colocarlas en los espacios en los que se encuentran en el plano",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.enable": "Mover tipo de objeto",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.disable": "Dejar de mover el tipo de objeto",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.enable": "Mover un tipo de objeto en el avión",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.disable": "Dejar de mover el tipo de objeto",
  "ResetRotationAngle.resetRotationAngle": "Restablecer a 0° el ángulo de rotación que actualmente es %{initialRotation}",
  "TenantOperations.sephora-sync-sap-success-factors.label": "sincronización MSC",
  "TenantOperations.st-grenoble-import-hr-file.label": "Importando el archivo HR",
  "TenantOperations.egis-import-hr-file.label": "Importar archivo HR",
  "TenantOperations.essilor-import-hr-file.label": "Importar archivo HR",
  "TenantOperations.agpm-import-hr-file.label": "Importando el archivo HR (STILOG)",
  "ConnectedPartnerContext.title": "Está conectado a <b>%{label}</b> ( %{host} )",
  "Operations.talentsoft-import.label": "Importación de Talentsoft",
  "Operations.zbre-sync.label": "Sincronización Z#ber",
  "Operations.exportZbre.label": "Exportar Z # bre",
  "GenericNoChangeTable.open.label": "Ver datos",
  "GenericNoChangeTable.open.help": "Ver el detalle de los datos idénticos",
  "Operations.sharingcloud-sync.label": "Sincronización de nube compartida",
  "Operations.moffi-sync.label": "Sincronización Moffi",
  "Operations.lucca-sync.label": "Sincronización de Lucca",
  "CompareObjectTypeUpdateIcon.help": "Esta sincronización actualizará las entidades.",
  "CompareObjectTypeDeleteIcon.help": "Esta sincronización realizará una eliminación de entidades que no provienen de la fuente",
  "CompareObjectTypeCreateIcon.help": "Esta sincronización creará entidades que no existen en el destino.",
  "RoomTooltip.roomWorkplaceAffectations": "Asignaciones de estaciones de trabajo",
  "RoomSegmentRoomsList.title": "Los espacios adjuntos a este segmento.",
  "MeetingRoomCard.seats.1": "%{count} asiento",
  "MeetingRoomCard.seats.n": "%{count} asientos",
  "MeetingRoomCard.locateSpace": "Localiza el espacio en el plano.",
  "MeetingRoomCard.viewPicture": "Ver foto del espacio",
  "days.monday": "Lunes",
  "days.tuesday": "Martes",
  "days.wednesday": "Miércoles",
  "days.thursday": "JUEVES",
  "days.friday": "Viernes",
  "days.saturday": "SÁBADO",
  "days.sunday": "Domingo",
  "WorkplaceAffectationDailyTitle.all": "Esta persona se ve afectada todos los días.",
  "WorkplaceAffectationDailyTitle.person.affected": "A esta persona se le asigna %{daysText}",
  "WorkplaceAffectationDailyTitle.person.notAffected": "Esta persona no se ve afectada",
  "WorkplaceAffectationDailyTitle.calculatedRate": "La tasa de asignación promedio es %{calculatedRate}",
  "WorkplaceNestedList.title": "Personas asignadas a estaciones de trabajo",
  "WorkplaceList.workplace.free": "Esta estación de trabajo es gratuita",
  "WorkplaceList.workplace.flex": "Esta estación de trabajo está en flex",
  "WorkplaceList.workplace.transit": "Esta estación de trabajo es compartida.",
  "WorkplaceList.zoomOnWorkplace": "Zoom a la estación de trabajo en el plan",
  "WorkplaceAffectionPersonListItem.remove.help": "Eliminar la asignación de la persona a la estación de trabajo",
  "WorkplaceAffectations.edit.help": "Asignar una persona a esta estación de trabajo",
  "WorkplaceAffectationDays.all": "Esta persona se ve afectada todos los días.",
  "WorkplaceAffectationDays.and": "%{days} y %{lastDay}",
  "WorkplaceAffectationDays.one": "el %{day}",
  "WorkplaceAffectationDays.person.affected": "A esta persona se le asigna %{daysText}",
  "WorkplaceAffectationDays.person.notAffected": "Esta persona no se ve afectada",
  "RoomWorkplaceList.EmptyList": "No hay estaciones de trabajo en este espacio.",
  "RoomCard.buttons.edit.false": "Editar propiedades del espacio",
  "RoomCard.buttons.edit.true": "Deja de editar",
  "RoomCard.tabs.people": "asignaciones",
  "RoomCard.tabs.inventory": "inventario",
  "RoomCard.tabs.room": "Espacio",
  "RoomAffectationsOnlyList.title": "Personas asignadas a espacios",
  "RoomAffectationsList.title": "Personas asignadas a espacios",
  "RoomAffectationsList.EmptyList": "No hay nadie asignado a este espacio.",
  "ItemsInventory.EmptyList": "No hay objetos en este espacio.",
  "MovePersonFromWorkplaceToRoomListButtonItem.label": "Mover a esta persona desde su estación de trabajo al espacio de la estación de trabajo",
  "MovePersonFromWorkplaceToRoomListButtonItem.help": "Esta opción requiere refrescar la página para ver el resultado, es posible encadenar varios movimientos sin refrescar",
  "CollapseWorkplaceAffectationList.title": "Asignar a esta persona solo para los días siguientes",
  "CollapseWorkplaceAffectationList.updateAffectationDay.true": "Afecta a esta persona %{day}",
  "CollapseWorkplaceAffectationList.updateAffectationDay.false": "Quitar la tarea de esta persona %{day}",
  "CancelAddWorkplaceToRoom.help": "Cancelar la adición de la estación de trabajo",
  "CancelAddItemToRoom.help": "Cancelar la adición del objeto",
  "AddPersonToRoom.help": "Asignar una persona al espacio %{name}",
  "SecurityComplianceModeSwitch.label": "Filtrar personas con perfiles de seguridad",
  "SecurityComplianceModeSwitch.description": "Ver solo personas con perfiles de seguridad en el mapa",
  "layoutViewSets.roomType.label": "Tipologías de espacios",
  "layoutViewSets.roomType.description": "Ver la planta según la tipología de espacios",
  "layoutViewSets.costCenter.label": "Refacturación",
  "layoutViewSets.costCenter.description": "Analiza las claves de la distribución económica de los espacios",
  "layoutViewSets.workplaces.label": "Ocupaciones",
  "layoutViewSets.workplaces.description": "Centrarse en ocupar puestos de trabajo",
  "layoutViewSets.organizationLevel0.label": "Direcciones",
  "layoutViewSets.organizationLevel0.description": "Ocupación por dirección",
  "layoutViewSets.flex.label": "Flexionar",
  "layoutViewSets.flex.description": "El uso flexible de espacios",
  "layoutViewSets.walls.label": "Particiones",
  "layoutViewSets.walls.description": "Centrarse en espacios y particiones.",
  "layoutViewSets.securityCompliance.label": "Cumplimiento de seguridad",
  "layoutViewSets.securityCompliance.description": "Analiza el cumplimiento de tu plan de prevención de seguridad y los perfiles de seguridad de las personas afectadas",
  "layoutViewSets.peopleDimensionTypes.label": "Barrios",
  "layoutViewSets.peopleDimensionTypes.description": "Analice capas de asignación y navegue por vecindario o zona",
  "LayoutViewSwitch.title": "Cambiando la visión del plan",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.viewSet": "Visión",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.help": "Puede cambiar la visión a través de los menús del plan.",
  "SurfyLegendBottomLogo.text": "Plano generado por Surfy",
  "SurfyLegendBottomLogo.caption": "https://www.surfy.pro",
  "MapLegendWorkplace.title": "Puesto de trabajo",
  "MapLegendWorkplace.workplaces.free": "Las estaciones de trabajo son gratuitas",
  "MapLegendWorkplace.workplaces.flex": "Las estaciones de trabajo están en flex",
  "MapLegendRoom.title": "Espacios",
  "MapLegendPersonSecurityProfile.title": "Perfiles de seguridad",
  "MapLegendFloor.title.building": "Edificio",
  "MapLegendFloor.title.floor": "piso",
  "MapLegend.workplaces": "Estaciones de trabajo",
  "MapLegend.rooms": "Espacios",
  "PersonSecurityProfileTabContent.tabs.merged": "Por perfiles de seguridad",
  "PersonSecurityProfileTabContent.tabs.split": "por asignaciones",
  "DimensionInfo.infos.building": "Información de construcción calculada",
  "DimensionInfo.infos.impactBuildings": "Recargar datos de construcción calculados",
  "DimensionToPeopleList.title": "Personas asignadas a %{name}",
  "DimensionToPeopleList.noDimensionPerson": "No hay nadie asignado directamente a esta capa de análisis",
  "DimensionPeople.title": "Personas asignadas a espacios",
  "AddPersonToDimension.help": "Asignar persona a %{name}",
  "CubyWallModeSelect.label": "Pantalla de partición",
  "CubyWallModeSelect.options.no": "Ninguno",
  "CubyWallModeSelect.options.half": "Medias particiones",
  "CubyWallModeSelect.options.reality": "Realidad",
  "CubyWallModeSelect.options.cuby": "Cuby",
  "CubySaveAsImageButton.label": "Salvar el imagen",
  "CubySaveAsImageButton.help": "Guardar imagen del plano de planta",
  "CubyFitToViewIsometricButtonOption.label": "Centrar el plano en vista isométrica",
  "CubyFitToViewIsometricButtonOption.help": "Centrar plano en espacios en vista isométrica",
  "CubyFitToViewZenithalButtonOption.label": "Centre el plano en vista cenital",
  "CubyFitToViewZenithalButtonOption.help": "Centrar el plano en los espacios en vista cenital",
  "RefetchFloorLayoutButton.refetch": "Recargar datos del plan",
  "ItemTypesMapFilterZone.tabs.options": "opciones",
  "FloorMap.tabs.layout": "Cambiar la visión del plan. La vista actual es <b>%{layoutName}</b>",
  "FloorMap.tabs.floor": "Ver información del piso",
  "FloorMap.tabs.building": "Ver información del edificio",
  "FloorMap.tabs.roomTypes": "Colorea los espacios del plano según las <b>tipologías de espacios.</b>",
  "FloorMap.tabs.roomTypeGroups": "Ver los indicadores de espacio en plano según los <b>grupos de tipologías de espacio</b>",
  "FloorMap.tabs.analyticsDimensionTypes": "Colorea los espacios del plano según las <b>capas de análisis.</b>",
  "FloorMap.tabs.itemTypes": "Mostrar en el mapa los <b> objetos </b> por familia y tipo de objetos",
  "FloorMap.tabs.workplaceTypes": "Mostrar en el mapa las <b> estaciones de trabajo </b> por tipo de estación de trabajo",
  "FloorMap.tabs.organizations": "Colorea los espacios del plano según las <b>organizaciones</b> .",
  "FloorMap.tabs.costCenters": "Espacios de color y estaciones de trabajo en relación con <b>los centros de costos.</b>",
  "FloorMap.tabs.users": "Estaciones de trabajo en color versus personas",
  "FloorMap.tabs.selection": "Ver los detalles de los elementos seleccionados en el plan.",
  "FloorMap.tabs.rooms": "Detalles de <b>espacios</b> seleccionados",
  "FloorMap.tabs.items": "Detalles de los <b> objetos </b> seleccionados",
  "FloorMap.tabs.workplaces": "Detalles de las <b> estaciones de trabajo </b> seleccionadas",
  "FloorMap.tabs.all": "Ver todas las formas seleccionadas en la lista",
  "FloorMap.tabs.peopleDimensionTypes": "Colorea los espacios en el plano según <b>las capas de asignación</b>",
  "FloorMap.tabs.workplaceUsage": "Colorea las estaciones de trabajo según su <b>estado</b>",
  "FloorMap.tabs.options": "Ver opciones de planes",
  "FloorMap.tabs.heatmap": "Colorear con mapas de calor",
  "FloorMap.tabs.pathFinding": "Encontrar tu camino en los espacios",
  "DateDimensionSelect.options.day": "Día",
  "DateDimensionSelect.options.week": "Semana",
  "DateDimensionSelect.options.month": "Mes",
  "DateDimensionSelect.options.year": "Año",
  "DateDimensionSelect.options.quarter": "Cuarto",
  "JupDateRangePicker.chooseRange": "Elige un período",
  "WorkpaceBookingPeopleCountByDate.title": "Número de personas reservadas por fecha",
  "WorkpaceBookingPeopleCountByDate.labels.line": "numero de personas",
  "WorkpaceBookingCountByDate.title": "Reservas de estaciones de trabajo por fecha",
  "WorkpaceBookingCountByDate.labels.line": "Número de reservas",
  "WorkpaceBookingAverageByWeekDay.title": "Reserva de puestos de trabajo por día de la semana",
  "WorkpaceBookingAverageByWeekDay.labels.line": "Promedio por semana",
  "WorkpaceBookingAverageByWeekDay.labels.bar": "Número de reservas",
  "PersonPanelWorkplaceAffectations.title": "Asignaciones de estaciones de trabajo",
  "PersonPanelRoomAffectations.title": "Asignaciones a espacios",
  "PersonPanelDimensionToPeople.title": "Asignaciones a %{dimensionTypeName}",
  "PersonPanelBuildingAffectations.title": "Asignaciones a edificios",
  "PersonPanelBuildingAffectations.addToPeopleCount.false": "Esta persona no es contable en el edificio.",
  "PersonAffectationsPanel.title": "asignaciones",
  "PersonAffectationsPanel.description": "Las tareas de la persona",
  "PersonSecurityPanel.title": "seguridad",
  "PersonSecurityPanel.description": "Información de seguridad y evacuación",
  "PersonRelationsPanel.title": "Relaciones",
  "PersonRelationsPanel.description": "Las relaciones de esta persona",
  "PersonInventoryPanel.title": "inventario",
  "PersonInventoryPanel.description": "Información de inventario",
  "PersonInventoryPanel.items.subheader": "Lista de objetos asociados",
  "PersonInfoPanel.title": "Información personal",
  "PersonContractPanel.title": "Contrato",
  "PersonContractPanel.description": "Información del contrato",
  "PersonContactPanel.title": "Contactar",
  "PersonContactPanel.description": "¿Cómo me comunico con esta persona?",
  "PersonBadgePanel.title": "Diverso",
  "PersonBadgePanel.description": "Información diversa sobre la persona.",
  "AvatarPersonDrawer.help": "Ver más información sobre %{name}",
  "TopLevelOrganizationFilter.Empty": "No hay ninguna organización asociada a los espacios, puedes agregar más modificando un espacio y asociándolo a una organización, luego puedes controlar su visualización desde esta sección",
  "OrganizationTabsFilter.tabs.topLevel": "Direcciones",
  "OrganizationTabsFilter.tabs.hierarchy": "Jerarquía",
  "OrganizationTabsFilter.tabs.level1": "Servicios",
  "OrganizationFloorMapFilter.TooltipTitle.notSelected": "Seleccione %{organization} para colorear los espacios en el plano.",
  "OrganizationFloorMapFilter.TooltipTitle.selected": "Si anula la selección de %{organization} se eliminarán los colores del plan.",
  "OrganizationFloorMapFilter.tooltip.true": "Seleccione todos los tipos de objetos a continuación para colorearlos en el mapa",
  "OrganizationFloorMapFilter.tooltip.false": "Anule la selección de todas las organizaciones a continuación",
  "Level1OrganizationFilter.Empty": "No hay ninguna organización asociada a los espacios, puedes agregar más modificando un espacio y asociándolo a una organización, luego puedes controlar su visualización desde esta sección",
  "HierarchyOrganizationFilter.Empty": "No hay ninguna organización asociada a los espacios, puedes agregar más modificando un espacio y asociándolo a una organización, luego puedes controlar su visualización desde esta sección",
  "CompanyDashboard.dashboards.workplace": "Panel de escritorio",
  "CompanyDashboard.dashboards.area": "Panel de superficies",
  "ChangeCompanyMenu.ChangeCompany": "Ver otra empresa en una página nueva",
  "WorkplaceTypeDataQualityNotUsed.columns.name": "Nombre del tipo de estación de trabajo",
  "WorkplaceTypeDataQualityNotUsed.columns.shape": "Formulario",
  "workplaceTypeLayoutFilter.Empty": "No hay estaciones de trabajo en este momento en los espacios, puedes agregar más modificando un espacio y agregando estaciones de trabajo, luego puedes controlar su visualización desde esta sección",
  "WorkplaceTypeInfo.help": "El número de estaciones de trabajo es %{count}",
  "CopyWorkplaceTypeToCart.help": "Copiar tipos de estaciones de trabajo al carrito",
  "WorkCanvas.Options.ZoomOnWorkplaceType.label": "Amplíe el tipo de estación de trabajo",
  "WorkCanvas.Options.ZoomOnWorkplaceType.help": "Acercar el tipo de estación de trabajo le permite ubicarlo en el área de trabajo",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.enable": "Enumere los tipos de objetos",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.disable": "Cerrar la lista de tipos de objetos",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.enable": "Consulte la lista de tipos de objetos para este tipo de estación de trabajo.",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.disable": "Cerrar la lista de tipos de objetos para este tipo de estación de trabajo",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.open": "Opciones de despliegue",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.close": "Opciones de plegado",
  "WorkplaceTypeItemTypesDrawer.title": "Lista de tipos de objetos",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.help": "Agregue un tipo de objeto para poder componer el tipo de estación de trabajo",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.label": "Agregar un tipo de objeto",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.help": "Cancelar la adición de un tipo de objeto en esta estación de trabajo",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.label": "Cancelar la adición de un tipo de objeto",
  "WorkCanvas.Options.DeleteStructureShapeOption.help": "Eliminar por completo la forma de la estructura de poder, por ejemplo, volver a dibujarla por completo",
  "WorkCanvas.Options.DeleteStructureShapeOption.label": "Eliminar forma",
  "WorkCanvas.Options.AddStructurePointOption.label.enable": "Agregar una cumbre",
  "WorkCanvas.Options.AddStructurePointOption.label.disable": "Deja de agregar un vértice",
  "WorkCanvas.Options.AddStructurePointOption.help.enable": "Agregar un vértice permite volver a trabajar con mayor precisión un formulario",
  "WorkCanvas.Options.AddStructurePointOption.help.disable": "Deja de crear cumbres",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloorButton.label": "Reserve una estación de trabajo en %{floorName}",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloor": "Reserve una estación de trabajo en %{floorName} para el período %{slotString}",
  "BookPersonBuildingWorkplace.availableWorkplaces": "%{freeWorkplaces} plazas disponibles",
  "BookPersonBuildingWorkplace.help": "%{bookedWorkplaces} reserva(s), %{freeWorkplaces} estaciones de trabajo disponibles en %{totalFloorWorkplacesCount}",
  "booking.snackbar.delete.workplace": "La reserva en la estación de trabajo %{workplaceName} ha sido cancelada para el período %{slot}",
  "booking.snackbar.delete.room": "La reserva en el espacio %{roomName} ha sido cancelada para el período %{slot}",
  "BookingWorkplaceTitle.booked": "Esta estación de trabajo ya está reservada",
  "BookingWorkplaceTitle.userBooked": "Has reservado esta estación de trabajo",
  "BookingWorkplaceTitle.free": "Reserva esta estación de trabajo",
  "PlanningPersonAffectations.alerts.noAffectation.title": "No se puede reservar una estación de trabajo",
  "PlanningPersonAffectations.alerts.noAffectation.message": "No estás asociado a ningún territorio, por favor contacta a tu responsable de asignación para poder reservar un espacio de trabajo.",
  "WorkingLocationToggle.locations.OFFICE": "Escritorio",
  "WorkingLocationToggle.locations.REMOTE": "Teletrabajo",
  "PersonBookingListItem.workplaceBookedOnFloor": "Vea la estación de trabajo %{workplaceName} en el plano de planta %{floorName}",
  "PersonBookingList.noBooking": "Ningún colega estará presente en la oficina en el mismo horario por el momento.",
  "PersonBookingList.bookings.one": "Un colega estará presente en el mismo espacio.",
  "PersonBookingList.bookings.more": "%{count} colegas estarán presentes en el mismo espacio",
  "ParkingBookIcon.parking.booked": "Tu parking está reservado",
  "ParkingBookIcon.parking.release.help": "Liberar reserva de estacionamiento",
  "ParkingBookIcon.parking.viewOnMap": "Ver parking reservado en el mapa",
  "ParkingBookIcon.parking.book.label": "Reserva de aparcamiento",
  "ParkingBookIcon.parking.book.help": "Reserve un estacionamiento que se asignará automáticamente al espacio",
  "HalfDayWorkingLocationToggle.am.label": "Mañana",
  "HalfDayWorkingLocationToggle.am.help": "El horario de mañana es de 8:00 a 13:30 horas.",
  "HalfDayWorkingLocationToggle.pm.label": "Tarde",
  "HalfDayWorkingLocationToggle.pm.help": "El horario de tarde es de 14:00 a 19:00 horas.",
  "DirectBuildingPlanningLabel.youAreAssigned": "Estás asignado al edificio %{buildingName}",
  "DimensionBuildingPlanningLabel.youAreAssigned": "Estás asignado a %{dimensionTypeName} %{dimensionName}",
  "BookedBuildingWorkplaceList.noWorkplaceBooked": "Sin estación de trabajo reservada",
  "BookedBuildingWorkplaceList.workplaceIsBooked": "Tu puesto de trabajo está reservado",
  "BookedBuildingWorkplaceList.viewBookedWorkplaceOnMap": "Ver la estación de trabajo %{workplaceName} que está reservada en el plan",
  "BookedBuildingWorkplaceList.freeWorkplaceBooking": "Liberar esta reserva",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.noFloor": "El tamaño no está en ningún piso. Es imposible reservarlo en este momento según el plano.",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.moreThanOneFloor": "El tamaño está en varios pisos imposible de reservar en este momento desde el plan.",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.drawer.title": "Reserve una estación de trabajo específica para el período %{slotString}",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.help": "Reserve una estación de trabajo específica en el plan para este espacio",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.label": "Reserve una estación de trabajo en %{dimensionName}",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.peopleCount": "Hay %{count} persona(s) con el perfil de seguridad %{name} asignado a las estaciones de trabajo",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.workplaceCount": "Hay %{count} estaciones de trabajo con al menos una persona con perfil de seguridad %{name}",
  "PersonSecurityProfileWorkplaceFilter.Empty": "Tus personas no tienen perfil de seguridad o no están asignadas a estaciones de trabajo, no es posible colorear las estaciones de trabajo de acuerdo a los perfiles de seguridad de las personas",
  "PersonSecurityProfileWorkplaceFilter.title": "Los perfiles de seguridad de las personas asignadas a los puestos de trabajo",
  "PersonSecurityProfileMerged.title": "Lista de perfiles de seguridad agrupados por tipo de perfil",
  "PersonSecurityProfileMerged.empty": "Ningún perfil está asociado a espacios o puestos de trabajo",
  "PersonSecurityProfileInRooms.title": "Los perfiles de seguridad de las personas asignadas a los espacios",
  "PersonSecurityProfileInRoomListItem.peopleCount": "Hay %{count} persona(s) con el perfil de seguridad %{name} asignado a los espacios",
  "PersonSecurityProfileInRoomListItem.roomsCount": "Hay %{count} espacio(s) con al menos una persona con perfil de seguridad %{name}",
  "ToggleAllOpenInfoState.true": "Cerrar todos los detalles e indicadores",
  "ToggleAllOpenInfoState.false": "Abrir todos los detalles e indicadores",
  "MapFiltersNodesToggleAll.help.true": "Seleccionar todo",
  "MapFiltersNodesToggleAll.help.false": "Deseleccionar todo",
  "MapFiltersNode.info.open": "Ver detalle e indicadores para %{label}",
  "MapFiltersNode.info.close": "Cerrar información adicional",
  "MapFiltersCategory.CategoryHasChildrenSelected": "Se seleccionan elementos",
  "MapFilterNodeToggleAll.action.true": "Seleccionar todo",
  "MapFilterNodeToggleAll.action.false": "Deseleccionar todo",
  "MapFilterNodeIsAllSelected.help": "Se cargará toda la selección a continuación, incluso si se crean nuevos objetos",
  "JupRoleToObjectTypeMatrix.views.help.true": "Ocultar vista de interfaz",
  "JupRoleToObjectTypeMatrix.views.help.false": "Mostrar vista de interfaz",
  "JupRoleToObjectTypeMatrix.objectTypes.help.checkbox": "Actualizar propiedad ( %{name} )",
  "GlobalOptions.CartCopyItemTypeOption.help": "Copiar tipos de artículos al carrito",
  "GlobalOptions.CartCopyWorkplaceTypeOption.help": "Copiar tipos de estaciones de trabajo al carrito",
  "GlobalOptions.CartCopyBuildingOption.help": "Copiar edificios al carrito",
  "CheckAllDefaultViews.shortcuts.title": "Atajos de configuración",
  "CheckAllDefaultViews.shortcuts.views.title": "Accesos directos para vistas de interfaz predeterminadas",
  "CheckAllDefaultViews.shortcuts.views.buttonsHelp": "Consulte esta vista para todo tipo de entidades",
  "CheckAllDefaultViews.shortcuts.objectTypes.title": "Accesos directos para tipos de entidad",
  "CheckAllDefaultViews.shortcuts.objectTypes.buttonsHelp": "Verifique esta regla para todo tipo de objetos",
  "RemoveItemColorsOption.label": "No colorear objetos",
  "RemoveItemColorsOption.help": "Colorea los objetos de blanco para que puedas enfocarte en otros elementos en el mapa",
  "ItemTypeOptions.help": "El número de objetos es %{count}",
  "ItemTypeMapFilter.TooltipTitle.notSelected": "Seleccione %{itemType} para ver los objetos en el mapa",
  "ItemTypeMapFilter.TooltipTitle.selected": "Al anular la selección %{itemType} se eliminará el color asociado del plan",
  "ItemTypeMapFilter.tooltip.true": "Seleccione todos los tipos de objetos a continuación para mostrarlos en el mapa",
  "ItemTypeMapFilter.tooltip.false": "Anule la selección de todos los tipos de objetos a continuación",
  "ItemTypeMapFilter.NoNode": "No hay objetos en este momento en los espacios, puedes agregar más modificando un espacio y agregando objetos al mismo, luego puedes controlar su visualización desde esta sección",
  "ItemTypeMapFilter.NoCategory": "No hay objetos en este momento en los espacios, puedes agregar más modificando un espacio y agregando objetos al mismo, luego puedes controlar su visualización desde esta sección",
  "ItemTypeDataQualityNotUsed.columns.name": "Nombre del tipo de objeto",
  "ItemTypeDataQualityNotUsed.columns.shape": "Formulario",
  "ItemTypeDataQualityNotUsed.columns.workplaceTypeCount": "Número de tipo de estación de trabajo",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.help": "Elija un plano de referencia para crear la forma con el fin de poder dibujar su tipo de objeto ubicándose en un plano y teniendo la escala correcta",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.label": "Elija un plano de referencia para crear la forma",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.help": "Elija un plano de referencia para componer el tipo de estación de trabajo con tipos de objetos existentes ubicándose en un plano y tener la escala adecuada y posicionar correctamente los tipos de objetos",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.label": "Elija un plano de referencia para componer la forma del tipo de estación de trabajo",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.help": "Elija un plano de referencia para crear la forma para poder dibujar la estructura ubicándose en un plano y teniendo la escala adecuada",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.label": "Elija un plano de referencia para crear la estructura",
  "ItemTypeAvatarSingleView.copy": "Copiar puntos al portapapeles",
  "ItemTypeAvatarSingleView.debug.label": "Habilitar el modo avanzado para 3d",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.help": "Elimine completamente la forma del tipo de objeto para que pueda, por ejemplo, volver a dibujarla por completo o transformarla en un icono",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.label": "Eliminar forma",
  "CopyItemTypesToCart.help": "Copiar tipos de artículos al carrito",
  "PhysicalItemNotInsideWorkplaceRoom.alignRooms": "Cambiar espacios de objetos al de la estación de trabajo.",
  "AddPersonToItem.text": "Asociar una persona con este objeto",
  "AddPersonToItem.help": "Asocia una persona a este objeto, puedes agregar varias personas para el mismo objeto",
  "DimensionTypeDescription.NoDescription": "No hay descripción para este tipo de capa de análisis, puede agregar más modificándola",
  "dimensionTypes.room_ground_type.one": "Naturaleza del suelo",
  "dimensionTypes.room_ground_type.description": "Permite conocer la composición del suelo en el espacio.",
  "dimensionTypes.room_usage.one": "Naturaleza de los espacios",
  "dimensionTypes.room_usage.description": "Permite identificar espacios según sus usos",
  "dimensionTypes.frequency.one": "frecuencia",
  "dimensionTypes.frequency.description": "Permite conocer la frecuencia de paso en el espacio.",
  "dimensionTypes.evacuation_zone.one": "seguridad",
  "dimensionTypes.evacuation_zone.description": "Gestionar zonas de seguridad y evacuación.",
  "dimensionTypes.referent.one": "Referencial",
  "dimensionTypes.referent.description": "Le permite saber quién está asignado al mantenimiento de este espacio.",
  "DimensionTypesByTab.action.true": "Seleccionar todo",
  "DimensionTypesByTab.action.false": "Deseleccionar todo",
  "DimensionTypesByTab.ListItemHasChildrenSelected": "Se seleccionan las dimensiones",
  "DimensionListItem.notSelected": "Seleccione %{dimension} para ver los espacios en el plano con el color asociado",
  "DimensionListItem.selected": "Anule la selección de %{dimension}",
  "DimensionInfo.roomsArea.help": "El área para %{dimensionType} %{dimension} es %{value} m²",
  "DimensionInfo.roomsCount.help": "Hay %{value} espacio(s) para %{dimensionType} %{dimension}",
  "DimensionInfo.peopleCount.help": "Hay %{value} persona(s) afectada(s) para %{dimensionType} %{dimension}",
  "DimensionInfo.totalPeopleCount.help": "Hay %{value} persona(s) afectada(s) en total para %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesCount.help": "Hay %{value} estaciones de trabajo para %{dimensionType} %{dimension}",
  "DimensionInfo.peopleRatio.help": "Hay %{value} m² por persona afectada para %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesRatio.help": "Hay %{value} m² por estación de trabajo para %{dimensionType} %{dimension}",
  "DimensionInfo.occupancyRate.help": "La tasa de ocupación es %{value} % para %{dimensionType} %{dimension}",
  "DimensionInfo.expansionRatio.help": "La tasa de expansión es %{value} para %{dimensionType} %{dimension}",
  "DimensionInfo.freeWorkplacesCount.help": "Hay %{value} estaciones de trabajo %{value} para %{dimensionType} %{dimension}",
  "DimensionInfo.flexWorkplacesCount.help": "Hay %{value} estaciones de trabajo flexibles para %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesCount.help": "Hay %{value} estaciones de trabajo compartidas para %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesRatio.help": "La tarifa de escritorio compartido es %{value} para %{dimensionType} %{dimension}",
  "DimensionInfo.flexRatio.help": "La tarifa de las estaciones de trabajo flexibles",
  "DimensionInfo.transitWorkplacesCount.help": "Hay %{value} estación (es) de trabajo provisional para %{dimensionType} %{dimension}",
  "DimensionInfo.dimensionPeopleCount.help": "Hay %{value} persona(s) afectada(s) en %{dimensionType} %{dimension}",
  "DimensionInfo.seatsCount.help": "Hay %{value} asientos para %{dimensionType} %{dimension}",
  "DimensionInfo.seatsPeopleRatio.help": "La tasa de asientos es %{value} asientos disponibles por persona para %{dimensionType} %{dimension}",
  "DimensionInfo.carbonFootprint.help": "La huella de carbono es %{value} de CO2 emitido para %{dimensionType} %{dimension}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.peopleCount": "Hay %{count} personas con el centro de costos %{costCenterName}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.workplaceCount": "Hay %{count} estaciones de trabajo con al menos una persona con centro de costos %{costCenterName}",
  "PersonCostCenterWorkplaceFilter.Empty": "No existen centros de costos asociados a las personas",
  "NoDataOnBuildingInfo.noData": "Seleccione todos los pisos en las opciones del plan para tener datos, no debe haber ningún dato para los pisos que ha seleccionado",
  "CostCenterWorkplaceMapFilter.nodeInfo.workplacesCount": "Hay %{count} estaciones de trabajo con el centro de costos %{name}",
  "CostCenterMapFilterTabs.tabs.rooms": "Espacios",
  "CostCenterMapFilterTabs.tabs.workplaces": "Estaciones de trabajo",
  "CostCenterMapFilterTabs.tabs.people": "Gente",
  "CostCenterMapFilter.Empty": "Actualmente no hay centros de costos asociados a los espacios, puedes agregar más modificando un espacio y asociándole un centro de costos, luego puedes controlar su visualización desde esta sección",
  "CostCenterWorkplaceMapFilter.Empty": "Actualmente no hay un centro de costos asociado con las estaciones de trabajo, puede agregar uno modificando una estación de trabajo y asociando un centro de costos con ella, luego puede controlar su visualización desde esta sección",
  "BuildingReports.items.sheets.physicals": "Objetos fisicos",
  "BuildingReports.items.sheets.virtuals": "Objetos virtuales",
  "BuildingReports.items.sheets.merged": "Fusión",
  "BuildingInventory.floor": "piso",
  "BuildingInventory.quantity": "cantidad",
  "BuildingInventory.price": "Precio",
  "BuildingInventory.manufacturer": "Fabricante",
  "BuildingInventory.quantityTotal": "total",
  "BuildingInventory.title": "Creación de inventario %{building.name}",
  "BuildingInventory.buttons.viewPDF.help": "Descarga el archivo en PDF para que puedas descargarlo o compartirlo",
  "BuildingInventory.buttons.viewPDF.label": "Descarga la versión PDF",
  "BuildingInventory.itemTypesFamilySectionTitle": "Categorías de inventario",
  "BuildingInventory.fileNamePrefix": "inventario",
  "BuildingLabel.scenario": "Este edificio es un escenario del edificio %{name}",
  "CopyBuildingToCart.help": "Copiar estructura de edificio",
  "BuildingClonePropertiesSelector.properties.clone.workplaces": "Copiar estaciones de trabajo",
  "BuildingClonePropertiesSelector.properties.clone.items": "Copiar objetos",
  "BuildingDistributionCost.floors.excel.tabs.floors": "Distribución de llaves por piso",
  "BuildingDistributionCost.floors.excel.tabs.building": "Llaves de distribución para el edificio",
  "BuildingDistributionCost.floors.excel.tabs.buildingDetailed": "Detalles del edificio por centro de costos",
  "BuildingDistributionCost.floors.excel.download.label": "Descarga el archivo excel con los desgloses",
  "BuildingDistributionCost.floors.excel.download.help": "Descargue el archivo excel para poder compartir y exportar las claves de distribución y áreas calificadas por centro de costo y por piso, la exportación incluye la distribución por piso o por edificio de los centros de costo",
  "BuildingDistributionCost.floors.excel.headers.floors.floorName": "Nombre del piso",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterName": "Centro de coste",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterArea": "Superficie de los espacios, incluida la distribución del suelo.",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterRoomsArea": "Área de espacios del centro de costo",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterDistributedFloorRatio": "Relación de uso en el suelo",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterFloorDistributedArea": "Superficie total de los espacios a distribuir en planta para este centro de coste",
  "BuildingDistributionCost.floors.excel.headers.floors.floorArea": "Superficie total del piso, incluidas las distribuciones del piso",
  "BuildingDistributionCost.floors.excel.headers.floors.totalFloorDistributedArea": "Superficie a distribuir en el suelo",
  "BuildingDistributionCost.floors.excel.headers.floors.totalBuildingDistributedArea": "Superficie a distribuir en el edificio",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterName": "Centro de coste",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterArea": "Área total del centro de costo",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterBuildingRatio": "Ratio de uso del edificio",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterDistributedBuildingArea": "Área total de espacios de construcción distribuidos",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterRoomsArea": "Área de espacios del centro de costo",
  "BuildingDistributionCost.floors.excel.headers.building.buildingArea": "Área total de espacios de construcción",
  "BuildingDistributionCost.floors.excel.headers.building.buildingDistributedArea": "Superficie a distribuir en el edificio",
  "BuildingDistributionCost.floors.excel.headers.building.totalBuildingArea": "Área total del edificio",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.buildingName": "Edificio",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterName": "Centro de coste",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterArea": "Área del centro de costos",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterBuildingRatio": "Clave de distribución en el edificio.",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.distributedCostCenterArea": "Distribución del centro de costos %{costCenterName}",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterTotalArea": "Superficie total a refacturar",
  "BuildingDistributionCost.excel.tabs.distributionCost": "Claves de distribución",
  "BuildingDistributionCost.excel.tabs.distributionCostDetails": "Detalles",
  "BuildingDistributionCost.excel.download.label": "Descarga el archivo excel sin desgloses",
  "BuildingDistributionCost.excel.download.help": "Descarga el archivo excel para poder compartir y exportar las claves de distribución y áreas calificadas por centro de costo",
  "BuildingDistributionCost.Title": "Distribución de claves y áreas calificadas por centro de coste sin averías",
  "BuildingDistributionCost.table.type": "Tipo",
  "BuildingDistributionCost.table.distributionKey": "Clave de distribución",
  "BuildingDistributionCost.table.costCenterDistributionKey": "Clave de asignación para el centro de coste",
  "BuildingDistributionCost.table.workplacesCount": "Cantidad de estaciones de trabajo",
  "BuildingDistributionCost.table.workplaceTotalCount": "Número total de estaciones de trabajo",
  "BuildingFloorSelection.title": "Los pisos para duplicar en tu escenario",
  "BuildingFloorSelection.all.select": "Seleccionar todos los pisos",
  "BuildingFloorSelection.all.unselect": "Deseleccionar todos los pisos",
  "BuildingCloneFloorSelection.title": "Los pisos para duplicar en tu escenario",
  "BuildingCloneFloorSelection.all.select": "Seleccionar todos los pisos",
  "BuildingCloneFloorSelection.all.unselect": "Deseleccionar todos los pisos",
  "BuildingClone.noClone": "Aún no se ha creado ningún escenario, puedes crear tu primer escenario para este edificio",
  "BuildingClone.buttons.CreateClone.label": "Crea un escenario",
  "BuildingClone.buttons.CreateClone.help": "El escenario duplicará el edificio con las propiedades marcadas.",
  "BuildingClone.accordion.title": "Crea un nuevo escenario",
  "BuildingClone.properties.clone.people": "Asignaciones duplicadas",
  "BuildingClone.properties.clone.workplaces": "Estaciones de trabajo duplicadas",
  "BuildingClone.properties.clone.items": "Objetos duplicados",
  "BuildingClone.properties.clone.dimensions": "Asociar capas de análisis y asignación con espacios",
  "BuildingClone.properties.clone.organization": "Organizaciones asociadas con espacios",
  "BuildingDashboard.dashboards.workplace": "Panel de escritorio",
  "BuildingDashboard.dashboards.area": "Panel de superficies",
  "CampusBuildingsAccordion.buildingCount": "El número de edificios",
  "CalculatedPropertiesAccordions.mesures": "Medidas",
  "CalculatedPropertiesAccordions.kpi": "Indicadores",
  "DimensionMapFilter.TooltipTitle.notSelected": "Seleccione %{dimension} para ver los espacios en el plano con el color asociado",
  "DimensionMapFilter.TooltipTitle.selected": "Al anular la selección de %{dimension} se eliminará el color asociado del plano",
  "DimensionMapFilter.tooltip.true": "Seleccione todos los filtros a continuación para colorearlos en el mapa",
  "DimensionMapFilter.tooltip.false": "Anule la selección de todos los filtros a continuación",
  "DimensionMapFilter.NoNode": "No hay capas de análisis en este momento, puede agregar más editando un espacio y agregando capas de análisis.",
  "DimensionMapFilter.NoCategory": "No hay capas de análisis disponibles, primero debe asociar algunas a los espacios",
  "SelectDimensionTypeNavigationLayoutIcon.select": "Seleccione este tipo de capa para la navegación",
  "SelectDimensionTypeNavigationLayoutIcon.unselect": "Eliminar navegación por capa de análisis y volver a navegación por espacios",
  "SelectDimensionTypeNavigationLayoutIcon.help": "La navegación por capa de análisis le permite hacer clic en un espacio, seleccionar la capa correspondiente y ver las personas asignadas a esta capa o las estaciones de trabajo y objetos asociados con esta capa a través de los espacios.",
  "DimensionTypeNavigationWarning.message": "Estás navegando por %{name} , los espacios se agruparán durante la selección. Haga clic para cancelar y volver a la navegación espacial.",
  "RoomCardSelectDimensions.needSave": "Guarde o cancele sus cambios antes de poder modificar las capas de análisis de este espacio",
  "AssignPersonToWorkplaceCheckListDialogTitle.title": "Ha asignado %{personName} a la estación de trabajo %{workplaceName}",
  "AssignPersonToRoomCheckListDialogTitle.title": "Asignó %{personName} al espacio %{roomName}",
  "WorkplaceFullName.noName": "Estación de trabajo sin nombre",
  "RoomFullName.noName": "espacio sin nombre",
  "AssignPersonCheckListWorkplaceTransit.title": "La estación de trabajo %{workplaceName} es una estación de trabajo temporal",
  "AssignPersonCheckListWorkplaceTransit.RemoveIsTransit": "Eliminar el tipo &quot;está pasando&quot; de la estación de trabajo",
  "AssignPersonCheckListWorkplaceAffectations.title": "Esta persona ya está asignada en otras estaciones de trabajo, ¿desea eliminar las siguientes asignaciones para %{personFullname} ?",
  "AssignPersonCheckListRoomAffectations.title": "Esta persona ya está directamente asignada a otros espacios, ¿desea eliminar las siguientes asignaciones para %{personFullname} ?",
  "AssignPersonCheckListDialogApplyButton.help": "Eliminar las asignaciones seleccionadas que pueden coincidir con las asignaciones anteriores de la persona",
  "AssignPersonCheckListDialogApplyButton.label": "Eliminar tareas seleccionadas",
  "AssignPersonCheckListDialog.actions.close.label": "cerca",
  "AssignPersonCheckListDialog.actions.close.help": "Cierra y no elimines ninguna otra tarea",
  "AssignPersonCheckListBuildingAffectations.title": "Esta persona ya está directamente asignada en otros edificios, ¿desea eliminar las siguientes asignaciones para %{personFullname} ?",
  "WorkplaceVirtualInventory.title": "Inventario de la estación de trabajo virtual",
  "WorkplacePhysicalInventory.title": "Inventario físico de la estación de trabajo",
  "WorkplaceTypeSeatsCount.label": "Numero de asientos",
  "WorkplaceTypeSeatsCount.help": "El número de asientos contados para este tipo de estación de trabajo",
  "WorkplaceTypeCarbonFootprintCount.label": "huella de carbono",
  "WorkplaceTypeCarbonFootprintCount.help": "La huella de carbono es la cantidad de gases de efecto invernadero que emiten los objetos de mobiliario de este tipo de puestos de trabajo",
  "DeleteWorkplace.help": "Eliminar estación de trabajo: [ %{name} ], las asignaciones también se eliminarán",
  "AddPersonToWorkplace.text": "Asignar una persona",
  "AddPersonToWorkplace.help": "Agregar asignación a esta estación de trabajo, puede agregar múltiples asignaciones para la misma estación de trabajo",
  "MouvementMatrixImport.errors.noSheet": "No se pudo encontrar la hoja de Excel con el nombre %{name} [ %{objectTypeName} ]",
  "RoomTypeGroupMapFilter.Empty": "No hay ningún grupo de tipo de espacio asociado con espacios a través de tipos de espacio, puede agregar más editando un grupo de tipo de espacio y agregándole un tipo de espacio asociado, luego puede controlar su visualización desde esta sección",
  "RoomTypeGroupLabel.exclude.tooltip": "El grupo de tipología de espacio excluye los tipos de espacio asociados.",
  "RoomTypeGroupHelpTitle.exclude": "La agrupación de tipos de espacio %{name} es de tipo de exclusión. Reúne todos los espacios a excepción de las siguientes tipologías de espacios:",
  "RoomTypeGroupHelpTitle.include": "La agrupación de tipos de espacio %{name} reúne las siguientes tipologías de espacio:",
  "RoomTypeGroupToRoomTypeLabel.exclude.tooltip": "Se excluye la tipología del espacio.",
  "RoomMapFilter.Empty": "No hay ningún tipo de espacio asociado a los espacios, puede agregar más modificando un espacio y agregando un tipo asociado, luego puede controlar su visualización desde esta sección",
  "LayoutFiltersTabZone.collapse.help": "El menú está cerrado, puede abrirlo haciendo clic en el primer icono para abrirlo y ver los detalles de los elementos del plan",
  "LayoutFiltersTabOpenToggleIcon.open.true": "Cierre el menú del mapa para optimizar el espacio de visualización del mapa.",
  "LayoutFiltersTabOpenToggleIcon.open.false": "Abra el menú del plan para ver información detallada relacionada con el plan.",
  "CompanyTypeLabel.notClassified": "Plataforma sin clasificar",
  "BuildingMenuItem.menu.scenario": "Escenarios ( %{count} )",
  "SearchMenuItem.icon.tooltip": "Buscar",
  "RemoveFromCartIconButton.help": "Quitar de la cesta",
  "CopyCartContentIntoTenant.buttons.single.paste.help": "Importar a esta empresa",
  "IndexContextMenuItem.navigation": "Navegación",
  "GlobalSearchIncludeScenarios.label": "Incluir escenarios en la búsqueda",
  "GlobalSearch.Input.placeholder": "Buscar",
  "GlobalSearch.Start": "Puede buscar, por ejemplo, personas, espacios, estaciones de trabajo, objetos u otras entidades, la búsqueda comenzará desde el segundo carácter",
  "GlobalSearch.NoResult": "No se encontraron resultados para tu búsqueda",
  "GlobalSearch.close.help": "Borrar búsqueda",
  "models.PartnerExportMappingConfigurationToFloor.singular": "Etapa incluida en la configuración de la transformación de las exportaciones de socios",
  "models.PartnerExportMappingConfigurationToFloor.plural": "Etapas incluidas en la configuración de transformación de exportaciones de socios",
  "models.PartnerExportMappingConfigurationToFloor.determinant.defined": "la etapa incluida en la configuración de la transformación de las exportaciones de socios",
  "models.PartnerExportMappingConfigurationToFloor.determinant.undefined": "una etapa incluida en la configuración de la transformación de las exportaciones de los socios",
  "models.PartnerExportMappingConfigurationToFloor.determinants.defined": "las etapas incluidas en las configuraciones de transformaciones exportadoras de socios",
  "models.PartnerExportMappingConfigurationToFloor.determinants.undefined": "Etapas incluidas en las configuraciones de transformaciones exportadoras de socios.",
  "models.PartnerExportMappingToRoomType.singular": "Transformación de las exportaciones de socios para tipos de espacio.",
  "models.PartnerExportMappingToRoomType.plural": "Transformaciones de exportaciones de socios para tipos de espacio.",
  "models.PartnerExportMappingToRoomType.determinant.defined": "la transformación de las exportaciones de socios para los tipos de espacio",
  "models.PartnerExportMappingToRoomType.determinant.undefined": "una transformación de las exportaciones de socios para tipos de espacios",
  "models.PartnerExportMappingToRoomType.determinants.defined": "transformaciones de las exportaciones de socios para tipos de espacio",
  "models.PartnerExportMappingToRoomType.determinants.undefined": "transformaciones de las exportaciones de socios para tipos de espacio",
  "models.PartnerExportMappingConfiguration.singular": "Configurar la transformación de exportaciones de socios",
  "models.PartnerExportMappingConfiguration.plural": "Configuraciones de transformaciones de exportación de socios",
  "models.PartnerExportMappingConfiguration.determinant.defined": "configurando la transformación de las exportaciones de los socios",
  "models.PartnerExportMappingConfiguration.determinant.undefined": "una configuración de la transformación de las exportaciones de socios",
  "models.PartnerExportMappingConfiguration.determinants.defined": "Configuraciones de transformaciones de exportación de socios.",
  "models.PartnerExportMappingConfiguration.determinants.undefined": "Configuraciones de transformaciones de exportación de socios.",
  "models.PartnerExportMapping.singular": "Transformación de las exportaciones de socios",
  "models.PartnerExportMapping.plural": "Transformaciones de las exportaciones de socios",
  "models.PartnerExportMapping.determinant.defined": "la transformación de las exportaciones de socios",
  "models.PartnerExportMapping.determinant.undefined": "una transformación de las exportaciones de los socios",
  "models.PartnerExportMapping.determinants.defined": "transformaciones de las exportaciones de socios",
  "models.PartnerExportMapping.determinants.undefined": "transformaciones de las exportaciones de socios",
  "models.WorkplaceTypeItemType.singular": "tipo de objeto en tipo de estación de trabajo",
  "models.WorkplaceTypeItemType.plural": "tipos de objeto en tipo de estación de trabajo",
  "models.WorkplaceTypeItemType.determinant.defined": "el tipo de objeto en el tipo de estación de trabajo",
  "models.WorkplaceTypeItemType.determinant.undefined": "un tipo de objeto en un tipo de estación de trabajo",
  "models.WorkplaceTypeItemType.determinants.defined": "tipos de objetos en tipos de estaciones de trabajo",
  "models.WorkplaceTypeItemType.determinants.undefined": "tipos de objetos en tipos de estaciones de trabajo",
  "models.WorkplaceTypeItemType.properties.id.label": "Identificador de tipo de objeto en el tipo de estación de trabajo",
  "models.WorkplaceTypeItemType.properties.zIndex.label": "Índice de altura",
  "models.WorkplaceTypeItemType.properties.zIndex.description": "El índice de altura le permite definir el orden de visualización de los tipos de objetos, cuanto mayor sea el índice, más estará el objeto por encima de los demás.",
  "models.WorkplaceTypeItemType.properties.physicalInventory.label": "Inventario físico",
  "models.WorkplaceTypeItemType.properties.physicalInventory.description": "Si se marca esta opción para cada estación de trabajo se creará un objeto físico en Surfy, este objeto puede tener una referencia única, en todos los casos el inventario del edificio estará actualizado",
  "models.WorkplaceTypeItemType.properties.seatsCount.label": "Numero de asientos",
  "models.WorkplaceTypeItemType.properties.seatsCount.description": "Le permite definir el número de asientos disponibles en el tipo de estación de trabajo para este tipo de objeto",
  "models.WorkplaceType.singular": "tipo de estación de trabajo",
  "models.WorkplaceType.plural": "tipos de estaciones de trabajo",
  "models.WorkplaceType.determinant.defined": "el tipo de estación de trabajo",
  "models.WorkplaceType.determinant.undefined": "un tipo de estación de trabajo",
  "models.WorkplaceType.determinants.defined": "tipos de estaciones de trabajo",
  "models.WorkplaceType.determinants.undefined": "tipos de estaciones de trabajo",
  "models.WorkplaceType.properties.id.label": "Identificador de tipología de estación de trabajo",
  "models.WorkplaceType.properties.id.description": "???",
  "models.WorkplaceType.properties.name.label": "Nombre del tipo de estación de trabajo",
  "models.WorkplaceType.properties.name.description": "???",
  "models.WorkplaceType.views.editor.help": "Edite formas y ubicaciones de tipos de objetos para el tipo de estación de trabajo %{name}",
  "models.WorkplaceType.views.editor.label": "Editar formas",
  "models.WorkplaceType.views.avatar.help": "Ver el formulario del tipo de estación de trabajo %{name}",
  "models.WorkplaceType.views.avatar.label": "Ver la forma",
  "models.WorkplaceType.views.dq-not-used.label": "No utilizado",
  "models.WorkplaceType.views.dq-not-used.help": "Enumere todos los tipos de estaciones de trabajo no utilizadas a través de estaciones de trabajo",
  "models.WorkplaceAffectation.singular": "Asignación de puestos de trabajo",
  "models.WorkplaceAffectation.plural": "Asignaciones de estaciones de trabajo",
  "models.WorkplaceAffectation.description": "Le permite asignar una estación de trabajo fija a una persona.",
  "models.WorkplaceAffectation.determinant.defined": "Asignación de trabajo",
  "models.WorkplaceAffectation.determinant.undefined": "Asignación de trabajo",
  "models.WorkplaceAffectation.determinants.defined": "asignaciones de trabajo",
  "models.WorkplaceAffectation.determinants.undefined": "asignaciones de trabajo",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.help": "Importar matrices de transferencia de estaciones de trabajo",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.label": "Importar matriz de transferencia",
  "models.Workplace.singular": "puesto de trabajo",
  "models.Workplace.plural": "estaciones de trabajo",
  "models.Workplace.determinant.defined": "la estacion de trabajo",
  "models.Workplace.determinant.undefined": "un puesto de trabajo",
  "models.Workplace.determinants.defined": "estaciones de trabajo",
  "models.Workplace.determinants.undefined": "estaciones de trabajo",
  "models.Workplace.views.assign-current-user.label": "Ocupar la estación de trabajo",
  "models.Workplace.views.assign-current-user.help": "Ocupar estación de trabajo %{name}",
  "models.Workplace.properties.id.label": "Identificador de estación de trabajo",
  "models.Workplace.properties.id.description": "???",
  "models.Workplace.properties.color.label": "color",
  "models.Workplace.properties.color.description": "El color que tomará el tipo de estación de trabajo en el plano",
  "models.Workplace.properties.name.label": "Nombre de la estación de trabajo",
  "models.Workplace.properties.name.description": "El nombre de la estación de trabajo se utiliza para identificarla de forma más sencilla.",
  "models.Workplace.properties.isFlex.label": "¿Es flexible?",
  "models.Workplace.properties.isFlex.description": "Si esta estación se usa en modo Flex",
  "models.Workplace.properties.isShared.label": "Está compartido ?",
  "models.Workplace.properties.isShared.description": "Si este puesto de trabajo es compartido por varias personas, este campo automático se valida tan pronto como haya al menos 2 asignaciones en el puesto de trabajo.",
  "models.Workplace.properties.isTransit.label": "Está pasando?",
  "models.Workplace.properties.isTransit.description": "Si esta posición es transitoria, esta posición será excluida de las estaciones de trabajo libres sin ser reservable en flex, una posición transitoria permite tener una estación de trabajo disponible para todos aquellos que deseen utilizarla sin estar incluidos en un sistema de reserva.",
  "models.Workplace.properties.isBookable.label": "¿Se puede reservar?",
  "models.Workplace.properties.isBookable.description": "Si esta estación de trabajo se puede reservar en un sistema de reservas",
  "models.Workplace.properties.position.label": "posición",
  "models.Workplace.properties.position.description": "La posición de la estación de trabajo en el espacio.",
  "models.Workplace.properties.rotation.label": "rotación",
  "models.Workplace.properties.rotation.description": "El ángulo de rotación de la estación de trabajo en el espacio.",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.label": "Tasa de asignación promedio",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.description": "Tasa media de asignación del puesto de trabajo según la asignación de los días de presencia de las personas",
  "models.Workplace.properties.workplaceAffectationsCount.label": "Numero de asignaciones",
  "models.Workplace.properties.workplaceAffectationsCount.description": "Número de asignaciones en la estación de trabajo",
  "models.Workplace.properties.comment.label": "Comentario",
  "models.Workplace.properties.comment.description": "Información adicional sobre la estación de trabajo.",
  "models.Workplace.properties.room.label": "Espacio para estaciones de trabajo",
  "models.UserRegistrationTenantRuleToJupRole.singular": "Asociación de regla de autenticación a rol",
  "models.UserRegistrationTenantRuleToJupRole.plural": "Asociaciones de regla a rol de autenticación",
  "models.UserRegistrationTenantRuleToJupRole.determinant.defined": "asociación de la regla de autenticación al rol",
  "models.UserRegistrationTenantRuleToJupRole.determinant.undefined": "una asociación de regla a rol de autenticación",
  "models.UserRegistrationTenantRuleToJupRole.determinants.defined": "regla de autenticación para asociaciones de roles",
  "models.UserRegistrationTenantRuleToJupRole.determinants.undefined": "asociaciones de reglas de autenticación de rol a rol",
  "models.UserRegistrationTenantRuleToContentRole.singular": "Regla de autenticación para la asociación de roles de contenido",
  "models.UserRegistrationTenantRuleToContentRole.plural": "Regla de autenticación para asociaciones de roles de contenido",
  "models.UserRegistrationTenantRuleToContentRole.determinant.defined": "Regla de autenticación para la asociación de roles de contenido",
  "models.UserRegistrationTenantRuleToContentRole.determinant.undefined": "una regla de autenticación para la asociación de roles de contenido",
  "models.UserRegistrationTenantRuleToContentRole.determinants.defined": "regla de autenticación para asociaciones de roles de contenido",
  "models.UserRegistrationTenantRuleToContentRole.determinants.undefined": "asociaciones de reglas de función a autenticación de contenido",
  "models.UserRegistrationTenantRule.singular": "Regla de autenticación",
  "models.UserRegistrationTenantRule.plural": "Reglas de autenticación",
  "models.UserRegistrationTenantRule.determinant.defined": "la regla de autenticación",
  "models.UserRegistrationTenantRule.determinant.undefined": "una regla de autenticación",
  "models.UserRegistrationTenantRule.determinants.defined": "reglas de autenticación",
  "models.UserRegistrationTenantRule.determinants.undefined": "reglas de autenticación",
  "models.UserRegistrationTenantRule.properties.domains.label": "Áreas",
  "models.UserRegistrationTenantRule.properties.domains.description": "Separe los dominios con espacios e incluya el signo de arroba",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.label": "Asociar roles automáticamente",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.description": "Asociar automáticamente roles y roles de contenido con usuarios que cumplan esta regla",
  "models.UserCompany.singular": "usuario de negocios",
  "models.UserCompany.plural": "usuarios de negocios",
  "models.UserCompany.description": "Los usuarios corporativos tienen acceso a la plataforma Surfy de su empresa",
  "models.UserCompany.determinant.defined": "el usuario de negocios",
  "models.UserCompany.determinant.undefined": "un usuario de negocios",
  "models.UserCompany.determinants.defined": "usuarios de negocios",
  "models.UserCompany.determinants.undefined": "usuarios empresariales",
  "models.UserCompany.properties.id.label": "ID de usuario de la empresa",
  "models.UserCompany.properties.buildingOwners.label": "Edificios propios",
  "models.UserCompany.properties.buildingOwners.description": "Edificios propiedad del usuario",
  "models.User.singular": "usuario",
  "models.User.plural": "usuarios",
  "models.User.determinant.defined": "usuario",
  "models.User.determinant.undefined": "un usuario",
  "models.User.determinants.defined": "los usuarios",
  "models.User.determinants.undefined": "usuarios",
  "models.User.properties.id.label": "ID de usuario",
  "models.User.properties.id.description": "???",
  "models.User.properties.firstname.label": "primer nombre",
  "models.User.properties.firstname.description": "El nombre del usuario",
  "models.User.properties.lastname.label": "Apellido",
  "models.User.properties.lastname.description": "El apellido del usuario",
  "models.User.properties.email.label": "e-mail",
  "models.User.properties.email.description": "El correo electrónico utilizado por el usuario para la correspondencia o para la autenticación.",
  "models.Structure.singular": "estructura",
  "models.Structure.plural": "estructuras",
  "models.Structure.determinant.defined": "la estructura",
  "models.Structure.determinant.undefined": "una estructura",
  "models.Structure.determinants.defined": "las estructuras",
  "models.Structure.determinants.undefined": "estructuras",
  "models.Structure.properties.nom.label": "Nombre de la estructura",
  "models.Structure.properties.nom.description": "Para encontrar y reutilizar la estructura fácilmente.",
  "models.Structure.properties.transform.label": "Transformación",
  "models.Structure.properties.transform.description": "Transformación de la estructura para calibrarla en un mapa",
  "models.Structure.views.editor.label": "Editar forma",
  "models.Structure.views.editor.help": "Modificar la forma de la estructura.",
  "models.Structure.views.gmap-calibrate.label": "Calibrar la estructura en un mapa",
  "models.Structure.views.gmap-calibrate.help": "Calibrar la estructura en un mapa para asociar coordenadas geográficas",
  "models.RoomTypeGroupToRoomType.singular": "asociación del grupo de tipología espacial con tipología espacial",
  "models.RoomTypeGroupToRoomType.plural": "asociaciones grupos de tipologías espaciales a tipologías espaciales",
  "models.RoomTypeGroupToRoomType.determinant.defined": "la asociación del grupo de tipología espacial con la tipología espacial",
  "models.RoomTypeGroupToRoomType.determinant.undefined": "una asociación grupal de tipología espacial a tipología espacial",
  "models.RoomTypeGroupToRoomType.determinants.defined": "asociaciones grupales de tipologías espaciales a tipologías espaciales",
  "models.RoomTypeGroupToRoomType.determinants.undefined": "asociaciones grupales de tipologías espaciales a tipologías espaciales",
  "models.RoomTypeGroupFloor.singular": "grupo de tipología de espacios",
  "models.RoomTypeGroupFloor.plural": "grupos de tipologías de espacios",
  "models.RoomTypeGroupFloor.determinant.defined": "el grupo de tipología de espacio de piso",
  "models.RoomTypeGroupFloor.determinant.undefined": "un grupo de tipologías de espacios",
  "models.RoomTypeGroupFloor.determinants.defined": "el grupo de tipología de espacio de piso",
  "models.RoomTypeGroupFloor.determinants.undefined": "grupos de tipologías de espacios",
  "models.RoomTypeGroupBuilding.singular": "tipología espacial grupo de edificios",
  "models.RoomTypeGroupBuilding.plural": "grupos de tipologías de espacios de construcción",
  "models.RoomTypeGroupBuilding.determinant.defined": "el grupo de tipología de espacios de construcción",
  "models.RoomTypeGroupBuilding.determinant.undefined": "un grupo de tipologías de espacios de construcción",
  "models.RoomTypeGroupBuilding.determinants.defined": "el grupo de tipología de espacios de construcción",
  "models.RoomTypeGroupBuilding.determinants.undefined": "grupos de tipologías de espacios de construcción",
  "models.RoomTypeGroup.singular": "grupo de tipología espacial",
  "models.RoomTypeGroup.plural": "grupos de tipología espacial",
  "models.RoomTypeGroup.determinant.defined": "el grupo de tipología espacial",
  "models.RoomTypeGroup.determinant.undefined": "un grupo de tipología espacial",
  "models.RoomTypeGroup.determinants.defined": "grupos de tipología espacial",
  "models.RoomTypeGroup.determinants.undefined": "grupos de tipologías espaciales",
  "models.RoomTypeGroup.properties.id.label": "Identificador de grupo de tipología espacial",
  "models.RoomTypeGroup.properties.name.label": "Nombre del grupo de tipología espacial",
  "models.RoomTypeGroup.properties.code.label": "código",
  "models.RoomTypeGroup.properties.color.label": "color",
  "models.RoomTypeGroup.properties.exclude.label": "Excluir",
  "models.RoomTypeGroup.properties.exclude.description": "Excluir tipologías de espacio de este grupo",
  "models.RoomTypeFloor.singular": "tipología de espacio de piso",
  "models.RoomTypeFloor.plural": "tipologías de espacio de piso",
  "models.RoomTypeFloor.determinant.defined": "la tipología del espacio del suelo",
  "models.RoomTypeFloor.determinant.undefined": "una tipología de espacio",
  "models.RoomTypeFloor.determinants.defined": "tipologías de espacio de piso",
  "models.RoomTypeFloor.determinants.undefined": "tipologías de espacio de piso",
  "models.RoomTypeBuilding.singular": "tipología de espacios de construcción",
  "models.RoomTypeBuilding.plural": "tipologías de espacios de construcción",
  "models.RoomTypeBuilding.determinant.defined": "la tipología del espacio de construcción",
  "models.RoomTypeBuilding.determinant.undefined": "una tipología del espacio de construcción",
  "models.RoomTypeBuilding.determinants.defined": "tipologías de espacios de construcción",
  "models.RoomTypeBuilding.determinants.undefined": "tipologías de espacios de construcción",
  "models.RoomType.singular": "tipología espacial",
  "models.RoomType.plural": "tipologías espaciales",
  "models.RoomType.determinant.defined": "tipología de espacio",
  "models.RoomType.determinant.undefined": "una tipología del espacio",
  "models.RoomType.determinants.defined": "tipologías espaciales",
  "models.RoomType.determinants.undefined": "tipologías de espacio",
  "models.RoomType.properties.id.label": "Identificador de tipología de espacio",
  "models.RoomType.properties.name.label": "Nombre del tipo de espacio",
  "models.RoomType.properties.color.label": "Color 2d",
  "models.RoomType.properties.color.description": "El color del tipo de espacio permite diferenciar cada tipo en el plano 2d",
  "models.RoomType.properties.color3d.label": "Color 3d",
  "models.RoomType.properties.color3d.description": "Permite administrar el color del tipo de espacio en 3d, esta opción solo es aplicable a la visión 3d del piso",
  "models.RoomType.properties.displayWallsOn3d.label": "Mostrar paredes",
  "models.RoomType.properties.displayWallsOn3d.description": "Le permite mostrar o no las paredes del espacio en el plano de planta 3d, las paredes no mostradas están punteadas en 2d, esto le permite tener una vista más agradable, especialmente para espacios abiertos",
  "models.RoomType.properties.icon.label": "Icono",
  "models.RoomType.properties.icon.description": "El icono por tipo de espacio permite visualizar para este tipo de espacio un icono en planos 2d y 3d en lugar de la información clásica sobre el plano, asociado al color de fondo esto permite hacer la lectura más agradable de la plan",
  "models.RoomType.properties.cadence.label": "Cadencia",
  "models.RoomType.properties.cadence.description": "La tarifa es un valor numérico que se utiliza para indicar la dificultad de limpieza de la tipología del espacio. Es igual al número de m² que se pueden tratar en una hora en esta tipología (circulación, laboratorio, etc.)",
  "models.RoomType.properties.isBookable.label": "¿Se puede reservar?",
  "models.RoomType.properties.isBookable.description": "Marque esta casilla si se puede reservar este tipo de espacio",
  "models.RoomPointSegmentType.singular": "Tipo de segmento",
  "models.RoomPointSegmentType.plural": "Tipos de segmento",
  "models.RoomPointSegmentType.determinant.defined": "el tipo de segmento",
  "models.RoomPointSegmentType.determinant.undefined": "un tipo de segmento",
  "models.RoomPointSegmentType.determinants.defined": "tipos de segmento",
  "models.RoomPointSegmentType.determinants.undefined": "tipos de segmento",
  "models.RoomPointSegment.singular": "calificación del segmento",
  "models.RoomPointSegment.plural": "calificaciones del segmento",
  "models.RoomPointSegment.determinant.defined": "calificación del segmento",
  "models.RoomPointSegment.determinant.undefined": "una calificación de segmento",
  "models.RoomPointSegment.determinants.defined": "calificaciones del segmento",
  "models.RoomPointSegment.determinants.undefined": "calificaciones del segmento",
  "models.RoomPointSegment.properties.reversePoints.label": "Puntos inversos",
  "models.RoomPointSegment.properties.reversePoints.description": "Invertir los puntos del segmento para tener la visualización, por ejemplo, de puertas en la dirección correcta",
  "models.RoomPointSegment.properties.displayBothSides.label": "Mostrar en ambos lados",
  "models.RoomPointSegment.properties.displayBothSides.description": "Mostrar segmento en ambos lados del segmento",
  "models.RoomPointSegment.views.dq-not-uniq.label": "Segmentos de puntos no únicos",
  "models.RoomPointSegment.views.dq-not-uniq.help": "Le permite comprobar que no existe un segmento duplicado exacto en los mismos puntos.",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.label": "Los puntos del segmento están en 2 pisos diferentes.",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.help": "Le permite comprobar que los puntos del segmento están en el mismo piso.",
  "models.RoomPointRoom.singular": "Asociación entre un punto y un espacio.",
  "models.RoomPointRoom.plural": "Asociaciones entre un punto y un espacio",
  "models.RoomPointRoom.determinant.defined": "la asociación entre un punto y un espacio",
  "models.RoomPointRoom.determinant.undefined": "Un punto",
  "models.RoomPointRoom.description": "La asociación entre un punto y un espacio permite preservar el orden de los puntos en un espacio para constituir un polión.",
  "models.RoomPointRoom.properties.id.label": "Identificador de la asociación entre un punto y un espacio.",
  "models.RoomPointRoom.properties.id.description": "???",
  "models.RoomPointRoom.properties.roomId.label": "ID de espacio",
  "models.RoomPointRoom.properties.roomId.description": "???",
  "models.RoomPointRoom.properties.externalId.label": "Identificador externo",
  "models.RoomPointRoom.properties.externalId.description": "???",
  "models.RoomPointRoom.properties.sortIndex.label": "Índice de clasificación",
  "models.RoomPointRoom.properties.sortIndex.description": "???",
  "models.RoomPointRoom.properties.roomPointId.label": "Identificador de punto",
  "models.RoomPointRoom.properties.roomPointId.description": "???",
  "models.RoomPoint.singular": "punto de espacios",
  "models.RoomPoint.plural": "puntos de espacios",
  "models.RoomPoint.determinant.defined": "el punto de los espacios",
  "models.RoomPoint.determinant.undefined": "un punto de espacios",
  "models.RoomPoint.properties.id.label": "Identificador del punto de espacios",
  "models.RoomPoint.properties.x.label": "x",
  "models.RoomPoint.properties.x.description": "Coordinar en el eje X",
  "models.RoomPoint.properties.y.label": "hay",
  "models.RoomPoint.properties.y.description": "Coordenada del eje Y",
  "models.RoomPoint.properties.sort_index.label": "orden",
  "models.RoomPoint.properties.sort_index.description": "El índice utilizado para la clasificación",
  "models.RoomPoint.properties.room.description": "???",
  "models.RoomPoint.properties.externalId.label": "Identificador externo",
  "models.RoomPoint.properties.externalId.description": "???",
  "models.RoomPoint.views.dq-uniq-position.label": "Posición de un solo punto",
  "models.RoomPoint.views.dq-uniq-position.help": "Le permite comprobar que no existe una posición duplicada exacta en los puntos.",
  "models.RoomPoint.views.dq-not-used.label": "Puntos no utilizados",
  "models.RoomPoint.views.dq-not-used.help": "Le permite ver puntos que no se utilizan en espacios.",
  "models.RoomConnector.singular": "Conector espacial",
  "models.RoomConnector.plural": "Conectores espaciales",
  "models.RoomConnector.determinant.defined": "el conector espacial",
  "models.RoomConnector.determinant.undefined": "un conector espacial",
  "models.RoomConnector.determinants.defined": "conectores espaciales",
  "models.RoomConnector.determinants.undefined": "conectores espaciales",
  "models.RoomConnector.description": "Los conectores espaciales le permiten crear un vínculo entre varios espacios en diferentes pisos.",
  "models.RoomConnector.properties.id.label": "ID del conector espacial",
  "models.RoomConnector.properties.name.label": "Nombre del conector espacial",
  "models.RoomConnector.properties.waitTime.label": "tiempo promedio de espera",
  "models.RoomConnector.properties.waitTime.description": "El tiempo de espera promedio antes de que el conector espacial esté disponible",
  "models.RoomConnector.properties.timePerFloor.label": "Tiempo entre cada piso",
  "models.RoomConnector.properties.timePerFloor.description": "El tiempo necesario para poder pasar de cada piso al siguiente.",
  "models.RoomAffectation.singular": "Asignación de espacio",
  "models.RoomAffectation.plural": "Asignaciones de espacio",
  "models.RoomAffectation.description": "Le permite asignar una persona a un solo espacio.",
  "models.RoomAffectation.determinant.defined": "asignación de espacio",
  "models.RoomAffectation.determinant.undefined": "una asignación de espacio",
  "models.RoomAffectation.determinants.defined": "asignaciones de espacio",
  "models.RoomAffectation.determinants.undefined": "asignaciones de espacio",
  "models.RoomAffectation.views.room-mouvement-matrix-import.help": "Importar matrices de transferencia de espacios",
  "models.RoomAffectation.views.room-mouvement-matrix-import.label": "Importar matriz de transferencia",
  "models.Room.singular": "espacio",
  "models.Room.plural": "espacios",
  "models.Room.determinant.defined": "espacio",
  "models.Room.determinant.undefined": "un espacio",
  "models.Room.determinants.defined": "los espacios",
  "models.Room.determinants.undefined": "espacios",
  "models.Room.description": "Los espacios son lugares de trabajo o zonas para dividir un piso en subespacios.",
  "models.Room.views.map.help": "Ver plan de espacio %{name}",
  "models.Room.views.map.label": "plan",
  "models.Room.views.dq-uniq-name.help": "Sugiere nombres para espacios que no tienen nombre o el nombre no es único en el mismo piso",
  "models.Room.views.dq-uniq-name.label": "Nombres propuestos para espacios",
  "models.Room.views.dq-no-point.help": "Espacios que tienen 0, 1 o 2 puntos y por lo tanto deberían tener área cero",
  "models.Room.views.dq-no-point.label": "Espacios sin puntos suficientes",
  "models.Room.views.dq-capacity-equals-seats-count.help": "Espacios que tengan una capacidad excluyendo asientos igual al número de asientos y que tengan una capacidad total duplicada",
  "models.Room.views.dq-capacity-equals-seats-count.label": "Espacios con una capacidad sin incluir asientos igual al número de asientos",
  "models.Room.views.dq-capacity-gt-0.help": "Permite ver si hay inconsistencias en las capacidades de los espacios o detectar, por ejemplo, muebles que aún no tienen asientos",
  "models.Room.views.dq-capacity-gt-0.label": "Espacios que tengan una capacidad excluyendo asientos distintos de 0",
  "models.Room.views.meeting-rooms.help": "Ver y navegar por salas de reuniones",
  "models.Room.views.meeting-rooms.label": "Salas de reuniones",
  "models.Room.properties.prettyName.label": "Nombre para mostrar",
  "models.Room.properties.prettyName.description": "Le permite tener un nombre para mostrar además del nombre técnico del espacio, por ejemplo para salas de reuniones.",
  "models.Room.properties.id.label": "ID de espacio",
  "models.Room.properties.livePeopleCount.label": "Número de personas en el espacio en tiempo real.",
  "models.Room.properties.livePeopleCount.description": "Este valor es actualizado por los sensores de conteo de personas presentes en el espacio y proporciona el número de personas presentes en tiempo real en el espacio.",
  "models.Room.properties.picture.label": "Foto desde el espacio",
  "models.Room.properties.picture.description": "La foto del espacio hace que sea fácil de visualizar.",
  "models.Room.properties.capacity.label": "Capacidad sin asientos",
  "models.Room.properties.capacity.description": "La capacidad declarada se puede utilizar para definir la cantidad de asientos disponibles en un espacio o para conocer la cantidad máxima de personas que se pueden colocar en un espacio, esta cifra se suma a la cantidad de asientos para dar la capacidad total.",
  "models.Room.properties.workplacesCount.label": "Cantidad de estaciones de trabajo",
  "models.Room.properties.workplacesCount.description": "El número de estaciones de trabajo en el espacio se calcula automáticamente.",
  "models.Room.properties.workplacesRatio.label": "Ratio por puesto de trabajo",
  "models.Room.properties.workplacesRatio.description": "El ratio por estación de trabajo es la cantidad de metros cuadrados de espacio dividido por la cantidad de estaciones de trabajo, este valor se calcula automáticamente",
  "models.Room.properties.peopleCount.label": "Numero de asignaciones",
  "models.Room.properties.peopleCount.description": "El número de personas asignadas al espacio, ya sea directamente o a través de una estación de trabajo.",
  "models.Room.properties.peopleRatio.label": "Ratio de ocupación",
  "models.Room.properties.peopleRatio.description": "El ratio de ocupación es el número de metros cuadrados del espacio dividido por el número de personas asignadas a los espacios, ya sea directamente o a través de una estación de trabajo, este valor se calcula",
  "models.Room.properties.freeWorkplacesCount.label": "Numero de vacantes",
  "models.Room.properties.freeWorkplacesCount.description": "Número de posiciones libres en el espacio",
  "models.Room.properties.flexWorkplacesCount.label": "Número de posiciones de flexión",
  "models.Room.properties.flexWorkplacesCount.description": "Número de posiciones flexibles en el espacio.",
  "models.Room.properties.sharedWorkplacesCount.label": "Número de estaciones de trabajo compartidas",
  "models.Room.properties.sharedWorkplacesCount.description": "Número de estaciones de trabajo compartidas por al menos 2 personas",
  "models.Room.properties.transitWorkplacesCount.label": "Número de estaciones de trabajo de tránsito",
  "models.Room.properties.transitWorkplacesCount.description": "Número de puestos de trabajo temporales, estos puestos no se cuentan en puestos libres y no son flexibles",
  "models.Room.properties.sharedWorkplacesRatio.label": "Tasa de puestos de trabajo compartidos",
  "models.Room.properties.sharedWorkplacesRatio.description": "Tasa de estaciones de trabajo compartidas por al menos 2 personas en comparación con todas las estaciones de trabajo en el espacio",
  "models.Room.properties.flexRatio.label": "Tasa de estaciones de trabajo flexibles",
  "models.Room.properties.flexRatio.description": "La tasa de estaciones de trabajo flexibles se calcula dividiendo el número de estaciones de trabajo flexibles por el número total de estaciones de trabajo",
  "models.Room.properties.name.label": "Nombre del espacio",
  "models.Room.properties.name.description": "El nombre del espacio se utiliza para definirlo y encontrarlo fácilmente.",
  "models.Room.properties.area.label": "superficie",
  "models.Room.properties.area.description": "El espacio calificado para este espacio",
  "models.Room.properties.perimeter.label": "perímetro",
  "models.Room.properties.perimeter.description": "El perímetro del espacio representa su contorno.",
  "models.Room.properties.costCenter.description": "Permite saber a qué centro de coste asociar el espacio a la hora de gestionar la refacturación al centro de coste por espacio.",
  "models.Room.properties.distributionCostType.description": "Le permite determinar el método de cálculo de la clave de distribución de costos.",
  "models.Room.properties.info.label": "Información adicional",
  "models.Room.properties.info.description": "Le permite mantener información adicional de tipo texto en el espacio",
  "models.Room.properties.bookingEmail.label": "Correo electrónico utilizado para reservar este espacio",
  "models.Room.properties.bookingEmail.description": "Este correo electrónico se utiliza para reservar esta sala a través del sistema de mensajería.",
  "models.Room.properties.keyCylinderCode.label": "Número de cilindro",
  "models.Room.properties.keyCylinderCode.description": "El número de cilindro permite definir el número de cilindro de la cerradura de la puerta del espacio o un elemento relacionado con el acceso físico al espacio.",
  "models.Room.reports.mouvementMatrix.fileName": "Matriz de transferencia",
  "models.Room.reports.mouvementMatrix.help": "Crea una matriz de transferencia en Excel que te permitirá realizar fácilmente los viajes de tus empleados",
  "models.PersonWorkingLocation.singular": "Lugar de trabajo de las personas",
  "models.PersonWorkingLocation.plural": "Lugares de trabajo de las personas",
  "models.PersonWorkingLocation.determinant.defined": "lugar de trabajo de las personas",
  "models.PersonWorkingLocation.determinant.undefined": "un lugar donde la gente trabaja",
  "models.PersonWorkingLocation.determinants.defined": "lugares de trabajo de las personas",
  "models.PersonWorkingLocation.determinants.undefined": "lugares de trabajo de las personas",
  "models.PersonWorkingLocation.description": "Un lugar de trabajo de personas define el lugar de trabajo de las personas",
  "models.PersonWorkingLocation.views.my-planning.help": "Gestionar mi agenda para las próximas semanas",
  "models.PersonWorkingLocation.views.my-planning.label": "Administrar mi agenda",
  "models.PersonToWorkplaceBooking.singular": "Reserva en los puestos de trabajo de las personas",
  "models.PersonToWorkplaceBooking.plural": "Reservas en los puestos de trabajo de las personas",
  "models.PersonToWorkplaceBooking.description": "Las reservas de puestos de trabajo de las personas quedan registradas y disponibles con las fechas de inicio y finalización de la reserva.",
  "models.PersonToWorkplaceBooking.determinant.defined": "reserva en el puesto de trabajo de las personas",
  "models.PersonToWorkplaceBooking.determinant.undefined": "una reserva en el puesto de trabajo de la gente",
  "models.PersonToWorkplaceBooking.determinants.defined": "reservas en los puestos de trabajo de las personas",
  "models.PersonToWorkplaceBooking.determinants.undefined": "reservas en los puestos de trabajo de las personas",
  "models.PersonToWorkplaceBooking.properties.startDatetime.label": "Inicio de la reserva",
  "models.PersonToWorkplaceBooking.properties.startDatetime.description": "La fecha y hora de inicio de la reserva.",
  "models.PersonToWorkplaceBooking.properties.endDatetime.label": "Fin de la reserva",
  "models.PersonToWorkplaceBooking.properties.endDatetime.description": "La fecha y hora de finalización de la reserva.",
  "models.PersonToWorkplaceBooking.views.dashboard-index.label": "Salpicadero",
  "models.PersonToWorkplaceBooking.views.dashboard-index.help": "Panel de reservas en los puestos de trabajo de las personas",
  "models.PersonToRoomBooking.singular": "Reserva para la zona de personas",
  "models.PersonToRoomBooking.plural": "Reservas para la zona de personas",
  "models.PersonToRoomBooking.description": "Las reservas de espacios de personas quedan registradas y disponibles con las fechas de inicio y finalización de la reserva.",
  "models.PersonToRoomBooking.determinant.defined": "reserva en la zona del pueblo",
  "models.PersonToRoomBooking.determinant.undefined": "una reserva para el área de personas",
  "models.PersonToRoomBooking.determinants.defined": "reservas para el área de personas",
  "models.PersonToRoomBooking.determinants.undefined": "reservas para el área de personas",
  "models.PersonToRoomBooking.properties.startDatetime.label": "Inicio de la reserva",
  "models.PersonToRoomBooking.properties.startDatetime.description": "La fecha y hora de inicio de la reserva.",
  "models.PersonToRoomBooking.properties.endDatetime.label": "Fin de la reserva",
  "models.PersonToRoomBooking.properties.endDatetime.description": "La fecha y hora de finalización de la reserva.",
  "models.PersonToPersonType.singular": "Tipo de relación entre personas",
  "models.PersonToPersonType.plural": "Tipos de relación entre personas",
  "models.PersonToPersonType.determinant.defined": "el tipo de relación entre personas",
  "models.PersonToPersonType.determinant.undefined": "un tipo de relación entre personas",
  "models.PersonToPersonType.determinants.defined": "tipos de relaciones entre personas",
  "models.PersonToPersonType.determinants.undefined": "tipos de relaciones entre personas",
  "models.PersonToPersonType.properties.labelForward.label": "Relación natural (adelante)",
  "models.PersonToPersonType.properties.labelForward.description": "La definición de relación en el sentido natural, por ejemplo entre un padre y su hijo, la definición natural es 'es el padre de'",
  "models.PersonToPersonType.properties.labelBackward.label": "Relación inversa",
  "models.PersonToPersonType.properties.labelBackward.description": "La definición de relación en el sentido inverso al natural, por ejemplo entre un padre y su hijo, la definición inversa del sentido natural es &quot;es hijo de&quot;",
  "models.PersonToPerson.singular": "Relación de persona a persona",
  "models.PersonToPerson.plural": "Relaciones de persona a persona",
  "models.PersonToPerson.determinant.defined": "relación de persona a persona",
  "models.PersonToPerson.determinant.undefined": "una relación de persona a persona",
  "models.PersonToPerson.determinants.defined": "relaciones de persona a persona",
  "models.PersonToPerson.determinants.undefined": "relaciones de persona a persona",
  "models.PersonToPerson.properties.personSource.label": "Persona fuente",
  "models.PersonToPerson.properties.personTarget.label": "Persona de destino",
  "models.PersonToDimensionBooking.singular": "Reserva a la capa de asignación de personas",
  "models.PersonToDimensionBooking.plural": "Reservas en la capa de asignación de personas",
  "models.PersonToDimensionBooking.description": "Las reservas para capas de asignación de personas se guardan y están disponibles con las fechas de inicio y finalización de la reserva.",
  "models.PersonToDimensionBooking.determinant.defined": "reserva en la capa de asignación de personas",
  "models.PersonToDimensionBooking.determinant.undefined": "una reserva en la capa de asignación de personas",
  "models.PersonToDimensionBooking.determinants.defined": "reservas en la capa de asignación de personas",
  "models.PersonToDimensionBooking.determinants.undefined": "reservas a la capa de asignación de personas",
  "models.PersonToDimensionBooking.properties.startDatetime.label": "Inicio de la reserva",
  "models.PersonToDimensionBooking.properties.startDatetime.description": "La fecha y hora de inicio de la reserva.",
  "models.PersonToDimensionBooking.properties.endDatetime.label": "Fin de la reserva",
  "models.PersonToDimensionBooking.properties.endDatetime.description": "La fecha y hora de finalización de la reserva.",
  "models.PersonState.singular": "estado de las personas",
  "models.PersonState.plural": "estado de las personas",
  "models.PersonState.description": "Permite definir todo tipo de contrato entre las personas y la empresa.",
  "models.PersonState.determinant.defined": "el estado de la gente",
  "models.PersonState.determinant.undefined": "un estado de personas",
  "models.PersonState.determinants.defined": "el estado de las personas",
  "models.PersonState.determinants.undefined": "de los estatutos de las personas",
  "models.PersonState.properties.id.label": "Identificador de estado de persona",
  "models.PersonState.properties.name.label": "Nombre del estado de la persona",
  "models.PersonToBuilding.singular": "Afecto al edificio",
  "models.PersonToBuilding.plural": "tareas de construcción",
  "models.PersonToBuilding.description": "Permite asignar una persona a un edificio, sin información adicional. La asignación puede o no contabilizarse.",
  "models.PersonToBuilding.determinant.defined": "afecto por el edificio",
  "models.PersonToBuilding.determinant.undefined": "un cariño por el edificio",
  "models.PersonToBuilding.determinants.defined": "construyendo afectos",
  "models.PersonToBuilding.determinants.undefined": "dolencias del edificio",
  "models.PersonToBuilding.properties.addToPeopleCount.label": "Asignación de conteo",
  "models.PersonToBuilding.properties.addToPeopleCount.description": "Agregue esta asignación al número total de personas asignadas al edificio.",
  "models.PersonSecurityProfile.singular": "perfil de seguridad personal",
  "models.PersonSecurityProfile.plural": "perfiles de seguridad personal",
  "models.PersonSecurityProfile.description": "Permite definir los diferentes perfiles de seguridad que se pueden asociar a las personas",
  "models.PersonSecurityProfile.determinant.defined": "perfil de seguridad personal",
  "models.PersonSecurityProfile.determinant.undefined": "un perfil de seguridad personal",
  "models.PersonSecurityProfile.determinants.defined": "perfiles de seguridad personal",
  "models.PersonSecurityProfile.determinants.undefined": "perfiles de seguridad personal",
  "models.PersonSecurityProfile.properties.id.label": "Identificador de perfil de seguridad personal",
  "models.PersonSecurityProfile.properties.name.label": "Nombre del perfil de seguridad",
  "models.PersonSecurityProfile.properties.name.description": "Permite definir los diferentes perfiles de seguridad que se pueden asociar a las personas",
  "models.PersonSecurityProfile.properties.color.label": "Color del perfil de seguridad",
  "models.PersonSecurityProfile.properties.color.description": "Le permite colorear la estación de trabajo de asignación y el ícono de seguridad de la persona según su perfil de seguridad.",
  "models.PersonSecurityProfile.properties.icon.label": "Icono de perfil de seguridad",
  "models.PersonSecurityProfile.properties.icon.description": "Le permite asignar un icono a un perfil de seguridad para visualizar claramente los perfiles de seguridad en el plan o en las listas.",
  "models.PersonCompanyToRoomType.singular": "Tipo de espacio proveedor",
  "models.PersonCompanyToRoomType.plural": "Tipos de espacios proveedores",
  "models.PersonCompanyToRoomType.description": "Los tipos de espacios de los proveedores de servicios permiten definir una relación entre un tipo de espacio y el proveedor de servicios y definir una misión.",
  "models.PersonCompanyToRoomType.determinant.defined": "el tipo de espacio del proveedor del servicio",
  "models.PersonCompanyToRoomType.determinant.undefined": "un tipo de espacio del proveedor de servicios",
  "models.PersonCompanyToRoomType.determinants.defined": "los tipos de espacios de los proveedores de servicios",
  "models.PersonCompanyToRoomType.determinants.undefined": "tipos de espacios de proveedores de servicios",
  "models.PersonGender.singular": "género de la persona",
  "models.PersonGender.plural": "Tipos de personas",
  "models.PersonGender.description": "Permite contar cada tipo, por ejemplo para gestión sanitaria.",
  "models.PersonGender.determinant.defined": "el género de la persona",
  "models.PersonGender.determinant.undefined": "un tipo de persona",
  "models.PersonGender.determinants.defined": "tipos de personas",
  "models.PersonGender.determinants.undefined": "Tipos de personas",
  "models.PersonGender.properties.name.label": "apellido",
  "models.PersonGender.properties.name.description": "El nombre de género de la persona.",
  "models.PersonCompanyToItemType.singular": "Tipo de objeto de proveedor",
  "models.PersonCompanyToItemType.plural": "Tipos de objetos de proveedor",
  "models.PersonCompanyToItemType.description": "Los tipos de objetos de proveedor de servicios permiten definir una relación entre el tipo de objeto y el proveedor de servicios y definir la misión.",
  "models.PersonCompanyToItemType.determinant.defined": "el tipo de objeto del proveedor de servicios",
  "models.PersonCompanyToItemType.determinant.undefined": "un tipo de objeto proveedor",
  "models.PersonCompanyToItemType.determinants.defined": "los tipos de objetos de los proveedores de servicios",
  "models.PersonCompanyToItemType.determinants.undefined": "tipos de objetos de los proveedores de servicios",
  "models.PersonCompanyToItem.singular": "Intervención sobre un objeto",
  "models.PersonCompanyToItem.plural": "Intervenciones sobre objetos",
  "models.PersonCompanyToItem.description": "Las intervenciones de los proveedores de servicios sobre los objetos permiten definir, por ejemplo, la fecha de una visita a un extintor.",
  "models.PersonCompanyToItem.determinant.defined": "intervención sobre un objeto",
  "models.PersonCompanyToItem.determinant.undefined": "una intervención sobre un objeto",
  "models.PersonCompanyToItem.determinants.defined": "intervenciones sobre objetos",
  "models.PersonCompanyToItem.determinants.undefined": "intervenciones sobre objetos",
  "models.PersonCompanyToItem.properties.datetime.label": "Fecha y hora de la intervención.",
  "models.PersonCompanyToItem.properties.datetime.description": "Cuando tuvo lugar la intervención.",
  "models.PersonCompanyToItem.properties.comment.label": "Comentario",
  "models.PersonCompanyToItem.properties.comment.description": "Un comentario sobre la intervención.",
  "models.PersonCompanyMission.singular": "misión del proveedor de servicios",
  "models.PersonCompanyMission.plural": "misiones de proveedores de servicios",
  "models.PersonCompanyMission.description": "Las misiones de los prestadores de servicios permiten conocer el área de intervención de los prestadores de servicios.",
  "models.PersonCompanyMission.determinant.defined": "la misión del proveedor de servicios",
  "models.PersonCompanyMission.determinant.undefined": "una misión del proveedor de servicios",
  "models.PersonCompanyMission.determinants.defined": "las misiones de los proveedores de servicios",
  "models.PersonCompanyMission.determinants.undefined": "misiones de los proveedores de servicios",
  "models.PersonCompanyMission.properties.name.label": "apellido",
  "models.PersonCompanyMission.properties.name.description": "El nombre de la misión del proveedor de servicios.",
  "models.PersonCompany.singular": "empresa proveedora de servicios",
  "models.PersonCompany.plural": "empresas de servicios",
  "models.PersonCompany.description": "La empresa proveedora de servicios le permite administrar el personal del proveedor de servicios por empresa.",
  "models.PersonCompany.determinant.defined": "la empresa proveedora de servicios",
  "models.PersonCompany.determinant.undefined": "una empresa de servicios",
  "models.PersonCompany.determinants.defined": "empresas de servicios",
  "models.PersonCompany.determinants.undefined": "empresas de servicios",
  "models.PersonCompany.properties.name.label": "apellido",
  "models.PersonCompany.properties.name.description": "El nombre del proveedor de servicios, por ejemplo, el nombre de la empresa de un proveedor de servicios.",
  "models.PersonCompany.properties.comment.label": "Informaciones complementarias",
  "models.PersonCompany.properties.comment.description": "Información adicional sobre el proveedor del servicio, como su misión, sus valores, la cobertura funcional de su servicio, etc.",
  "models.PersonCompany.properties.contact.label": "Contactar",
  "models.PersonCompany.properties.contact.description": "Información de contacto del proveedor del servicio.",
  "models.PersonCompany.properties.documents.label": "Documentos relacionados",
  "models.PersonCompany.properties.documents.description": "El enlace a los documentos asociados con este proveedor de servicios.",
  "models.Person.singular": "persona",
  "models.Person.plural": "gente",
  "models.Person.description": "Estas son las personas introducidas en la base de datos de Surfy",
  "models.Person.determinant.defined": "la persona",
  "models.Person.determinant.undefined": "una persona",
  "models.Person.determinants.defined": "las personas",
  "models.Person.determinants.undefined": "personas",
  "models.Person.properties.id.label": "ID de Surfy",
  "models.Person.properties.fullname.label": "nombre completo",
  "models.Person.properties.fullname.description": "El nombre completo de la persona para que sea más fácil de encontrar.",
  "models.Person.properties.personState.label": "Estado",
  "models.Person.properties.personState.description": "Permite indicar el tipo de contrato que tiene la persona con la empresa",
  "models.Person.properties.personSecurityProfile.label": "Perfil de seguridad",
  "models.Person.properties.personSecurityProfile.description": "Permite indicar el perfil de seguridad de la persona para la gestión de seguridad.",
  "models.Person.properties.firstname.label": "primer nombre",
  "models.Person.properties.firstname.description": "El primer nombre de la persona.",
  "models.Person.properties.lastname.label": "Apellido",
  "models.Person.properties.lastname.description": "Apellido de la persona",
  "models.Person.properties.email.label": "e-mail",
  "models.Person.properties.email.description": "El correo electrónico de la persona",
  "models.Person.properties.picture.label": "Foto de perfil",
  "models.Person.properties.picture.description": "La foto de la persona para tenerla en el trombinoscopio o en investigación",
  "models.Person.properties.monitorReference.label": "Referencia de pantalla",
  "models.Person.properties.monitorReference.description": "La referencia de la pantalla del ordenador asociada a esta persona.",
  "models.Person.properties.computerReference.label": "Referencia de la computadora",
  "models.Person.properties.computerReference.description": "La referencia del ordenador asociado a esta persona.",
  "models.Person.properties.cellphone.label": "Teléfono móvil",
  "models.Person.properties.cellphone.description": "El teléfono móvil de la persona.",
  "models.Person.properties.telephone.label": "Teléfono fijo",
  "models.Person.properties.telephone.description": "El teléfono fijo de la persona",
  "models.Person.properties.title.label": "título",
  "models.Person.properties.title.description": "El titulo de la persona",
  "models.Person.properties.badgeNumber.label": "Número de insignia",
  "models.Person.properties.badgeNumber.description": "El número de identificación de la persona",
  "models.Person.properties.boxNumber.label": "Número de casillero",
  "models.Person.properties.boxNumber.description": "El número de casillero de la persona",
  "models.Person.properties.badgeRestaurant.label": "Insignia RIE",
  "models.Person.properties.badgeRestaurant.description": "La referencia del RIE o distintivo de restaurante de empresa",
  "models.Person.properties.registrationNumber.label": "registro",
  "models.Person.properties.registrationNumber.description": "El número de registro de la persona.",
  "models.Person.properties.startDate.label": "Fecha de entrada",
  "models.Person.properties.startDate.description": "La fecha en que la persona se incorporó a la empresa.",
  "models.Person.properties.endDate.label": "Fecha de lanzamiento",
  "models.Person.properties.endDate.description": "La fecha de salida de la persona de la empresa.",
  "models.Person.properties.code.label": "Número de registro",
  "models.Person.properties.code.description": "El número de recursos humanos de la persona.",
  "models.Person.properties.personToPersonTargets.label": "Relaciones con esta persona",
  "models.Person.properties.personToPersonTargets.description": "Permite conocer la relación ascendente entre dos personas, por ejemplo la relación jerárquica",
  "models.Person.properties.personToPersonSources.label": "Relaciones de esta persona",
  "models.Person.properties.personToPersonSources.description": "Permite conocer la relación descendente entre dos personas, por ejemplo la relación jerárquica",
  "models.Person.properties.organization.label": "La organización de la persona.",
  "models.Person.properties.organization.description": "El servicio de conexión de la persona.",
  "models.Person.properties.info.label": "Comentario",
  "models.Person.properties.info.description": "Comente sobre la persona que permite mantener información adicional o miscelánea",
  "models.Person.properties.notAffectable.label": "No asignable",
  "models.Person.properties.notAffectable.description": "La persona no puede ser asignada a una estación de trabajo, espacio, edificio o capa de asignación.",
  "models.Person.views.home.help": "Ver el archivo de la persona <b>%{name}</b> con su información y asignaciones",
  "models.Person.views.home.label": "archivo de persona",
  "models.Person.views.relationship-list.help": "Enumere las relaciones entre las personas",
  "models.Person.views.relationship-list.label": "Lista de relaciones",
  "models.Person.views.dq-only-associated-to-building.help": "Enumerar las personas asignables que están asignadas a un edificio y contadas sin ser asignadas (estación de trabajo, capa de asignación, espacio)",
  "models.Person.views.dq-only-associated-to-building.label": "Personas asignadas a un edificio sin otra asignación",
  "models.Person.views.dq-near-end-date.help": "Enumere las personas que tienen una fecha de finalización del contrato posterior a hoy y que están asignadas a una estación de trabajo",
  "models.Person.views.dq-near-end-date.label": "Personas que abandonan la empresa.",
  "models.Person.views.dq-no-affectations.label": "Personas sin asignaciones",
  "models.Person.views.dq-no-affectations.help": "Enumere las personas asignables que no tienen asignaciones (edificio, estación de trabajo, capa de asignación, espacio)",
  "models.Person.views.dq-person-duplicate.label": "personas duplicadas",
  "models.Person.views.dq-person-duplicate.help": "Listar personas duplicadas",
  "models.PartnerApiCredential.singular": "Clave de API de socio",
  "models.PartnerApiCredential.plural": "Claves de API de socios",
  "models.PartnerApiCredential.determinant.defined": "la clave de API del socio",
  "models.PartnerApiCredential.determinant.undefined": "una clave de API de socio",
  "models.PartnerApiCredential.determinants.defined": "claves de API de socio",
  "models.PartnerApiCredential.determinants.undefined": "claves de API de socio",
  "models.PartnerApiCredential.properties.enable.label": "Activado",
  "models.PartnerApiCredential.properties.enable.description": "Debes activar la clave para usarla",
  "models.OrganizationFloor.singular": "Organización de pisos",
  "models.OrganizationFloor.plural": "Organización del piso",
  "models.OrganizationFloor.determinant.defined": "la organización de los pisos",
  "models.OrganizationFloor.determinant.undefined": "una organización de pisos",
  "models.OrganizationFloor.determinants.defined": "organizaciones de piso",
  "models.OrganizationFloor.determinants.undefined": "organizaciones de piso",
  "models.OrganizationBuilding.singular": "Organización de edificios",
  "models.OrganizationBuilding.plural": "Construyendo organizaciones",
  "models.OrganizationBuilding.determinant.defined": "organización de edificios",
  "models.OrganizationBuilding.determinant.undefined": "una organización de edificios",
  "models.OrganizationBuilding.determinants.defined": "construyendo organizaciones",
  "models.OrganizationBuilding.determinants.undefined": "construyendo organizaciones",
  "models.Organization.singular": "organización",
  "models.Organization.plural": "organizaciones",
  "models.Organization.determinant.defined": "la organizacion",
  "models.Organization.determinant.undefined": "una organización",
  "models.Organization.determinants.defined": "organizaciones",
  "models.Organization.determinants.undefined": "organizaciones",
  "models.Organization.description": "Las organizaciones tienen dos niveles jerárquicos: direcciones y departamentos, y permiten definir la estructura organizativa de la empresa.",
  "models.Organization.properties.id.label": "ID de organización",
  "models.Organization.properties.name.label": "apellido",
  "models.Organization.properties.name.description": "Nombre que definirá la organización",
  "models.Organization.properties.code.label": "código",
  "models.Organization.properties.code.description": "Este código se puede utilizar para contener la codificación de la organización o la clave de identificación mediante software de terceros.",
  "models.Organization.properties.organizationId.label": "ID de gestión",
  "models.Organization.properties.organizationId.description": "Es gracias a este identificador que es posible crear la jerarquía organizativa",
  "models.Organization.properties.organization.label": "Dirección",
  "models.Organization.properties.organizations.label": "Servicios",
  "models.Organization.views.hierarchy.label": "Jerarquía",
  "models.Organization.views.hierarchy.help": "Ver la jerarquía de la organización",
  "models.Organization.views.dq-organization-to-room.label": "Errores en la organización de los espacios",
  "models.Organization.views.dq-organization-to-room.help": "Detectar asociaciones espaciales con organizaciones que no son válidas",
  "models.Organization.views.dq-organization-hierarchy.label": "Errores de jerarquía organizacional",
  "models.Organization.views.dq-organization-hierarchy.help": "Detectar organizaciones que no están en la jerarquía correcta",
  "models.OpenerPostMessageHost.singular": "Host de mensajes para ventana emergente",
  "models.OpenerPostMessageHost.plural": "Hosts de mensajes para ventanas emergentes",
  "models.OpenerPostMessageHost.determinant.defined": "anfitrión de mensajes emergentes",
  "models.OpenerPostMessageHost.determinant.undefined": "un host de mensajes emergentes",
  "models.OpenerPostMessageHost.determinants.defined": "hosts de mensajes emergentes",
  "models.OpenerPostMessageHost.determinants.undefined": "hosts de mensajes emergentes",
  "models.OpenerPostMessageHost.description": "Un host de mensajes emergentes es un elemento que se comunica con una ventana emergente abierta sobre las acciones del plan.",
  "models.OccupancyStatus.singular": "estado de ocupación",
  "models.OccupancyStatus.plural": "estados de ocupación",
  "models.OccupancyStatus.determinant.defined": "el estado de ocupación",
  "models.OccupancyStatus.determinant.undefined": "un estado de ocupación",
  "models.OccupancyStatus.determinants.defined": "estados de ocupación",
  "models.OccupancyStatus.determinants.undefined": "estados de ocupación",
  "models.OccupancyStatus.description": "El estado de ocupación permite identificar en tiempo real el estado de un espacio o puesto de trabajo, por ejemplo si está libre, ocupado o okupado, el estado de ocupación se actualiza día por los objetos conectados presentes en el espacio.",
  "models.OccupancyStatus.properties.id.label": "Identificador del estado de ocupación",
  "models.OccupancyStatus.properties.name.label": "Nombre del estado de ocupación",
  "models.OccupancyStatus.properties.color.label": "color",
  "models.OccupancyStatus.properties.color.description": "Color le permite colorear espacios o estaciones de trabajo en planos según su estado de ocupación",
  "models.OccupancyStatus.properties.code.label": "Código de estado de ocupación",
  "models.OccupancyStatus.properties.code.description": "El código permite identificar y realizar operaciones técnicas sobre el estado de ocupación.",
  "models.Object3dModel.singular": "modelo 3d",
  "models.Object3dModel.plural": "modelos 3d",
  "models.Object3dModel.determinant.defined": "el modelo 3d",
  "models.Object3dModel.determinant.undefined": "un modelo 3d",
  "models.Object3dModel.determinants.defined": "modelos 3d",
  "models.Object3dModel.determinants.undefined": "modelos 3d",
  "models.Object3dModel.description": "El Modelo 3D permite una representación 3D realista de los objetos colocados en el plano; En ausencia de un modelo 3D, los objetos se representan en forma completa en la vista 3D.",
  "models.Object3dModel.properties.origin.label": "Orientación",
  "models.Object3dModel.properties.origin.description": "Use X si el objeto mira hacia la derecha o Y si el objeto mira hacia abajo",
  "models.MapScale.singular": "escala plana",
  "models.MapScale.plural": "escamas planas",
  "models.MapScale.determinant.defined": "escala",
  "models.MapScale.determinant.undefined": "una escalera",
  "models.MapScale.determinants.defined": "las escamas",
  "models.MapScale.determinants.undefined": "escamas",
  "models.MapScale.properties.id.label": "Identificador de escala",
  "models.MapScale.properties.p1.description": "Punto de partida",
  "models.MapScale.properties.p2.description": "Punto de llegada",
  "models.MapScale.properties.name.label": "Nombre de la escala",
  "models.MapScale.properties.name.description": "Para recordar el nombre y reutilizarlo en otros suelos",
  "models.MapScale.properties.length.label": "distancia",
  "models.MapScale.properties.length.description": "La distancia que se muestra en el plano entre los 2 puntos en metros.",
  "models.MapScale.properties.roomTextSize.label": "Tamaño del texto espacial",
  "models.MapScale.properties.roomTextSize.description": "El tamaño del texto de los espacios en el plano para optimizar la visualización.",
  "models.MapScale.properties.workplaceTextSize.label": "Tamaño de texto en objetos",
  "models.MapScale.properties.workplaceTextSize.description": "Tamaño del texto en estaciones de trabajo y objetos en el mapa para optimizar la visualización",
  "models.MapScale.properties.segmentDistanceTextSize.label": "Tamaño del texto del segmento",
  "models.MapScale.properties.segmentDistanceTextSize.description": "El tamaño del texto en las distancias entre los puntos en el mapa para optimizar la visualización",
  "models.MapScale.properties.itemTypeIconSize.label": "Tamaño de los iconos de tipo de objeto",
  "models.MapScale.properties.itemTypeIconSize.description": "El tamaño de los iconos de tipo de objeto en el mapa, el tamaño estará limitado por el tamaño del espacio.",
  "models.MapScale.properties.roomIconSize.label": "Tamaño de los iconos de tipo espacio",
  "models.MapScale.properties.roomIconSize.description": "El tamaño de los iconos en el mapa en espacios en relación con los tipos de espacio.",
  "models.MapScale.properties.strokeWidth.label": "Grosor de la línea",
  "models.MapScale.properties.strokeWidth.description": "Es posible reducir el grosor de las líneas para aumentar la legibilidad del plan",
  "models.MapScale.views.dq-not-used.label": "escalas sin usar",
  "models.MapScale.views.dq-not-used.help": "Ver escalas que no se usan en pisos y se pueden quitar",
  "models.MapScale.views.dq-uniq-name.label": "Nombres propuestos para escalas.",
  "models.MapScale.views.dq-uniq-name.help": "Proporciona nombres únicos para básculas, incluidos los pisos y edificios donde se utilizan.",
  "models.Manufacturer.singular": "Fabricante de tipo de objeto",
  "models.Manufacturer.plural": "Fabricantes de tipos de objetos",
  "models.Manufacturer.determinant.defined": "el fabricante del tipo de objeto",
  "models.Manufacturer.determinant.undefined": "un fabricante del tipo de objeto",
  "models.Manufacturer.determinants.defined": "fabricantes de tipos de objetos",
  "models.Manufacturer.determinants.undefined": "fabricantes típicos de objetos",
  "models.Manufacturer.properties.name.label": "Nombre del proveedor del tipo de objeto",
  "models.Manufacturer.properties.name.description": "Identifica el nombre o la marca del fabricante.",
  "models.Manufacturer.properties.website.label": "Sitio de Internet",
  "models.Manufacturer.properties.website.description": "Dirección del sitio web del fabricante",
  "models.Legend.singular": "Leyenda",
  "models.Legend.plural": "Leyenda",
  "models.Legend.determinant.defined": "la leyenda",
  "models.Legend.determinant.undefined": "una leyenda",
  "models.Legend.determinants.defined": "las leyendas",
  "models.Legend.determinants.undefined": "leyendas",
  "models.Legend.description": "La leyenda le permite configurar las propiedades visibles cuando el plano se guarda como imagen.",
  "models.JupUserCompanyToJupRole.singular": "Rol del usuario de la empresa",
  "models.JupUserCompanyToJupRole.plural": "Roles de usuario de la empresa",
  "models.JupUserCompanyToJupRole.determinant.defined": "el rol del usuario empresarial",
  "models.JupUserCompanyToJupRole.determinant.undefined": "un rol del usuario de la empresa",
  "models.JupUserCompanyToJupRole.determinants.defined": "roles de usuario de la empresa",
  "models.JupUserCompanyToJupRole.determinants.undefined": "roles de usuario de la empresa",
  "models.JupUiView.singular": "Vista de interfaz",
  "models.JupUiView.plural": "Vistas de la interfaz",
  "models.JupUiView.determinant.defined": "la vista de la interfaz",
  "models.JupUiView.determinant.undefined": "una vista de interfaz",
  "models.JupUiView.determinants.defined": "vistas de la interfaz",
  "models.JupUiView.determinants.undefined": "vistas de la interfaz",
  "models.JupUiTenantOperation.singular": "Operación de interfaz para una empresa.",
  "models.JupUiTenantOperation.plural": "Operaciones de interfaz para una empresa",
  "models.JupUiTenantOperation.determinant.defined": "la operación de interfaz para una empresa",
  "models.JupUiTenantOperation.determinant.undefined": "una operación de interfaz para una empresa",
  "models.JupUiTenantOperation.determinants.defined": "operaciones de interfaz para una empresa",
  "models.JupUiTenantOperation.determinants.undefined": "operaciones de interfaz para una empresa",
  "models.JupUiOption.singular": "Opción de interfaz",
  "models.JupUiOption.plural": "Opciones de interfaz",
  "models.JupUiOption.determinant.defined": "opción de interfaz",
  "models.JupUiOption.determinant.undefined": "una opción de interfaz",
  "models.JupUiOption.determinants.defined": "opciones de interfaz",
  "models.JupUiOption.determinants.undefined": "opciones de interfaz",
  "models.JupUiOperation.singular": "Operación de interfaz",
  "models.JupUiOperation.plural": "Operaciones de interfaz",
  "models.JupUiOperation.determinant.defined": "operación de interfaz",
  "models.JupUiOperation.determinant.undefined": "una operación de interfaz",
  "models.JupUiOperation.determinants.defined": "operaciones de interfaz",
  "models.JupUiOperation.determinants.undefined": "operaciones de interfaz",
  "models.JupUiLayout.singular": "visión del plan",
  "models.JupUiLayout.plural": "Visiones del plan",
  "models.JupUiLayout.determinant.defined": "la visión del plan",
  "models.JupUiLayout.determinant.undefined": "una visión del plan",
  "models.JupUiLayout.determinants.defined": "las visiones del plan",
  "models.JupUiLayout.determinants.undefined": "visiones del plan",
  "models.JupRoleToJupUiView.singular": "Asociación de roles con vistas de interfaz",
  "models.JupRoleToJupUiView.plural": "Asociaciones de roles con vistas de interfaz",
  "models.JupRoleToJupUiView.determinant.defined": "asociar el rol con vistas de interfaz",
  "models.JupRoleToJupUiView.determinant.undefined": "una asociación del rol a las vistas de la interfaz",
  "models.JupRoleToJupUiView.determinants.defined": "asociaciones de roles con vistas de interfaz",
  "models.JupRoleToJupUiView.determinants.undefined": "asociaciones de roles con vistas de interfaz",
  "models.JupRoleToJupUiView.properties.canSee.label": "Puede ver la vista",
  "models.JupRoleToJupUiView.properties.canSee.description": "Permitir que el rol vea la vista",
  "models.JupRoleToJupUiOption.singular": "Rol de la asociación a las visiones del plan",
  "models.JupRoleToJupUiOption.plural": "Asociaciones de roles para planificar visiones",
  "models.JupRoleToJupUiOption.determinant.defined": "la asociación del rol con las visiones del plan",
  "models.JupRoleToJupUiOption.determinant.undefined": "una asociación del rol con las visiones del plan",
  "models.JupRoleToJupUiOption.determinants.defined": "asociaciones del rol a las visiones del plan",
  "models.JupRoleToJupUiOption.determinants.undefined": "asociaciones del rol a las visiones del plan",
  "models.JupRoleToJupUiOption.properties.canSee.label": "Puede ver la opción",
  "models.JupRoleToJupUiOption.properties.canSee.description": "Permitir que el rol vea la opción",
  "models.JupRoleToJupUiOperation.singular": "Asociación de roles con operaciones de interfaz",
  "models.JupRoleToJupUiOperation.plural": "Asociación de roles con operaciones de interfaz",
  "models.JupRoleToJupUiOperation.determinant.defined": "asociación del rol con operaciones de interfaz",
  "models.JupRoleToJupUiOperation.determinant.undefined": "una asociación del rol a las operaciones de interfaz",
  "models.JupRoleToJupUiOperation.determinants.defined": "asociaciones de roles con operaciones de interfaz",
  "models.JupRoleToJupUiOperation.determinants.undefined": "asociaciones de roles con operaciones de interfaz",
  "models.JupRoleToJupObjectType.singular": "Asociación de rol a tipo de objeto",
  "models.JupRoleToJupObjectType.plural": "Rol en las asociaciones de tipos de objetos",
  "models.JupRoleToJupObjectType.determinant.defined": "la asociación del rol con el tipo de objeto",
  "models.JupRoleToJupObjectType.determinant.undefined": "una asociación del rol al tipo de objeto",
  "models.JupRoleToJupObjectType.determinants.defined": "las asociaciones del rol al tipo de objeto",
  "models.JupRoleToJupObjectType.determinants.undefined": "asociaciones del rol al tipo de objeto",
  "models.JupRoleToJupObjectType.properties.arCreate.label": "Creación (C)",
  "models.JupRoleToJupObjectType.properties.arCreate.description": "Permitir la creación de entidades",
  "models.JupRoleToJupObjectType.properties.arRead.label": "Lectura (R)",
  "models.JupRoleToJupObjectType.properties.arRead.description": "Permite la lectura de entidades.",
  "models.JupRoleToJupObjectType.properties.arUpdate.label": "Actualizar (U)",
  "models.JupRoleToJupObjectType.properties.arUpdate.description": "Permite la actualización de entidades",
  "models.JupRoleToJupObjectType.properties.arDelete.label": "Supresión (D)",
  "models.JupRoleToJupObjectType.properties.arDelete.description": "Permite la eliminación de entidades",
  "models.JupRole.singular": "Papel",
  "models.JupRole.plural": "Roles",
  "models.JupRole.determinant.defined": "el papel",
  "models.JupRole.determinant.undefined": "un papel",
  "models.JupRole.determinants.defined": "los roles",
  "models.JupRole.determinants.undefined": "roles",
  "models.JupRole.views.matrix.help": "La matriz de seguridad del rol %{name}",
  "models.JupRole.views.matrix.label": "Matriz",
  "models.JupRole.views.help.help": "Resumen de permisos de roles",
  "models.JupRole.views.help.label": "Ayuda",
  "models.JupObjectType.singular": "Tipo de entidad",
  "models.JupObjectType.plural": "Tipos de entidad",
  "models.JupObjectType.determinant.defined": "el tipo de entidad",
  "models.JupObjectType.determinant.undefined": "un tipo de entidad",
  "models.JupObjectType.determinants.defined": "tipos de entidad",
  "models.JupObjectType.determinants.undefined": "tipos de entidad",
  "models.ItemTypePoint.singular": "Tipos de puntos de objetos",
  "models.ItemTypePoint.plural": "Puntos de tipos de objetos",
  "models.ItemTypePoint.determinant.defined": "punto de tipos de objetos",
  "models.ItemTypePoint.determinant.undefined": "un punto de tipos de objetos",
  "models.ItemTypePoint.determinants.defined": "puntos de tipos de objetos",
  "models.ItemTypePoint.determinants.undefined": "puntos de tipos de objetos",
  "models.ItemTypePoint.properties.id.label": "login",
  "models.ItemTypePoint.properties.id.description": "???",
  "models.ItemTypePoint.properties.x.label": "x",
  "models.ItemTypePoint.properties.x.description": "???",
  "models.ItemTypePoint.properties.y.label": "hay",
  "models.ItemTypePoint.properties.y.description": "???",
  "models.ItemTypePoint.properties.externalId.label": "Identificador externo",
  "models.ItemTypePoint.properties.externalId.description": "???",
  "models.ItemTypePoint.properties.itemTypeId.label": "Identificador de tipo de objeto",
  "models.ItemTypePoint.properties.itemTypeId.description": "???",
  "models.ItemTypePoint.properties.sortIndex.label": "Índice de clasificación",
  "models.ItemTypePoint.properties.sortIndex.description": "???",
  "models.ItemTypePoint.properties.itemType.label": "Tipo de objeto",
  "models.ItemTypePoint.properties.itemType.description": "???",
  "models.ItemTypeFamily.singular": "familia de tipos de objetos",
  "models.ItemTypeFamily.plural": "familias de tipos de objeto",
  "models.ItemTypeFamily.determinant.defined": "la familia de tipos de objetos",
  "models.ItemTypeFamily.determinant.undefined": "una familia de tipos de objetos",
  "models.ItemTypeFamily.determinants.defined": "familias de tipos de objetos",
  "models.ItemTypeFamily.determinants.undefined": "familias de tipos de objetos",
  "models.ItemTypeFamily.description": "Le permite visualizar objetos por Familia en los planos y en el inventario en pdf.",
  "models.ItemTypeFamily.properties.id.label": "Identificador de la familia de tipos del objeto.",
  "models.ItemTypeFamily.properties.name.label": "Nombre de la familia de tipos del objeto.",
  "models.ItemTypeFamily.properties.name.description": "El nombre de la familia permite identificarla, este nombre se utiliza para agrupar los tipos de objeto",
  "models.ItemType.singular": "tipo de objeto",
  "models.ItemType.plural": "tipos de objetos",
  "models.ItemType.determinant.defined": "el tipo de objeto",
  "models.ItemType.determinant.undefined": "un tipo de objeto",
  "models.ItemType.determinants.defined": "tipos de objeto",
  "models.ItemType.determinants.undefined": "tipos de objeto",
  "models.ItemType.properties.id.label": "Identificador del tipo del objeto",
  "models.ItemType.properties.id.description": "Identificador del tipo del objeto",
  "models.ItemType.properties.description.label": "Descripción",
  "models.ItemType.properties.description.description": "Permite tener información adicional sobre el tipo de objeto",
  "models.ItemType.properties.name.label": "Nombre del tipo de objeto",
  "models.ItemType.properties.name.description": "Permite identificar rápidamente el tipo de objeto con un nombre completo, lógico y descriptivo; Puedes indicar las dimensiones, por ejemplo: Mesa de reuniones 340x120; Consejo: comience siempre con la dimensión más grande",
  "models.ItemType.properties.zIndex.label": "Índice de altura",
  "models.ItemType.properties.zIndex.description": "Cuanto mayor sea el índice de altura, más se posicionará el objeto por encima de los demás; Puede ser negativo; por ejemplo para un asiento: -1; Consejo: para iconos, establezca el índice en 9",
  "models.ItemType.properties.picture.label": "foto",
  "models.ItemType.properties.picture.description": "Permite cargar la foto del tipo de objeto, que será visible en el inventario en PDF y en la hoja del objeto seleccionado en el plano.",
  "models.ItemType.properties.iconShape.label": "Forma de icono",
  "models.ItemType.properties.iconShape.description": "La forma del icono puede influir en su visualización en el plano",
  "models.ItemType.properties.displayItemReferenceInMap.label": "Mostrar información del plan",
  "models.ItemType.properties.displayItemReferenceInMap.description": "Le permite mostrar el campo “Referencia” de cada objeto en el plano.",
  "models.ItemType.properties.code.label": "código",
  "models.ItemType.properties.code.description": "Le permite acceder rápidamente al tipo de objeto escribiendo el código en la búsqueda durante la creación del objeto.",
  "models.ItemType.properties.icon.label": "Icono",
  "models.ItemType.properties.icon.description": "Le brinda acceso a tres tipos de íconos: 1) íconos “Fontawsome”, visibles marcando “mostrar todo” o buscando por palabra clave en inglés en el cuadro de búsqueda; 2) Íconos “SURFY” destinados a ilustraciones agregadas a planos en ubicaciones estratégicas (Baños, Escaleras, Ascensores, Puntos de Copia, etc.) pero que también pueden usarse como íconos clásicos; 3) Los Iconos “SURFY 2” que enumeran los iconos reglamentarios de la norma de Seguridad ISO 7010; Su forma puede ser redonda, cuadrada o triangular.",
  "models.ItemType.properties.color.label": "color",
  "models.ItemType.properties.color.description": "Se puede elegir entre una preselección o una selección avanzada mediante código Hexa o RGB para respetar su carta gráfica.",
  "models.ItemType.properties.height.label": "Altura",
  "models.ItemType.properties.height.description": "Permite dar la altura en centímetros del tipo de objeto en visión 3d",
  "models.ItemType.properties.price.label": "Precio",
  "models.ItemType.properties.price.description": "El precio de compra del tipo de artículo.",
  "models.ItemType.properties.seatsCount.label": "Numero de asientos",
  "models.ItemType.properties.seatsCount.description": "El número de plazas para este tipo de objetos (sillón, butaca, sofá, etc.) se acumula en Surfy por espacio, planta y edificio",
  "models.ItemType.properties.manufacturer.description": "Le permite identificar el fabricante del tipo de objeto.",
  "models.ItemType.properties.carbonFootprint.label": "huella de carbono",
  "models.ItemType.properties.carbonFootprint.description": "La huella de carbono es el peso en Kilogramos de CO2 que emite cada objeto de este tipo; lo da el fabricante",
  "models.ItemType.properties.iconBackgroundColor.label": "Color de fondo del icono",
  "models.ItemType.properties.iconBackgroundColor.description": "El color de fondo le permite configurar correctamente los iconos multicolores, particularmente los triangulares.",
  "models.ItemType.properties.iconBorderColor.label": "Color del borde del icono",
  "models.ItemType.properties.iconBorderColor.description": "El color del borde le permite configurar correctamente los iconos multicolores, especialmente los triangulares.",
  "models.ItemType.properties.isAffectable.label": "¿Es asociable con una persona?",
  "models.ItemType.properties.isAffectable.description": "Permite saber si el tipo de objeto se puede asociar a una persona",
  "models.ItemType.properties.excludeFromPathfinding.label": "Habilitar navegación",
  "models.ItemType.properties.excludeFromPathfinding.description": "Le permite habilitar la navegación para este tipo de objeto.",
  "models.ItemType.views.shape-editor.help": "Edite la forma del tipo de objeto %{name}",
  "models.ItemType.views.shape-editor.label": "Editar forma",
  "models.ItemType.views.avatar.help": "Ver la forma de %{name}",
  "models.ItemType.views.avatar.label": "Formulario",
  "models.ItemType.views.dq-not-used.label": "No utilizado",
  "models.ItemType.views.dq-not-used.help": "Enumere todos los tipos de objetos no utilizados mediante objetos o mediante tipos de estaciones de trabajo no utilizados",
  "models.ItemToPerson.singular": "Asociación de objeto a persona",
  "models.ItemToPerson.plural": "Asociaciones de objeto a persona",
  "models.ItemToPerson.description": "Permite asociar un objeto a una persona (asiento ergonómico, taquilla)",
  "models.ItemToPerson.determinant.defined": "asociación de objeto a persona",
  "models.ItemToPerson.determinant.undefined": "una asociación de objeto a persona",
  "models.ItemToPerson.determinants.defined": "asociaciones de objeto a persona",
  "models.ItemToPerson.determinants.undefined": "asociaciones de objeto a persona",
  "models.ItemFact.singular": "Movimiento de objetos",
  "models.ItemFact.plural": "Movimientos de objetos",
  "models.ItemFact.determinant.defined": "el movimiento de un objeto",
  "models.ItemFact.determinant.undefined": "un movimiento de objeto",
  "models.ItemFact.determinants.defined": "movimientos de objetos",
  "models.ItemFact.determinants.undefined": "movimientos de objetos",
  "models.Item.singular": "objeto",
  "models.Item.plural": "objetos",
  "models.Item.determinant.defined": "sujeto",
  "models.Item.determinant.undefined": "un objeto",
  "models.Item.determinants.defined": "los objetos",
  "models.Item.determinants.undefined": "los objetos",
  "models.Item.views.dq-item-not-in-workplace-room.label": "Espacios de objetos diferentes de espacios de estaciones de trabajo",
  "models.Item.views.dq-item-not-in-workplace-room.help": "Lista de objetos físicos en estaciones de trabajo que se encuentran en espacios diferentes a los espacios de la estación de trabajo",
  "models.Item.properties.id.label": "Identificador del objeto",
  "models.Item.properties.price.label": "Precio",
  "models.Item.properties.price.description": "El precio de compra del artículo si es diferente del precio del tipo de artículo.",
  "models.Item.properties.reference.label": "Referencia de objeto",
  "models.Item.properties.reference.description": "La referencia de objeto se utiliza para encontrarlo y diferenciar este objeto de otros.",
  "models.Item.properties.code.label": "Código inmovilizador",
  "models.Item.properties.code.description": "El número de activo se utiliza para mantener el número de contabilidad.",
  "models.Item.properties.purchaseDate.label": "Fecha de compra",
  "models.Item.properties.purchaseDate.description": "La fecha de compra del objeto.",
  "models.Item.properties.room.label": "Espacio de objetos",
  "models.Item.properties.itemAffectationsCount.label": "Número de asociaciones a personas.",
  "models.Item.properties.itemAffectationsCount.description": "El número de asociaciones de este objeto con personas.",
  "models.Floor.singular": "piso",
  "models.Floor.plural": "pisos",
  "models.Floor.determinant.defined": "arriba",
  "models.Floor.determinant.undefined": "un piso",
  "models.Floor.determinants.defined": "Las etapas",
  "models.Floor.determinants.undefined": "pisos",
  "models.Floor.description": "Los pisos representan una superficie de trabajo o un nivel de un edificio.",
  "models.Floor.views.map.help": "Plano de planta %{name} en 2d",
  "models.Floor.views.map.label": "Plan 2d",
  "models.Floor.views.3d.help": "Plano de planta %{name} en 3d",
  "models.Floor.views.3d.label": "Plano 3d",
  "models.Floor.views.cuby.help": "Plano de planta %{name} en 3d",
  "models.Floor.views.cuby.label": "3d",
  "models.Floor.views.simple-list.help": "Lista de pisos con pocos detalles",
  "models.Floor.views.simple-list.label": "Lista simple",
  "models.Floor.views.geojson.help": "Ver información en GeoJson",
  "models.Floor.views.geojson.label": "Copiar coordenadas GeoJson",
  "models.Floor.views.standalone-2d-map.help": "El plano de planta %{name} en 2d sin menú",
  "models.Floor.views.standalone-2d-map.label": "solo plano 2d",
  "models.Floor.properties.id.label": "Identificador del piso",
  "models.Floor.properties.name.label": "Nombre del piso",
  "models.Floor.properties.name.description": "El nombre del piso se usa para poder encontrarlo fácilmente.",
  "models.Floor.properties.level.label": "nivel",
  "models.Floor.properties.level.description": "El nivel del piso permite definir su posición con respecto a los otros pisos, por ejemplo, use 0 para la planta baja o -1 para los aparcamientos",
  "models.Floor.properties.backgroundLayout.label": "Plan de fondo",
  "models.Floor.properties.backgroundLayout.description": "El fondo le permite tener un primer nivel de capa para volver a dibujar los planos, debe ser a escala",
  "models.Floor.properties.backgroundLayoutOpacity.label": "Opacidad de fondo",
  "models.Floor.properties.backgroundLayoutOpacity.description": "La opacidad le permite ver más o menos el fondo.",
  "models.Floor.properties.regulatoryCapacity.label": "Capacidad reguladora",
  "models.Floor.properties.regulatoryCapacity.description": "La capacidad reguladora de la plataforma permite gestionar la evacuación de público y empleados",
  "models.Floor.properties.pathfindingGraph.label": "Gráfico de navegación de piso",
  "models.Floor.properties.pathfindingGraph.description": "El gráfico de navegación le permite calcular los caminos más cortos entre puntos del suelo.",
  "models.Floor.properties.workplacesCount.label": "Cantidad de estaciones de trabajo",
  "models.Floor.properties.workplacesCount.description": "El número de estaciones de trabajo en el piso se calcula automáticamente.",
  "models.Floor.properties.workplacesRatio.label": "Proporción de la estación de trabajo",
  "models.Floor.properties.workplacesRatio.description": "La relación de estación de trabajo es el número de metros cuadrados en el piso dividido por el número de estaciones de trabajo, este valor se calcula automáticamente",
  "models.Floor.properties.peopleCount.label": "Numero de asignaciones",
  "models.Floor.properties.peopleCount.description": "El número de personas asignadas al piso, ya sea directamente asignadas a los espacios o a través de una estación de trabajo.",
  "models.Floor.properties.totalPeopleCount.label": "Número de asignaciones totales",
  "models.Floor.properties.totalPeopleCount.description": "El número de personas asignadas al piso, ya sea directamente asignadas a los espacios o a través de una estación de trabajo.",
  "models.Floor.properties.peopleRatio.label": "Ratio de ocupación",
  "models.Floor.properties.peopleRatio.description": "El ratio de ocupación es el número de metros cuadrados de planta dividido por el número de personas asignadas ya sea directamente a los espacios o a través de una estación de trabajo, este valor se calcula",
  "models.Floor.properties.freeWorkplacesCount.label": "Numero de vacantes",
  "models.Floor.properties.freeWorkplacesCount.description": "Número de extensiones libres en el piso",
  "models.Floor.properties.flexWorkplacesCount.label": "Número de posiciones de flexión",
  "models.Floor.properties.flexWorkplacesCount.description": "Número de posiciones de flexión en el suelo",
  "models.Floor.properties.roomsArea.label": "Superficie calificada",
  "models.Floor.properties.roomsArea.description": "La superficie calificada es la suma de las superficies de los espacios",
  "models.Floor.properties.roomsCount.label": "Número de espacios",
  "models.Floor.properties.roomsCount.description": "El número de espacios presentes en este piso",
  "models.Floor.properties.sharedWorkplacesCount.label": "Número de estaciones de trabajo compartidas",
  "models.Floor.properties.sharedWorkplacesCount.description": "Número de puestos de trabajo compartidos en el suelo por al menos 2 personas",
  "models.Floor.properties.sharedWorkplacesRatio.label": "Tasa de puestos de trabajo compartidos",
  "models.Floor.properties.sharedWorkplacesRatio.description": "Tasa de estaciones de trabajo compartidas por al menos 2 personas en comparación con todas las estaciones de trabajo en el piso",
  "models.Floor.properties.flexRatio.label": "Tasa de estaciones de trabajo flexibles",
  "models.Floor.properties.flexRatio.description": "La tasa de estaciones de trabajo flexibles se calcula dividiendo el número de estaciones de trabajo flexibles por el número total de estaciones de trabajo",
  "models.Floor.properties.transitWorkplacesCount.label": "Número de estaciones de trabajo de tránsito",
  "models.Floor.properties.transitWorkplacesCount.description": "Número de puestos de trabajo temporales, estos puestos no se cuentan en puestos libres y no son flexibles",
  "models.Floor.properties.height.label": "Altura del techo",
  "models.Floor.properties.height.description": "La altura bajo el techo del piso.",
  "models.Floor.properties.mapScale.label": "escala del plan",
  "models.Floor.properties.mapScale.description": "La escala nos permite calcular proporcionalmente las áreas y tamaños reales de los objetos.",
  "models.FactType.singular": "Tipo de hecho",
  "models.FactType.plural": "Tipos de hechos",
  "models.FactType.determinant.defined": "el tipo de hecho",
  "models.FactType.determinant.undefined": "un tipo de hecho",
  "models.FactType.determinants.defined": "tipos de hecho",
  "models.FactType.determinants.undefined": "tipos de hecho",
  "models.Fact.singular": "Hecho",
  "models.Fact.plural": "Hechos",
  "models.Fact.determinant.defined": "el hecho",
  "models.Fact.determinant.undefined": "un hecho",
  "models.Fact.determinants.defined": "los hechos",
  "models.Fact.determinants.undefined": "hechos",
  "models.DistributionCostType.singular": "tipo de distribución de costos",
  "models.DistributionCostType.plural": "tipos de distribución de costos",
  "models.DistributionCostType.determinant.defined": "el tipo de distribución de costos",
  "models.DistributionCostType.determinant.undefined": "un tipo de distribución de costos",
  "models.DistributionCostType.determinants.defined": "tipos de distribución de costos",
  "models.DistributionCostType.determinants.undefined": "tipos de distribución de costos",
  "models.DistributionCostType.properties.name.label": "Nombre del tipo de distribución de costos.",
  "models.DistributionCostType.properties.code.labe": "código",
  "models.DistributionCostType.properties.code.description": "El código se usa para poder calcular automáticamente los costos asociados",
  "models.DimensionTypeToBuilding.singular": "Tipo de capa de asignación de edificio",
  "models.DimensionTypeToBuilding.plural": "Tipos de capas de asignación de edificios",
  "models.DimensionTypeToBuilding.determinant.defined": "el tipo de capa de asignación de edificio",
  "models.DimensionTypeToBuilding.determinant.undefined": "un tipo de capa de asignación de edificios",
  "models.DimensionTypeToBuilding.determinants.defined": "los tipos de capas de asignación de edificios",
  "models.DimensionTypeToBuilding.determinants.undefined": "tipos de capas de asignación de edificios",
  "models.DimensionTypeToBuilding.description": "Los tipos de capas de asignación de edificios le permiten definir los diferentes tipos de capas de asignación de edificios. Al asociar un tipo de capa de asignación a un edificio, esto le permite transformar una capa de análisis en una capa de asignación.",
  "models.DimensionType.singular": "Tipo de capa",
  "models.DimensionType.plural": "Tipos de capa",
  "models.DimensionType.determinant.defined": "el tipo de capa",
  "models.DimensionType.determinant.undefined": "un tipo de capa",
  "models.DimensionType.determinants.defined": "tipos de capas",
  "models.DimensionType.determinants.undefined": "tipos de capas por piso",
  "models.DimensionType.properties.id.label": "Identificador del tipo de dimensión.",
  "models.DimensionType.properties.order.label": "Orden de visualización",
  "models.DimensionType.properties.order.description": "Le permite ordenar tipos de capas para mostrarlas",
  "models.DimensionType.properties.name.label": "Nombre del tipo de dimensión.",
  "models.DimensionType.properties.code.label": "Código de tipo de dimensión",
  "models.DimensionType.properties.code.description": "El código identifica el tipo de dimensión, se usa cuando se aplican cálculos específicos al tipo de dimensión",
  "models.DimensionToPerson.singular": "Asignación a capa de asignación",
  "models.DimensionToPerson.plural": "Asignaciones a capas de asignación",
  "models.DimensionToPerson.description": "Le permite asignar una persona a un distrito, territorio o aldea.",
  "models.DimensionToPerson.determinant.defined": "la asignación a la capa de asignación",
  "models.DimensionToPerson.determinant.undefined": "una asignación a la capa de asignación",
  "models.DimensionToPerson.determinants.defined": "asignaciones a capas de asignación",
  "models.DimensionToPerson.determinants.undefined": "asignaciones a capas de asignación",
  "models.DimensionRoom.singular": "Capa de análisis espacial",
  "models.DimensionRoom.plural": "Capas de análisis espacial.",
  "models.DimensionRoom.determinant.defined": "la capa de análisis espacial",
  "models.DimensionRoom.determinant.undefined": "una capa de análisis espacial",
  "models.DimensionRoom.determinants.defined": "capas de análisis espacial",
  "models.DimensionRoom.determinants.undefined": "capas de análisis espacial",
  "models.DimensionRoom.properties.id.label": "Identificador de la capa de análisis espacial.",
  "models.DimensionFloor.singular": "Capa de análisis por piso",
  "models.DimensionFloor.plural": "Análisis de capas por piso",
  "models.DimensionFloor.determinant.defined": "la capa de análisis por piso",
  "models.DimensionFloor.determinant.undefined": "una capa de análisis por piso",
  "models.DimensionFloor.determinants.defined": "capas de análisis por piso",
  "models.DimensionFloor.determinants.undefined": "capas de análisis por piso",
  "models.DimensionFloor.properties.id.label": "Identificador de capa de análisis por piso",
  "models.DimensionFloor.properties.peopleCount.label": "Numero de asignaciones",
  "models.DimensionFloor.properties.peopleCount.description": "El número de personas asignadas, ya sea directamente asignadas a los espacios o a través de una estación de trabajo para este piso.",
  "models.DimensionFloor.properties.totalPeopleCount.label": "Número total de asignaciones indirectas en la sala",
  "models.DimensionFloor.properties.totalPeopleCount.description": "El número total de personas asignadas indirectamente al piso, ya sea directamente asignadas a espacios o a través de una estación de trabajo, pero no a través de las capas de asignación que están solo en el nivel del edificio.",
  "models.DimensionBuilding.singular": "Capa de análisis construyendo",
  "models.DimensionBuilding.plural": "Análisis de capas construyendo",
  "models.DimensionBuilding.determinant.defined": "la capa de análisis mediante la construcción",
  "models.DimensionBuilding.determinant.undefined": "una capa de análisis por edificio",
  "models.DimensionBuilding.determinants.defined": "capas de análisis mediante la construcción",
  "models.DimensionBuilding.determinants.undefined": "capas de análisis mediante la construcción",
  "models.DimensionBuilding.properties.id.label": "Identificador de capa de análisis construyendo",
  "models.DimensionBuilding.properties.dimensionPeopleCount.label": "Número de asignaciones directamente a esta capa de asignación",
  "models.DimensionBuilding.properties.dimensionPeopleCount.description": "El número de personas asignadas a esta capa de asignación para todo el edificio.",
  "models.DimensionBuilding.properties.totalPeopleCount.label": "Número total de asignaciones",
  "models.DimensionBuilding.properties.totalPeopleCount.description": "El número total de personas asignadas, ya sea directamente asignadas a espacios, a través de una estación de trabajo o mediante una capa de asignación.",
  "models.Dimension.singular": "Capa de análisis",
  "models.Dimension.plural": "Capas de análisis",
  "models.Dimension.determinant.defined": "la capa de análisis",
  "models.Dimension.determinant.undefined": "una capa de análisis",
  "models.Dimension.determinants.defined": "capas de análisis",
  "models.Dimension.determinants.undefined": "capas de análisis",
  "models.Dimension.properties.id.label": "Identificador de capa de análisis",
  "models.Dimension.properties.id.description": "Identificador interno de surf",
  "models.Dimension.properties.name.label": "Nombre de la capa de análisis.",
  "models.Dimension.properties.name.description": "Útil para diferenciar la capa entre otras.",
  "models.Dimension.properties.color.label": "color",
  "models.Dimension.properties.color.description": "El color de la capa de análisis permite diferenciar espacios en el plano.",
  "models.Dimension.properties.value.label": "Valor numérico",
  "models.Dimension.properties.value.description": "El valor se puede usar para asociar la capa con un valor numérico para poder realizar estadísticas analíticas",
  "models.Dimension.properties.peopleCount.label": "Número de asignaciones directas",
  "models.Dimension.properties.peopleCount.description": "El número de personas que están asignadas directamente a esta capa de asignación en el edificio",
  "models.Dimension.properties.manualPeopleCount.label": "Número de asignaciones manuales directas",
  "models.Dimension.properties.manualPeopleCount.description": "La cantidad de personas que están asignadas directamente a esta capa de asignación sin considerar asignaciones con personas reales",
  "models.Dimension.properties.totalPeopleCount.label": "Número total de asignaciones directas",
  "models.Dimension.properties.totalPeopleCount.description": "El número total de personas asignadas directamente a esta capa de asignación en el edificio, la suma de las personas reales asignadas y el número de personas asignadas manualmente.",
  "models.Dimension.properties.carbonFootprintPerMeter.label": "Huella de carbono por metro cuadrado",
  "models.Dimension.properties.carbonFootprintPerMeter.description": "La huella de carbono por metro cuadrado calcula la huella de carbono en kilogramos de CO2 de una capa de análisis por metro cuadrado",
  "models.CostCenterFloor.singular": "centro de costos de piso",
  "models.CostCenterFloor.plural": "centros de costos piso",
  "models.CostCenterFloor.determinant.defined": "el centro de costos de los pisos",
  "models.CostCenterFloor.determinant.undefined": "un centro de costo mínimo",
  "models.CostCenterFloor.determinants.defined": "centros de costos de piso",
  "models.CostCenterFloor.determinants.undefined": "centros de costos de piso",
  "models.CostCenterBuilding.singular": "centro de costos de construcción",
  "models.CostCenterBuilding.plural": "centros de costos de construcción",
  "models.CostCenterBuilding.determinant.defined": "el centro de costos de los edificios",
  "models.CostCenterBuilding.determinant.undefined": "un centro de costos de construcción",
  "models.CostCenterBuilding.determinants.defined": "centros de costos de construcción",
  "models.CostCenterBuilding.determinants.undefined": "centros de costos de construcción",
  "models.CostCenter.singular": "centro de coste",
  "models.CostCenter.plural": "Centros de costo",
  "models.CostCenter.description": "El centro de costos permite distribuir espacios dinámicamente para refacturar",
  "models.CostCenter.determinant.defined": "el centro de costo",
  "models.CostCenter.determinant.undefined": "un centro de costos",
  "models.CostCenter.determinants.defined": "Centros de costo",
  "models.CostCenter.determinants.undefined": "Centros de costo",
  "models.CostCenter.properties.id.label": "Identificador del centro de costos",
  "models.CostCenter.properties.name.label": "Nombre del centro de costos",
  "models.CostCenter.properties.color.label": "color",
  "models.CostCenter.properties.distributeByFloor.label": "Distribuir por piso",
  "models.CostCenter.properties.distributeByFloor.description": "Prorratear el espacio utilizado por este centro de costos en el piso a otros centros de costos en el mismo piso",
  "models.CostCenter.properties.distributeByBuilding.label": "Distribuir por edificio",
  "models.CostCenter.properties.distributeByBuilding.description": "Prorratea el espacio utilizado por este centro de costos en el edificio a los otros centros de costos en el edificio.",
  "models.ContentRoleToUserCompany.singular": "Rol de contenido de usuario de la empresa",
  "models.ContentRoleToUserCompany.plural": "Funciones de contenido de usuario de la empresa",
  "models.ContentRoleToUserCompany.determinant.defined": "la función de contenido del usuario empresarial",
  "models.ContentRoleToUserCompany.determinant.undefined": "un rol de contenido de usuario empresarial",
  "models.ContentRoleToUserCompany.determinants.defined": "roles de contenido de usuario de la empresa",
  "models.ContentRoleToUserCompany.determinants.undefined": "roles de contenido de usuario de la empresa",
  "models.ContentRoleToJupUiTenantOperation.singular": "Asociación de funciones de contenido a operaciones de interfaz para una empresa",
  "models.ContentRoleToJupUiTenantOperation.plural": "Asociación de funciones de contenido a operaciones de interfaz para una empresa",
  "models.ContentRoleToJupUiTenantOperation.determinant.defined": "asociar el rol de contenido con operaciones de interfaz para una empresa",
  "models.ContentRoleToJupUiTenantOperation.determinant.undefined": "una asociación del rol de contenido a las operaciones de interfaz para una empresa",
  "models.ContentRoleToJupUiTenantOperation.determinants.defined": "asociaciones de roles de contenido para operaciones de interfaz para una empresa",
  "models.ContentRoleToJupUiTenantOperation.determinants.undefined": "asociaciones de roles de contenido para operaciones de interfaz para una empresa",
  "models.ContentRoleToFloor.singular": "Función de asociación del contenido a los pisos",
  "models.ContentRoleToFloor.plural": "Asociaciones de roles de contenido a pisos",
  "models.ContentRoleToFloor.determinant.defined": "la asociación del papel del contenido a los pisos",
  "models.ContentRoleToFloor.determinant.undefined": "una asociación del papel del contenido a los pisos",
  "models.ContentRoleToFloor.determinants.defined": "las asociaciones del papel del contenido a los pisos",
  "models.ContentRoleToFloor.determinants.undefined": "asociaciones del papel del contenido a los pisos",
  "models.ContentRoleToBuilding.singular": "Asociación de roles de contenido con edificios",
  "models.ContentRoleToBuilding.plural": "Asociaciones de roles de contenido a edificios",
  "models.ContentRoleToBuilding.determinant.defined": "la asociación del papel del contenido a los edificios",
  "models.ContentRoleToBuilding.determinant.undefined": "una asociación del papel del contenido a los edificios",
  "models.ContentRoleToBuilding.determinants.defined": "asociaciones del papel del contenido a los edificios",
  "models.ContentRoleToBuilding.determinants.undefined": "asociaciones del papel del contenido a los edificios",
  "models.ContentRole.singular": "Rol de contenido",
  "models.ContentRole.plural": "Roles de contenido",
  "models.ContentRole.determinant.defined": "el papel del contenido",
  "models.ContentRole.determinant.undefined": "un rol de contenido",
  "models.ContentRole.determinants.defined": "roles de contenido",
  "models.ContentRole.determinants.undefined": "roles de contenido",
  "models.CompanyType.singular": "Tipo de empresa",
  "models.CompanyType.plural": "tipo de negocios",
  "models.CompanyType.determinant.defined": "el tipo de negocio",
  "models.CompanyType.determinant.undefined": "un tipo de negocio",
  "models.CompanyType.determinants.defined": "tipos de negocios",
  "models.CompanyType.determinants.undefined": "tipos de negocios",
  "models.CompanyType.properties.name.label": "Nombre del tipo de negocio",
  "models.Company.singular": "negocios",
  "models.Company.plural": "negocios",
  "models.Company.determinant.defined": "ahora",
  "models.Company.determinant.undefined": "una empresa",
  "models.Company.determinants.defined": "las empresas",
  "models.Company.determinants.undefined": "empresas",
  "models.Company.properties.id.label": "Identificación de la compañía",
  "models.Company.properties.logoPath.label": "logo",
  "models.Company.properties.logoPath.description": "La ruta del logotipo de su empresa",
  "models.Company.properties.iconPath.label": "icono",
  "models.Company.properties.iconPath.description": "El logo de la empresa en cuadrado",
  "models.Company.properties.name.label": "nombre de la empresa",
  "models.Company.properties.workingDaysCount.label": "Número de días laborables por semana",
  "models.Company.properties.workingDaysCount.description": "El número de días laborables a la semana puede ser de 5 para los días laborables, 6 incluido el sábado y 7 incluido el domingo",
  "models.Company.views.usage.label": "Uso de plataformas",
  "models.Company.views.usage.help": "Comprender el uso de las plataformas disponibles",
  "models.Company.views.cards.help": "Vista de negocios de azulejos.",
  "models.Company.views.cards.label": "Azulejos",
  "models.Company.views.dq-fix-inventory.label": "Consistencia del inventario",
  "models.Company.views.dq-fix-inventory.help": "Encuentre y repare inconsistencias de inventario físico y virtual para estaciones de trabajo",
  "models.Company.views.dq-shapes-position.label": "Colocación de formas",
  "models.Company.views.dq-shapes-position.help": "Encuentre y cambie la posición de las formas que están en el plano en un espacio diferente al de la base de datos",
  "models.Company.views.people-info.label": "Estadísticas sobre la creación de tareas por parte de las personas",
  "models.Company.views.people-info.help": "Ver estadísticas de tareas",
  "models.Company.reports.export-all.fileName": "respaldo",
  "models.Company.reports.export-all.help": "Haga una copia de seguridad de todos los datos de Surfy",
  "models.Company.reports.export-all-duplicate.fileName": "duplicación",
  "models.Company.reports.export-all-duplicate.help": "Backup de datos de la empresa para hacer una copia de la plataforma",
  "models.Campus.singular": "campus",
  "models.Campus.plural": "campus",
  "models.Campus.description": "Campus se utiliza para agrupar edificios que se encuentran en la misma ubicación.",
  "models.Campus.determinant.defined": "el campus",
  "models.Campus.determinant.undefined": "un campus",
  "models.Campus.determinants.defined": "campus",
  "models.Campus.determinants.undefined": "campus",
  "models.Campus.views.cards.help": "Vista grupal de edificios.",
  "models.Campus.views.cards.label": "Info",
  "models.Campus.properties.id.label": "Identificación del campus",
  "models.Campus.properties.name.label": "Nombre del campus",
  "models.Campus.properties.name.description": "Nombre del campus",
  "models.Campus.properties.color.label": "color",
  "models.Campus.properties.color.description": "color del campus",
  "models.Campus.properties.externalId.label": "Identificador externo",
  "models.BuildingType.singular": "tipo de edificio",
  "models.BuildingType.plural": "tipos de edificios",
  "models.BuildingType.determinant.defined": "el tipo de edificio",
  "models.BuildingType.determinant.undefined": "un tipo de edificio",
  "models.BuildingType.determinants.defined": "tipos de edificios",
  "models.BuildingType.determinants.undefined": "tipos de edificios",
  "models.BuildingType.properties.id.label": "Identificador del tipo de edificio.",
  "models.BuildingType.properties.name.label": "Nombre del tipo de edificio.",
  "models.BuildingType.properties.name.description": "Nombre del tipo de edificio.",
  "models.BuildingType.properties.code.label": "código",
  "models.BuildingType.properties.code.description": "???",
  "models.BuildingType.properties.externalId.label": "Identificador externo",
  "models.BuildingType.properties.externalId.description": "???",
  "models.Building.singular": "Edificio",
  "models.Building.plural": "edificios",
  "models.Building.determinant.defined": "el edificio",
  "models.Building.determinant.undefined": "un edificio",
  "models.Building.determinants.defined": "los edificios",
  "models.Building.determinants.undefined": "edificios",
  "models.Building.description": "El edificio se utiliza para agrupar las plantas.",
  "models.Building.reports.workplaces.fileName": "Estaciones de trabajo",
  "models.Building.reports.workplaces.help": "Informe de la estación de trabajo del edificio",
  "models.Building.reports.allWorkplaces.fileName": "Estaciones de trabajo con asignaciones",
  "models.Building.reports.allWorkplaces.help": "Informe de todas las estaciones de trabajo del edificio, incluidas las asignaciones.",
  "models.Building.reports.workplaceAffectations.fileName": "Asignaciones de estaciones de trabajo",
  "models.Building.reports.workplaceAffectations.help": "Informe de asignación de estaciones de trabajo del edificio",
  "models.Building.reports.buildingPeople.fileName": "Gente",
  "models.Building.reports.buildingPeople.help": "Informe de afectados en el edificio",
  "models.Building.reports.organizations.fileName": "Organizaciones",
  "models.Building.reports.organizations.help": "Informe de organizaciones de construcción",
  "models.Building.reports.buildingItems.fileName": "inventario",
  "models.Building.reports.buildingItems.help": "Informe de inventario de edificios",
  "models.Building.reports.area.fileName": "Espacios",
  "models.Building.reports.area.help": "Informe de espacios de construcción",
  "models.Building.reports.buildingCleaning.fileName": "Beneficios",
  "models.Building.reports.buildingCleaning.help": "Informe de servicios de limpieza de edificios",
  "models.Building.reports.buildingDimensions.fileName": "Capas de análisis",
  "models.Building.reports.buildingDimensions.help": "Informe de capas de análisis del espacio del edificio",
  "models.Building.views.cards.help": "Vista de edificios de azulejos",
  "models.Building.views.cards.label": "Info",
  "models.Building.views.pictures.help": "Ver edificios con fotos",
  "models.Building.views.pictures.label": "Imágenes",
  "models.Building.views.gmap.help": "Ver los edificios en un mapa",
  "models.Building.views.gmap.label": "Mapa",
  "models.Building.views.cost-distribution-by-cost-center.help": "<b>Claves de distribución</b> y superficie calificada por centro de coste del edificio %{name}",
  "models.Building.views.cost-distribution-by-cost-center.label": "Claves de distribución",
  "models.Building.views.3d-cards.help": "Ver edificios 3d",
  "models.Building.views.3d-cards.label": "3d",
  "models.Building.views.assets.help": "Activos inmobiliarios",
  "models.Building.views.assets.label": "inamovible",
  "models.Building.views.cuby.help": "El plano interactivo <b>en 3D</b> del edificio %{name}",
  "models.Building.views.cuby.label": "Plano 3d",
  "models.Building.views.3d.help": "El plano 3d del edificio %{name} (cuby)",
  "models.Building.views.3d.label": "Plano 3d",
  "models.Building.views.clone.help": "Construyendo <b>escenarios</b> y proyectos %{name}",
  "models.Building.views.clone.label": "Escenarios",
  "models.Building.views.building-ifc.help": "Exportar este edificio a IFC para BIM",
  "models.Building.views.building-ifc.label": "CFI",
  "models.Building.views.zbre-sync.help": "Sincroniza el edificio con la plataforma Zbre",
  "models.Building.views.zbre-sync.label": "Sincronización zbre",
  "models.Building.views.inventory.help": "<b>Inventario</b> de construcción %{name}",
  "models.Building.views.inventory.label": "inventario",
  "models.Building.views.list-simple.help": "Lista de edificios con pocos detalles",
  "models.Building.views.list-simple.label": "Lista simple",
  "models.Building.views.building-3d-gmap.label": "edificio 3d en el plan",
  "models.Building.views.building-3d-gmap.help": "Ver el edificio en 3d en un plano",
  "models.Building.properties.id.label": "Identificador de edificio",
  "models.Building.properties.name.label": "Nombre del edificio",
  "models.Building.properties.name.description": "Nombre del edificio o escenario",
  "models.Building.properties.picture.label": "Foto del edificio",
  "models.Building.properties.picture.description": "Puedes utilizar una foto de tu edificio para encontrarlo rápidamente desde la página de inicio (ver edificios con fotos) o para ilustrar las opiniones de los colaboradores.",
  "models.Building.properties.documents.label": "Documentos relacionados",
  "models.Building.properties.documents.description": "Mantenga un enlace a la ubicación de los documentos asociados con este edificio en su GED",
  "models.Building.properties.securityDeposit.label": "Depósito de seguridad",
  "models.Building.properties.securityDeposit.description": "Monto del depósito depositado al firmar el contrato de arrendamiento",
  "models.Building.properties.buildings.label": "Escenarios de edificios",
  "models.Building.properties.buildings.description": "Escenarios generados desde este edificio.",
  "models.Building.properties.constructionYear.label": "Año de construcción del edificio",
  "models.Building.properties.constructionYear.description": "Año de construcción del edificio que permite medir su obsolescencia",
  "models.Building.properties.parkingSpaceCount.label": "Número de plazas de aparcamiento",
  "models.Building.properties.parkingSpaceCount.description": "Número de plazas de aparcamiento disponibles",
  "models.Building.properties.yearlyParkingRent.label": "Alquiler anual de aparcamientos",
  "models.Building.properties.yearlyParkingRent.description": "Proporción del alquiler asignada al estacionamiento",
  "models.Building.properties.yearlyTaxFees.label": "Importe de las cuotas anuales",
  "models.Building.properties.yearlyTaxFees.description": "Monto total de impuestos",
  "models.Building.properties.yearlyExploitationFees.label": "Gastos operativos anuales",
  "models.Building.properties.yearlyExploitationFees.description": "Monto anual de gastos operativos (ejemplo: agua, electricidad)",
  "models.Building.properties.rentReferenceIndex.label": "Referencia de alquiler",
  "models.Building.properties.rentReferenceIndex.description": "El índice de referencia de alquiler (RRI) se utiliza como base para revisar los alquileres de viviendas vacías o amuebladas.",
  "models.Building.properties.color.label": "color",
  "models.Building.properties.color.description": "El color del edificio se utiliza para definir el color de fondo en las presentaciones de los pisos o del edificio y poder distinguir este edificio de los demás.",
  "models.Building.properties.roomsCount.label": "Número de espacios",
  "models.Building.properties.roomsCount.description": "El número de espacios creados en este edificio.",
  "models.Building.properties.roomsArea.label": "Superficie calificada",
  "models.Building.properties.roomsArea.description": "La superficie calificada representa todas las zonas modeladas en Surfy",
  "models.Building.properties.workplacesCount.label": "Cantidad de estaciones de trabajo",
  "models.Building.properties.workplacesCount.description": "El número de estaciones de trabajo en el edificio se calcula automáticamente.",
  "models.Building.properties.workplacesRatio.label": "Proporción de la estación de trabajo",
  "models.Building.properties.workplacesRatio.description": "El ratio por puesto de trabajo es el número de metros cuadrados del edificio dividido por el número de puestos de trabajo, este valor se calcula automáticamente",
  "models.Building.properties.peopleCount.label": "Numero de asignaciones",
  "models.Building.properties.peopleCount.description": "El número de personas asignadas al edificio, barrios, espacios o estaciones de trabajo.",
  "models.Building.properties.peopleRatio.label": "Ratio de ocupación",
  "models.Building.properties.peopleRatio.description": "El ratio de ocupación es el número de metros cuadrados del edificio dividido por el número de personas asignadas ya sea directamente a los barrios, espacios o puestos de trabajo, este valor se calcula",
  "models.Building.properties.freeWorkplacesCount.label": "Numero de vacantes",
  "models.Building.properties.freeWorkplacesCount.description": "Número de posiciones libres en el edificio",
  "models.Building.properties.flexWorkplacesCount.label": "Número de posiciones de flexión",
  "models.Building.properties.flexWorkplacesCount.description": "Número de puestos de trabajo flexibles en el edificio",
  "models.Building.properties.address.label": "dirección",
  "models.Building.properties.address.description": "La dirección del edificio para localizarlo en el mapa",
  "models.Building.properties.yearlyCondominiumFees.label": "Cargos anuales",
  "models.Building.properties.yearlyCondominiumFees.description": "Importe de los cargos anuales de gestión o copropiedad, por ejemplo",
  "models.Building.properties.yearlyRent.label": "Renta anual",
  "models.Building.properties.yearlyRent.description": "Monto de alquiler anual para este edificio",
  "models.Building.properties.leaseStartDate.label": "Fecha de inicio del arrendamiento",
  "models.Building.properties.leaseStartDate.description": "Fecha de inicio del arrendamiento",
  "models.Building.properties.leaseEndDate.label": "Fecha de finalización del arrendamiento",
  "models.Building.properties.leaseEndDate.description": "Fecha de finalización del arrendamiento",
  "models.Building.properties.purchaseDate.label": "Fecha de compra del edificio",
  "models.Building.properties.purchaseDate.description": "Fecha de compra del edificio",
  "models.Building.properties.buildingId.label": "Identificador de edificio de referencia",
  "models.Building.properties.buildingId.description": "El identificador del edificio de referencia se utiliza en el contexto de la creación de escenarios, el identificador permite la asociación con este edificio",
  "models.Building.properties.building.label": "Edificio original",
  "models.Building.properties.building.description": "El edificio original o de referencia se utiliza en la creación de escenarios, permite identificar el edificio original a partir del cual se creó el edificio.",
  "models.Building.properties.jupUiLayout.label": "Visión del plan por defecto",
  "models.Building.properties.jupUiLayout.description": "Cuando se abre por primera vez un plano de este edificio, se seleccionará la visión predeterminada; después de la primera apertura, se aplicará la visión actual",
  "models.Building.properties.sharedWorkplacesCount.label": "Número de estaciones de trabajo compartidas",
  "models.Building.properties.sharedWorkplacesCount.description": "Número de puestos de trabajo compartidos en el edificio por al menos 2 personas",
  "models.Building.properties.sharedWorkplacesRatio.label": "Tasa de puestos de trabajo compartidos",
  "models.Building.properties.sharedWorkplacesRatio.description": "Tasa de estaciones de trabajo compartidas por al menos 2 personas en comparación con todas las estaciones de trabajo del edificio",
  "models.Building.properties.flexRatio.label": "Tasa de estaciones de trabajo flexibles",
  "models.Building.properties.flexRatio.description": "La tasa de estaciones de trabajo flexibles se calcula dividiendo el número de estaciones de trabajo flexibles por el número total de estaciones de trabajo",
  "models.Building.properties.transitWorkplacesCount.label": "Número de estaciones de trabajo de tránsito",
  "models.Building.properties.transitWorkplacesCount.description": "Número de puestos de trabajo temporales, estos puestos no se cuentan en puestos libres y no son flexibles",
  "models.Building.properties.regulatoryCapacity.label": "Capacidad reguladora",
  "models.Building.properties.regulatoryCapacity.description": "La capacidad reguladora de la plataforma permite gestionar la evacuación de público y empleados",
  "models.Building.properties.dimensionPeopleCount.label": "Número de asignaciones de capas",
  "models.Building.properties.dimensionPeopleCount.description": "El número de personas que están asignadas a las capas de asignación asociadas con este edificio",
  "models.Building.properties.userCompanyOwner.label": "Usuario propietario del edificio",
  "models.Building.properties.userCompanyOwner.description": "El usuario propietario del edificio siempre ve el edificio incluso en presencia de un rol de contenido, en caso de creación de un escenario, el usuario que creó el escenario se convierte en el propietario, el propietario puede cambiarse más adelante",
  "models.AuthentificationConnection.singular": "Inicio de sesión de autenticación",
  "models.AuthentificationConnection.plural": "Conexiones de autenticación",
  "models.AuthentificationConnection.determinant.defined": "la conexión de autenticación",
  "models.AuthentificationConnection.determinant.undefined": "una conexión de autenticación",
  "models.AuthentificationConnection.determinants.defined": "conexiones de autenticación",
  "models.AuthentificationConnection.determinants.undefined": "conexiones de autenticación",
  "models.ApiUserToJupRole.singular": "Asociación de usuario de API con rol",
  "models.ApiUserToJupRole.plural": "Asociaciones de usuarios de API a roles",
  "models.ApiUserToJupRole.determinant.defined": "Asociación de usuario de API con rol",
  "models.ApiUserToJupRole.determinant.undefined": "una asociación de usuario de API al rol",
  "models.ApiUserToJupRole.determinants.defined": "Asociaciones de usuarios de API a roles",
  "models.ApiUserToJupRole.determinants.undefined": "Asociaciones de usuarios de API a roles",
  "models.ApiUserToContentRole.singular": "Asociación del usuario de API con el rol de contenido",
  "models.ApiUserToContentRole.plural": "Asociaciones de usuarios de API a rol de contenido",
  "models.ApiUserToContentRole.determinant.defined": "Asociación de usuario de API con rol de contenido",
  "models.ApiUserToContentRole.determinant.undefined": "una asociación de usuario de API con el rol de contenido",
  "models.ApiUserToContentRole.determinants.defined": "Asociaciones de usuarios de API a la función de contenido",
  "models.ApiUserToContentRole.determinants.undefined": "Asociaciones de usuarios de API a la función de contenido",
  "models.ApiUser.singular": "Usuario de API",
  "models.ApiUser.plural": "Usuarios de API",
  "models.ApiUser.determinant.defined": "Usuario de API",
  "models.ApiUser.determinant.undefined": "un usuario de API",
  "models.ApiUser.determinants.defined": "Usuarios de API",
  "models.ApiUser.determinants.undefined": "Usuarios de API",
  "models.ApiUser.properties.clientSecret.label": "Código secreto",
  "models.ApiUser.properties.clientSecret.description": "la contraseña secreta para su cuenta de API se puede generar y nunca debe divulgarse",
  "ToggleZbreSyncCheckbox.label": "Sincroniza con ocupaciones en tiempo real en Z#ber",
  "ToggleZbreSyncCheckbox.help": "La sincronización permite colorear espacios y puestos de trabajo según los sensores colocados en Z#ber",
  "FloorSpaceSlider.title": "Espacio entre cada piso en centímetros",
  "FloorSelector.title": "Seleccionar pisos",
  "FloorSelector.focus": "Seleccione solo este piso",
  "FloorSelector.selectAll.false": "Seleccionar todos los pisos",
  "FloorSelector.selectAll.true": "Deseleccionar todos los pisos",
  "ToggleEnableMissingFloors.label": "Mostrar pisos fantasma",
  "ToggleEnableMissingFloors.help": "Mostrar pisos fantasma para los pisos faltantes entre el nivel 0 y el piso más alto según los niveles de piso reales",
  "RoomGraphHandler.buttons.generateGraph.label": "Generar el gráfico de orientación.",
  "RoomGraphHandler.buttons.generateGraph.description": "Al generar el gráfico de orientación se calculan los nodos a través de los cuales el buscador de ruta puede encontrar los espacios y muebles. Si se puede seleccionar el espacio original, el gráfico ya se ha generado.",
  "RoomGraphHandler.buttons.selectOriginRoom.label": "Seleccionar espacio original",
  "RoomGraphHandler.buttons.selectOriginRoom.description": "Seleccione un espacio y luego podrá usar esta opción para definirlo como el espacio inicial.",
  "RoomGraphHandler.icons.displayNodes.description": "Mostrar caminos en las habitaciones",
  "RoomGraphHandler.icons.displayBoundingBoxes.description": "Mostrar espacios de exclusión de muebles",
  "RoomGraphHandler.icons.enablePathfinding.description": "Activar el dibujo de ruta desde el espacio de origen con la forma debajo del mouse",
  "RoomGraphHandler.rooms.origin": "espacio original",
  "ThemeModeSwitchMenuItem.dark.label": "Cambiar al modo de luz",
  "ThemeModeSwitchMenuItem.dark.help": "El uso del modo brillante le permite trabajar con un fondo blanco.",
  "ThemeModeSwitchMenuItem.light.label": "Cambiar al modo oscuro",
  "ThemeModeSwitchMenuItem.light.help": "El modo oscuro le permite trabajar con colores oscuros en el fondo para reducir la fatiga visual.",
  "copilot.actions.add.door": "Surfy Copilot acaba de agregar una puerta",
  "generateDocumentation.properties.technicalName": "Nombre técnico",
  "generateDocumentation.properties.belongsTo": "Entidades asociadas (únicas)",
  "generateDocumentation.properties.hasMany": "Entidades asociadas (lista)",
  "generateDocumentation.properties.base": "Propiedades básicas",
  "generateDocumentation.properties.mandatory": "Propiedades obligatorias",
  "help.key1": "Hola %{name}",
  "help.key2": "adiós %{name}"
};
const it = {
  "ImportUpdateOption.label": "Aggiornare",
  "ImportUpdateOption.help": "Aggiorna gli oggetti selezionati",
  "ImportUpdateEntitiesTable.description": "Elenco di oggetti che richiedono un aggiornamento",
  "PropertyTypeErrors.title": "I seguenti valori non esistono per la proprietà <b>%{propertyTypeLabel}</b> in <b>%{objectTypeLabel}</b>",
  "ImportDeleteOption.label": "Cancellare",
  "ImportDeleteOption.help": "Elimina gli oggetti selezionati in Surfy",
  "ImportDeleteEntitiesTable.description": "Elenco di oggetti che richiedono l'eliminazione in Surfy",
  "ImportCreateOption.label": "Creare",
  "ImportCreateOption.help": "Esegui la creazione di oggetti selezionati in Surfy",
  "ImportCreateEntitiesTable.description": "Elenco di elementi che richiedono la creazione",
  "ImportCreateEntitiesTable.open.label": "Visualizza le entità da creare",
  "ImportCreateEntitiesTable.open.help": "Vedi i dettagli delle entità da creare perché ci sono più di 500 linee, per motivi di prestazioni le linee sono nascoste per impostazione predefinita",
  "ImportCreateAllOption.label": "Crea tutto",
  "ImportCreateAllOption.help": "Eseguire la creazione di tutti gli oggetti senza selezionarli singolarmente",
  "entitiesImportType.date.wrongImportFormat": "Il formato della data %{value} non è corretto, il formato previsto è %{excelImportDateFormat}",
  "InfoTabContent.description": "Errori o informazioni notevoli durante l'importazione",
  "InfoTabContent.noChange": "Nessun cambiamento è stato osservato in confronto",
  "InfoTabContent.copyIds": "Copia gli ID entità negli appunti",
  "InfoTabContent.equals.multiple": "%{count} oggetti esistenti e non modificati",
  "InfoTabContent.equals.one": "Un singolo oggetto che esiste già e non è stato modificato",
  "InfoTabContent.open.label": "Vedi i dettagli di importazione",
  "InfoTabContent.open.help": "Vedere i dettagli di importazione per confronti identici",
  "ImportObjectType.tabs.create.label": "Creazione",
  "ImportObjectType.tabs.update.label": "Aggiornare",
  "ImportObjectType.tabs.errors.label": "Informazioni",
  "ImportObjectType.tabs.delete.label": "Cancellazione",
  "ImportObjectType.usedKeys": "La chiave di riconciliazione utilizzata è:",
  "ImportObjectType.errors.noChange": "Nessun cambiamento è stato osservato nel confronto",
  "CompareEntities.buttons.reset.label": "Ricomincia",
  "CompareEntities.buttons.reset.help": "Riavvia l'importazione",
  "ObjectTypeImportKeys.title": "Le chiavi disponibili per riconciliare %{determinants.undefined} nell'ordine che preferisci, se desideri modificare una delle proprietà della chiave devi utilizzare l'identificatore come chiave",
  "ObjectTypeImportScalarProperties.help": "Copia negli appunti",
  "ImportHelpDrawerIconButton.icon.help": "Consulta la guida sull'importazione dei dati per %{determinants.defined}",
  "ImportHelpDrawerIconButton.drawer.title": "Aiuto con l'importazione %{determinants.undefined}",
  "ImportHelpDrawerIconButton.drawer.tabLabel": "Importa aiuto",
  "DownloadObjectTypeImportTemplateFileButton.label": "Scarica il modello di importazione",
  "DownloadObjectTypeImportTemplateFileButton.help": "Scarica un modello di importazione in formato excl con i nomi delle colonne che puoi scegliere",
  "ImportHelpDrawer.tab": "Aiuta a importare %{objectTypeLabel}",
  "BelongsToListItem.clipboard": "Copia il titolo della colonna negli appunti",
  "BelongsToListItem.noKeys": "Nessuna chiave univoca disponibile",
  "BelongsToImportHelp.title": "Tipi di oggetto associati a %{objectTypeLabel} ordinati in base alle chiavi di importazione disponibili",
  "FileDropZone.dropZone": "Sposta e trascina il file di importazione in quest'area o fai clic nell'area per selezionare il file",
  "EntitiesImporter.tabs.file": "File",
  "EntitiesImporter.tabs.copypaste": "Copia e incolla",
  "TextAreaImporter.errors.title": "Errori riscontrati durante l'importazione",
  "TextAreaImporter.textarea.placeholder": "Copia e incolla le tue colonne da excel con il titolo per trovare le proprietà da aggiornare",
  "TextAreaImporter.help": "Utilizza la scheda tra ogni colonna includendo il nome di ciascuna colonna nella prima riga o incollalo direttamente da Excel",
  "ImportOptionsBar.buttons.compare.label": "Confrontare",
  "ImportOptionsBar.buttons.compare.help": "Avviare il confronto con i dati in navigazione per determinare le modifiche da importare",
  "ImportErrors.errors.title": "Errori riscontrati durante l'importazione",
  "DashboardView.tabs.reports": "Rapporti Excel",
  "IconShape.values.circle": "Cerchio",
  "IconShape.values.rectangle": "Rettangolo",
  "IconShape.values.triangle": "Triangolo",
  "EntityDialogSearchList.NoResult": "Nessun risultato trovato, cancella i filtri o modifica la ricerca",
  "FieldTypeEntity.edit": "Modifica %{determinant.defined}",
  "FieldTypeEntity.remove": "Rimuovi %{determinant.defined}",
  "FieldTypeEntity.add": "Aggiungi %{determinant.undefined}",
  "LegendSelector.title": "Seleziona legenda",
  "LegendSelector.labels.default": "Legenda predefinita",
  "HasManyStandaloneNoData.noData": "Non esiste alcun %{targetObjectTypeLabel} associato per %{determinant.defined}",
  "FieldTypeAddress.edit": "Cambia indirizzo",
  "FieldTypeAddress.remove": "Elimina indirizzo",
  "AutocompleteAddress.autocomplete.placeholder": "Trova il tuo indirizzo qui",
  "AddressDialog.search": "Trova l'indirizzo",
  "AddressDialog.validate": "convalidare",
  "FieldTypePassword.icons.copy": "Copia il contenuto della password negli appunti",
  "FieldTypePassword.icons.generate": "Genera una password univoca",
  "FieldTypeModel3d.Remove": "Rimuovi il modello 3D",
  "FieldTypeModel3d.Upload": "Cambia modello 3D",
  "FieldTypeImage.Remove": "Rimuovi immagine",
  "FieldTypeImage.Upload": "Cambia immagine",
  "FieldTypeIcon.Edit": "Cambia icona",
  "FieldTypeIcon.Remove": "rimuovi icona",
  "FieldTypeColor.Remove": "rimuovere il colore",
  "FieldTypeColor.NoColorHelp": "Seleziona un colore",
  "FieldTypeColor.NotHexMatchError": "Il campo non rispetta il formato esadecimale di un colore",
  "CopyImagePathToClipboard.CopyUrl": "Copia URL",
  "ColorBox.NoColorHelp": "Seleziona un colore tramite la tavolozza",
  "ChangeColor.classic": "Seleziona un colore con la piastra avanzata",
  "weight.kilogram": "Chilogrammo",
  "weight.gram": "Grammo",
  "distance.meter": "Metri",
  "distance.centimeter": "centimetri",
  "FieldTypeIndexBoolean.help": "Modificare direttamente il valore",
  "FieldTypeIndexBoolean.values.true": "SÌ",
  "FieldTypeIndexBoolean.values.false": "NO",
  "calculatedProperties.properties.workplacesCount.label": "Numero di postazioni di lavoro",
  "calculatedProperties.properties.workplacesCount.description": "Il numero totale di postazioni di lavoro negli spazi",
  "calculatedProperties.properties.workplacesRatio.label": "Rapporto di postazioni di lavoro",
  "calculatedProperties.properties.workplacesRatio.description": "Il rapporto workstation è il numero di metri quadrati diviso per il numero di workstation",
  "calculatedProperties.properties.peopleCount.label": "Numero di incarichi",
  "calculatedProperties.properties.peopleCount.description": "Il numero di persone interessate, direttamente assegnate agli spazi o attraverso una postazione di lavoro",
  "calculatedProperties.properties.totalPeopleCount.label": "Numero totale di incarichi",
  "calculatedProperties.properties.totalPeopleCount.description": "Il numero totale di persone assegnate, assegnate direttamente agli spazi o tramite una postazione di lavoro",
  "calculatedProperties.properties.peopleRatio.label": "Rapporto di occupazione",
  "calculatedProperties.properties.peopleRatio.description": "L'indice di occupazione è il numero di metri quadrati diviso per il numero di persone assegnate direttamente agli spazi o tramite una postazione di lavoro",
  "calculatedProperties.properties.freeWorkplacesCount.label": "Numero di posti vacanti",
  "calculatedProperties.properties.freeWorkplacesCount.description": "Numero totale di posti vacanti",
  "calculatedProperties.properties.flexWorkplacesCount.label": "Numero di posizioni flessibili",
  "calculatedProperties.properties.flexWorkplacesCount.description": "Numero totale di posizioni flessibili",
  "calculatedProperties.properties.occupancyRate.label": "Tasso di occupazione",
  "calculatedProperties.properties.occupancyRate.description": "Permette di conoscere il tasso di occupazione delle postazioni di lavoro, è il numero di persone interessate diviso il numero di postazioni di lavoro",
  "calculatedProperties.properties.expansionRatio.label": "Tasso di crescita eccessiva",
  "calculatedProperties.properties.expansionRatio.description": "Consente di conoscere il tasso di utilizzo delle postazioni, è l'inverso del numero di persone interessate diviso per il numero delle postazioni",
  "calculatedProperties.properties.roomsArea.label": "Zona qualificata",
  "calculatedProperties.properties.roomsArea.description": "La superficie qualificata è la somma delle superfici dei vani",
  "calculatedProperties.properties.roomsCount.label": "Numero di spazi",
  "calculatedProperties.properties.roomsCount.description": "Il numero totale di spazi",
  "calculatedProperties.properties.sharedWorkplacesCount.label": "Numero di postazioni condivise",
  "calculatedProperties.properties.sharedWorkplacesCount.description": "Numero totale di postazioni condivise da almeno 2 persone",
  "calculatedProperties.properties.sharedWorkplacesRatio.label": "Tasso di postazioni di lavoro condivise",
  "calculatedProperties.properties.sharedWorkplacesRatio.description": "Percentuale di postazioni condivise da almeno 2 persone rispetto a tutte le postazioni",
  "calculatedProperties.properties.flexRatio.label": "Tasso di postazioni di lavoro flessibili",
  "calculatedProperties.properties.flexRatio.description": "La tariffa per workstation flessibili viene calcolata dividendo il numero di workstation flessibili per il numero totale di workstation",
  "calculatedProperties.properties.transitWorkplacesCount.label": "Numero di postazioni di transito",
  "calculatedProperties.properties.transitWorkplacesCount.description": "Numero di postazioni temporanee, queste posizioni non sono conteggiate nelle posizioni libere e non sono in flex",
  "calculatedProperties.properties.seatsCount.label": "Numero di posti",
  "calculatedProperties.properties.seatsCount.description": "Il numero totale di posti",
  "calculatedProperties.properties.seatsPeopleRatio.label": "Tariffa posti a sedere in base all'assegnazione",
  "calculatedProperties.properties.seatsPeopleRatio.description": "Il numero di posti per persona interessata",
  "calculatedProperties.properties.carbonFootprint.label": "Impronta ecologica",
  "calculatedProperties.properties.carbonFootprint.description": "L'impronta di carbonio è il numero di CO2 emesse",
  "calculatedProperties.properties.totalCapacityCount.label": "Capacità totale",
  "calculatedProperties.properties.totalCapacityCount.description": "La capacità totale dei posti è la somma del numero di posti e della capacità dei non posti a livello dello spazio.",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.label": "Tasso di posti per postazione di lavoro",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.description": "La tariffa dei posti per postazione è la capienza totale degli spazi divisa per il numero delle postazioni, questo ci permette di capire la tariffa dei posti in base al numero delle postazioni",
  "DeleteMultipleDialog.title": "Rimuovi %{determinants.undefined}",
  "DeleteMultipleDialog.content": "Stai per eliminare <b>%{determinants.undefined}</b> , questa azione non è reversibile e potrebbe avere un impatto, sei sicuro di voler eseguire questa azione?",
  "DeleteMultipleDialog.cancel.label": "per cancellare",
  "DeleteMultipleDialog.cancel.help": "Annulla eliminazione",
  "DeleteMultipleDialog.delete.label": "Cancellare",
  "DeleteMultipleDialog.delete.help": "Elimina definitivamente %{determinants.defined}",
  "DownloadTableToExcelIconButton.help": "Esporta %{determinants.defined} selezionato",
  "DeleteMultipleEntities.help": "Elimina %{determinants.defined} selezionati",
  "EntityCreateModeSelect.open-on-create.text": "Aperto dopo la creazione",
  "EntityCreateModeSelect.open-on-create.help": "Una volta creato il tuo oggetto, verrai reindirizzato alla pagina di visualizzazione dell'oggetto per vederne le proprietà e le associazioni",
  "EntityCreateModeSelect.keep-creating.text": "continua a creare",
  "EntityCreateModeSelect.keep-creating.help": "Questa opzione consente di continuare a creare più oggetti di seguito mantenendo le proprietà della vecchia creazione",
  "EntityCreateModeSelect.edit-on-create.text": "Modifica dopo la creazione",
  "EntityCreateModeSelect.edit-on-create.help": "Una volta creato l'oggetto, verrai reindirizzato alla pagina di modifica dell'oggetto per completarne le proprietà e le associazioni",
  "TableView.options": "Opzioni",
  "ErrorImpossibleToFindTheEntity.text": "Impossibile trovare %{determinant.defined} ricercato",
  "ErrorImpossibleToFindTheEntities.text": "Impossibile trovare %{determinants.defined} cercato",
  "EntityPropertyTypesMandatoryNotRespected.title": "Le seguenti proprietà sono obbligatorie",
  "entity.properties.mandatory": "La proprietà %{name} è obbligatoria.",
  "entity.properties.calculated": "La proprietà %{name} viene calcolata automaticamente.",
  "entity.properties.readonly-lock": "La proprietà %{name} è di sola lettura e non può essere modificata da questa pagina.",
  "EntityHasManyProperties.associations.others": "Associazioni per %{determinant.defined}",
  "EntityHasManyProperties.associations.reporting": "Associazioni di reporting per %{determinant.defined}",
  "EntityHasManyProperties.associations.security": "Associazioni di sicurezza per %{determinant.defined}",
  "EntitiesView.NoItem": "Non esiste alcun %{objectType} , puoi creare il tuo primo %{objectType} utilizzando il pulsante qui sotto",
  "DeleteDialog.title": "Rimuovi %{determinant.undefined}",
  "DeleteDialog.content": "Stai per eliminare <b>%{determinant.undefined}</b> , questa azione non è reversibile e potrebbe avere un impatto, sei sicuro di voler eseguire questa azione?",
  "DeleteDialog.cancel.label": "per cancellare",
  "DeleteDialog.cancel.help": "Annulla eliminazione",
  "DeleteDialog.delete.label": "Cancellare",
  "DeleteDialog.delete.help": "Elimina definitivamente %{determinant.defined}",
  "ExportQueryNodeToFileButton.help.list": "Scarica in excel %{determinants.defined}",
  "entity.excel.headers.count": "%{label} :Numero",
  "entity.properties.externalId.label": "Chiave esterna",
  "entity.properties.externalId.description": "Questo campo può essere utilizzato per contenere la chiave di corrispondenza in un altro software",
  "entity.properties.createdAt.label": "Data di creazione",
  "entity.properties.createdAt.description": "Data di creazione in Surfy, ti permette di conoscere la storia della creazione in Surfy",
  "entity.properties.userCompanyCreatedBy.label": "Creato dall'utente",
  "entity.properties.userCompanyCreatedBy.description": "Creato da questo utente in Surfy, ti permette di conoscere la cronologia della creazione in Surfy",
  "entity.properties.userCompanyCreatedById.label": "ID dell'utente che ha creato",
  "entity.properties.userCompanyCreatedById.description": "Crea dall'identificatore di questo utente in Surfy, ti permette di conoscere la cronologia della creazione in Surfy",
  "entity.properties.userCompanyUpdatedById.label": "ID dell'utente che ha modificato",
  "entity.properties.userCompanyUpdatedById.description": "Aggiornato dall'identificatore di questo utente in Surfy, permette di conoscere la cronologia della creazione in Surfy",
  "entity.properties.userCompanyUpdatedBy.label": "Aggiornato dall'utente",
  "entity.properties.userCompanyUpdatedBy.description": "Aggiornato da questo utente in Surfy, permette di conoscere la cronologia delle modifiche in Surfy",
  "entity.properties.updatedAt.label": "Data aggiornata",
  "entity.properties.updatedAt.description": "Data di aggiornamento in Surfy, permette di conoscere la cronologia delle modifiche",
  "entity.delete.button.label": "Cancellare",
  "entity.delete.button.help": "Elimina %{determinant.defined} %{name}",
  "entity.cancel": "per cancellare",
  "entity.see.label": "Vedere",
  "entity.see.help": "Vedi %{determinant.defined} %{name}",
  "entity.views.dataquality.help": "Rapporti e azioni per la qualità dei dati per %{determinants.defined}",
  "entity.views.dataquality.label": "Qualità dei dati",
  "entity.views.list.help": "Elenco %{determinants.defined}",
  "entity.views.list.label": "Elenco",
  "entity.views.import.help": "Importa %{determinants.undefined}",
  "entity.views.import.label": "Importare",
  "entity.views.details.help": "Vedi %{determinant.defined} %{name}",
  "entity.views.details.label": "Vedere",
  "entity.views.create.help": "Crea %{determinant.undefined}",
  "entity.views.create.label": "Creare",
  "entity.views.edit.help": "Modifica %{determinant.defined} %{name}",
  "entity.views.edit.label": "Modificare",
  "entity.views.dashboard.help": "Dashboard per %{determinant.defined} %{name}",
  "entity.views.dashboard.label": "Pannello di controllo",
  "entity.create.validate.help": "Convalida la creazione per %{determinant.defined}",
  "entity.create.validate.label": "Convalida la creazione",
  "entity.create.button.help": "Inizia la creazione per %{determinant.defined}",
  "entity.create.button.label": "Crea %{determinant.defined}",
  "entity.create.association.help": "Inizia la creazione per %{determinant.undefined}",
  "entity.create.association.label": "Crea %{determinant.undefined}",
  "entity.update.button.label": "Salvaguardare",
  "entity.update.button.help": "Risparmia %{determinant.defined} %{name}",
  "entity.createAndAssociate.button.label": "Crea e associa",
  "entity.createAndAssociate.button.help": "Crea e associa %{determinant.undefined}",
  "entity.associate.button.label": "Socio",
  "entity.associate.button.help": "Associato %{determinant.undefined}",
  "entity.back": "Ritorno",
  "WorkCanvas.Options.ZoomCanvasOption.label.enable": "Abilita lente d'ingrandimento intorno al mouse",
  "WorkCanvas.Options.ZoomCanvasOption.label.disable": "Disabilita la lente d'ingrandimento intorno al mouse",
  "WorkCanvas.Options.ZoomCanvasOption.help.enable": "L'attivazione della lente d'ingrandimento permette di avere una visione d'insieme di un'area o di un pavimento e di vedere il comportamento del mouse in modo preciso",
  "WorkCanvas.Options.ZoomCanvasOption.help.disable": "Ferma la lente d'ingrandimento del mouse",
  "WorkCanvas.Options.AddSegmentPointOption.label.enable": "Aggiungere un vertice su un segmento",
  "WorkCanvas.Options.AddSegmentPointOption.label.disable": "Smetti di aggiungere un vertice su un segmento",
  "WorkCanvas.Options.AddSegmentPointOption.help.enable": "L'aggiunta di un vertice su un segmento consente di posizionare un punto ovunque senza tener conto degli altri punti",
  "WorkCanvas.Options.AddSegmentPointOption.help.disable": "Smetti di creare vertici sui segmenti",
  "WorkCanvas.Options.AddSegmentPointOption.description": "Seleziona uno spazio per poter creare un vertice su uno dei segmenti",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.enable": "Abilita l'orientamento della creazione del vertice inverso",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.disable": "Disabilita l'inversione dell'orientamento della creazione dei vertici",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.enable": "L'attivazione dell'inversione dell'orientamento di creazione dei vertici permette di cambiare la direzione di creazione dei vertici",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.disable": "Disabilita l'inversione per trovare la direzione iniziale di creazione dei vertici",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.enable": "Abilita l'inversione ad angolo retto per la creazione del vertice",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.disable": "Disabilita l'inversione ad angolo retto per la creazione del vertice",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.enable": "Abilita capovolgi consente di utilizzare l'angolo retto durante la creazione di vertici sull'altro segmento",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.disable": "La disattivazione dell'inversione consente di utilizzare l'angolo retto sul segmento iniziale",
  "LoadingSvgCircle.pleaseWait": "Attendi durante la sincronizzazione",
  "WorkCanvas.Options.AddRoomPointOption.label.enable": "Aggiungi vertice",
  "WorkCanvas.Options.AddRoomPointOption.label.disable": "Smetti di aggiungere un vertice",
  "WorkCanvas.Options.AddRoomPointOption.help.enable": "L'aggiunta di un vertice consente di rielaborare una forma con maggiore precisione",
  "WorkCanvas.Options.AddRoomPointOption.help.disable": "Smetti di creare vertici",
  "WorkCanvas.Options.SplitPolygoneOption.label": "Spazio separato",
  "WorkCanvas.Options.SplitPolygoneOption.help": "Crea 2 spazi da un altro spazio scegliendo 2 vertici",
  "WorkCanvas.Options.SplitRoomPointOption.help": "Il vertice diviso consente di riutilizzare più vertici per ogni segmento e quindi di creare spazi separati",
  "WorkCanvas.Options.SplitRoomPointOption.label": "Vertice separato",
  "WorkCanvas.Options.MergeRoomPointsOption.help": "Unisci vertici consente di riutilizzare lo stesso vertice per spazi diversi",
  "WorkCanvas.Options.MergeRoomPointsOption.label": "Unisci i vertici",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.help": "Rimuovere i vertici dallo spazio",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.label": "Elimina i vertici selezionati",
  "WorkCanvas.Options.ZoomOnEdgePoints.help": "Ingrandisci uno o più punti per poter lavorare in silenzio",
  "WorkCanvas.Options.ZoomOnEdgePoints.label": "Zoom su punti",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.enable": "Sposta il tipo di oggetto",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.disable": "Fermati",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.enable": "Sposta il tipo di oggetto sul piano",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.disable": "Interrompi lo spostamento del tipo di oggetto",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.help": "Rimuovere il tipo di oggetto dal tipo di workstation",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.label": "Rimuovi il tipo di oggetto",
  "WorkCanvas.Options.DeleteItemTypePointsOption.help": "Elimina i vertici del tipo di oggetto",
  "WorkCanvas.Options.DeleteItemTypePointsOption.label": "Elimina i vertici selezionati",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.enable": "Aggiungi una forma",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.disable": "Smetti di aggiungere la forma",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.enable": "Aggiungi una forma per un tipo di oggetto sulla pianta",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.disable": "Smetti di creare la forma",
  "WorkCanvas.Options.AddItemTypeShapeSaveOption.help": "Salva il tipo di oggetto in fase di creazione",
  "WorkCanvas.Options.AddItemTypePointOption.label.enable": "Aggiungi vertice",
  "WorkCanvas.Options.AddItemTypePointOption.label.disable": "Smetti di aggiungere un vertice",
  "WorkCanvas.Options.AddItemTypePointOption.help.enable": "L'aggiunta di un vertice consente di rielaborare una forma con maggiore precisione",
  "WorkCanvas.Options.AddItemTypePointOption.help.disable": "Smetti di creare vertici",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.enable": "Sposta gli spazi",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.disable": "Smetti di viaggiare",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.enable": "Abilita lo spostamento degli spazi sulla planimetria",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.disable": "Smetti di spostare gli spazi",
  "WorkCanvas.Options.ToggleMoveRoomOption.description": "Una volta attivato, seleziona uno spazio e puoi spostarlo",
  "WorkCanvas.Options.DuplicateShapesOption.label": "Forme duplicate",
  "WorkCanvas.Options.DuplicateShapesOption.help": "Forme duplicate senza proprietà per creare rapidamente oggetti o workstation sulla planimetria",
  "CancelDuplicateShapsToRoomMouse.help": "Annulla forme duplicate",
  "ToggleWorkplaceFreeConditionTypeIconButton.or": "Visualizza le postazioni libere per tutti i giorni richiesti",
  "ToggleWorkplaceFreeConditionTypeIconButton.and": "Vedi le postazioni libere per almeno uno dei giorni richiesti",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.false": "Post senza colore %{day}",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.true": "Smettila di colorare i post gratuiti %{day}",
  "FreeWorkplacesDayList.title": "Vedi posti liberi %{days}",
  "FreeWorkplacesDayList.conditions.and": "E",
  "FreeWorkplacesDayList.conditions.or": "O",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.enable": "Colora i posti di blocco",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.disable": "Smetti di colorare i posti di incrocio",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.enable": "Vedi sulla planimetria le postazioni di lavoro di passaggio",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.disable": "Non vedere più le workstation di passaggio in modo diverso sul piano",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.enable": "Colore post condivisi",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.disable": "Smetti di colorare i post condivisi",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.enable": "Visualizza sulla planimetria le postazioni di lavoro condivise da almeno 2 persone",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.disable": "Non vedere più le workstation condivise in modo diverso sul piano",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.enable": "Oggetti colorati senza associazione",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.disable": "Smetti di colorare gli oggetti senza associazione",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.enable": "Visualizza gli oggetti gratuiti sulla mappa",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.disable": "Gli oggetti gratuiti non vengono più visualizzati in modo diverso sulla mappa",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.enable": "Colora le posizioni prenotabili",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.disable": "Smetti di colorare le posizioni prenotabili",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.enable": "Visualizza sulla planimetria colori le postazioni prenotabili",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.disable": "Non vediamo più le postazioni di lavoro prenotabili in modo diverso in termini di",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.enable": "Posizioni libere da colorare",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.disable": "Smetti di colorare post gratuiti",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.enable": "Visualizza le posizioni libere sulla mappa",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.disable": "Non vedere più le posizioni libere in modo diverso sul piano",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.enable": "Colora i pali in flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.disable": "Smetti di colorare i post in flex",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.enable": "Guarda le posizioni flessibili sulla mappa",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.disable": "Non vedere più le posizioni flessibili in modo diverso sul piano",
  "WorkCanvas.Options.CalibrateLayoutOption.help.enable": "Calibrare la pianta permette di ingrandire o ridurre le dimensioni di tutti gli spazi o di spostarli tutti sulla pianta",
  "WorkCanvas.Options.CalibrateLayoutOption.help.disable": "Smetti di calibrare il piano",
  "WorkCanvas.Options.CalibrateLayoutOption.label.enable": "Calibrare il piano",
  "WorkCanvas.Options.CalibrateLayoutOption.label.disable": "Smetti di calibrare il piano",
  "CalibrateLayoutDrawer.title": "Calibrare il piano",
  "CalibrateLayoutDrawer.options.mapScale.label": "Allinea la scala del piano",
  "CalibrateLayoutDrawer.options.mapScale.help": "Applica il fattore di scala agli elementi della scala (lunghezza e dimensione dei testi)",
  "CalibrateLayoutDrawer.options.inputs.scale.label": "Fattore di scala",
  "CalibrateLayoutDrawer.options.inputs.step.label": "Valore di traduzione",
  "CalibrateLayoutDrawer.options.inputs.translate.x.label": "Asse X",
  "CalibrateLayoutDrawer.options.inputs.translate.y.label": "Asse Y",
  "CalibrateLayoutDrawer.options.reduce.label": "Ridurre",
  "CalibrateLayoutDrawer.options.save.label": "registrare",
  "CalibrateLayoutDrawer.options.save.help": "Salva la calibrazione per pianificare",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.enable": "Attiva la visualizzazione delle icone sulla planimetria in 2d",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.disable": "Disabilita la visualizzazione delle icone sulla mappa",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.enable": "Le icone associate alle tipologie di vani facilitano la visualizzazione delle tipologie di vani in pianta",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.disable": "Visualizza le informazioni sullo spazio",
  "WorkCanvasToggleOptionHelp.shortcut": "Scorciatoia da tastiera: <b>%{shortcut}</b>",
  "WorkCanvasShortcutTooltipHelp.help": "Scorciatoia da tastiera: <b>%{shortcut}</b>",
  "WorkCanvas.Options.ZoomOutOption.label": "Rimpicciolisci la mappa",
  "WorkCanvas.Options.ZoomOutOption.help": "Rimpicciolire la pianta centrando la posizione del mouse",
  "WorkCanvas.Options.ZoomOutOption.description": "È possibile utilizzare la rotellina del mouse e il touchpad per ridurre lo zoom",
  "WorkCanvas.Options.ZoomOnMousePosition.help": "Zoom sulla posizione del mouse per poter lavorare con maggiore precisione su un'area",
  "WorkCanvas.Options.ZoomOnMousePosition.label": "Zoom alla posizione del mouse",
  "WorkCanvasLoadingIcon.title": "Caricamento del piano",
  "WorkCanvas.Options.ZoomOnItemsOption.help": "Ingrandisci uno o più oggetti per poter lavorare con maggiore precisione",
  "WorkCanvas.Options.ZoomOnItemsOption.label": "Zoom sulla selezione",
  "WorkCanvas.Options.ZoomOnDimensionsOption.label": "Ingrandisci i livelli di assegnazione",
  "WorkCanvas.Options.ZoomOnDimensionsOption.help": "Ingrandisci direttamente i livelli di assegnazione in cui puoi prenotare il piano",
  "WorkCanvas.Options.ZoomInOption.label": "Ingrandisci la mappa",
  "WorkCanvas.Options.ZoomInOption.help": "Ingrandisci il piano centrando verso l'alto a sinistra dello schermo",
  "WorkCanvas.Options.ZoomInOption.description": "È possibile utilizzare la rotellina del mouse e il touchpad per eseguire lo zoom",
  "WorkCanvas.Options.ToggleSelectModeOption.help.enable": "Ottieni le opzioni del piano per poter ingrandire o vedere i dettagli delle forme e attivare le scorciatoie da tastiera, puoi anche fare clic nel piano per attivare la manipolazione",
  "WorkCanvas.Options.ToggleSelectModeOption.help.disable": "???",
  "WorkCanvas.Options.ToggleSelectModeOption.label.enable": "Inizia a manipolare lo spazio di lavoro",
  "WorkCanvas.Options.ToggleSelectModeOption.label.disable": "Interrompi la manipolazione dell'area di lavoro",
  "WorkCanvas.Options.ToggleSelectModeOption.description": "Puoi selezionare più forme tenendo premuto <b>MAIUSC</b> e facendo clic sulle forme",
  "WorkCanvas.Options.ToggleEditModeOption.label.enable": "Attiva la modalità di modifica del piano",
  "WorkCanvas.Options.ToggleEditModeOption.label.disable": "Disabilita la modalità di modifica del piano",
  "WorkCanvas.Options.ToggleEditModeOption.help.enable": "Attivare la modalità di modifica del piano permette di creare e spostare forme o creare spazi",
  "WorkCanvas.Options.ToggleEditModeOption.help.disable": "Disattiva la modalità di modifica del piano per tornare alla modalità di lettura del piano",
  "WorkCanvas.Options.ToggleEditModeOption.description": "Quando si ruotano oggetti e postazioni, di default viene applicato un angolo di 45°, per disattivarlo utilizzare il tasto <b>MAIUSC</b> della tastiera",
  "WorkCanvas.Options.FitToViewOption.label": "Centrare la mappa per vedere tutto",
  "WorkCanvas.Options.FitToViewOption.help": "Consente di avere una panoramica del piano",
  "HeatMapSelection.title": "Colora gli spazi con una mappa termica per capire le densità, le mappe termiche per il momento non sono esportabili in immagine",
  "HeatMapSelection.heatmaps.seatsCount.label": "Densità di posti a sedere",
  "HeatMapSelection.heatmaps.seatsCount.description": "Colora gli spazi in base al numero di posti",
  "HeatMapSelection.heatmaps.workplacesCount.label": "Densità della postazione di lavoro",
  "HeatMapSelection.heatmaps.workplacesCount.description": "Colora gli spazi in base al numero di postazioni di lavoro",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.label": "Densità degli incarichi alle postazioni di lavoro",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.description": "Colora gli spazi in base al numero di incarichi di postazione di lavoro",
  "HeatMapSelection.heatmaps.carbonFootprintCount.label": "Densità dell'impronta di carbonio dei mobili",
  "HeatMapSelection.heatmaps.carbonFootprintCount.description": "Colora gli spazi in base all'impronta di carbonio dei mobili",
  "FurnituresSelectionDragZone.help": "Sposta gruppo",
  "FurnituresSelection.move": "Sposta l'intero gruppo",
  "WorkCanvas.Options.TextAnchorOption.label.enable": "Imposta la posizione del testo visualizzato",
  "WorkCanvas.Options.TextAnchorOption.label.disable": "Interrompi la gestione del testo visualizzato",
  "WorkCanvas.Options.TextAnchorOption.help.enable": "Sposta il testo visualizzato",
  "WorkCanvas.Options.TextAnchorOption.help.disable": "Interrompi lo spostamento del testo visualizzato",
  "TextAnchorDrawer.title": "Modifica la posizione del testo visualizzato per %{determinant.defined} %{name}",
  "WorkCanvas.Options.TextAnchorDrawer.label.enable": "Sposta il testo visualizzato",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.label": "Personalizza la posizione del testo",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.help": "Consente di attivare la personalizzazione della posizione del testo del piano",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.label": "Abilita la visualizzazione dell'ancora",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.help": "Permette di attivare la visualizzazione del segmento e del punto di ancoraggio per questo spazio",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.label": "Reimposta la posizione del testo",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.help": "Questa opzione riporta la posizione del testo per questo spazio nella sua posizione originale",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.label": "Ripristina la posizione dell'ancora",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.help": "Questa opzione riporta la posizione di ancoraggio di questo spazio nella sua posizione originale",
  "ShapeTextAnchorDrawer.empty": "Seleziona una forma compatibile per spostare il testo visualizzato",
  "IconsPicker.DisplayAll.text": "Mostra tutto",
  "IconsPicker.DisplayAll.help": "Tieni presente che il caricamento potrebbe richiedere del tempo.",
  "IconsPicker.close": "Chiudi la selezione dell'icona",
  "IconPickerSearch.SearchPlaceholder": "Cerca un'icona con almeno 3 lettere",
  "EntitiesAutocomplete.searchEmpty.help.false": "Seleziona %{determinants.defined} senza %{objectTypeName}",
  "EntitiesAutocomplete.searchEmpty.help.true": "Ritorna alla modalità di ricerca standard",
  "SearchFieldString.searchEmpty.help.false": "Cerca elementi vuoti o senza valore",
  "SearchFieldString.searchEmpty.help.true": "Riattiva la ricerca standard",
  "SearchFilters.buttons.clear.label": "Cancella tutti i filtri",
  "SearchFilters.buttons.clear.help": "Cancella tutti i filtri e ripristinali al loro stato iniziale per assicurarti di poter vedere tutte le entità disponibili",
  "RightSearchFilterDrawer.filter": "Filtra %{determinants.defined}",
  "RightSearchFilterDrawer.tabLabel": "Filtro",
  "RightSearchFilterDrawer.buttons.clear.label": "Cancella tutti i filtri",
  "RightSearchFilterDrawer.buttons.clear.help": "Cancella tutti i filtri e ripristinali al loro stato iniziale per assicurarti di poter vedere tutte le entità disponibili",
  "PropertSelectorDrawer.help": "Seleziona le proprietà che desideri visualizzare nella tabella",
  "PropertSelectorDrawer.options.reset.label": "Ripristina selezione",
  "PropertSelectorDrawer.options.reset.help": "Ripristina la selezione delle proprietà al loro stato iniziale",
  "PropertSelectorDrawer.tabLabel": "Proprietà",
  "TableSelectionAllCheckbox.checked.true": "Deseleziona tutto",
  "TableSelectionAllCheckbox.checked.false": "Seleziona tutto",
  "TableSelectionAllCheckbox.help": "Seleziona o deseleziona tutte le righe (comprese quelle non visibili nell'elenco impaginato)",
  "TableOptionsRow.checked.true": "Deseleziona tutto",
  "TableOptionsRow.checked.false": "Seleziona tutto",
  "TableOptionsRow.help": "Seleziona o deseleziona tutte le righe",
  "ErrorTextZone.reload": "Ripeti l'operazione",
  "ReportErrorSteps.report.title": "Hai appena riscontrato un errore",
  "ReportErrorSteps.report.description": "Questo errore è stato segnalato ai nostri team e cercheremo di correggerlo il più rapidamente possibile.",
  "ReportErrorSteps.report.steps.title": "Puoi provare in ordine",
  "ReportErrorSteps.report.steps.reload": "Ricarica la pagina e verifica se l'errore è stato risolto",
  "ReportErrorSteps.report.steps.logout": "Disconnettiti e torna a questa pagina dopo esserti ricollegato",
  "ReportErrorSteps.report.steps.contact": "Contattaci in modo che possiamo offrirti un'alternativa il più rapidamente possibile",
  "ReportErrorByMailButton.label": "Contattaci",
  "RefreshPageButton.label": "Ricarica la pagina",
  "Errors.networkError": "Sono stati rilevati problemi di connessione o di rete, attendi e riprova tra qualche secondo",
  "ShowEntityDrawer.title.show": "Vedi %{determinant.defined}",
  "ShowEntityDrawer.title.listItem": "Vedi le informazioni per %{determinant.defined} nella barra laterale",
  "EditEntityDrawer.title.edit": "Modifica %{determinant.defined}",
  "RightDrawerContent.close": "Chiudere il pannello di destra cliccando sulla croce.",
  "DropDownOptions.moreOptions": "Visualizza altre opzioni per %{determinant.defined} %{name}",
  "BuildingFloorsList.title": "Naviga tra i piani",
  "RefetchEntityButton.refetch": "Ricarica dati",
  "RefetchEntitiesButton.refetch": "Ricarica i dati dell'oggetto visibile",
  "RefetchObjectTypeIcon.help": "Ricarica i dati per %{determinant.defined}",
  "ImpactButtonReload.help.single": "Aggiorna i dati calcolati per %{determinant.defined}",
  "ImpactButtonReload.help.list": "Aggiorna i dati calcolati per %{determinants.defined}",
  "EditInlineToggleIconButton.edit.label": "Modificare",
  "EditInlineToggleIconButton.edit.help": "Modifica direttamente in questa pagina le proprietà di %{determinant.defined}",
  "EditInlineToggleIconButton.cancel.help": "Interrompi la modifica senza salvare",
  "ConfirmationButtons.confirm": "Conferma il completamento dell'azione",
  "ConfirmationButtons.cancel": "per cancellare",
  "ConfirmationButtons.loading": "L'azione è in esecuzione, attendere",
  "EmailNotVerified.errorMessage": "Per favore convalida la tua email ( %{email} ), una volta convalidata, puoi disconnetterti e riconnetterti per accedere a Surfy",
  "NoRoleAssociated.noRole": "Nessun ruolo sembra essere associato al tuo utente per l'azienda %{tenant} , contatta il tuo amministratore",
  "NoCompanies.title.whatIsSurfy": "Cos'è Surfy?",
  "NoCompanies.NoCompanyAssigned": "Non sei associato ad alcuna piattaforma, al momento non puoi utilizzare surfy",
  "NoCompanies.whatIsSurfy": "Surfy propone la digitalizzazione delle planimetrie degli edifici per facilitare la gestione dell'ambiente di lavoro.<br/> Puoi utilizzare l'app Surfy per<ul><li> organizzare gli spazi</li><li> assegnare i dipendenti</li><li> spazi di rifatturazione</li><li> analizzare gli spazi</li><li> gestire la conformità e le normative</li><li> connettere gli spazi</li><li> gestire gli orari delle presenze</li><li> riservare spazi di lavoro</li></ul>",
  "NoCompanies.whatIsSurfyForTeams": "Surfy propone la digitalizzazione delle planimetrie degli edifici per facilitare la gestione dell'ambiente di lavoro. Puoi utilizzare l'app Surfy per<ul><li> gestisci il tuo programma di presenza</li><li> dichiarare la propria presenza in ufficio</li><li> prenotare uno spazio di lavoro</li><li> indicare che stai telelavorando</li><li> vedere quali colleghi hanno prenotato una postazione di lavoro sul piano</li></ul>",
  "NoCompanies.ContactUs.text": "Accedi alla tua piattaforma aziendale",
  "NoCompanies.ContactUs.subject": "Accesso a Surfy",
  "NoCompanies.ContactUs.body": "Ciao, potresti farmi accedere all'applicazione Surfy? Grazie.",
  "NoCompanies.accessSurfy.title": "Perché non riesco ad accedere a Surfy?",
  "NoCompanies.accessSurfy.alreadyUsing": "Se la tua azienda utilizza già Surfy, contatta il tuo responsabile dell'ambiente di lavoro per richiedere l'accesso oppure contattaci tramite il seguente link",
  "NoCompanies.accessSurfy.joinTenant": "Unisciti alla piattaforma della tua azienda",
  "NoCompanies.notUsing.title": "La tua azienda non utilizza ancora Surfy?",
  "NoCompanies.knowMore": "Scopri di più su Surfy",
  "AuthenticationButton.connections.google-oauth2.label": "Google",
  "AuthenticationButton.connections.google-oauth2.help": "Accedi con il tuo account Google",
  "AuthenticationButton.connections.AzureADv2.label": "Ufficio 365",
  "AuthenticationButton.connections.AzureADv2.help": "Accedi con il tuo account aziendale Microsoft tramite Office 365",
  "AuthenticationButton.connections.auth0.label": "Conto da surf",
  "AuthenticationButton.connections.auth0.help": "Accedi con il tuo account Surfy",
  "Auth0AuthenticationButton.connections.auth0.label": "Conto Surfy (id aperto)",
  "Auth0AuthenticationButton.connections.auth0.help": "Accedi con il tuo account Surfy",
  "EnterpriseConnectionButton.label": "Azienda",
  "EnterpriseConnectionButton.help": "Accedi con il tuo account aziendale tramite un'autenticazione dedicata come OKTA o DigitalP@ss",
  "EnterpriseConnectionForm.title": "Inserisci la tua email in modo che possiamo riconoscere la tua attività",
  "EnterpriseConnectionForm.forms.email.placeholder": "E-mail",
  "EnterpriseConnectionForm.error": "Impossibile identificare la tua azienda con la tua email",
  "EnterpriseConnectionForm.buttons.validate.label": "convalidare",
  "EnterpriseConnectionForm.buttons.validate.help": "Convalidare l'e-mail ti consente di conoscere la tua azienda e di indirizzarti alla giusta piattaforma di autenticazione",
  "EnterpriseConnectionForm.buttons.back.label": "Ritorno",
  "EnterpriseConnectionForm.buttons.back.help": "Torna alla pagina di autenticazione con tutte le opzioni",
  "LoginView.loadingPage": "Caricamento della pagina di autenticazione",
  "LoginView.connections.google-oauth2.label": "Google",
  "LoginView.connections.google-oauth2.help": "Accedi con il tuo account Google",
  "LoginView.connections.AzureADv2.label": "Ufficio 365",
  "LoginView.connections.AzureADv2.help": "Accedi con il tuo account aziendale Microsoft tramite Office 365",
  "LoginView.connections.Username-Password-Authentication.label": "Conto da surf",
  "LoginView.connections.Username-Password-Authentication.help": "Accedi con il tuo account Surfy",
  "LoginView.texts.title": "Login",
  "LoginView.texts.description": "Accesso a Surfy",
  "LoginView.helpers.register": "Registra la tua attività con Surfy",
  "LoginView.helpers.moreInfo": "Scopri di più su Surfy",
  "LoginView.helpers.privacy": "politica sulla riservatezza",
  "CustomUserRegisterForm.tabs.login": "Per accedere",
  "CustomUserRegisterForm.tabs.signup": "Registrati",
  "CustomUserRegisterForm.form.email": "E-mail",
  "CustomUserRegisterForm.form.password": "Parola d'ordine",
  "CustomUserRegisterForm.form.firstName": "Nome",
  "CustomUserRegisterForm.form.lastName": "Cognome",
  "CustomUserRegisterForm.form.confirmPassword": "conferma password",
  "CustomUserRegisterForm.buttons.login.label": "convalidare",
  "CustomUserRegisterForm.buttons.login.help": "Accedi se hai già un account",
  "CustomUserRegisterForm.buttons.signup.label": "convalidare",
  "CustomUserRegisterForm.buttons.signup.help": "Iscriviti a Surfy se non hai un account",
  "ReportChart.NoValue": "Senza valore",
  "ChangeLanguage.title": "Cambia la lingua",
  "ChangeLanguage.help": "Cambia la lingua dell'app",
  "DataQualityTable.numberOfLines": "Numero di righe",
  "AllTenantsDataQualityTable.enableAllTenants.label": "Includi tutte le piattaforme",
  "SingleNodeQuery.refetch": "Ricarica dati",
  "ListRefetchButton.refetch": "Ricarica i dati dell'oggetto visibile",
  "ImpactObjectTypeIconButton.refetch": "Ricarica tutti i dati indipendentemente dai filtri",
  "CollapseSwitchButton.help.true": "Nascondi il dettaglio",
  "CollapseSwitchButton.help.false": "Guarda il dettaglio",
  "menu.logout": "disconnessione",
  "menu.tenantOperations": "Sincronizzazione",
  "menu.menuLeft.shoppingCart": "Cestino",
  "menu.menuLeft.personCompanies": "Fornitori",
  "menu.menuLeft.workplace": "Posti di lavoro personali",
  "menu.menuLeft.security": "Sicurezza",
  "menu.menuLeft.globalSecurity": "Sicurezza globale",
  "menu.menuLeft.all": "Amministrazione",
  "menu.menuLeft.operations": "Operazioni",
  "menu.menuLeft.types": "Tipi",
  "menu.menuLeft.roomTypes": "Tipologie di spazio",
  "menu.menuLeft.inventory": "Inventari",
  "menu.menuLeft.people": "Persone",
  "menu.menuLeft.spaces": "Spazi",
  "menu.menuLeft.organizations": "Organizzazioni",
  "menu.menuLeft.dimensions": "Livelli di analisi",
  "menu.menuLeft.api": "API",
  "menu.menuLeft.authentification": "Autenticazione",
  "menu.menuLeft.globalAdmin": "Amministrazione globale",
  "menu.menuLeft.human": "Collaboratori",
  "menu.menuLeft.things": "Mobilia",
  "menu.menuLeft.admin": "Amministrazione",
  "menu.menuLeft.surfy": "Surfista",
  "menu.menuLeft.partnerExportMapping": "Partner",
  "menu.menuLeft.personType": "Tipi",
  "menu.menuLeft.personRelations": "Relazioni",
  "menu.menuLeft.affectations": "Compiti",
  "menu.menuLeft.buildings": "Edifici",
  "menu.menuLeft.thingsType": "Tipi",
  "menu.menuLeft.spacePoints": "Punti",
  "menu.menuLeft.adminReporting": "Segnalazione",
  "menu.menuLeft.adminCostCenterReporting": "Centro di costo",
  "menu.menuLeft.adminDimensionReporting": "Dimensioni",
  "menu.menuLeft.adminRoomTypeReporting": "Tipo di spazi",
  "menu.menuLeft.adminOrganizationReporting": "Organizzazioni",
  "menu.menuLeft.adminRoomTypeGroupReporting": "Gruppi di tipologia spaziale",
  "menu.menuLeft.buildingFacts": "Dati dell'edificio con data e ora",
  "menu.menuLeft.itemsFact": "Dati dell'oggetto con data e ora",
  "menu.menuLeft.segments": "Segmenti",
  "menu.menuLeft.connectors": "Connettori",
  "menu.menuLeft.planning": "Orari",
  "menu.menuLeft.bookings": "Prenotazioni",
  "menu.menuLeft.help": "Aiuto",
  "menu.menuLeft.company": "Piattaforme",
  "ReduceMenuSwitch.open.true": "Espandi il menu",
  "ReduceMenuSwitch.open.false": "Comprimi il menu per sfruttare lo spazio di lavoro",
  "LogoutMenuLink.logout": "disconnessione",
  "HelpPortalListItemLink.label": "Portale di aiuto",
  "HelpPortalListItemLink.help": "Scopri il portale di assistenza di Surfy con tutti i nostri tutorial e guide per l'utente",
  "ChangeLogListItemLink.label": "Notizia",
  "ChangeLogListItemLink.help": "Scopri cosa c'è di nuovo e cosa è cambiato in Surfy",
  "DisplayRoomTexts.dragOption": "Tenere premuto e modificare l'ordine di visualizzazione degli immobili sulla pianta spostando il campo in alto o in basso",
  "DisplayRoomTexts.roomPeopleDimensions.label": "Quartiere",
  "DisplayRoomTexts.roomPeopleDimensions.help": "Mostra o meno il quartiere sulla mappa",
  "DisplayRoomTexts.roomSeatsCount.label": "Numero di posti",
  "DisplayRoomTexts.roomSeatsCount.help": "Visualizza o meno il numero di posti sulla mappa",
  "DisplayRoomTexts.roomCapacity.label": "Capacità spaziale",
  "DisplayRoomTexts.roomCapacity.help": "Mostra o meno la capacità di spazio sulla planimetria",
  "DisplayRoomTexts.roomCostCenter.label": "Centro di costo",
  "DisplayRoomTexts.roomCostCenter.help": "Mostrare o meno il centro di costo dello spazio sulla planimetria",
  "DisplayRoomTexts.roomMergedName.label": "Nome unito",
  "DisplayRoomTexts.roomMergedName.help": "Visualizzare o meno il nome unito dello spazio sulla planimetria, questo nome combina il nome visualizzato e il nome dello spazio",
  "DisplayRoomTexts.roomName.label": "Nome dello spazio",
  "DisplayRoomTexts.roomName.help": "Mostrare o meno il nome dello spazio sulla planimetria",
  "DisplayRoomTexts.roomPrettyName.label": "Nome da visualizzare",
  "DisplayRoomTexts.roomPrettyName.help": "Mostra o meno il nome visualizzato dello spazio sulla planimetria",
  "DisplayRoomTexts.roomArea.label": "La zona",
  "DisplayRoomTexts.roomArea.help": "Mostrare o meno la superficie del vano sulla planimetria",
  "DisplayRoomTexts.roomType.label": "Tipologia dello spazio",
  "DisplayRoomTexts.roomType.help": "Visualizzare o meno la tipologia dello spazio",
  "DisplayRoomTexts.roomPerimeter.label": "Perimetro",
  "DisplayRoomTexts.roomPerimeter.help": "Mostrare o meno il perimetro dello spazio sulla pianta",
  "DisplayRoomTexts.roomOrganizationLevel1.label": "Servizio",
  "DisplayRoomTexts.roomOrganizationLevel1.help": "Visualizzare o meno il nome del servizio spaziale sul piano",
  "DisplayRoomTexts.roomOrganizationTopLevel.label": "Direzione",
  "DisplayRoomTexts.roomOrganizationTopLevel.help": "Mostrare o meno il nome della direzione dello spazio sulla pianta",
  "DisplayRoomTexts.roomPeople.label": "Persone assegnate agli spazi",
  "DisplayRoomTexts.roomPeople.help": "Visualizzare o meno i nomi delle persone assegnate a questo spazio sulla planimetria",
  "DisplayRoomTexts.roomWorkplaceAffectations.label": "Persone assegnate alle postazioni di lavoro",
  "DisplayRoomTexts.roomWorkplaceAffectations.help": "Visualizzare o meno i nomi delle persone assegnate alle postazioni di lavoro in questo spazio della planimetria",
  "DisplayRoomTexts.roomPeopleCount.label": "Numero di incarichi",
  "DisplayRoomTexts.roomPeopleCount.help": "Visualizza o meno il numero di persone assegnate a questo spazio nel piano",
  "DisplayRoomTexts.roomPeopleRatio.label": "Rapporto di occupazione",
  "DisplayRoomTexts.roomPeopleRatio.help": "Mostra o meno il rapporto di occupazione dello spazio sulla planimetria",
  "DisplayRoomTexts.roomWorkplacesCount.label": "Numero di postazioni di lavoro",
  "DisplayRoomTexts.roomWorkplacesCount.help": "Mostra o meno il numero di postazioni di lavoro presenti nello spazio della planimetria",
  "DisplayRoomTexts.roomWorkplacesRatio.label": "Rapporto di postazioni di lavoro",
  "DisplayRoomTexts.roomWorkplacesRatio.help": "Mostra o meno il rapporto tra le postazioni di lavoro dello spazio sulla pianta",
  "DisplayRoomTexts.roomOccupancyRate.label": "Tasso di occupazione",
  "DisplayRoomTexts.roomOccupancyRate.help": "Visualizzare o meno il tasso di occupazione degli spazi sul piano",
  "DisplayRoomTexts.roomExpansionRatio.label": "Tasso di crescita eccessiva",
  "DisplayRoomTexts.roomExpansionRatio.help": "Mostra o meno il tasso di espansione dello spazio sul piano",
  "DisplayRoomTexts.roomFreeWorkplacesCount.label": "Numero di posti vacanti",
  "DisplayRoomTexts.roomFreeWorkplacesCount.help": "Visualizza o meno il numero di posizioni libere sul piano",
  "DisplayRoomTexts.roomFlexWorkplacesCount.label": "Numero di posizioni flessibili",
  "DisplayRoomTexts.roomFlexWorkplacesCount.help": "Visualizzare o meno il numero di posizioni flessibili sul piano",
  "DisplayRoomOptions.roomSeatsCount.one": "%{value} posto",
  "DisplayRoomOptions.roomSeatsCount.more": "%{value} posti",
  "DisplayRoomOptions.roomCapacity.one": "Capacità: %{value} spazio",
  "DisplayRoomOptions.roomCapacity.more": "Capacità: %{value} posti",
  "DisplayRoomOptions.roomFreeWorkplacesCount.one": "%{value} posizione libera",
  "DisplayRoomOptions.roomFreeWorkplacesCount.more": "%{value} posti vacanti",
  "DisplayRoomOptions.roomFlexWorkplacesCount.one": "%{value} elemento flessibile",
  "DisplayRoomOptions.roomFlexWorkplacesCount.more": "%{value} posizioni flessibili",
  "DisplayRoomOptions.roomWorkplacesCount.one": "%{value} workstation",
  "DisplayRoomOptions.roomWorkplacesCount.more": "%{value} workstation",
  "DisplayRoomOptions.roomPeopleCount.one": "%{value} persona interessata",
  "DisplayRoomOptions.roomPeopleCount.more": "%{value} persone interessate",
  "DisplayRoomOptions.roomOccupancyRate": "Occupazione: %{value}",
  "DisplayRoomOptions.roomExpansionRatio": "Espansione: %{value}",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.enable": "Gestisci i testi di visualizzazione dello spazio",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.disable": "Chiudi la gestione del testo del display",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.enable": "Consente di configurare i testi che verranno visualizzati sulla planimetria per ogni spazio",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.disable": "Torna alla normale modalità di modifica del piano.",
  "DisplayRoomTextsDrawer.tabs.map": "Piano",
  "DisplayRoomTextsDrawer.tabs.tooltip": "Descrizione comando",
  "DisplayRoomTextsDrawer.tabs.base.tabs.rooms": "Spazi",
  "DisplayRoomTextsDrawer.tabs.base.tabs.people": "Persone",
  "DisplayRoomTextsDrawer.tabs.base.people.description": "Per definire le proprietà delle persone da visualizzare sulla planimetria, scegliere nella scheda spazio le persone assegnate agli spazi o alle postazioni di lavoro quindi scegliere le proprietà in questa scheda",
  "DisplayWorkplaceTexts.workplaceName.label": "Nome della stazione di lavoro",
  "DisplayWorkplaceTexts.workplaceName.help": "Visualizza o meno il nome della workstation sul piano",
  "DisplayWorkplaceTexts.workplaceCostCenter.label": "Centro di costo",
  "DisplayWorkplaceTexts.workplaceCostCenter.help": "Visualizza o meno il centro di costo della workstation sul piano",
  "DisplayWorkplaceTexts.people.label": "Mostra le persone",
  "DisplayWorkplaceTexts.people.help": "Visualizza o meno le persone assegnate alla workstation sul piano",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.label": "Direzione",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.help": "Visualizzare o meno le indicazioni delle postazioni sulla planimetria",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.label": "Servizio",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.help": "Visualizzare o meno i servizi delle postazioni in planimetria",
  "DisplayPersonTexts.personPicture.label": "Foto di persone",
  "DisplayPersonTexts.personPicture.help": "Visualizzare o meno in planimetria la foto delle persone assegnate alle postazioni di lavoro",
  "DisplayPersonTexts.personName.label": "Nome delle persone",
  "DisplayPersonTexts.personName.help": "Visualizzare o meno il nome delle persone assegnate alle postazioni presenti nel piano",
  "DisplayPersonTexts.personSecurityProfile.label": "Profilo di sicurezza",
  "DisplayPersonTexts.personSecurityProfile.help": "Visualizzare o meno il profilo di sicurezza delle persone assegnate alle postazioni del piano",
  "DisplayPersonTexts.personOrganizationLevel0.label": "Direzione",
  "DisplayPersonTexts.personOrganizationLevel0.help": "Visualizzare o meno in pianta la direzione delle persone addette alle postazioni di lavoro",
  "DisplayPersonTexts.personOrganizationLevel1.label": "Servizio",
  "DisplayPersonTexts.personOrganizationLevel1.help": "Visualizzare o meno il servizio delle persone assegnate alle postazioni in planimetria",
  "DisplayPersonTexts.personOrganizationHierarchy.label": "Gerarchia dell'organizzazione",
  "DisplayPersonTexts.personOrganizationHierarchy.help": "Visualizzare o meno sulla planimetria il reparto e la direzione delle persone addette alle postazioni di lavoro",
  "DisplayPersonTexts.personCostCenter.label": "Centro di costo",
  "DisplayPersonTexts.personCostCenter.help": "Visualizzare o meno il centro di costo delle persone assegnate alle postazioni del piano",
  "DisplayPersonTexts.personCode.label": "Numero di registrazione",
  "DisplayPersonTexts.personCode.help": "Se visualizzare o meno il numero delle persone assegnate alle postazioni del piano",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.enable": "Gestire i testi di visualizzazione della workstation",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.disable": "Chiudi la gestione del testo del display",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.enable": "Consente di configurare i testi che verranno visualizzati in planimetria per ogni postazione",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.disable": "Torna alla normale modalità di modifica del piano.",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.enable": "Attiva la trasparenza dei colori di sfondo degli spazi",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.disable": "Disattiva la trasparenza del colore",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.enable": "L'abilitazione della trasparenza del colore consente di vedere lo sfondo attraverso gli spazi",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.disable": "La disattivazione della trasparenza del colore reimposta i colori degli spazi",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.description": "La trasparenza dei colori degli spazi permette di vedere la pianta di base",
  "WorkCanvas.Options.MapScaleOption.label.enable": "Gestisci la scala",
  "WorkCanvas.Options.MapScaleOption.label.disable": "Chiudere la gestione scala",
  "WorkCanvas.Options.MapScaleOption.help.enable": "Obbligatorio configurare la scala sulla propria planimetria per avere gli spazi e gli oggetti nella scala corretta",
  "WorkCanvas.Options.MapScaleOption.help.disable": "Torna alla normale modalità di modifica del piano.",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.label": "Elimina scala",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.help": "Eliminare la scala equivale a rimuovere la scala dalla pianta ed eliminarla dalla base, non sarà più accessibile da altre piante. Non è possibile eliminare una scala che si trova su più piani.",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.label": "Separa scala",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.help": "Lo scollegamento della bilancia da questo piano la rimuove dal piano, ma la mantiene nel database per un uso futuro",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.label": "Zoom in scala",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.help": "Lo zoom rende facile trovare la scala sulla planimetria.",
  "WorkCanvas.Options.DrawMapScaleOption.help": "Devi configurare la bilancia sul tuo piano, fare clic all'inizio e alla fine della bilancia sul piano per calibrarla",
  "ToggleCopilotEnable.label.false": "Attiva Surfy Copilot",
  "ToggleCopilotEnable.label.true": "Disabilita Surfy Copilot",
  "ToggleCopilotEnable.help.false": "Attiva Surfy Copilot per abilitare il riconoscimento automatico della porta",
  "ToggleCopilotEnable.help.true": "Disabilita Surfy Copilot e torna alla modellazione manuale",
  "WorkCanvas.Options.CopilotOption.label.enable": "Copilota Surfy",
  "WorkCanvas.Options.CopilotOption.label.disable": "Chiudi le opzioni di Surfy Copilot ",
  "WorkCanvas.Options.CopilotOption.help.enable": "Attiva e regola le opzioni di Surfy Copilot",
  "WorkCanvas.Options.CopilotOption.help.disable": "Ritorna alla modalità normale del piano.",
  "WorkCanvas.Options.AddRoomShapeOption.label.enable": "Aggiungi uno spazio",
  "WorkCanvas.Options.AddRoomShapeOption.label.disable": "Annulla l'aggiunta di uno spazio",
  "WorkCanvas.Options.AddRoomShapeOption.help.enable": "Aggiungi spazio sulla planimetria",
  "WorkCanvas.Options.AddRoomShapeOption.help.disable": "Annulla la creazione dello spazio",
  "WorkCanvas.Options.AddRoomShapeOption.description": "Gli angoli di creazione sono bloccati a 45°, per sbloccarli tieni premuto il tasto <b>SHIFT</b> della tastiera e continua la creazione, per creare il tuo vertice posiziona il mouse nel cerchio all'intersezione del triangolo, Per iniziare uno spazio riutilizzando un vertice esistente , tieni premuto il tasto <b>ALT</b> della tastiera e clicca sul vertice.",
  "WorkCanvas.Options.AddRoomShapeSaveOption.label": "Salva lo spazio attualmente in fase di modellazione",
  "WorkCanvas.Options.AddRoomShapeSaveOption.help": "Salva spazio chiuderà automaticamente lo spazio e lo salverà consentendoti di aggiungervi oggetti o postazioni di lavoro",
  "WorkCanvas.Options.ViewLegendOption.label.enable": "Legenda in anteprima",
  "WorkCanvas.Options.ViewLegendOption.label.disable": "Chiudi la didascalia dell'immagine salvata del piano",
  "WorkCanvas.Options.ViewLegendOption.help.enable": "Scopri a cosa serve la sezione della legenda della mappa",
  "WorkCanvas.Options.ViewLegendOption.help.disable": "Ritorna alla modalità normale del piano.",
  "DownloadImageQualitySlider.label": "Qualità dell'immagine esportata",
  "DownloadImagePdfButton.label": "Scarica la planimetria senza legenda (PDF)",
  "DownloadImagePdfButton.help": "Scarica il piano in PDF senza legenda, questa funzionalità è in beta",
  "WorkCanvas.Options.DownloadImageOption.label.enable": "Salva come immagine",
  "WorkCanvas.Options.DownloadImageOption.label.disable": "Chiudi le opzioni di salvataggio dell'immagine del piano",
  "WorkCanvas.Options.DownloadImageOption.help.enable": "Salva il piano come immagine tramite questa opzione",
  "WorkCanvas.Options.DownloadImageOption.help.disable": "Ritorna alla modalità normale del piano.",
  "DownloadImageDrawer.ViewImage.text": "Scarica la planimetria con legenda (PNG)",
  "DownloadImageDrawer.ViewImage.help": "Scarica l'intero piano in buona qualità con la legenda, l'esportazione potrebbe richiedere più tempo.",
  "DownloadImageDrawer.ViewImageNoLegend.text": "Scarica la planimetria senza legenda (PNG)",
  "DownloadImageDrawer.ViewImageNoLegend.help": "Scarica l'intero piano in buona qualità senza la legenda, l'esportazione potrebbe richiedere più tempo.",
  "DownloadImageDrawer.ScreenshotNoLegend.text": "Screenshot senza didascalia",
  "DownloadImageDrawer.ScreenshotNoLegend.help": "Scarica l'immagine di ciò che vedi a schermo senza didascalia, l'output sarà veloce ma la qualità dell'export non sarà ottimale",
  "DownloadBuildingImagesAccordion.accordion.title": "Esporta le immagini dell'intero edificio",
  "DownloadBuildingImagesAccordion.buttons.download.help": "Scarica tutte le planimetrie di tutti i piani dell'edificio in formato png in un zip, i tempi di attesa per questa estrazione possono essere lunghi",
  "DownloadBuildingImagesAccordion.buttons.download.label": "Scarica ZIP",
  "DisplayTexts.dragOption": "È possibile ordinare e scegliere la visualizzazione delle proprietà sulla planimetria spostando in alto o in basso le piccole barre del campo",
  "DisplayRoomTextsPeople.roomPeopleFullName.label": "Nome completo della persona",
  "DisplayRoomTextsPeople.roomPeopleFullName.help": "Se mostrare o meno il nome completo della persona sulla mappa",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.label": "Profilo di sicurezza",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.help": "Visualizzare o meno il profilo di sicurezza delle persone assegnate agli spazi in planimetria",
  "NumberOfPeoplePerRowField.label": "Numero di persone per linea per assegnazioni di spazio",
  "WorkCanvas.Options.BackgroundLayoutOption.label.enable": "Gestisci la mappa di base",
  "WorkCanvas.Options.BackgroundLayoutOption.label.disable": "Chiudi la gestione dell'immagine di sfondo",
  "WorkCanvas.Options.BackgroundLayoutOption.help.enable": "Consente di gestire lo sfondo",
  "WorkCanvas.Options.BackgroundLayoutOption.help.disable": "Torna alla normale modalità di modifica del piano.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.label": "Elimina scala",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.help": "Eliminare la scala equivale a rimuovere la scala dalla pianta ed eliminarla dalla base, non sarà più accessibile da altre piante. Non è possibile eliminare una scala che si trova su più piani.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.label": "Separa scala",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.help": "Lo scollegamento della bilancia da questo piano la rimuove dal piano, ma la mantiene nel database per un uso futuro",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.label": "Zoom in scala",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.help": "Lo zoom rende facile trovare la scala sulla planimetria.",
  "WorkplaceCanvasItem.workplace.free": "La stazione di lavoro non è occupata",
  "WorkplaceCanvasItem.workplace.isFlex": "La postazione è in flex",
  "WorkplaceCanvasItem.workplace.isTransit": "La postazione è transitoria",
  "WorkplaceCanvasItem.workplace.isBookable": "La postazione di lavoro è prenotabile",
  "WrongRoomsTable.table.headers.objectType": "Natura",
  "WrongRoomsTable.table.headers.type": "Tipo",
  "WrongRoomsTable.table.headers.identity": "Identità",
  "WrongRoomsTable.table.headers.currentRoom": "spazio attuale",
  "WrongRoomsTable.table.headers.newRoom": "nuovo spazio",
  "WrongRoomsTable.SelectAll.checked.true": "Deseleziona tutto",
  "WrongRoomsTable.SelectAll.checked.false": "Seleziona tutto",
  "WrongRoomsTable.SelectAll.help": "Seleziona o deseleziona tutte le righe",
  "WrongRoomsListner.dialog.title": "Convalida la scelta degli spazi",
  "WrongRoomsListner.dialog.description": "Ci sono forme che non sono nel loro spazio di partenza",
  "WrongRoomsListner.close.label": "Chiudere",
  "WrongRoomsListner.close.help": "chiudi questa finestra",
  "MoveShapestoNewRoomAsyncButton.label": "Applicare il cambio di spazio",
  "MoveShapestoNewRoomAsyncButton.help": "Cambia gli spazi delle forme selezionate per metterle negli spazi in cui si trovano sulla pianta",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.enable": "Sposta il tipo di oggetto",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.disable": "Interrompi lo spostamento del tipo di oggetto",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.enable": "Sposta un tipo di oggetto sul piano",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.disable": "Interrompi lo spostamento del tipo di oggetto",
  "ResetRotationAngle.resetRotationAngle": "Reimposta a 0° l'angolo di rotazione che attualmente è %{initialRotation}",
  "TenantOperations.sephora-sync-sap-success-factors.label": "Sincronizzazione MSC",
  "TenantOperations.st-grenoble-import-hr-file.label": "Importazione del file HR",
  "TenantOperations.egis-import-hr-file.label": "Importazione file HR",
  "TenantOperations.essilor-import-hr-file.label": "Importazione file HR",
  "TenantOperations.agpm-import-hr-file.label": "Importazione del file HR (STILOG)",
  "ConnectedPartnerContext.title": "Sei connesso a <b>%{label}</b> ( %{host} )",
  "Operations.talentsoft-import.label": "Importa Talentsoft",
  "Operations.zbre-sync.label": "Sincronizzazione Z#ber",
  "Operations.exportZbre.label": "Esporta Z#ber",
  "GenericNoChangeTable.open.label": "Visualizza i dati",
  "GenericNoChangeTable.open.help": "Vedi il dettaglio dei dati identici",
  "Operations.sharingcloud-sync.label": "Sincronizzazione del cloud di condivisione",
  "Operations.moffi-sync.label": "Sincronizzazione Moffi",
  "Operations.lucca-sync.label": "Sincronizzazione Lucca",
  "CompareObjectTypeUpdateIcon.help": "Questa sincronizzazione aggiornerà le entità",
  "CompareObjectTypeDeleteIcon.help": "Questa sincronizzazione eseguirà un'eliminazione delle entità che non provengono dall'origine",
  "CompareObjectTypeCreateIcon.help": "Questa sincronizzazione creerà entità che non esistono nella destinazione",
  "RoomTooltip.roomWorkplaceAffectations": "Compiti della postazione di lavoro",
  "RoomSegmentRoomsList.title": "Gli spazi allegati a questo segmento",
  "MeetingRoomCard.seats.1": "%{count} posto",
  "MeetingRoomCard.seats.n": "%{count} posti",
  "MeetingRoomCard.locateSpace": "Individua lo spazio sulla planimetria",
  "MeetingRoomCard.viewPicture": "Vedi la foto dello spazio",
  "days.monday": "Lunedi",
  "days.tuesday": "Martedì",
  "days.wednesday": "Mercoledì",
  "days.thursday": "GIOVEDÌ",
  "days.friday": "Venerdì",
  "days.saturday": "SABATO",
  "days.sunday": "Domenica",
  "WorkplaceAffectationDailyTitle.all": "Questa persona è colpita ogni giorno",
  "WorkplaceAffectationDailyTitle.person.affected": "A questa persona è assegnato %{daysText}",
  "WorkplaceAffectationDailyTitle.person.notAffected": "Questa persona non è influenzata",
  "WorkplaceAffectationDailyTitle.calculatedRate": "Il tasso medio di assegnazione è %{calculatedRate}",
  "WorkplaceNestedList.title": "Persone assegnate alle postazioni di lavoro",
  "WorkplaceList.workplace.free": "Questa postazione è gratuita",
  "WorkplaceList.workplace.flex": "Questa workstation è in flex",
  "WorkplaceList.workplace.transit": "Questa workstation è condivisa",
  "WorkplaceList.zoomOnWorkplace": "Zoom sulla workstation sulla planimetria",
  "WorkplaceAffectionPersonListItem.remove.help": "Rimuovere l'assegnazione della persona alla workstation",
  "WorkplaceAffectations.edit.help": "Assegna una persona a questa workstation",
  "WorkplaceAffectationDays.all": "Questa persona è colpita ogni giorno",
  "WorkplaceAffectationDays.and": "%{days} e %{lastDay}",
  "WorkplaceAffectationDays.one": "il %{day}",
  "WorkplaceAffectationDays.person.affected": "A questa persona è assegnato %{daysText}",
  "WorkplaceAffectationDays.person.notAffected": "Questa persona non è influenzata",
  "RoomWorkplaceList.EmptyList": "Non sono presenti postazioni di lavoro in questo spazio",
  "RoomCard.buttons.edit.false": "Modifica le proprietà dello spazio",
  "RoomCard.buttons.edit.true": "Interrompi la modifica",
  "RoomCard.tabs.people": "Compiti",
  "RoomCard.tabs.inventory": "Inventario",
  "RoomCard.tabs.room": "Spazio",
  "RoomAffectationsOnlyList.title": "Persone assegnate agli spazi",
  "RoomAffectationsList.title": "Persone assegnate agli spazi",
  "RoomAffectationsList.EmptyList": "Non c'è nessuno assegnato a questo spazio",
  "ItemsInventory.EmptyList": "Non ci sono oggetti in questo spazio",
  "MovePersonFromWorkplaceToRoomListButtonItem.label": "Sposta questa persona dalla sua postazione di lavoro allo spazio della postazione di lavoro",
  "MovePersonFromWorkplaceToRoomListButtonItem.help": "Questa opzione richiede l'aggiornamento della pagina per vedere il risultato, è possibile concatenare più movimenti senza aggiornare",
  "CollapseWorkplaceAffectationList.title": "Assegna questa persona solo per i giorni seguenti",
  "CollapseWorkplaceAffectationList.updateAffectationDay.true": "Colpisci questa persona %{day}",
  "CollapseWorkplaceAffectationList.updateAffectationDay.false": "Rimuovi l'incarico di questa persona %{day}",
  "CancelAddWorkplaceToRoom.help": "Annulla aggiunta workstation",
  "CancelAddItemToRoom.help": "Annulla l'aggiunta di oggetti",
  "AddPersonToRoom.help": "Assegna una persona allo spazio %{name}",
  "SecurityComplianceModeSwitch.label": "Filtra le persone con profili di sicurezza",
  "SecurityComplianceModeSwitch.description": "Visualizza sulla mappa solo le persone con profili di sicurezza",
  "layoutViewSets.roomType.label": "Tipi di spazi",
  "layoutViewSets.roomType.description": "Vedere la planimetria in base alla tipologia degli spazi",
  "layoutViewSets.costCenter.label": "Rimborso",
  "layoutViewSets.costCenter.description": "Analizzare le chiavi per la distribuzione finanziaria degli spazi",
  "layoutViewSets.workplaces.label": "occupazioni",
  "layoutViewSets.workplaces.description": "Concentrati sull'occupazione delle postazioni di lavoro",
  "layoutViewSets.organizationLevel0.label": "Indicazioni",
  "layoutViewSets.organizationLevel0.description": "Occupazione per direzione",
  "layoutViewSets.flex.label": "Flettere",
  "layoutViewSets.flex.description": "L'occupazione flessibile degli spazi",
  "layoutViewSets.walls.label": "Partizioni",
  "layoutViewSets.walls.description": "Concentrati su spazi e partizioni",
  "layoutViewSets.securityCompliance.label": "Conformità alla sicurezza",
  "layoutViewSets.securityCompliance.description": "Analizza la conformità del tuo piano di prevenzione della sicurezza e i profili di sicurezza delle persone interessate",
  "layoutViewSets.peopleDimensionTypes.label": "Quartieri",
  "layoutViewSets.peopleDimensionTypes.description": "Analizza i livelli di assegnazione e naviga per quartiere o zona",
  "LayoutViewSwitch.title": "Cambia la visione del piano",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.viewSet": "Visione",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.help": "Puoi modificare la visione tramite i menu del piano",
  "SurfyLegendBottomLogo.text": "Piano generato da Surfy",
  "SurfyLegendBottomLogo.caption": "https://www.surfy.pro",
  "MapLegendWorkplace.title": "Posto di lavoro",
  "MapLegendWorkplace.workplaces.free": "Le postazioni sono gratuite",
  "MapLegendWorkplace.workplaces.flex": "Le postazioni sono in flex",
  "MapLegendRoom.title": "Spazi",
  "MapLegendPersonSecurityProfile.title": "Profili di sicurezza",
  "MapLegendFloor.title.building": "Edificio",
  "MapLegendFloor.title.floor": "Piano",
  "MapLegend.workplaces": "Posti di lavoro personali",
  "MapLegend.rooms": "Spazi",
  "PersonSecurityProfileTabContent.tabs.merged": "Per profili di sicurezza",
  "PersonSecurityProfileTabContent.tabs.split": "Per incarichi",
  "DimensionInfo.infos.building": "Informazioni sull'edificio calcolate",
  "DimensionInfo.infos.impactBuildings": "Ricarica i dati dell'edificio calcolati",
  "DimensionToPeopleList.title": "Persone assegnate a %{name}",
  "DimensionToPeopleList.noDimensionPerson": "Non c'è nessuno assegnato direttamente a questo livello di analisi",
  "DimensionPeople.title": "Persone assegnate agli spazi",
  "AddPersonToDimension.help": "Assegna persona a %{name}",
  "CubyWallModeSelect.label": "Visualizzazione delle partizioni",
  "CubyWallModeSelect.options.no": "Nessuno",
  "CubyWallModeSelect.options.half": "Mezze partizioni",
  "CubyWallModeSelect.options.reality": "La realtà",
  "CubyWallModeSelect.options.cuby": "Cubo",
  "CubySaveAsImageButton.label": "Salva immagine",
  "CubySaveAsImageButton.help": "Salva l'immagine della planimetria",
  "CubyFitToViewIsometricButtonOption.label": "Centrare il piano nella vista isometrica",
  "CubyFitToViewIsometricButtonOption.help": "Pianta centrale su vani in vista isometrica",
  "CubyFitToViewZenithalButtonOption.label": "Centrare il piano nella vista zenitale",
  "CubyFitToViewZenithalButtonOption.help": "Centrare la pianta sugli spazi in vista zenitale",
  "RefetchFloorLayoutButton.refetch": "Ricarica i dati del piano",
  "ItemTypesMapFilterZone.tabs.options": "Opzioni",
  "FloorMap.tabs.layout": "Cambiare la visione del piano. La vista corrente è <b>%{layoutName}</b>",
  "FloorMap.tabs.floor": "Vedi le informazioni sul piano",
  "FloorMap.tabs.building": "Vedi le informazioni sull'edificio",
  "FloorMap.tabs.roomTypes": "Colora gli spazi sulla planimetria in base alle <b>tipologie di spazio</b>",
  "FloorMap.tabs.roomTypeGroups": "Consulta gli indicatori di spazio sulla planimetria secondo i <b>gruppi di tipologie di spazio</b>",
  "FloorMap.tabs.analyticsDimensionTypes": "Colora gli spazi sulla pianta in base ai <b>livelli di analisi</b>",
  "FloorMap.tabs.itemTypes": "Visualizza <b>gli oggetti</b> sulla pianta per famiglia e tipo di oggetti",
  "FloorMap.tabs.workplaceTypes": "Visualizza le <b>postazioni</b> per tipo di postazione sul piano",
  "FloorMap.tabs.organizations": "Colora gli spazi sulla planimetria secondo le <b>organizzazioni</b>",
  "FloorMap.tabs.costCenters": "Spazi colore e postazioni di lavoro in relazione ai <b>centri di costo</b>",
  "FloorMap.tabs.users": "Postazioni a colori contro persone",
  "FloorMap.tabs.selection": "Vedi i dettagli degli elementi selezionati sulla pianta",
  "FloorMap.tabs.rooms": "Dettagli degli <b>spazi</b> selezionati",
  "FloorMap.tabs.items": "Dettagli degli <b>oggetti</b> selezionati",
  "FloorMap.tabs.workplaces": "Dettagli delle <b>workstation</b> selezionate",
  "FloorMap.tabs.all": "Visualizza tutte le forme selezionate nell'elenco",
  "FloorMap.tabs.peopleDimensionTypes": "Colora gli spazi sul piano in base <b>ai livelli di assegnazione</b>",
  "FloorMap.tabs.workplaceUsage": "Colora le postazioni di lavoro in base al loro <b>stato</b>",
  "FloorMap.tabs.options": "Vedi le opzioni del piano",
  "FloorMap.tabs.heatmap": "Colorare con mappe di calore",
  "FloorMap.tabs.pathFinding": "Orientarsi negli spazi",
  "DateDimensionSelect.options.day": "Giorno",
  "DateDimensionSelect.options.week": "Settimana",
  "DateDimensionSelect.options.month": "Mese",
  "DateDimensionSelect.options.year": "Anno",
  "DateDimensionSelect.options.quarter": "Trimestre",
  "JupDateRangePicker.chooseRange": "Scegli un periodo",
  "WorkpaceBookingPeopleCountByDate.title": "Numero di persone prenotate per data",
  "WorkpaceBookingPeopleCountByDate.labels.line": "Numero di persone",
  "WorkpaceBookingCountByDate.title": "Prenotazioni postazioni per data",
  "WorkpaceBookingCountByDate.labels.line": "Numero di prenotazioni",
  "WorkpaceBookingAverageByWeekDay.title": "Prenotazione delle postazioni di lavoro per giorno della settimana",
  "WorkpaceBookingAverageByWeekDay.labels.line": "Media settimanale",
  "WorkpaceBookingAverageByWeekDay.labels.bar": "Numero di prenotazioni",
  "PersonPanelWorkplaceAffectations.title": "Compiti della postazione di lavoro",
  "PersonPanelRoomAffectations.title": "Assegnazioni agli spazi",
  "PersonPanelDimensionToPeople.title": "Assegnazioni a %{dimensionTypeName}",
  "PersonPanelBuildingAffectations.title": "Assegnazioni agli edifici",
  "PersonPanelBuildingAffectations.addToPeopleCount.false": "Questa persona non sta contabilizzando nell'edificio",
  "PersonAffectationsPanel.title": "Compiti",
  "PersonAffectationsPanel.description": "I compiti della persona",
  "PersonSecurityPanel.title": "Sicurezza",
  "PersonSecurityPanel.description": "Informazioni sulla sicurezza e sull'evacuazione",
  "PersonRelationsPanel.title": "Relazioni",
  "PersonRelationsPanel.description": "Le relazioni di questa persona",
  "PersonInventoryPanel.title": "Inventario",
  "PersonInventoryPanel.description": "Informazioni sull'inventario",
  "PersonInventoryPanel.items.subheader": "Elenco degli oggetti associati",
  "PersonInfoPanel.title": "Informazioni personali",
  "PersonContractPanel.title": "Contrarre",
  "PersonContractPanel.description": "Informazioni sul contratto",
  "PersonContactPanel.title": "Contatto",
  "PersonContactPanel.description": "Come posso contattare questa persona?",
  "PersonBadgePanel.title": "Vari",
  "PersonBadgePanel.description": "Informazioni varie sulla persona",
  "AvatarPersonDrawer.help": "Visualizza ulteriori informazioni su %{name}",
  "TopLevelOrganizationFilter.Empty": "Non esiste alcuna organizzazione associata agli spazi, puoi aggiungerne altre modificando uno spazio e associandolo a un'organizzazione, quindi puoi controllarne la visualizzazione da questa sezione",
  "OrganizationTabsFilter.tabs.topLevel": "Indicazioni",
  "OrganizationTabsFilter.tabs.hierarchy": "Gerarchia",
  "OrganizationTabsFilter.tabs.level1": "Servizi",
  "OrganizationFloorMapFilter.TooltipTitle.notSelected": "Seleziona %{organization} per colorare gli spazi sulla planimetria",
  "OrganizationFloorMapFilter.TooltipTitle.selected": "Deselezionando %{organization} verranno rimossi i colori dalla mappa",
  "OrganizationFloorMapFilter.tooltip.true": "Seleziona tutti i tipi di oggetti qui sotto per colorarli sulla mappa",
  "OrganizationFloorMapFilter.tooltip.false": "Deseleziona tutte le organizzazioni di seguito",
  "Level1OrganizationFilter.Empty": "Non esiste alcuna organizzazione associata agli spazi, puoi aggiungerne altre modificando uno spazio e associandolo a un'organizzazione, quindi puoi controllarne la visualizzazione da questa sezione",
  "HierarchyOrganizationFilter.Empty": "Non esiste alcuna organizzazione associata agli spazi, puoi aggiungerne altre modificando uno spazio e associandolo a un'organizzazione, quindi puoi controllarne la visualizzazione da questa sezione",
  "CompanyDashboard.dashboards.workplace": "Cruscotto del desktop",
  "CompanyDashboard.dashboards.area": "Dashboard delle superfici",
  "ChangeCompanyMenu.ChangeCompany": "Vedere un'altra attività in una nuova pagina",
  "WorkplaceTypeDataQualityNotUsed.columns.name": "Nome del tipo di workstation",
  "WorkplaceTypeDataQualityNotUsed.columns.shape": "Modulo",
  "workplaceTypeLayoutFilter.Empty": "Al momento non sono presenti postazioni di lavoro negli spazi, puoi aggiungerne altre modificando uno spazio e aggiungendovi postazioni di lavoro, quindi puoi controllarne la visualizzazione da questa sezione",
  "WorkplaceTypeInfo.help": "Il numero di workstation è %{count}",
  "CopyWorkplaceTypeToCart.help": "Copia i tipi di workstation nel carrello",
  "WorkCanvas.Options.ZoomOnWorkplaceType.label": "Ingrandisci il tipo di workstation",
  "WorkCanvas.Options.ZoomOnWorkplaceType.help": "Zoomando sul tipo di workstation è possibile individuarla nell'area di lavoro",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.enable": "Elenca i tipi di oggetti",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.disable": "Chiudere l'elenco dei tipi di oggetto",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.enable": "Vedere l'elenco dei tipi di oggetto per questo tipo di workstation",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.disable": "Chiudere l'elenco dei tipi di oggetto per questo tipo di workstation",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.open": "Apri le opzioni",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.close": "Opzioni di piegatura",
  "WorkplaceTypeItemTypesDrawer.title": "Elenco dei tipi di oggetto",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.help": "Aggiungere un tipo di oggetto per poter comporre il tipo di workstation",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.label": "Aggiungi un tipo di oggetto",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.help": "Annulla aggiunta di un tipo di oggetto a questo centro di lavoro",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.label": "Annulla l'aggiunta di un tipo di oggetto",
  "WorkCanvas.Options.DeleteStructureShapeOption.help": "Rimuovere completamente la forma della struttura del potere, ad esempio ridisegnarla interamente",
  "WorkCanvas.Options.DeleteStructureShapeOption.label": "elimina forma",
  "WorkCanvas.Options.AddStructurePointOption.label.enable": "Aggiungi vertice",
  "WorkCanvas.Options.AddStructurePointOption.label.disable": "Smetti di aggiungere un vertice",
  "WorkCanvas.Options.AddStructurePointOption.help.enable": "L'aggiunta di un vertice consente di rielaborare una forma con maggiore precisione",
  "WorkCanvas.Options.AddStructurePointOption.help.disable": "Smetti di creare vertici",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloorButton.label": "Prenota una postazione di lavoro a %{floorName}",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloor": "Prenota una postazione di lavoro al %{floorName} per il periodo %{slotString}",
  "BookPersonBuildingWorkplace.availableWorkplaces": "%{freeWorkplaces} posti disponibili",
  "BookPersonBuildingWorkplace.help": "%{bookedWorkplaces} prenotazione/i, %{freeWorkplaces} postazioni di lavoro disponibili su %{totalFloorWorkplacesCount}",
  "booking.snackbar.delete.workplace": "La prenotazione sulla postazione di lavoro %{workplaceName} è stata cancellata per il periodo %{slot}",
  "booking.snackbar.delete.room": "La prenotazione nello spazio %{roomName} è stata cancellata per il periodo %{slot}",
  "BookingWorkplaceTitle.booked": "Questa postazione di lavoro è già prenotata",
  "BookingWorkplaceTitle.userBooked": "Hai prenotato questa postazione di lavoro",
  "BookingWorkplaceTitle.free": "Prenota questa postazione di lavoro",
  "PlanningPersonAffectations.alerts.noAffectation.title": "Impossibile prenotare una postazione di lavoro",
  "PlanningPersonAffectations.alerts.noAffectation.message": "Non sei associato ad alcun territorio, contatta il tuo responsabile di assegnazione per poter prenotare uno spazio di lavoro",
  "WorkingLocationToggle.locations.OFFICE": "Scrivania",
  "WorkingLocationToggle.locations.REMOTE": "Telelavoro",
  "PersonBookingListItem.workplaceBookedOnFloor": "Vedi la workstation %{workplaceName} sulla planimetria %{floorName}",
  "PersonBookingList.noBooking": "Nessun collega sarà per il momento presente in ufficio nello stesso orario",
  "PersonBookingList.bookings.one": "Nello stesso slot sarà presente un collega",
  "PersonBookingList.bookings.more": "%{count} colleghi saranno presenti nello stesso slot",
  "ParkingBookIcon.parking.booked": "Il tuo parcheggio è riservato",
  "ParkingBookIcon.parking.release.help": "Rilascio prenotazione parcheggio",
  "ParkingBookIcon.parking.viewOnMap": "Vedi i parcheggi riservati sulla mappa",
  "ParkingBookIcon.parking.book.label": "Prenotare il parcheggio",
  "ParkingBookIcon.parking.book.help": "Prenota un parcheggio che verrà automaticamente assegnato allo slot",
  "HalfDayWorkingLocationToggle.am.label": "Mattina",
  "HalfDayWorkingLocationToggle.am.help": "L'orario mattutino è dalle 8:00 alle 13:30.",
  "HalfDayWorkingLocationToggle.pm.label": "Pomeriggio",
  "HalfDayWorkingLocationToggle.pm.help": "L'orario pomeridiano è dalle 14:00 alle 19:00.",
  "DirectBuildingPlanningLabel.youAreAssigned": "Ti è stato assegnato l'edificio %{buildingName}",
  "DimensionBuildingPlanningLabel.youAreAssigned": "Ti è stato assegnato %{dimensionTypeName} %{dimensionName}",
  "BookedBuildingWorkplaceList.noWorkplaceBooked": "Nessuna postazione riservata",
  "BookedBuildingWorkplaceList.workplaceIsBooked": "La tua postazione di lavoro è riservata",
  "BookedBuildingWorkplaceList.viewBookedWorkplaceOnMap": "Visualizza la workstation %{workplaceName} riservata nel piano",
  "BookedBuildingWorkplaceList.freeWorkplaceBooking": "Rilascia questa prenotazione",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.noFloor": "La metratura non è su nessun piano impossibile da prenotare al momento dalla planimetria",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.moreThanOneFloor": "La metratura è su più piani impossibile prenotarla al momento essendo in planimetria",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.drawer.title": "Prenota una postazione di lavoro specifica per il periodo %{slotString}",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.help": "Prenota una postazione di lavoro specifica nel piano per questo slot",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.label": "Prenota una postazione di lavoro in %{dimensionName}",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.peopleCount": "Ci sono %{count} persone con profilo di sicurezza %{name} assegnate alle workstation",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.workplaceCount": "Ci sono %{count} postazioni di lavoro con almeno una persona con profilo di sicurezza %{name}",
  "PersonSecurityProfileWorkplaceFilter.Empty": "Le tue persone non hanno un profilo di sicurezza o non sono assegnate alle postazioni, non è possibile colorare le postazioni in base ai profili di sicurezza delle persone",
  "PersonSecurityProfileWorkplaceFilter.title": "I profili di sicurezza delle persone assegnate alle postazioni di lavoro",
  "PersonSecurityProfileMerged.title": "Elenco dei profili di sicurezza raggruppati per tipo di profilo",
  "PersonSecurityProfileMerged.empty": "Nessun profilo è associato a spazi o postazioni di lavoro",
  "PersonSecurityProfileInRooms.title": "I profili di sicurezza delle persone assegnate agli spazi",
  "PersonSecurityProfileInRoomListItem.peopleCount": "Ci sono %{count} persone con profilo di sicurezza %{name} assegnate agli spazi",
  "PersonSecurityProfileInRoomListItem.roomsCount": "Ci sono %{count} spazi con almeno una persona con profilo di sicurezza %{name}",
  "ToggleAllOpenInfoState.true": "Chiudi tutti i dettagli e gli indicatori",
  "ToggleAllOpenInfoState.false": "Apri tutti i dettagli e gli indicatori",
  "MapFiltersNodesToggleAll.help.true": "Seleziona tutto",
  "MapFiltersNodesToggleAll.help.false": "Deseleziona tutto",
  "MapFiltersNode.info.open": "Visualizza i dettagli e gli indicatori per %{label}",
  "MapFiltersNode.info.close": "Chiudi informazioni aggiuntive",
  "MapFiltersCategory.CategoryHasChildrenSelected": "Gli elementi sono selezionati",
  "MapFilterNodeToggleAll.action.true": "Seleziona tutto",
  "MapFilterNodeToggleAll.action.false": "Deseleziona tutto",
  "MapFilterNodeIsAllSelected.help": "Verrà caricata tutta la selezione sottostante, anche se vengono creati nuovi oggetti",
  "JupRoleToObjectTypeMatrix.views.help.true": "Nascondi la visualizzazione dell'interfaccia",
  "JupRoleToObjectTypeMatrix.views.help.false": "Mostra vista interfaccia",
  "JupRoleToObjectTypeMatrix.objectTypes.help.checkbox": "Aggiorna proprietà ( %{name} )",
  "GlobalOptions.CartCopyItemTypeOption.help": "Copia i tipi di articoli nel carrello",
  "GlobalOptions.CartCopyWorkplaceTypeOption.help": "Copia i tipi di workstation nel carrello",
  "GlobalOptions.CartCopyBuildingOption.help": "Copia gli edifici nel carrello",
  "CheckAllDefaultViews.shortcuts.title": "Collegamenti di installazione",
  "CheckAllDefaultViews.shortcuts.views.title": "Scorciatoie per le visualizzazioni dell'interfaccia predefinite",
  "CheckAllDefaultViews.shortcuts.views.buttonsHelp": "Controlla questa vista per tutti i tipi di entità",
  "CheckAllDefaultViews.shortcuts.objectTypes.title": "Scorciatoie per i tipi di entità",
  "CheckAllDefaultViews.shortcuts.objectTypes.buttonsHelp": "Verifica questa regola per tutti i tipi di oggetti",
  "RemoveItemColorsOption.label": "Non colorare gli oggetti",
  "RemoveItemColorsOption.help": "Colora gli oggetti di bianco in modo da poterti concentrare su altri elementi sulla mappa",
  "ItemTypeOptions.help": "Il numero di oggetti è %{count}",
  "ItemTypeMapFilter.TooltipTitle.notSelected": "Seleziona %{itemType} per vedere gli elementi sulla mappa",
  "ItemTypeMapFilter.TooltipTitle.selected": "Deselezionando %{itemType} verrà rimosso il colore associato dal piano",
  "ItemTypeMapFilter.tooltip.true": "Seleziona tutti i tipi di oggetti di seguito per visualizzarli sulla mappa",
  "ItemTypeMapFilter.tooltip.false": "Deseleziona tutti i tipi di oggetto di seguito",
  "ItemTypeMapFilter.NoNode": "Al momento non ci sono oggetti negli spazi, puoi aggiungerne altri modificando uno spazio e aggiungendovi oggetti, quindi puoi controllarne la visualizzazione da questa sezione",
  "ItemTypeMapFilter.NoCategory": "Al momento non ci sono oggetti negli spazi, puoi aggiungerne altri modificando uno spazio e aggiungendovi oggetti, quindi puoi controllarne la visualizzazione da questa sezione",
  "ItemTypeDataQualityNotUsed.columns.name": "Nome del tipo di oggetto",
  "ItemTypeDataQualityNotUsed.columns.shape": "Modulo",
  "ItemTypeDataQualityNotUsed.columns.workplaceTypeCount": "Numero del tipo di postazione di lavoro",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.help": "Scegli un piano di riferimento per creare la forma in modo da poter disegnare il tuo tipo di oggetto posizionandoti su un piano e avendo la giusta scala",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.label": "Scegli un piano di riferimento per creare la forma",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.help": "Scegli un piano di riferimento per comporre la tipologia di postazione con tipologie di oggetti esistenti posizionandoti su un piano e avendo la giusta scala e posizionando correttamente le tipologie di oggetti",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.label": "Scegliere un piano di riferimento per comporre la forma del tipo di workstation",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.help": "Scegli un piano di riferimento per creare la forma in modo da poter disegnare la struttura posizionandoti su una pianta e avendo la giusta scala",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.label": "Scegli un piano di riferimento per creare la struttura",
  "ItemTypeAvatarSingleView.copy": "Copia i punti negli appunti",
  "ItemTypeAvatarSingleView.debug.label": "Abilita la modalità avanzata per il 3D",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.help": "Rimuovere completamente la forma del tipo di oggetto per poterlo, ad esempio, ridisegnarlo interamente o trasformarlo in un'icona",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.label": "elimina forma",
  "CopyItemTypesToCart.help": "Copia i tipi di articoli nel carrello",
  "PhysicalItemNotInsideWorkplaceRoom.alignRooms": "Cambiare gli spazi degli oggetti in quelli della workstation",
  "AddPersonToItem.text": "Associa una persona a questo oggetto",
  "AddPersonToItem.help": "Associa una persona a questo oggetto, puoi aggiungere più persone per lo stesso oggetto",
  "DimensionTypeDescription.NoDescription": "Non esiste una descrizione per questo tipo di livello di analisi, puoi aggiungerne altri modificandolo",
  "dimensionTypes.room_ground_type.one": "Tipo di terreno",
  "dimensionTypes.room_ground_type.description": "Permette di conoscere la composizione del terreno nello spazio",
  "dimensionTypes.room_usage.one": "Tipo di spazi",
  "dimensionTypes.room_usage.description": "Permette di identificare gli spazi in base ai loro usi",
  "dimensionTypes.frequency.one": "Frequenza",
  "dimensionTypes.frequency.description": "Permette di conoscere la frequenza del passaggio nello spazio",
  "dimensionTypes.evacuation_zone.one": "Sicurezza",
  "dimensionTypes.evacuation_zone.description": "Consente di gestire le zone di sicurezza e di evacuazione",
  "dimensionTypes.referent.one": "Referente",
  "dimensionTypes.referent.description": "Ti permette di sapere chi è assegnato alla manutenzione di questo spazio",
  "DimensionTypesByTab.action.true": "Seleziona tutto",
  "DimensionTypesByTab.action.false": "Deseleziona tutto",
  "DimensionTypesByTab.ListItemHasChildrenSelected": "Le dimensioni sono selezionate",
  "DimensionListItem.notSelected": "Seleziona %{dimension} per vedere gli spazi sulla planimetria con il colore associato",
  "DimensionListItem.selected": "Deseleziona %{dimension}",
  "DimensionInfo.roomsArea.help": "L'area per %{dimensionType} %{dimension} è %{value} m²",
  "DimensionInfo.roomsCount.help": "Sono presenti %{value} spazio/i per %{dimensionType} %{dimension}",
  "DimensionInfo.peopleCount.help": "Ci sono %{value} persone assegnate per %{dimensionType} %{dimension}",
  "DimensionInfo.totalPeopleCount.help": "Ci sono %{value} persone interessate in totale per %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesCount.help": "Sono presenti %{value} workstation per %{dimensionType} %{dimension}",
  "DimensionInfo.peopleRatio.help": "C'è %{value} m² per persona interessata per %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesRatio.help": "C'è %{value} m² per workstation per %{dimensionType} %{dimension}",
  "DimensionInfo.occupancyRate.help": "Il tasso di occupazione è %{value} % per %{dimensionType} %{dimension}",
  "DimensionInfo.expansionRatio.help": "Il tasso di espansione è %{value} per %{dimensionType} %{dimension}",
  "DimensionInfo.freeWorkplacesCount.help": "Sono disponibili %{value} workstation gratuite per %{dimensionType} %{dimension}",
  "DimensionInfo.flexWorkplacesCount.help": "Sono presenti %{value} workstation in flex per %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesCount.help": "Sono presenti %{value} workstation condivise per %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesRatio.help": "La tariffa per desktop condivisi è %{value} per %{dimensionType} %{dimension}",
  "DimensionInfo.flexRatio.help": "Il tasso di postazioni di lavoro flessibili",
  "DimensionInfo.transitWorkplacesCount.help": "Sono presenti %{value} -in per %{dimensionType} %{dimension}",
  "DimensionInfo.dimensionPeopleCount.help": "Sono presenti %{value} persone interessate in %{dimensionType} %{dimension}",
  "DimensionInfo.seatsCount.help": "Ci sono %{value} postazioni per %{dimensionType} %{dimension}",
  "DimensionInfo.seatsPeopleRatio.help": "La tariffa dei posti è %{value} posti disponibili a persona per %{dimensionType} %{dimension}",
  "DimensionInfo.carbonFootprint.help": "L'impronta di carbonio è %{value} di CO2 emessa per %{dimensionType} %{dimension}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.peopleCount": "Ci sono %{count} persone con centro di costo %{costCenterName}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.workplaceCount": "Ci sono %{count} postazioni di lavoro con almeno una persona con centro di costo %{costCenterName}",
  "PersonCostCenterWorkplaceFilter.Empty": "Non ci sono centri di costo associati alle persone",
  "NoDataOnBuildingInfo.noData": "Seleziona tutti i piani nelle opzioni del piano per avere i dati, non ci devono essere dati per i piani che hai selezionato",
  "CostCenterWorkplaceMapFilter.nodeInfo.workplacesCount": "Ci sono %{count} postazioni di lavoro con centro di costo %{name}",
  "CostCenterMapFilterTabs.tabs.rooms": "Spazi",
  "CostCenterMapFilterTabs.tabs.workplaces": "Posti di lavoro personali",
  "CostCenterMapFilterTabs.tabs.people": "Persone",
  "CostCenterMapFilter.Empty": "Non ci sono centri di costo attualmente associati agli spazi, puoi aggiungerne altri modificando uno spazio e associandovi un centro di costo, poi puoi controllarne la visualizzazione da questa sezione",
  "CostCenterWorkplaceMapFilter.Empty": "Al momento non ci sono centri di costo associati alle workstation, puoi aggiungerne altri modificando una workstation e associando ad essa un centro di costo, quindi puoi controllarne la visualizzazione da questa sezione",
  "BuildingReports.items.sheets.physicals": "Oggetti fisici",
  "BuildingReports.items.sheets.virtuals": "Oggetti virtuali",
  "BuildingReports.items.sheets.merged": "Fusione",
  "BuildingInventory.floor": "Piano",
  "BuildingInventory.quantity": "Quantità",
  "BuildingInventory.price": "Prezzo",
  "BuildingInventory.manufacturer": "Creatore",
  "BuildingInventory.quantityTotal": "Totale",
  "BuildingInventory.title": "L'inventario dell'edificio %{building.name}",
  "BuildingInventory.buttons.viewPDF.help": "Scarica il file PDF in modo da poterlo scaricare o condividere",
  "BuildingInventory.buttons.viewPDF.label": "Scarica la versione PDF",
  "BuildingInventory.itemTypesFamilySectionTitle": "Categorie di inventario",
  "BuildingInventory.fileNamePrefix": "inventario",
  "BuildingLabel.scenario": "Questo edificio è uno scenario dell'edificio %{name}",
  "CopyBuildingToCart.help": "Copia la struttura dell'edificio",
  "BuildingClonePropertiesSelector.properties.clone.workplaces": "Copiare le postazioni di lavoro",
  "BuildingClonePropertiesSelector.properties.clone.items": "Copia oggetti",
  "BuildingDistributionCost.floors.excel.tabs.floors": "Chiavi di distribuzione per piano",
  "BuildingDistributionCost.floors.excel.tabs.building": "Chiavi di distribuzione per l'edificio",
  "BuildingDistributionCost.floors.excel.tabs.buildingDetailed": "Dettagli dell'edificio per centro di costo",
  "BuildingDistributionCost.floors.excel.download.label": "Scarica il file excel con le disaggregazioni",
  "BuildingDistributionCost.floors.excel.download.help": "Scarica il file excel per poter condividere ed esportare le chiavi di distribuzione e le aree qualificate per centro di costo e per piano, l'export prevede la distribuzione per piano o per edificio dei centri di costo",
  "BuildingDistributionCost.floors.excel.headers.floors.floorName": "Nome del piano",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterName": "Centro di costo",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterArea": "Area degli spazi comprese le distribuzioni del pavimento",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterRoomsArea": "Area degli spazi del centro di costo",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterDistributedFloorRatio": "Rapporto di utilizzo nel pavimento",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterFloorDistributedArea": "Superficie totale degli spazi da distribuire al piano per questo centro di costo",
  "BuildingDistributionCost.floors.excel.headers.floors.floorArea": "Superficie totale comprese le distribuzioni del pavimento",
  "BuildingDistributionCost.floors.excel.headers.floors.totalFloorDistributedArea": "Superficie da distribuire nel pavimento",
  "BuildingDistributionCost.floors.excel.headers.floors.totalBuildingDistributedArea": "Superficie calpestabile da distribuire nell'edificio",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterName": "Centro di costo",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterArea": "Area totale del centro di costo",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterBuildingRatio": "Rapporto di utilizzo dell'edificio",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterDistributedBuildingArea": "Superficie totale degli spazi distribuiti dell'edificio",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterRoomsArea": "Area degli spazi del centro di costo",
  "BuildingDistributionCost.floors.excel.headers.building.buildingArea": "Superficie totale degli spazi dell'edificio",
  "BuildingDistributionCost.floors.excel.headers.building.buildingDistributedArea": "Superficie da distribuire nell'edificio",
  "BuildingDistributionCost.floors.excel.headers.building.totalBuildingArea": "Superficie totale edificabile",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.buildingName": "Edificio",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterName": "Centro di costo",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterArea": "Zona del centro di costo",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterBuildingRatio": "Chiave di distribuzione nell'edificio",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.distributedCostCenterArea": "Distribuzione del centro di costo %{costCenterName}",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterTotalArea": "Superficie totale da rifatturare",
  "BuildingDistributionCost.excel.tabs.distributionCost": "Chiavi di distribuzione",
  "BuildingDistributionCost.excel.tabs.distributionCostDetails": "Particolari",
  "BuildingDistributionCost.excel.download.label": "Scarica il file excel senza suddivisioni",
  "BuildingDistributionCost.excel.download.help": "Scarica il file excel per poter condividere ed esportare le chiavi di distribuzione e le aree qualificate per centro di costo",
  "BuildingDistributionCost.Title": "Chiavi di distribuzione e aree qualificate per centro di costo senza suddivisioni",
  "BuildingDistributionCost.table.type": "Tipo",
  "BuildingDistributionCost.table.distributionKey": "Chiave di distribuzione",
  "BuildingDistributionCost.table.costCenterDistributionKey": "Chiave di allocazione per centro di costo",
  "BuildingDistributionCost.table.workplacesCount": "Numero di postazioni di lavoro",
  "BuildingDistributionCost.table.workplaceTotalCount": "Numero totale di postazioni di lavoro",
  "BuildingFloorSelection.title": "Pavimenti da duplicare nel tuo scenario",
  "BuildingFloorSelection.all.select": "Seleziona tutti i piani",
  "BuildingFloorSelection.all.unselect": "Deseleziona tutti i piani",
  "BuildingCloneFloorSelection.title": "Pavimenti da duplicare nel tuo scenario",
  "BuildingCloneFloorSelection.all.select": "Seleziona tutti i piani",
  "BuildingCloneFloorSelection.all.unselect": "Deseleziona tutti i piani",
  "BuildingClone.noClone": "Nessuno scenario è stato ancora creato, puoi creare il tuo primo scenario per questo edificio",
  "BuildingClone.buttons.CreateClone.label": "Crea uno scenario",
  "BuildingClone.buttons.CreateClone.help": "Lo scenario duplicherà l'edificio con le proprietà controllate",
  "BuildingClone.accordion.title": "Crea un nuovo scenario",
  "BuildingClone.properties.clone.people": "Compiti duplicati",
  "BuildingClone.properties.clone.workplaces": "Postazioni di lavoro duplicate",
  "BuildingClone.properties.clone.items": "Oggetti duplicati",
  "BuildingClone.properties.clone.dimensions": "Associare i livelli di analisi e assegnazione agli spazi",
  "BuildingClone.properties.clone.organization": "Associare le organizzazioni con gli spazi",
  "BuildingDashboard.dashboards.workplace": "Cruscotto del desktop",
  "BuildingDashboard.dashboards.area": "Dashboard delle superfici",
  "CampusBuildingsAccordion.buildingCount": "Il numero di edifici",
  "CalculatedPropertiesAccordions.mesures": "Misure",
  "CalculatedPropertiesAccordions.kpi": "Indicatori",
  "DimensionMapFilter.TooltipTitle.notSelected": "Seleziona %{dimension} per vedere gli spazi sulla planimetria con il colore associato",
  "DimensionMapFilter.TooltipTitle.selected": "Deselezionando %{dimension} verrà rimosso il colore associato dal piano",
  "DimensionMapFilter.tooltip.true": "Seleziona tutti i filtri sottostanti per colorarli sulla mappa",
  "DimensionMapFilter.tooltip.false": "Deseleziona tutti i filtri di seguito",
  "DimensionMapFilter.NoNode": "Al momento non ci sono layer di analisi, puoi aggiungerne altri modificando uno spazio e aggiungendovi layer di analisi",
  "DimensionMapFilter.NoCategory": "Non ci sono layer di analisi disponibili, devi prima associarne alcuni ai vani",
  "SelectDimensionTypeNavigationLayoutIcon.select": "Seleziona questo tipo di livello per la navigazione",
  "SelectDimensionTypeNavigationLayoutIcon.unselect": "Rimuovi la navigazione per livello di analisi e torna alla navigazione per spazi",
  "SelectDimensionTypeNavigationLayoutIcon.help": "La navigazione per layer di analisi permette di cliccare su uno spazio, selezionare il layer corrispondente e vedere attraverso gli spazi le persone assegnate a questo layer oppure le postazioni e gli oggetti associati a questo layer",
  "DimensionTypeNavigationWarning.message": "Stai navigando per %{name} , gli spazi verranno raggruppati durante la selezione. Fare clic per annullare e tornare alla navigazione nello spazio",
  "RoomCardSelectDimensions.needSave": "Salva o annulla le modifiche prima di poter modificare i livelli di analisi di questo spazio",
  "AssignPersonToWorkplaceCheckListDialogTitle.title": "Hai assegnato %{personName} alla workstation %{workplaceName}",
  "AssignPersonToRoomCheckListDialogTitle.title": "Hai assegnato %{personName} allo spazio %{roomName}",
  "WorkplaceFullName.noName": "Postazione di lavoro senza nome",
  "RoomFullName.noName": "spazio senza nome",
  "AssignPersonCheckListWorkplaceTransit.title": "La workstation %{workplaceName} è una workstation temporanea",
  "AssignPersonCheckListWorkplaceTransit.RemoveIsTransit": "Rimuovere il tipo &quot;sta passando&quot; dalla workstation",
  "AssignPersonCheckListWorkplaceAffectations.title": "Questa persona è già assegnata su altre postazioni di lavoro, vuoi rimuovere le seguenti assegnazioni per %{personFullname}",
  "AssignPersonCheckListRoomAffectations.title": "Questa persona è già assegnata direttamente ad altri spazi, vuoi rimuovere le seguenti assegnazioni per %{personFullname}",
  "AssignPersonCheckListDialogApplyButton.help": "Elimina gli incarichi selezionati che potrebbero corrispondere ai vecchi incarichi della persona",
  "AssignPersonCheckListDialogApplyButton.label": "Elimina i compiti selezionati",
  "AssignPersonCheckListDialog.actions.close.label": "Chiudere",
  "AssignPersonCheckListDialog.actions.close.help": "Chiudi e non eliminare altre assegnazioni",
  "AssignPersonCheckListBuildingAffectations.title": "Questa persona è già assegnata direttamente su altri edifici, vuoi rimuovere le seguenti assegnazioni per %{personFullname}",
  "WorkplaceVirtualInventory.title": "Inventario della workstation virtuale",
  "WorkplacePhysicalInventory.title": "Inventario fisico della workstation",
  "WorkplaceTypeSeatsCount.label": "Numero di posti",
  "WorkplaceTypeSeatsCount.help": "Il numero di postazioni conteggiate per questo tipo di postazione di lavoro",
  "WorkplaceTypeCarbonFootprintCount.label": "Impronta ecologica",
  "WorkplaceTypeCarbonFootprintCount.help": "L'impronta di carbonio è la quantità di gas serra emessi dagli oggetti d'arredo di questo tipo di postazione di lavoro",
  "DeleteWorkplace.help": "Elimina workstation: [ %{name} ], anche le assegnazioni verranno eliminate",
  "AddPersonToWorkplace.text": "Assegna una persona",
  "AddPersonToWorkplace.help": "Aggiungi un compito a questa workstation, puoi aggiungere più compiti per la stessa workstation",
  "MouvementMatrixImport.errors.noSheet": "Impossibile trovare il foglio Excel con nome %{name} [ %{objectTypeName} ]",
  "RoomTypeGroupMapFilter.Empty": "Non esiste alcun gruppo di tipi di spazio associato agli spazi tramite i tipi di spazio, puoi aggiungerne altri modificando un gruppo di tipi di spazio e aggiungendovi associando un tipo di spazio, quindi puoi controllarne la visualizzazione da questa sezione",
  "RoomTypeGroupLabel.exclude.tooltip": "Il gruppo di tipologie di spazio esclude i tipi di spazio associati",
  "RoomTypeGroupHelpTitle.exclude": "Il tipo di spazio raggruppato %{name} è di tipo esclusione. Riunisce tutti gli spazi ad eccezione delle seguenti tipologie di spazi:",
  "RoomTypeGroupHelpTitle.include": "Il raggruppamento di tipi di spazio %{name} riunisce le seguenti tipologie di spazio:",
  "RoomTypeGroupToRoomTypeLabel.exclude.tooltip": "La tipologia dello spazio è esclusa",
  "RoomMapFilter.Empty": "Non esiste un tipo di spazio associato agli spazi, puoi aggiungerne altri modificando uno spazio e aggiungendovi un tipo associato, quindi puoi controllarne la visualizzazione da questa sezione",
  "LayoutFiltersTabZone.collapse.help": "Il menu è chiuso, puoi aprirlo cliccando sulla prima icona per aprirlo e vedere i dettagli degli elementi del piano",
  "LayoutFiltersTabOpenToggleIcon.open.true": "Chiudi il menu della mappa per ottimizzare lo spazio di visualizzazione della mappa",
  "LayoutFiltersTabOpenToggleIcon.open.false": "Apri il menu del piano per visualizzare informazioni dettagliate relative al piano",
  "CompanyTypeLabel.notClassified": "Piattaforma non classificata",
  "BuildingMenuItem.menu.scenario": "Scenari ( %{count} )",
  "SearchMenuItem.icon.tooltip": "ricercare",
  "RemoveFromCartIconButton.help": "Rimuovere dal cestino",
  "CopyCartContentIntoTenant.buttons.single.paste.help": "Importa in questa azienda",
  "IndexContextMenuItem.navigation": "Navigazione",
  "GlobalSearchIncludeScenarios.label": "Includi scenari nella ricerca",
  "GlobalSearch.Input.placeholder": "ricercare",
  "GlobalSearch.Start": "Puoi cercare ad esempio persone, spazi, postazioni di lavoro, oggetti o altre entità, la ricerca partirà dal 2° carattere",
  "GlobalSearch.NoResult": "Nessun risultato è stato trovato per la tua ricerca",
  "GlobalSearch.close.help": "Cancella ricerca",
  "models.PartnerExportMappingConfigurationToFloor.singular": "Fase inclusa nella configurazione della trasformazione delle esportazioni dei partner",
  "models.PartnerExportMappingConfigurationToFloor.plural": "Fasi incluse nella configurazione della trasformazione dell'esportazione dei partner",
  "models.PartnerExportMappingConfigurationToFloor.determinant.defined": "la fase inclusa nella configurazione della trasformazione delle esportazioni dei partner",
  "models.PartnerExportMappingConfigurationToFloor.determinant.undefined": "una tappa inserita nella configurazione della trasformazione dell'export partner",
  "models.PartnerExportMappingConfigurationToFloor.determinants.defined": "le fasi incluse nelle configurazioni delle trasformazioni di esportazione dei partner",
  "models.PartnerExportMappingConfigurationToFloor.determinants.undefined": "fasi incluse nelle configurazioni delle trasformazioni di esportazione dei partner",
  "models.PartnerExportMappingToRoomType.singular": "Trasformazione delle esportazioni dei partner per tipi di spazio",
  "models.PartnerExportMappingToRoomType.plural": "Trasformazioni delle esportazioni dei partner per i tipi di spazio",
  "models.PartnerExportMappingToRoomType.determinant.defined": "la trasformazione delle esportazioni dei partner per tipologie di spazi",
  "models.PartnerExportMappingToRoomType.determinant.undefined": "una trasformazione delle esportazioni dei partner per tipologie di spazi",
  "models.PartnerExportMappingToRoomType.determinants.defined": "trasformazioni delle esportazioni dei partner per tipologie di spazio",
  "models.PartnerExportMappingToRoomType.determinants.undefined": "trasformazioni delle esportazioni dei partner per tipologie di spazio",
  "models.PartnerExportMappingConfiguration.singular": "Configurazione della trasformazione dell'esportazione dei partner",
  "models.PartnerExportMappingConfiguration.plural": "Configurazioni delle trasformazioni di esportazione dei partner",
  "models.PartnerExportMappingConfiguration.determinant.defined": "configurare la trasformazione delle esportazioni dei partner",
  "models.PartnerExportMappingConfiguration.determinant.undefined": "una configurazione della trasformazione delle esportazioni dei partner",
  "models.PartnerExportMappingConfiguration.determinants.defined": "configurazioni delle trasformazioni di esportazione dei partner",
  "models.PartnerExportMappingConfiguration.determinants.undefined": "configurazioni delle trasformazioni di esportazione dei partner",
  "models.PartnerExportMapping.singular": "Trasformazione delle esportazioni dei partner",
  "models.PartnerExportMapping.plural": "Trasformazioni delle esportazioni dei partner",
  "models.PartnerExportMapping.determinant.defined": "la trasformazione delle esportazioni dei partner",
  "models.PartnerExportMapping.determinant.undefined": "una trasformazione delle esportazioni dei partner",
  "models.PartnerExportMapping.determinants.defined": "trasformazioni delle esportazioni dei partner",
  "models.PartnerExportMapping.determinants.undefined": "trasformazioni delle esportazioni dei partner",
  "models.WorkplaceTypeItemType.singular": "tipo di oggetto nel tipo di workstation",
  "models.WorkplaceTypeItemType.plural": "tipi di oggetto nel tipo di workstation",
  "models.WorkplaceTypeItemType.determinant.defined": "il tipo di oggetto nel tipo di workstation",
  "models.WorkplaceTypeItemType.determinant.undefined": "un tipo di oggetto in un tipo di workstation",
  "models.WorkplaceTypeItemType.determinants.defined": "tipi di oggetti nei tipi di workstation",
  "models.WorkplaceTypeItemType.determinants.undefined": "tipi di oggetto nei tipi di workstation",
  "models.WorkplaceTypeItemType.properties.id.label": "Identificatore del tipo di oggetto nel tipo di workstation",
  "models.WorkplaceTypeItemType.properties.zIndex.label": "Indice di altezza",
  "models.WorkplaceTypeItemType.properties.zIndex.description": "L'indice di altezza permette di definire l'ordine di visualizzazione delle tipologie di oggetto, più grande è l'indice più l'oggetto sarà sopra gli altri",
  "models.WorkplaceTypeItemType.properties.physicalInventory.label": "Inventario fisico",
  "models.WorkplaceTypeItemType.properties.physicalInventory.description": "Se questa opzione è selezionata per ogni postazione di lavoro verrà creato un oggetto fisico in Surfy, questo oggetto potrà avere un riferimento univoco, in tutti i casi l'inventario dell'edificio sarà aggiornato",
  "models.WorkplaceTypeItemType.properties.seatsCount.label": "Numero di posti",
  "models.WorkplaceTypeItemType.properties.seatsCount.description": "Permette di definire il numero di posti disponibili nella tipologia postazione per questo tipo di oggetto",
  "models.WorkplaceType.singular": "tipo di postazione di lavoro",
  "models.WorkplaceType.plural": "tipi di postazione di lavoro",
  "models.WorkplaceType.determinant.defined": "il tipo di postazione di lavoro",
  "models.WorkplaceType.determinant.undefined": "un tipo di postazione di lavoro",
  "models.WorkplaceType.determinants.defined": "tipi di postazione di lavoro",
  "models.WorkplaceType.determinants.undefined": "tipi di postazione di lavoro",
  "models.WorkplaceType.properties.id.label": "Identificatore del tipo di workstation",
  "models.WorkplaceType.properties.id.description": "???",
  "models.WorkplaceType.properties.name.label": "Nome del tipo di workstation",
  "models.WorkplaceType.properties.name.description": "???",
  "models.WorkplaceType.views.editor.help": "Modifica forme e posizioni dei tipi di oggetto per il tipo di workstation %{name}",
  "models.WorkplaceType.views.editor.label": "Modifica forme",
  "models.WorkplaceType.views.avatar.help": "Visualizza il modulo del tipo di workstation %{name}",
  "models.WorkplaceType.views.avatar.label": "Vedi il modulo",
  "models.WorkplaceType.views.dq-not-used.label": "Non usato",
  "models.WorkplaceType.views.dq-not-used.help": "Elenca tutti i tipi di workstation inutilizzati tramite workstation",
  "models.WorkplaceAffectation.singular": "Assegnazione postazione di lavoro",
  "models.WorkplaceAffectation.plural": "Compiti della postazione di lavoro",
  "models.WorkplaceAffectation.description": "Permette di assegnare una postazione fissa ad una persona",
  "models.WorkplaceAffectation.determinant.defined": "incarico di lavoro",
  "models.WorkplaceAffectation.determinant.undefined": "incarico di lavoro",
  "models.WorkplaceAffectation.determinants.defined": "incarichi di lavoro",
  "models.WorkplaceAffectation.determinants.undefined": "incarichi di lavoro",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.help": "Importa matrici di trasferimento workstation",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.label": "Importa matrice di trasferimento",
  "models.Workplace.singular": "posto di lavoro",
  "models.Workplace.plural": "posti di lavoro personali",
  "models.Workplace.determinant.defined": "desktop",
  "models.Workplace.determinant.undefined": "una postazione di lavoro",
  "models.Workplace.determinants.defined": "postazioni di lavoro",
  "models.Workplace.determinants.undefined": "postazioni di lavoro",
  "models.Workplace.views.assign-current-user.label": "Occupare la postazione di lavoro",
  "models.Workplace.views.assign-current-user.help": "Occupa la postazione di lavoro %{name}",
  "models.Workplace.properties.id.label": "ID stazione di lavoro",
  "models.Workplace.properties.id.description": "???",
  "models.Workplace.properties.color.label": "Colore",
  "models.Workplace.properties.color.description": "Il colore che il tipo di workstation assumerà sul piano",
  "models.Workplace.properties.name.label": "Nome della stazione di lavoro",
  "models.Workplace.properties.name.description": "Il nome della workstation viene utilizzato per identificarla in modo più semplice",
  "models.Workplace.properties.isFlex.label": "è flessibile?",
  "models.Workplace.properties.isFlex.description": "Se questa estensione viene utilizzata in modalità Flex",
  "models.Workplace.properties.isShared.label": "è condiviso?",
  "models.Workplace.properties.isShared.description": "Se questa postazione è condivisa da più persone, questo campo automatico viene convalidato non appena ci sono almeno 2 assegnazioni sulla postazione",
  "models.Workplace.properties.isTransit.label": "sta passando?",
  "models.Workplace.properties.isTransit.description": "Se questa posizione è transitoria, questa posizione sarà esclusa dalle postazioni libere senza essere prenotabile in flex, una posizione transitoria permette di avere una postazione a disposizione per tutti coloro che desiderano utilizzarla senza essere inseriti in un sistema di prenotazione",
  "models.Workplace.properties.isBookable.label": "è prenotabile?",
  "models.Workplace.properties.isBookable.description": "Se questa postazione di lavoro è prenotabile in un sistema di prenotazione",
  "models.Workplace.properties.position.label": "Posizione",
  "models.Workplace.properties.position.description": "La posizione della postazione di lavoro nello spazio",
  "models.Workplace.properties.rotation.label": "Rotazione",
  "models.Workplace.properties.rotation.description": "L'angolo di rotazione della postazione di lavoro nello spazio",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.label": "Tasso medio di assegnazione",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.description": "Tasso medio di assegnazione della postazione in funzione dell'assegnazione dei giorni di presenza delle persone",
  "models.Workplace.properties.workplaceAffectationsCount.label": "Numero di incarichi",
  "models.Workplace.properties.workplaceAffectationsCount.description": "Numero di assegnazioni sulla workstation",
  "models.Workplace.properties.comment.label": "Commento",
  "models.Workplace.properties.comment.description": "Ulteriori informazioni sulla stazione di lavoro",
  "models.Workplace.properties.room.label": "Spazio della postazione di lavoro",
  "models.UserRegistrationTenantRuleToJupRole.singular": "Associazione della regola di autenticazione al ruolo",
  "models.UserRegistrationTenantRuleToJupRole.plural": "Associazioni di autenticazione da regola a ruolo",
  "models.UserRegistrationTenantRuleToJupRole.determinant.defined": "associazione della regola di autenticazione al ruolo",
  "models.UserRegistrationTenantRuleToJupRole.determinant.undefined": "un'associazione da regola a ruolo di autenticazione",
  "models.UserRegistrationTenantRuleToJupRole.determinants.defined": "associazioni da regola a ruolo di autenticazione",
  "models.UserRegistrationTenantRuleToJupRole.determinants.undefined": "associazioni da regola a ruolo di autenticazione",
  "models.UserRegistrationTenantRuleToContentRole.singular": "Regola di autenticazione all'associazione del ruolo del contenuto",
  "models.UserRegistrationTenantRuleToContentRole.plural": "Regola di autenticazione per le associazioni di ruoli del contenuto",
  "models.UserRegistrationTenantRuleToContentRole.determinant.defined": "Regola di autenticazione all'associazione del ruolo del contenuto",
  "models.UserRegistrationTenantRuleToContentRole.determinant.undefined": "una regola di autenticazione per l'associazione del ruolo del contenuto",
  "models.UserRegistrationTenantRuleToContentRole.determinants.defined": "regola di autenticazione alle associazioni di ruoli del contenuto",
  "models.UserRegistrationTenantRuleToContentRole.determinants.undefined": "associazioni di regole da ruolo ad autenticazione del contenuto",
  "models.UserRegistrationTenantRule.singular": "Regola di autenticazione",
  "models.UserRegistrationTenantRule.plural": "Regole di autenticazione",
  "models.UserRegistrationTenantRule.determinant.defined": "la regola di autenticazione",
  "models.UserRegistrationTenantRule.determinant.undefined": "una regola di autenticazione",
  "models.UserRegistrationTenantRule.determinants.defined": "regole di autenticazione",
  "models.UserRegistrationTenantRule.determinants.undefined": "regole di autenticazione",
  "models.UserRegistrationTenantRule.properties.domains.label": "le zone",
  "models.UserRegistrationTenantRule.properties.domains.description": "Separare i domini con spazi e includere il segno di chiocciola",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.label": "Associa automaticamente i ruoli",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.description": "Associa automaticamente ruoli e ruoli contenuto agli utenti che soddisfano questa regola",
  "models.UserCompany.singular": "utente aziendale",
  "models.UserCompany.plural": "utenti aziendali",
  "models.UserCompany.description": "Gli utenti aziendali hanno accesso alla piattaforma Surfy della propria azienda",
  "models.UserCompany.determinant.defined": "utente aziendale",
  "models.UserCompany.determinant.undefined": "un utente aziendale",
  "models.UserCompany.determinants.defined": "utenti aziendali",
  "models.UserCompany.determinants.undefined": "utenti aziendali",
  "models.UserCompany.properties.id.label": "ID utente dell'azienda",
  "models.UserCompany.properties.buildingOwners.label": "Edifici di proprietà",
  "models.UserCompany.properties.buildingOwners.description": "Edifici di proprietà dell'utente",
  "models.User.singular": "utente",
  "models.User.plural": "utenti",
  "models.User.determinant.defined": "l'utente",
  "models.User.determinant.undefined": "un utente",
  "models.User.determinants.defined": "gli utenti",
  "models.User.determinants.undefined": "utenti",
  "models.User.properties.id.label": "ID utente",
  "models.User.properties.id.description": "???",
  "models.User.properties.firstname.label": "Nome",
  "models.User.properties.firstname.description": "Il nome dell'utente",
  "models.User.properties.lastname.label": "Cognome",
  "models.User.properties.lastname.description": "Il cognome dell'utente",
  "models.User.properties.email.label": "E-mail",
  "models.User.properties.email.description": "L'e-mail utilizzata dall'utente per la corrispondenza o per l'autenticazione",
  "models.Structure.singular": "struttura",
  "models.Structure.plural": "strutture",
  "models.Structure.determinant.defined": "la struttura",
  "models.Structure.determinant.undefined": "una struttura",
  "models.Structure.determinants.defined": "le strutture",
  "models.Structure.determinants.undefined": "strutture",
  "models.Structure.properties.nom.label": "Nome della struttura",
  "models.Structure.properties.nom.description": "Per trovare e riutilizzare facilmente la struttura",
  "models.Structure.properties.transform.label": "Trasformazione",
  "models.Structure.properties.transform.description": "Trasformazione della struttura per calibrarla su mappa",
  "models.Structure.views.editor.label": "Modifica forma",
  "models.Structure.views.editor.help": "Modifica la forma della struttura",
  "models.Structure.views.gmap-calibrate.label": "Calibrare la struttura su una mappa",
  "models.Structure.views.gmap-calibrate.help": "Calibrare la struttura su una mappa per associare le coordinate geografiche",
  "models.RoomTypeGroupToRoomType.singular": "associazione del gruppo di tipologie di spazio con la tipologia di spazio",
  "models.RoomTypeGroupToRoomType.plural": "associazioni di gruppi di tipologie spaziali a tipologie spaziali",
  "models.RoomTypeGroupToRoomType.determinant.defined": "l'associazione del gruppo di tipologie di spazio con la tipologia di spazio",
  "models.RoomTypeGroupToRoomType.determinant.undefined": "un'associazione di gruppo di tipologia di spazio con tipologia di spazio",
  "models.RoomTypeGroupToRoomType.determinants.defined": "associazioni di gruppo di tipologie di spazio a tipologie di spazio",
  "models.RoomTypeGroupToRoomType.determinants.undefined": "associazioni di gruppo di tipologie di spazio a tipologie di spazio",
  "models.RoomTypeGroupFloor.singular": "gruppo di tipologie di superficie",
  "models.RoomTypeGroupFloor.plural": "gruppi di tipologie di superficie",
  "models.RoomTypeGroupFloor.determinant.defined": "il gruppo di tipologie di superficie",
  "models.RoomTypeGroupFloor.determinant.undefined": "un gruppo di tipologie di superficie",
  "models.RoomTypeGroupFloor.determinants.defined": "il gruppo di tipologie di superficie",
  "models.RoomTypeGroupFloor.determinants.undefined": "gruppi di tipologie di superficie",
  "models.RoomTypeGroupBuilding.singular": "gruppo di edifici per tipologia spaziale",
  "models.RoomTypeGroupBuilding.plural": "gruppi di tipologie di spazi edilizi",
  "models.RoomTypeGroupBuilding.determinant.defined": "il gruppo di tipologia degli spazi edificabili",
  "models.RoomTypeGroupBuilding.determinant.undefined": "un gruppo di tipologie di spazi edilizi",
  "models.RoomTypeGroupBuilding.determinants.defined": "il gruppo di tipologia degli spazi edificabili",
  "models.RoomTypeGroupBuilding.determinants.undefined": "gruppi di tipologie di spazi edilizi",
  "models.RoomTypeGroup.singular": "gruppo di tipologie di spazio",
  "models.RoomTypeGroup.plural": "gruppi di tipologie spaziali",
  "models.RoomTypeGroup.determinant.defined": "il gruppo di tipologia spaziale",
  "models.RoomTypeGroup.determinant.undefined": "un gruppo di tipologia spaziale",
  "models.RoomTypeGroup.determinants.defined": "gruppi di tipologie spaziali",
  "models.RoomTypeGroup.determinants.undefined": "gruppi di tipologie spaziali",
  "models.RoomTypeGroup.properties.id.label": "Identificatore del gruppo della tipologia di spazio",
  "models.RoomTypeGroup.properties.name.label": "Nome del gruppo di tipologie di spazio",
  "models.RoomTypeGroup.properties.code.label": "codificato",
  "models.RoomTypeGroup.properties.color.label": "Colore",
  "models.RoomTypeGroup.properties.exclude.label": "Escludere",
  "models.RoomTypeGroup.properties.exclude.description": "Escludi tipologie di spazio da questo gruppo",
  "models.RoomTypeFloor.singular": "tipologia dello spazio calpestabile",
  "models.RoomTypeFloor.plural": "tipologie di superficie",
  "models.RoomTypeFloor.determinant.defined": "la tipologia della superficie",
  "models.RoomTypeFloor.determinant.undefined": "una tipologia di superficie",
  "models.RoomTypeFloor.determinants.defined": "tipologie di superficie",
  "models.RoomTypeFloor.determinants.undefined": "tipologie di superficie",
  "models.RoomTypeBuilding.singular": "tipologia dello spazio edilizio",
  "models.RoomTypeBuilding.plural": "tipologie degli spazi edilizi",
  "models.RoomTypeBuilding.determinant.defined": "la tipologia dello spazio edificabile",
  "models.RoomTypeBuilding.determinant.undefined": "una tipologia di spazio edificabile",
  "models.RoomTypeBuilding.determinants.defined": "tipologie degli spazi edilizi",
  "models.RoomTypeBuilding.determinants.undefined": "tipologie degli spazi edilizi",
  "models.RoomType.singular": "tipologia dello spazio",
  "models.RoomType.plural": "tipologie spaziali",
  "models.RoomType.determinant.defined": "tipologia spaziale",
  "models.RoomType.determinant.undefined": "una tipologia di spazio",
  "models.RoomType.determinants.defined": "tipologie spaziali",
  "models.RoomType.determinants.undefined": "tipologie spaziali",
  "models.RoomType.properties.id.label": "Identificatore della tipologia di spazio",
  "models.RoomType.properties.name.label": "Nome del tipo di spazio",
  "models.RoomType.properties.color.label": "Colore in 2d",
  "models.RoomType.properties.color.description": "Il colore del tipo di spazio consente di differenziare ogni tipo sul piano 2d",
  "models.RoomType.properties.color3d.label": "colore 3D",
  "models.RoomType.properties.color3d.description": "Permette di gestire il colore del tipo di spazio in 3d, questa opzione è applicabile solo alla visione 3d del pavimento",
  "models.RoomType.properties.displayWallsOn3d.label": "Mostra muri",
  "models.RoomType.properties.displayWallsOn3d.description": "Permette di visualizzare o meno le pareti dello spazio nella planimetria 3d, le pareti non visualizzate sono punteggiate in 2d, questo permette di avere una visione più gradevole, soprattutto per gli spazi aperti",
  "models.RoomType.properties.icon.label": "Icona",
  "models.RoomType.properties.icon.description": "L'icona per il tipo di spazio permette di visualizzare per questo tipo di spazio un'icona nelle piante 2d e 3d al posto delle classiche informazioni sulla pianta, associata al colore di sfondo questo permette di rendere maggiormente la lettura della pianta piacevole",
  "models.RoomType.properties.cadence.label": "Cadenza",
  "models.RoomType.properties.cadence.description": "La tariffa è un valore numerico utilizzato per indicare la difficoltà di pulizia della tipologia di spazio. È pari al numero di m² trattabili in un'ora in questa tipologia (circolazione, laboratorio, ecc.)",
  "models.RoomType.properties.isBookable.label": "è prenotabile?",
  "models.RoomType.properties.isBookable.description": "Seleziona questa casella se questo tipo di spazio può essere prenotato",
  "models.RoomPointSegmentType.singular": "Tipo di segmento",
  "models.RoomPointSegmentType.plural": "Tipi di segmento",
  "models.RoomPointSegmentType.determinant.defined": "il tipo di segmento",
  "models.RoomPointSegmentType.determinant.undefined": "un tipo di segmento",
  "models.RoomPointSegmentType.determinants.defined": "tipi di segmenti",
  "models.RoomPointSegmentType.determinants.undefined": "tipi di segmenti",
  "models.RoomPointSegment.singular": "qualificazione del segmento",
  "models.RoomPointSegment.plural": "qualifiche di segmento",
  "models.RoomPointSegment.determinant.defined": "qualificazione del segmento",
  "models.RoomPointSegment.determinant.undefined": "una qualificazione del segmento",
  "models.RoomPointSegment.determinants.defined": "qualifiche di segmento",
  "models.RoomPointSegment.determinants.undefined": "qualifiche di segmento",
  "models.RoomPointSegment.properties.reversePoints.label": "Punti inversi",
  "models.RoomPointSegment.properties.reversePoints.description": "Invertire i punti del segmento per avere la visualizzazione, ad esempio, delle porte nella giusta direzione",
  "models.RoomPointSegment.properties.displayBothSides.label": "Mostra su entrambi i lati",
  "models.RoomPointSegment.properties.displayBothSides.description": "Mostra il segmento su entrambi i lati del segmento",
  "models.RoomPointSegment.views.dq-not-uniq.label": "Segmenti di punti non univoci",
  "models.RoomPointSegment.views.dq-not-uniq.help": "Permette di verificare che non vi sia un segmento duplicato esatto sugli stessi punti",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.label": "I punti del segmento si trovano su 2 piani diversi",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.help": "Permette di verificare che i punti del segmento siano sullo stesso piano",
  "models.RoomPointRoom.singular": "Associazione tra un punto e uno spazio",
  "models.RoomPointRoom.plural": "Associazioni tra un punto e uno spazio",
  "models.RoomPointRoom.determinant.defined": "l'associazione tra un punto e uno spazio",
  "models.RoomPointRoom.determinant.undefined": "un punto",
  "models.RoomPointRoom.description": "L'associazione tra un punto e uno spazio permette di preservare l'ordine dei punti in uno spazio per costituire un polione",
  "models.RoomPointRoom.properties.id.label": "Identificatore dell'associazione tra un punto e uno spazio",
  "models.RoomPointRoom.properties.id.description": "???",
  "models.RoomPointRoom.properties.roomId.label": "Identificatore di spazio",
  "models.RoomPointRoom.properties.roomId.description": "???",
  "models.RoomPointRoom.properties.externalId.label": "Identificatore esterno",
  "models.RoomPointRoom.properties.externalId.description": "???",
  "models.RoomPointRoom.properties.sortIndex.label": "Ordina indice",
  "models.RoomPointRoom.properties.sortIndex.description": "???",
  "models.RoomPointRoom.properties.roomPointId.label": "ID punto",
  "models.RoomPointRoom.properties.roomPointId.description": "???",
  "models.RoomPoint.singular": "punto di spazi",
  "models.RoomPoint.plural": "punti spaziali",
  "models.RoomPoint.determinant.defined": "punto di spazi",
  "models.RoomPoint.determinant.undefined": "un punto di spazi",
  "models.RoomPoint.properties.id.label": "ID punto spazi",
  "models.RoomPoint.properties.x.label": "X",
  "models.RoomPoint.properties.x.description": "Coordinata sull'asse X",
  "models.RoomPoint.properties.y.label": "là",
  "models.RoomPoint.properties.y.description": "Coordinata sull'asse Y",
  "models.RoomPoint.properties.sort_index.label": "Ordine",
  "models.RoomPoint.properties.sort_index.description": "L'indice utilizzato per l'ordinamento",
  "models.RoomPoint.properties.room.description": "???",
  "models.RoomPoint.properties.externalId.label": "Identificatore esterno",
  "models.RoomPoint.properties.externalId.description": "???",
  "models.RoomPoint.views.dq-uniq-position.label": "Posizione del punto singolo",
  "models.RoomPoint.views.dq-uniq-position.help": "Permette di verificare che non vi sia una esatta posizione duplicata sui punti",
  "models.RoomPoint.views.dq-not-used.label": "Punti inutilizzati",
  "models.RoomPoint.views.dq-not-used.help": "Consente di visualizzare i punti non utilizzati negli spazi",
  "models.RoomConnector.singular": "Connettore spaziale",
  "models.RoomConnector.plural": "Connettori spaziali",
  "models.RoomConnector.determinant.defined": "il connettore spaziale",
  "models.RoomConnector.determinant.undefined": "un connettore spaziale",
  "models.RoomConnector.determinants.defined": "connettori spaziali",
  "models.RoomConnector.determinants.undefined": "connettori spaziali",
  "models.RoomConnector.description": "I connettori degli spazi consentono di creare un collegamento tra più spazi su piani diversi",
  "models.RoomConnector.properties.id.label": "ID del connettore dello spazio",
  "models.RoomConnector.properties.name.label": "Nome del connettore dello spazio",
  "models.RoomConnector.properties.waitTime.label": "Tempo medio di attesa",
  "models.RoomConnector.properties.waitTime.description": "Il tempo di attesa medio prima che il connettore dello spazio diventi disponibile",
  "models.RoomConnector.properties.timePerFloor.label": "Tempo tra ogni piano",
  "models.RoomConnector.properties.timePerFloor.description": "Il tempo necessario per potersi spostare da ogni piano al successivo",
  "models.RoomAffectation.singular": "Allocazione dello spazio",
  "models.RoomAffectation.plural": "Assegnazioni degli spazi",
  "models.RoomAffectation.description": "Permette di assegnare una persona ad un singolo spazio",
  "models.RoomAffectation.determinant.defined": "allocazione dello spazio",
  "models.RoomAffectation.determinant.undefined": "una allocazione dello spazio",
  "models.RoomAffectation.determinants.defined": "assegnazioni di spazi",
  "models.RoomAffectation.determinants.undefined": "assegnazioni di spazi",
  "models.RoomAffectation.views.room-mouvement-matrix-import.help": "Importa matrici di trasferimento di spazi",
  "models.RoomAffectation.views.room-mouvement-matrix-import.label": "Importa matrice di trasferimento",
  "models.Room.singular": "spazio",
  "models.Room.plural": "spazi",
  "models.Room.determinant.defined": "spazio",
  "models.Room.determinant.undefined": "un'area",
  "models.Room.determinants.defined": "gli spazi",
  "models.Room.determinants.undefined": "spazi",
  "models.Room.description": "Gli spazi sono luoghi di lavoro o zone per dividere un piano in sottospazi",
  "models.Room.views.map.help": "Visualizza planimetria %{name}",
  "models.Room.views.map.label": "Piano",
  "models.Room.views.dq-uniq-name.help": "Suggerisce nomi per spazi che non hanno un nome o il nome non è univoco sullo stesso piano",
  "models.Room.views.dq-uniq-name.label": "Nomi proposti per gli spazi",
  "models.Room.views.dq-no-point.help": "Spazi che hanno 0, 1 o 2 punti e quindi dovrebbero avere area zero",
  "models.Room.views.dq-no-point.label": "Spazi senza punti sufficienti",
  "models.Room.views.dq-capacity-equals-seats-count.help": "Spazi che hanno una capienza esclusi i posti pari al numero dei posti e che hanno una capienza totale raddoppiata",
  "models.Room.views.dq-capacity-equals-seats-count.label": "Spazi con una capienza posti esclusi pari al numero dei posti a sedere",
  "models.Room.views.dq-capacity-gt-0.help": "Permette di vedere se ci sono incongruenze nelle capienze degli spazi o rilevare, ad esempio, mobili che non dispongono ancora di posti a sedere",
  "models.Room.views.dq-capacity-gt-0.label": "Spazi che hanno una capienza posti esclusi diversa da 0",
  "models.Room.views.meeting-rooms.help": "Visualizza ed esplora le sale riunioni",
  "models.Room.views.meeting-rooms.label": "Sale riunioni",
  "models.Room.properties.prettyName.label": "Nome da visualizzare",
  "models.Room.properties.prettyName.description": "Consente di avere un nome visualizzato oltre al nome tecnico dello spazio, ad esempio per le sale riunioni",
  "models.Room.properties.id.label": "Identificatore di spazio",
  "models.Room.properties.livePeopleCount.label": "Numero di persone nello spazio in tempo reale",
  "models.Room.properties.livePeopleCount.description": "Questo valore viene aggiornato dai sensori contapersone presenti nello spazio e fornisce il numero di persone presenti in tempo reale nello spazio",
  "models.Room.properties.picture.label": "Foto dallo spazio",
  "models.Room.properties.picture.description": "La foto dello spazio lo rende facile da visualizzare",
  "models.Room.properties.capacity.label": "Capacità esclusi i posti",
  "models.Room.properties.capacity.description": "La capacità dichiarata può essere utilizzata per definire il numero di posti disponibili in uno spazio o per conoscere il numero massimo di persone che possono essere messe in uno spazio, questa cifra viene aggiunta al numero di posti per dare la capacità totale",
  "models.Room.properties.workplacesCount.label": "Numero di postazioni di lavoro",
  "models.Room.properties.workplacesCount.description": "Il numero di postazioni di lavoro nello spazio viene calcolato automaticamente",
  "models.Room.properties.workplacesRatio.label": "Rapporto per postazione di lavoro",
  "models.Room.properties.workplacesRatio.description": "Il rapporto per postazione di lavoro è il numero di metri quadrati di spazio diviso per il numero di postazioni di lavoro, questo valore viene calcolato automaticamente",
  "models.Room.properties.peopleCount.label": "Numero di incarichi",
  "models.Room.properties.peopleCount.description": "Il numero di persone assegnate allo spazio, direttamente o tramite una postazione di lavoro",
  "models.Room.properties.peopleRatio.label": "Rapporto di occupazione",
  "models.Room.properties.peopleRatio.description": "Il tasso di occupazione è il numero di metri quadrati dello spazio diviso per il numero di persone assegnate agli spazi, direttamente o tramite postazione di lavoro, questo valore viene calcolato",
  "models.Room.properties.freeWorkplacesCount.label": "Numero di posti vacanti",
  "models.Room.properties.freeWorkplacesCount.description": "Numero di posizioni libere nello spazio",
  "models.Room.properties.flexWorkplacesCount.label": "Numero di posizioni flessibili",
  "models.Room.properties.flexWorkplacesCount.description": "Numero di posizioni flessibili nello spazio",
  "models.Room.properties.sharedWorkplacesCount.label": "Numero di postazioni condivise",
  "models.Room.properties.sharedWorkplacesCount.description": "Numero di postazioni condivise da almeno 2 persone",
  "models.Room.properties.transitWorkplacesCount.label": "Numero di postazioni di transito",
  "models.Room.properties.transitWorkplacesCount.description": "Numero di postazioni temporanee, queste posizioni non sono conteggiate nelle posizioni libere e non sono in flex",
  "models.Room.properties.sharedWorkplacesRatio.label": "Tasso di postazioni di lavoro condivise",
  "models.Room.properties.sharedWorkplacesRatio.description": "Percentuale di postazioni condivise da almeno 2 persone rispetto a tutte le postazioni presenti nello spazio",
  "models.Room.properties.flexRatio.label": "Tasso di postazioni di lavoro flessibili",
  "models.Room.properties.flexRatio.description": "La tariffa per workstation flessibili viene calcolata dividendo il numero di workstation flessibili per il numero totale di workstation",
  "models.Room.properties.name.label": "Nome dello spazio",
  "models.Room.properties.name.description": "Il nome dello spazio viene utilizzato per definirlo e trovarlo facilmente.",
  "models.Room.properties.area.label": "La zona",
  "models.Room.properties.area.description": "La superficie qualificata per questo spazio",
  "models.Room.properties.perimeter.label": "Perimetro",
  "models.Room.properties.perimeter.description": "Il perimetro dello spazio ne rappresenta il contorno",
  "models.Room.properties.costCenter.description": "Permette di sapere a quale centro di costo associare lo spazio quando si tratta di gestire la rifatturazione al centro di costo per spazio",
  "models.Room.properties.distributionCostType.description": "Consente di determinare il metodo di calcolo della chiave di distribuzione dei costi",
  "models.Room.properties.info.label": "Informazioni aggiuntive",
  "models.Room.properties.info.description": "Ti consente di mantenere ulteriori informazioni simili a un testo sullo spazio",
  "models.Room.properties.bookingEmail.label": "Email utilizzata per la prenotazione di questo spazio",
  "models.Room.properties.bookingEmail.description": "Questa e-mail ti consente di prenotare questa stanza tramite il sistema di messaggistica",
  "models.Room.properties.keyCylinderCode.label": "Numero del cilindro",
  "models.Room.properties.keyCylinderCode.description": "Il numero del cilindro consente di definire il numero del cilindro della serratura della porta dello spazio o un elemento relativo all'accesso fisico allo spazio",
  "models.Room.reports.mouvementMatrix.fileName": "Matrice di trasferimento",
  "models.Room.reports.mouvementMatrix.help": "Crea una matrice di trasferimento in excel che ti permetta di effettuare facilmente gli spostamenti dei tuoi dipendenti",
  "models.PersonWorkingLocation.singular": "Luogo di lavoro delle persone",
  "models.PersonWorkingLocation.plural": "I luoghi di lavoro delle persone",
  "models.PersonWorkingLocation.determinant.defined": "luogo di lavoro delle persone",
  "models.PersonWorkingLocation.determinant.undefined": "un luogo dove le persone lavorano",
  "models.PersonWorkingLocation.determinants.defined": "luoghi di lavoro delle persone",
  "models.PersonWorkingLocation.determinants.undefined": "luoghi di lavoro delle persone",
  "models.PersonWorkingLocation.description": "Un luogo di lavoro delle persone definisce il luogo di lavoro delle persone",
  "models.PersonWorkingLocation.views.my-planning.help": "Gestisci il mio programma per le prossime settimane",
  "models.PersonWorkingLocation.views.my-planning.label": "Gestisci il mio programma",
  "models.PersonToWorkplaceBooking.singular": "Prenotazione alle postazioni di lavoro delle persone",
  "models.PersonToWorkplaceBooking.plural": "Prenotazioni alle postazioni di lavoro delle persone",
  "models.PersonToWorkplaceBooking.description": "Le prenotazioni delle postazioni di lavoro delle persone vengono registrate e disponibili con le date di inizio e fine della prenotazione",
  "models.PersonToWorkplaceBooking.determinant.defined": "prenotazione presso la postazione di lavoro delle persone",
  "models.PersonToWorkplaceBooking.determinant.undefined": "una prenotazione presso la postazione di lavoro delle persone",
  "models.PersonToWorkplaceBooking.determinants.defined": "prenotazioni presso le postazioni di lavoro delle persone",
  "models.PersonToWorkplaceBooking.determinants.undefined": "prenotazioni presso le postazioni di lavoro delle persone",
  "models.PersonToWorkplaceBooking.properties.startDatetime.label": "Inizio prenotazione",
  "models.PersonToWorkplaceBooking.properties.startDatetime.description": "La data e l'ora di inizio della prenotazione",
  "models.PersonToWorkplaceBooking.properties.endDatetime.label": "Fine della prenotazione",
  "models.PersonToWorkplaceBooking.properties.endDatetime.description": "La data e l'ora in cui termina la prenotazione",
  "models.PersonToWorkplaceBooking.views.dashboard-index.label": "Pannello di controllo",
  "models.PersonToWorkplaceBooking.views.dashboard-index.help": "Dashboard delle prenotazioni presso le postazioni di lavoro delle persone",
  "models.PersonToRoomBooking.singular": "Prenotazione per l'area persone",
  "models.PersonToRoomBooking.plural": "Prenotazioni per l'area persone",
  "models.PersonToRoomBooking.description": "Le prenotazioni per gli spazi delle persone sono registrate e disponibili con le date di inizio e fine della prenotazione",
  "models.PersonToRoomBooking.determinant.defined": "prenotazione nell'area popolare",
  "models.PersonToRoomBooking.determinant.undefined": "una prenotazione per l'area persone",
  "models.PersonToRoomBooking.determinants.defined": "prenotazioni per l'area persone",
  "models.PersonToRoomBooking.determinants.undefined": "prenotazioni per l'area persone",
  "models.PersonToRoomBooking.properties.startDatetime.label": "Inizio prenotazione",
  "models.PersonToRoomBooking.properties.startDatetime.description": "La data e l'ora di inizio della prenotazione",
  "models.PersonToRoomBooking.properties.endDatetime.label": "Fine della prenotazione",
  "models.PersonToRoomBooking.properties.endDatetime.description": "La data e l'ora in cui termina la prenotazione",
  "models.PersonToPersonType.singular": "Tipo di relazione tra le persone",
  "models.PersonToPersonType.plural": "Tipi di relazione tra le persone",
  "models.PersonToPersonType.determinant.defined": "il tipo di relazione tra le persone",
  "models.PersonToPersonType.determinant.undefined": "un tipo di relazione tra le persone",
  "models.PersonToPersonType.determinants.defined": "tipi di relazioni tra le persone",
  "models.PersonToPersonType.determinants.undefined": "tipi di relazioni tra le persone",
  "models.PersonToPersonType.properties.labelForward.label": "Relazione naturale [avanti]",
  "models.PersonToPersonType.properties.labelForward.description": "La definizione di relazione in senso naturale, ad esempio tra un padre e suo figlio, la definizione naturale è 'è il padre di'",
  "models.PersonToPersonType.properties.labelBackward.label": "Relazione inversa",
  "models.PersonToPersonType.properties.labelBackward.description": "La definizione di relazione in senso naturale inverso, ad esempio tra un padre e suo figlio, la definizione inversa del senso naturale è 'è figlio di'",
  "models.PersonToPerson.singular": "rapporto da persona a persona",
  "models.PersonToPerson.plural": "Relazioni da persona a persona",
  "models.PersonToPerson.determinant.defined": "rapporto da persona a persona",
  "models.PersonToPerson.determinant.undefined": "un rapporto da persona a persona",
  "models.PersonToPerson.determinants.defined": "relazioni da persona a persona",
  "models.PersonToPerson.determinants.undefined": "relazioni da persona a persona",
  "models.PersonToPerson.properties.personSource.label": "Persona di origine",
  "models.PersonToPerson.properties.personTarget.label": "persona di destinazione",
  "models.PersonToDimensionBooking.singular": "Prenotazione al livello di assegnazione delle persone",
  "models.PersonToDimensionBooking.plural": "Prenotazioni sul livello di assegnazione delle persone",
  "models.PersonToDimensionBooking.description": "Le prenotazioni per i livelli di assegnazione delle persone vengono salvate e disponibili con le date di inizio e fine della prenotazione",
  "models.PersonToDimensionBooking.determinant.defined": "prenotazione al livello di assegnazione delle persone",
  "models.PersonToDimensionBooking.determinant.undefined": "una prenotazione sul livello di assegnazione delle persone",
  "models.PersonToDimensionBooking.determinants.defined": "prenotazioni sul livello di assegnazione delle persone",
  "models.PersonToDimensionBooking.determinants.undefined": "prenotazioni al livello di assegnazione delle persone",
  "models.PersonToDimensionBooking.properties.startDatetime.label": "Inizio prenotazione",
  "models.PersonToDimensionBooking.properties.startDatetime.description": "La data e l'ora di inizio della prenotazione",
  "models.PersonToDimensionBooking.properties.endDatetime.label": "Fine della prenotazione",
  "models.PersonToDimensionBooking.properties.endDatetime.description": "La data e l'ora in cui termina la prenotazione",
  "models.PersonState.singular": "stato delle persone",
  "models.PersonState.plural": "stato delle persone",
  "models.PersonState.description": "Permette di definire tutte le tipologie di contratto tra le persone e l'azienda",
  "models.PersonState.determinant.defined": "lo stato delle persone",
  "models.PersonState.determinant.undefined": "uno stato di persone",
  "models.PersonState.determinants.defined": "statuti del popolo",
  "models.PersonState.determinants.undefined": "statuti del popolo",
  "models.PersonState.properties.id.label": "Identificatore dello stato della persona",
  "models.PersonState.properties.name.label": "Nome dello stato della persona",
  "models.PersonToBuilding.singular": "Affetto per l'edificio",
  "models.PersonToBuilding.plural": "incarichi edilizi",
  "models.PersonToBuilding.description": "Consente di assegnare una persona a un edificio, senza informazioni aggiuntive. L'assegnazione può essere conteggiata o meno.",
  "models.PersonToBuilding.determinant.defined": "affetto per l'edificio",
  "models.PersonToBuilding.determinant.undefined": "un affetto per l'edificio",
  "models.PersonToBuilding.determinants.defined": "costruendo affetti",
  "models.PersonToBuilding.determinants.undefined": "disturbi edilizi",
  "models.PersonToBuilding.properties.addToPeopleCount.label": "Conta assegnazione",
  "models.PersonToBuilding.properties.addToPeopleCount.description": "Aggiungi questa assegnazione al numero totale di persone assegnate all'edificio",
  "models.PersonSecurityProfile.singular": "profilo di sicurezza delle persone",
  "models.PersonSecurityProfile.plural": "profili di sicurezza delle persone",
  "models.PersonSecurityProfile.description": "Permette di definire i diversi profili di sicurezza che possono essere associati alle persone",
  "models.PersonSecurityProfile.determinant.defined": "profilo di sicurezza delle persone",
  "models.PersonSecurityProfile.determinant.undefined": "un profilo di sicurezza delle persone",
  "models.PersonSecurityProfile.determinants.defined": "profili di sicurezza delle persone",
  "models.PersonSecurityProfile.determinants.undefined": "profili di sicurezza delle persone",
  "models.PersonSecurityProfile.properties.id.label": "Identificatore del profilo di sicurezza personale",
  "models.PersonSecurityProfile.properties.name.label": "Nome del profilo di sicurezza",
  "models.PersonSecurityProfile.properties.name.description": "Permette di definire i diversi profili di sicurezza che possono essere associati alle persone",
  "models.PersonSecurityProfile.properties.color.label": "Colore del profilo di sicurezza",
  "models.PersonSecurityProfile.properties.color.description": "Consente di colorare la postazione di lavoro dell'assegnazione e l'icona di sicurezza della persona in base al suo profilo di sicurezza",
  "models.PersonSecurityProfile.properties.icon.label": "Icona del profilo di sicurezza",
  "models.PersonSecurityProfile.properties.icon.description": "Permette di assegnare un'icona ad un profilo di sicurezza per poter visualizzare in modo chiaro i profili di sicurezza sulla planimetria o nelle liste",
  "models.PersonCompanyToRoomType.singular": "Tipo di spazio del provider",
  "models.PersonCompanyToRoomType.plural": "Tipi di spazi del provider",
  "models.PersonCompanyToRoomType.description": "Le tipologie di spazi dei prestatori di servizi permettono di definire una relazione tra una tipologia di spazio e il prestatore di servizi e di definire una missione.",
  "models.PersonCompanyToRoomType.determinant.defined": "il tipo di spazio del fornitore di servizi",
  "models.PersonCompanyToRoomType.determinant.undefined": "un tipo di spazio del fornitore di servizi",
  "models.PersonCompanyToRoomType.determinants.defined": "le tipologie degli spazi dei fornitori di servizi",
  "models.PersonCompanyToRoomType.determinants.undefined": "tipi di spazi dei fornitori di servizi",
  "models.PersonGender.singular": "genere della persona",
  "models.PersonGender.plural": "Tipi di persone",
  "models.PersonGender.description": "Permette di contare ogni tipologia, ad esempio per la gestione sanitaria",
  "models.PersonGender.determinant.defined": "il genere della persona",
  "models.PersonGender.determinant.undefined": "un tipo di persona",
  "models.PersonGender.determinants.defined": "tipi di persone",
  "models.PersonGender.determinants.undefined": "tipi di persone",
  "models.PersonGender.properties.name.label": "Nome",
  "models.PersonGender.properties.name.description": "Il nome di sesso della persona",
  "models.PersonCompanyToItemType.singular": "Tipo di oggetto fornitore",
  "models.PersonCompanyToItemType.plural": "Tipi di oggetti del provider",
  "models.PersonCompanyToItemType.description": "I tipi di oggetto del fornitore di servizi consentono di definire una relazione tra il tipo di oggetto e il fornitore di servizi e di definire la missione.",
  "models.PersonCompanyToItemType.determinant.defined": "il tipo di oggetto del fornitore di servizi",
  "models.PersonCompanyToItemType.determinant.undefined": "un tipo di oggetto provider",
  "models.PersonCompanyToItemType.determinants.defined": "i tipi di oggetti dei fornitori di servizi",
  "models.PersonCompanyToItemType.determinants.undefined": "tipi di oggetti dei fornitori di servizi",
  "models.PersonCompanyToItem.singular": "Intervento su un oggetto",
  "models.PersonCompanyToItem.plural": "Interventi sugli oggetti",
  "models.PersonCompanyToItem.description": "Gli interventi dei fornitori di servizi sugli oggetti consentono di definire, ad esempio, la data di una visita ad un estintore",
  "models.PersonCompanyToItem.determinant.defined": "intervento su un oggetto",
  "models.PersonCompanyToItem.determinant.undefined": "un intervento su un oggetto",
  "models.PersonCompanyToItem.determinants.defined": "interventi sugli oggetti",
  "models.PersonCompanyToItem.determinants.undefined": "interventi sugli oggetti",
  "models.PersonCompanyToItem.properties.datetime.label": "Data e ora dell'intervento",
  "models.PersonCompanyToItem.properties.datetime.description": "Quando è avvenuto l'intervento",
  "models.PersonCompanyToItem.properties.comment.label": "Commento",
  "models.PersonCompanyToItem.properties.comment.description": "Un commento all'intervento",
  "models.PersonCompanyMission.singular": "missione del fornitore di servizi",
  "models.PersonCompanyMission.plural": "missioni del fornitore di servizi",
  "models.PersonCompanyMission.description": "Le missioni dei fornitori di servizi consentono di conoscere l'area di intervento dei fornitori di servizi",
  "models.PersonCompanyMission.determinant.defined": "la missione del fornitore di servizi",
  "models.PersonCompanyMission.determinant.undefined": "una missione del fornitore di servizi",
  "models.PersonCompanyMission.determinants.defined": "le missioni dei fornitori di servizi",
  "models.PersonCompanyMission.determinants.undefined": "missioni dei fornitori di servizi",
  "models.PersonCompanyMission.properties.name.label": "Nome",
  "models.PersonCompanyMission.properties.name.description": "Il nome della missione del fornitore di servizi",
  "models.PersonCompany.singular": "azienda fornitrice di servizi",
  "models.PersonCompany.plural": "società di servizi",
  "models.PersonCompany.description": "L'azienda fornitrice di servizi consente di gestire il personale del fornitore di servizi per azienda.",
  "models.PersonCompany.determinant.defined": "la società fornitrice di servizi",
  "models.PersonCompany.determinant.undefined": "una società di servizi",
  "models.PersonCompany.determinants.defined": "società di servizi",
  "models.PersonCompany.determinants.undefined": "società di servizi",
  "models.PersonCompany.properties.name.label": "Nome",
  "models.PersonCompany.properties.name.description": "Il nome del fornitore di servizi, ad esempio il nome dell'azienda di un fornitore di servizi",
  "models.PersonCompany.properties.comment.label": "Ulteriori informazioni",
  "models.PersonCompany.properties.comment.description": "Informazioni aggiuntive sul fornitore di servizi, come la sua missione, i suoi valori, la copertura funzionale del suo servizio, ecc.",
  "models.PersonCompany.properties.contact.label": "Contatto",
  "models.PersonCompany.properties.contact.description": "Informazioni di contatto del fornitore di servizi",
  "models.PersonCompany.properties.documents.label": "Documenti correlati",
  "models.PersonCompany.properties.documents.description": "Il collegamento ai documenti associati a questo fornitore di servizi",
  "models.Person.singular": "persona",
  "models.Person.plural": "persone",
  "models.Person.description": "Queste sono le persone inserite nel database di Surfy",
  "models.Person.determinant.defined": "la persona",
  "models.Person.determinant.undefined": "una persona",
  "models.Person.determinants.defined": "la gente",
  "models.Person.determinants.undefined": "persone",
  "models.Person.properties.id.label": "Carta d'identità",
  "models.Person.properties.fullname.label": "Nome e cognome",
  "models.Person.properties.fullname.description": "Il nome completo della persona che lo rende più facile da trovare",
  "models.Person.properties.personState.label": "Stato",
  "models.Person.properties.personState.description": "Permette di indicare la tipologia di contratto che la persona ha con l'azienda",
  "models.Person.properties.personSecurityProfile.label": "Profilo di sicurezza",
  "models.Person.properties.personSecurityProfile.description": "Permette di indicare il profilo di sicurezza della persona per la gestione della sicurezza",
  "models.Person.properties.firstname.label": "Nome",
  "models.Person.properties.firstname.description": "Il nome della persona",
  "models.Person.properties.lastname.label": "Cognome",
  "models.Person.properties.lastname.description": "Il cognome della persona",
  "models.Person.properties.email.label": "E-mail",
  "models.Person.properties.email.description": "L'e-mail della persona",
  "models.Person.properties.picture.label": "Immagine del profilo",
  "models.Person.properties.picture.description": "La foto della persona per averla nel trombinoscopio o nella ricerca",
  "models.Person.properties.monitorReference.label": "Riferimento dello schermo",
  "models.Person.properties.monitorReference.description": "Il riferimento dello schermo del computer associato a questa persona",
  "models.Person.properties.computerReference.label": "Riferimento informatico",
  "models.Person.properties.computerReference.description": "Il riferimento del computer associato a questa persona",
  "models.Person.properties.cellphone.label": "Cellulare",
  "models.Person.properties.cellphone.description": "Il cellulare della persona",
  "models.Person.properties.telephone.label": "Telefono",
  "models.Person.properties.telephone.description": "Il telefono fisso della persona",
  "models.Person.properties.title.label": "Titolo",
  "models.Person.properties.title.description": "Il titolo della persona",
  "models.Person.properties.badgeNumber.label": "Numero di matricola",
  "models.Person.properties.badgeNumber.description": "Il numero di badge della persona",
  "models.Person.properties.boxNumber.label": "Numero dell'armadietto",
  "models.Person.properties.boxNumber.description": "Il numero dell'armadietto della persona",
  "models.Person.properties.badgeRestaurant.label": "Distintivo RIE",
  "models.Person.properties.badgeRestaurant.description": "Il riferimento per il badge RIE o ristorante aziendale",
  "models.Person.properties.registrationNumber.label": "Registrazione",
  "models.Person.properties.registrationNumber.description": "Il numero di registrazione della persona",
  "models.Person.properties.startDate.label": "Data di ingresso",
  "models.Person.properties.startDate.description": "La data in cui la persona è entrata a far parte dell'azienda",
  "models.Person.properties.endDate.label": "Data di rilascio",
  "models.Person.properties.endDate.description": "La data di uscita della persona dall'azienda",
  "models.Person.properties.code.label": "Numero di registrazione",
  "models.Person.properties.code.description": "Il numero HR della persona",
  "models.Person.properties.personToPersonTargets.label": "Relazione con questa persona",
  "models.Person.properties.personToPersonTargets.description": "Permette di conoscere il rapporto ascendente tra due persone, ad esempio il rapporto gerarchico",
  "models.Person.properties.personToPersonSources.label": "Relazioni di questa persona",
  "models.Person.properties.personToPersonSources.description": "Permette di conoscere il rapporto discendente tra due persone, ad esempio il rapporto gerarchico",
  "models.Person.properties.organization.label": "L'organizzazione della persona",
  "models.Person.properties.organization.description": "Il servizio di connessione della persona",
  "models.Person.properties.info.label": "Commento",
  "models.Person.properties.info.description": "Commenta la persona che consente di conservare informazioni aggiuntive o varie",
  "models.Person.properties.notAffectable.label": "Non assegnabile",
  "models.Person.properties.notAffectable.description": "La persona non può essere assegnata a una postazione di lavoro, uno spazio, un edificio o un livello di assegnazione",
  "models.Person.views.home.help": "Visualizza il file della persona <b>%{name}</b> con le sue informazioni e i suoi incarichi",
  "models.Person.views.home.label": "dossier personale",
  "models.Person.views.relationship-list.help": "Elenca le relazioni tra le persone",
  "models.Person.views.relationship-list.label": "Elenco delle relazioni",
  "models.Person.views.dq-only-associated-to-building.help": "Elenca le persone assegnabili che sono assegnate a un edificio e conteggiate senza essere assegnate (postazione di lavoro, livello di assegnazione, spazio)",
  "models.Person.views.dq-only-associated-to-building.label": "Persone addette ad un edificio senza altro incarico",
  "models.Person.views.dq-near-end-date.help": "Elenca le persone che hanno una data di fine contratto successiva alla data odierna e che sono assegnate a una workstation",
  "models.Person.views.dq-near-end-date.label": "Persone che lasciano l'azienda",
  "models.Person.views.dq-no-affectations.label": "Persone senza incarichi",
  "models.Person.views.dq-no-affectations.help": "Elenca le persone assegnabili che non hanno incarichi (edificio, postazione di lavoro, livello di assegnazione, spazio)",
  "models.Person.views.dq-person-duplicate.label": "Persone duplicate",
  "models.Person.views.dq-person-duplicate.help": "Elenca le persone duplicate",
  "models.PartnerApiCredential.singular": "Chiave API partner",
  "models.PartnerApiCredential.plural": "Chiavi API partner",
  "models.PartnerApiCredential.determinant.defined": "la chiave API del partner",
  "models.PartnerApiCredential.determinant.undefined": "una chiave API partner",
  "models.PartnerApiCredential.determinants.defined": "chiavi API partner",
  "models.PartnerApiCredential.determinants.undefined": "chiavi API partner",
  "models.PartnerApiCredential.properties.enable.label": "Abilitato",
  "models.PartnerApiCredential.properties.enable.description": "È necessario attivare la chiave per utilizzarla",
  "models.OrganizationFloor.singular": "Organizzazione dei piani",
  "models.OrganizationFloor.plural": "Organizzazioni di piani",
  "models.OrganizationFloor.determinant.defined": "l'organizzazione dei piani",
  "models.OrganizationFloor.determinant.undefined": "un'organizzazione dei piani",
  "models.OrganizationFloor.determinants.defined": "organizzazioni di piano",
  "models.OrganizationFloor.determinants.undefined": "organizzazioni di piano",
  "models.OrganizationBuilding.singular": "Organizzazione degli edifici",
  "models.OrganizationBuilding.plural": "Organizzazioni di edifici",
  "models.OrganizationBuilding.determinant.defined": "organizzazione degli edifici",
  "models.OrganizationBuilding.determinant.undefined": "organizzazione degli edifici",
  "models.OrganizationBuilding.determinants.defined": "organizzazioni edilizie",
  "models.OrganizationBuilding.determinants.undefined": "organizzazioni edilizie",
  "models.Organization.singular": "organizzazione",
  "models.Organization.plural": "organizzazioni",
  "models.Organization.determinant.defined": "l'organizzazione",
  "models.Organization.determinant.undefined": "un'organizzazione",
  "models.Organization.determinants.defined": "organizzazioni",
  "models.Organization.determinants.undefined": "organizzazioni",
  "models.Organization.description": "Le organizzazioni hanno due livelli gerarchici: direzioni e dipartimenti e consentono di definire la struttura organizzativa dell'azienda",
  "models.Organization.properties.id.label": "ID organizzazione",
  "models.Organization.properties.name.label": "Nome",
  "models.Organization.properties.name.description": "Nome che definirà l'organizzazione",
  "models.Organization.properties.code.label": "codificato",
  "models.Organization.properties.code.description": "Questo codice può essere utilizzato per contenere la codifica dell'organizzazione oppure la chiave per l'identificazione tramite software di terze parti",
  "models.Organization.properties.organizationId.label": "Identificativo di gestione",
  "models.Organization.properties.organizationId.description": "È grazie a questo identificatore che è possibile creare la gerarchia organizzativa",
  "models.Organization.properties.organization.label": "Direzione",
  "models.Organization.properties.organizations.label": "Servizi",
  "models.Organization.views.hierarchy.label": "Gerarchia",
  "models.Organization.views.hierarchy.help": "Visualizza la gerarchia organizzativa",
  "models.Organization.views.dq-organization-to-room.label": "Errori nell'organizzazione degli spazi",
  "models.Organization.views.dq-organization-to-room.help": "Rileva associazioni spaziali con organizzazioni non valide",
  "models.Organization.views.dq-organization-hierarchy.label": "Errori di gerarchia organizzativa",
  "models.Organization.views.dq-organization-hierarchy.help": "Rileva le organizzazioni che non si trovano nella gerarchia corretta",
  "models.OpenerPostMessageHost.singular": "Host di messaggi per popup",
  "models.OpenerPostMessageHost.plural": "Host di messaggi per popup",
  "models.OpenerPostMessageHost.determinant.defined": "host di messaggi popup",
  "models.OpenerPostMessageHost.determinant.undefined": "un host di messaggi popup",
  "models.OpenerPostMessageHost.determinants.defined": "host di messaggi popup",
  "models.OpenerPostMessageHost.determinants.undefined": "host di messaggi pop-up",
  "models.OpenerPostMessageHost.description": "Un host di messaggi popup è un elemento che comunica con un popup aperto sulle azioni del piano",
  "models.OccupancyStatus.singular": "stato di occupazione",
  "models.OccupancyStatus.plural": "stati di occupazione",
  "models.OccupancyStatus.determinant.defined": "lo stato di occupazione",
  "models.OccupancyStatus.determinant.undefined": "uno stato di occupazione",
  "models.OccupancyStatus.determinants.defined": "stati di occupazione",
  "models.OccupancyStatus.determinants.undefined": "stati di occupazione",
  "models.OccupancyStatus.description": "Lo stato di occupazione permette di identificare lo stato in tempo reale di uno spazio o postazione di lavoro, ad esempio se è libero, occupato o occupato, lo stato di occupazione viene aggiornato giorno per giorno dagli oggetti connessi presenti nello spazio",
  "models.OccupancyStatus.properties.id.label": "Identificatore dello stato di occupazione",
  "models.OccupancyStatus.properties.name.label": "Nome dello stato di occupazione",
  "models.OccupancyStatus.properties.color.label": "Colore",
  "models.OccupancyStatus.properties.color.description": "Colore consente di colorare gli spazi o le postazioni di lavoro sui piani in base al loro stato di occupazione",
  "models.OccupancyStatus.properties.code.label": "Codice dello stato di occupazione",
  "models.OccupancyStatus.properties.code.description": "Il codice permette di identificare ed effettuare operazioni tecniche sullo stato di occupazione",
  "models.Object3dModel.singular": "modello 3d",
  "models.Object3dModel.plural": "modelli 3d",
  "models.Object3dModel.determinant.defined": "il modello 3d",
  "models.Object3dModel.determinant.undefined": "un modello 3d",
  "models.Object3dModel.determinants.defined": "modelli 3d",
  "models.Object3dModel.determinants.undefined": "modelli 3d",
  "models.Object3dModel.description": "Il Modello 3D consente una rappresentazione 3D realistica degli oggetti posti sulla pianta; In assenza di un modello 3D, gli oggetti sono rappresentati in forma completa nella vista 3D",
  "models.Object3dModel.properties.origin.label": "Orientamento",
  "models.Object3dModel.properties.origin.description": "Usa X se l'oggetto è rivolto a destra o Y se l'oggetto è rivolto verso il basso",
  "models.MapScale.singular": "scala del progetto",
  "models.MapScale.plural": "scale del progetto",
  "models.MapScale.determinant.defined": "la scala",
  "models.MapScale.determinant.undefined": "scala",
  "models.MapScale.determinants.defined": "le scale",
  "models.MapScale.determinants.undefined": "bilancia",
  "models.MapScale.properties.id.label": "ID bilancia",
  "models.MapScale.properties.p1.description": "Punto di partenza",
  "models.MapScale.properties.p2.description": "Punto di arrivo",
  "models.MapScale.properties.name.label": "Nome scala",
  "models.MapScale.properties.name.description": "Per ricordare il nome e riutilizzarlo su altri piani",
  "models.MapScale.properties.length.label": "Distanza",
  "models.MapScale.properties.length.description": "La distanza mostrata sulla planimetria tra i 2 punti in metri",
  "models.MapScale.properties.roomTextSize.label": "Dimensione del testo dello spazio",
  "models.MapScale.properties.roomTextSize.description": "La dimensione del testo degli spazi sulla pianta per ottimizzare la visualizzazione",
  "models.MapScale.properties.workplaceTextSize.label": "Dimensione del testo sugli oggetti",
  "models.MapScale.properties.workplaceTextSize.description": "La dimensione del testo sulle postazioni e sugli oggetti in pianta per ottimizzare la visualizzazione",
  "models.MapScale.properties.segmentDistanceTextSize.label": "Dimensione del testo del segmento",
  "models.MapScale.properties.segmentDistanceTextSize.description": "La dimensione del testo sulle distanze tra i punti sulla pianta per ottimizzare la visualizzazione",
  "models.MapScale.properties.itemTypeIconSize.label": "Dimensioni delle icone del tipo di oggetto",
  "models.MapScale.properties.itemTypeIconSize.description": "La dimensione delle icone del tipo di oggetto sulla mappa, la dimensione sarà limitata dalla dimensione dello spazio",
  "models.MapScale.properties.roomIconSize.label": "Dimensioni delle icone del tipo di spazio",
  "models.MapScale.properties.roomIconSize.description": "La dimensione delle icone sulla mappa negli spazi rispetto ai tipi di spazio",
  "models.MapScale.properties.strokeWidth.label": "Spessore della linea",
  "models.MapScale.properties.strokeWidth.description": "È possibile ridurre lo spessore delle linee per aumentare la leggibilità del piano",
  "models.MapScale.views.dq-not-used.label": "Scale inutilizzate",
  "models.MapScale.views.dq-not-used.help": "Visualizza le scale che non vengono utilizzate sui pavimenti e che possono essere rimosse",
  "models.MapScale.views.dq-uniq-name.label": "Nomi proposti per le scale",
  "models.MapScale.views.dq-uniq-name.help": "Fornisce nomi univoci per le scale, inclusi i piani e gli edifici in cui vengono utilizzate",
  "models.Manufacturer.singular": "Produttore del tipo di oggetto",
  "models.Manufacturer.plural": "Produttori di tipi di oggetti",
  "models.Manufacturer.determinant.defined": "il produttore del tipo di oggetto",
  "models.Manufacturer.determinant.undefined": "un produttore del tipo di oggetto",
  "models.Manufacturer.determinants.defined": "produttori di tipi di oggetti",
  "models.Manufacturer.determinants.undefined": "produttori tipici di oggetti",
  "models.Manufacturer.properties.name.label": "Nome del fornitore del tipo di oggetto",
  "models.Manufacturer.properties.name.description": "Identifica il nome o il marchio del produttore",
  "models.Manufacturer.properties.website.label": "Sito web",
  "models.Manufacturer.properties.website.description": "Indirizzo del sito web del produttore",
  "models.Legend.singular": "Leggenda",
  "models.Legend.plural": "Leggenda",
  "models.Legend.determinant.defined": "la leggenda",
  "models.Legend.determinant.undefined": "una leggenda",
  "models.Legend.determinants.defined": "le leggende",
  "models.Legend.determinants.undefined": "leggende",
  "models.Legend.description": "La legenda permette di configurare le proprietà visibili quando la planimetria viene salvata come immagine",
  "models.JupUserCompanyToJupRole.singular": "Ruolo utente aziendale",
  "models.JupUserCompanyToJupRole.plural": "Ruoli utente aziendali",
  "models.JupUserCompanyToJupRole.determinant.defined": "il ruolo dell'utente aziendale",
  "models.JupUserCompanyToJupRole.determinant.undefined": "un ruolo di utente aziendale",
  "models.JupUserCompanyToJupRole.determinants.defined": "ruoli degli utenti aziendali",
  "models.JupUserCompanyToJupRole.determinants.undefined": "ruoli utente aziendali",
  "models.JupUiView.singular": "Vista interfaccia",
  "models.JupUiView.plural": "Viste dell'interfaccia",
  "models.JupUiView.determinant.defined": "la vista dell'interfaccia",
  "models.JupUiView.determinant.undefined": "una vista dell'interfaccia",
  "models.JupUiView.determinants.defined": "viste dell'interfaccia",
  "models.JupUiView.determinants.undefined": "viste dell'interfaccia",
  "models.JupUiTenantOperation.singular": "Operazione di interfaccia per un'azienda",
  "models.JupUiTenantOperation.plural": "Operazioni di interfaccia per un'azienda",
  "models.JupUiTenantOperation.determinant.defined": "l'operazione di interfaccia per un'azienda",
  "models.JupUiTenantOperation.determinant.undefined": "un'operazione di interfaccia per un'azienda",
  "models.JupUiTenantOperation.determinants.defined": "operazioni di interfaccia per un'azienda",
  "models.JupUiTenantOperation.determinants.undefined": "operazioni di interfaccia per un'azienda",
  "models.JupUiOption.singular": "Opzione interfaccia",
  "models.JupUiOption.plural": "Opzioni di interfaccia",
  "models.JupUiOption.determinant.defined": "opzione di interfaccia",
  "models.JupUiOption.determinant.undefined": "un'opzione di interfaccia",
  "models.JupUiOption.determinants.defined": "opzioni di interfaccia",
  "models.JupUiOption.determinants.undefined": "opzioni di interfaccia",
  "models.JupUiOperation.singular": "Funzionamento dell'interfaccia",
  "models.JupUiOperation.plural": "Operazioni di interfaccia",
  "models.JupUiOperation.determinant.defined": "funzionamento dell'interfaccia",
  "models.JupUiOperation.determinant.undefined": "un'operazione di interfaccia",
  "models.JupUiOperation.determinants.defined": "operazioni di interfaccia",
  "models.JupUiOperation.determinants.undefined": "operazioni di interfaccia",
  "models.JupUiLayout.singular": "Visione del piano",
  "models.JupUiLayout.plural": "Visioni del piano",
  "models.JupUiLayout.determinant.defined": "la visione del piano",
  "models.JupUiLayout.determinant.undefined": "una visione del piano",
  "models.JupUiLayout.determinants.defined": "le visioni del piano",
  "models.JupUiLayout.determinants.undefined": "visioni del piano",
  "models.JupRoleToJupUiView.singular": "Associazione di ruoli alle viste interfaccia",
  "models.JupRoleToJupUiView.plural": "Associazioni di ruolo per interfacciare le viste",
  "models.JupRoleToJupUiView.determinant.defined": "l'associazione del ruolo alle viste dell'interfaccia",
  "models.JupRoleToJupUiView.determinant.undefined": "un'associazione del ruolo alle viste dell'interfaccia",
  "models.JupRoleToJupUiView.determinants.defined": "associazioni di ruoli per interfacciare le viste",
  "models.JupRoleToJupUiView.determinants.undefined": "associazioni di ruoli per interfacciare le viste",
  "models.JupRoleToJupUiView.properties.canSee.label": "può vedere la vista",
  "models.JupRoleToJupUiView.properties.canSee.description": "Consenti alla vista di essere vista dal ruolo",
  "models.JupRoleToJupUiOption.singular": "Ruolo associativo alle visioni del progetto",
  "models.JupRoleToJupUiOption.plural": "Associazioni di ruolo per progettare visioni",
  "models.JupRoleToJupUiOption.determinant.defined": "l'associazione del ruolo con le visioni del piano",
  "models.JupRoleToJupUiOption.determinant.undefined": "un'associazione del ruolo con le visioni del piano",
  "models.JupRoleToJupUiOption.determinants.defined": "associazioni di ruolo alle visioni del progetto",
  "models.JupRoleToJupUiOption.determinants.undefined": "associazioni di ruolo alle visioni del progetto",
  "models.JupRoleToJupUiOption.properties.canSee.label": "Può vedere l'opzione",
  "models.JupRoleToJupUiOption.properties.canSee.description": "Consenti all'opzione di essere visualizzata per ruolo",
  "models.JupRoleToJupUiOperation.singular": "Ruolo di associazione per interfacciare le operazioni",
  "models.JupRoleToJupUiOperation.plural": "Ruolo di associazione per interfacciare le operazioni",
  "models.JupRoleToJupUiOperation.determinant.defined": "associazione del ruolo alle operazioni di interfaccia",
  "models.JupRoleToJupUiOperation.determinant.undefined": "un'associazione del ruolo alle operazioni di interfaccia",
  "models.JupRoleToJupUiOperation.determinants.defined": "associazioni di ruoli per interfacciare le operazioni",
  "models.JupRoleToJupUiOperation.determinants.undefined": "associazioni di ruoli per interfacciare le operazioni",
  "models.JupRoleToJupObjectType.singular": "Ruolo di associazione al tipo di oggetto",
  "models.JupRoleToJupObjectType.plural": "Associazioni di tipo da ruolo a oggetto",
  "models.JupRoleToJupObjectType.determinant.defined": "l'associazione del ruolo al tipo di oggetto",
  "models.JupRoleToJupObjectType.determinant.undefined": "un'associazione del ruolo al tipo di oggetto",
  "models.JupRoleToJupObjectType.determinants.defined": "le associazioni del ruolo al tipo di oggetto",
  "models.JupRoleToJupObjectType.determinants.undefined": "associazioni del ruolo al tipo di oggetto",
  "models.JupRoleToJupObjectType.properties.arCreate.label": "Creazione (C)",
  "models.JupRoleToJupObjectType.properties.arCreate.description": "Consenti la creazione di entità",
  "models.JupRoleToJupObjectType.properties.arRead.label": "Lettura (R)",
  "models.JupRoleToJupObjectType.properties.arRead.description": "Consenti la lettura delle entità",
  "models.JupRoleToJupObjectType.properties.arUpdate.label": "Aggiorna (U)",
  "models.JupRoleToJupObjectType.properties.arUpdate.description": "Consenti la modifica delle entità",
  "models.JupRoleToJupObjectType.properties.arDelete.label": "Elimina (D)",
  "models.JupRoleToJupObjectType.properties.arDelete.description": "Consenti l'eliminazione di entità",
  "models.JupRole.singular": "Ruolo",
  "models.JupRole.plural": "Ruoli",
  "models.JupRole.determinant.defined": "il ruolo",
  "models.JupRole.determinant.undefined": "un ruolo",
  "models.JupRole.determinants.defined": "i ruoli",
  "models.JupRole.determinants.undefined": "ruoli",
  "models.JupRole.views.matrix.help": "La matrice di sicurezza del ruolo %{name}",
  "models.JupRole.views.matrix.label": "Matrice",
  "models.JupRole.views.help.help": "Riepilogo delle autorizzazioni del ruolo",
  "models.JupRole.views.help.label": "Aiuto",
  "models.JupObjectType.singular": "Tipo di entità",
  "models.JupObjectType.plural": "Tipi di entità",
  "models.JupObjectType.determinant.defined": "tipo di entità",
  "models.JupObjectType.determinant.undefined": "un tipo di entità",
  "models.JupObjectType.determinants.defined": "tipi di entità",
  "models.JupObjectType.determinants.undefined": "tipi di entità",
  "models.ItemTypePoint.singular": "Punto dei tipi di oggetto",
  "models.ItemTypePoint.plural": "Punti dei tipi di oggetto",
  "models.ItemTypePoint.determinant.defined": "punto dei tipi di oggetto",
  "models.ItemTypePoint.determinant.undefined": "un punto di tipi di oggetto",
  "models.ItemTypePoint.determinants.defined": "punti di tipi di oggetto",
  "models.ItemTypePoint.determinants.undefined": "punti di tipi di oggetto",
  "models.ItemTypePoint.properties.id.label": "ID",
  "models.ItemTypePoint.properties.id.description": "???",
  "models.ItemTypePoint.properties.x.label": "X",
  "models.ItemTypePoint.properties.x.description": "???",
  "models.ItemTypePoint.properties.y.label": "là",
  "models.ItemTypePoint.properties.y.description": "???",
  "models.ItemTypePoint.properties.externalId.label": "Identificatore esterno",
  "models.ItemTypePoint.properties.externalId.description": "???",
  "models.ItemTypePoint.properties.itemTypeId.label": "Identificatore del tipo di oggetto",
  "models.ItemTypePoint.properties.itemTypeId.description": "???",
  "models.ItemTypePoint.properties.sortIndex.label": "Ordina indice",
  "models.ItemTypePoint.properties.sortIndex.description": "???",
  "models.ItemTypePoint.properties.itemType.label": "Tipo di oggetto",
  "models.ItemTypePoint.properties.itemType.description": "???",
  "models.ItemTypeFamily.singular": "famiglia di tipi di oggetti",
  "models.ItemTypeFamily.plural": "famiglie di tipi di oggetti",
  "models.ItemTypeFamily.determinant.defined": "la famiglia dei tipi di oggetto",
  "models.ItemTypeFamily.determinant.undefined": "una famiglia di tipi di oggetti",
  "models.ItemTypeFamily.determinants.defined": "famiglie di tipi di oggetti",
  "models.ItemTypeFamily.determinants.undefined": "famiglie di tipi di oggetti",
  "models.ItemTypeFamily.description": "Permette di visualizzare gli oggetti per Famiglia sulle planimetrie e nell'inventario pdf",
  "models.ItemTypeFamily.properties.id.label": "Identificatore della famiglia di tipi dell'oggetto",
  "models.ItemTypeFamily.properties.name.label": "Nome della famiglia di tipi dell'oggetto",
  "models.ItemTypeFamily.properties.name.description": "Il nome della famiglia ne permette l'identificazione, questo nome serve per raggruppare le tipologie di oggetti",
  "models.ItemType.singular": "tipo di oggetto",
  "models.ItemType.plural": "tipi di oggetti",
  "models.ItemType.determinant.defined": "il tipo di oggetto",
  "models.ItemType.determinant.undefined": "un tipo di oggetto",
  "models.ItemType.determinants.defined": "tipi di oggetti",
  "models.ItemType.determinants.undefined": "tipi di oggetti",
  "models.ItemType.properties.id.label": "Identificatore del tipo di oggetto",
  "models.ItemType.properties.id.description": "Identificatore del tipo di oggetto",
  "models.ItemType.properties.description.label": "Descrizione",
  "models.ItemType.properties.description.description": "Permette di avere informazioni aggiuntive sulla tipologia dell'oggetto",
  "models.ItemType.properties.name.label": "Nome del tipo di oggetto",
  "models.ItemType.properties.name.description": "Permette di identificare velocemente la tipologia di oggetto con un nome completo, logico e descrittivo; Puoi indicare le dimensioni, ad esempio: Tavolo Riunione 340x120; Suggerimento: inizia sempre con la dimensione più grande",
  "models.ItemType.properties.zIndex.label": "Indice di altezza",
  "models.ItemType.properties.zIndex.description": "Più alto è l'indice di altezza, più l'oggetto sarà posizionato sopra gli altri; Può essere negativo; ad esempio per un posto: -1; Suggerimento: per le Icone, imposta l'indice su 9",
  "models.ItemType.properties.picture.label": "Foto",
  "models.ItemType.properties.picture.description": "Permette di caricare la foto della tipologia dell'oggetto, che sarà visibile nell'inventario in PDF e sulla scheda dell'oggetto selezionato in planimetria",
  "models.ItemType.properties.iconShape.label": "Forma dell'icona",
  "models.ItemType.properties.iconShape.description": "La forma dell'icona può influenzare la sua visualizzazione in pianta",
  "models.ItemType.properties.displayItemReferenceInMap.label": "Visualizza le informazioni sul piano",
  "models.ItemType.properties.displayItemReferenceInMap.description": "Permette di visualizzare il campo “Riferimento” di ogni oggetto presente sulla planimetria",
  "models.ItemType.properties.code.label": "codificato",
  "models.ItemType.properties.code.description": "Permette di accedere velocemente alla tipologia dell'oggetto digitando il codice nella ricerca durante la creazione dell'oggetto",
  "models.ItemType.properties.icon.label": "Icona",
  "models.ItemType.properties.icon.description": "Dà accesso a tre tipi di icone: 1) Icone “Fontawsome”, visibili selezionando “mostra tutto” o effettuando una ricerca per parola chiave in inglese nella casella di ricerca; 2) Icone “SURFY” destinate ad illustrazioni aggiunte a planimetrie in posizioni strategiche (WC, Scale, Ascensori, Punti Copia, ecc.) ma che possono essere utilizzate anche come icone classiche; 3) Le Icone “SURFY 2” che elencano le icone normative dello standard di Sicurezza ISO 7010; La loro forma può essere rotonda, quadrata o triangolare",
  "models.ItemType.properties.color.label": "Colore",
  "models.ItemType.properties.color.description": "Può essere scelto da una preselezione, oppure in selezione avanzata tramite codice Hexa o RGB per rispettare la vostra carta grafica",
  "models.ItemType.properties.height.label": "Altezza",
  "models.ItemType.properties.height.description": "Permette di dare l'altezza in centimetri del tipo di oggetto nella visione 3d",
  "models.ItemType.properties.price.label": "Prezzo",
  "models.ItemType.properties.price.description": "Il prezzo di acquisto del tipo di articolo",
  "models.ItemType.properties.seatsCount.label": "Numero di posti",
  "models.ItemType.properties.seatsCount.description": "Il numero di posti per questo tipo di oggetto (poltrona, sedile, divano, ecc.) viene accumulato in Surfy per spazio, piano ed edificio",
  "models.ItemType.properties.manufacturer.description": "Permette di identificare il produttore della tipologia di oggetto",
  "models.ItemType.properties.carbonFootprint.label": "Impronta ecologica",
  "models.ItemType.properties.carbonFootprint.description": "L'impronta di carbonio è il peso in chilogrammi di CO2 emessa da ciascun oggetto di questo tipo di oggetti; è dato dal produttore",
  "models.ItemType.properties.iconBackgroundColor.label": "Colore di sfondo dell'icona",
  "models.ItemType.properties.iconBackgroundColor.description": "Il colore di sfondo permette di configurare correttamente le icone multicolori, in particolare quelle triangolari.",
  "models.ItemType.properties.iconBorderColor.label": "Colore del bordo dell'icona",
  "models.ItemType.properties.iconBorderColor.description": "Il colore del bordo consente di configurare correttamente le icone multicolori, soprattutto quelle triangolari.",
  "models.ItemType.properties.isAffectable.label": "È associabile ad una persona?",
  "models.ItemType.properties.isAffectable.description": "Permette di sapere se la tipologia di oggetto può essere associata ad una persona",
  "models.ItemType.properties.excludeFromPathfinding.label": "Abilita la navigazione",
  "models.ItemType.properties.excludeFromPathfinding.description": "Consente di abilitare la navigazione per questo tipo di oggetto",
  "models.ItemType.views.shape-editor.help": "Modifica la forma del tipo di oggetto %{name}",
  "models.ItemType.views.shape-editor.label": "Modifica forma",
  "models.ItemType.views.avatar.help": "Guarda la forma di %{name}",
  "models.ItemType.views.avatar.label": "Modulo",
  "models.ItemType.views.dq-not-used.label": "Non usato",
  "models.ItemType.views.dq-not-used.help": "Elenca tutti i tipi di oggetti inutilizzati tramite oggetti o tramite tipi di workstation inutilizzati",
  "models.ItemToPerson.singular": "Associazione di oggetto a persona",
  "models.ItemToPerson.plural": "Associazioni da oggetto a persona",
  "models.ItemToPerson.description": "Permette di associare un oggetto ad una persona (seduta ergonomica, armadietto)",
  "models.ItemToPerson.determinant.defined": "associazione di oggetto a persona",
  "models.ItemToPerson.determinant.undefined": "un'associazione da oggetto a persona",
  "models.ItemToPerson.determinants.defined": "associazioni da oggetto a persona",
  "models.ItemToPerson.determinants.undefined": "associazioni da oggetto a persona",
  "models.ItemFact.singular": "Movimento dell'oggetto",
  "models.ItemFact.plural": "Movimenti di oggetti",
  "models.ItemFact.determinant.defined": "il movimento di un oggetto",
  "models.ItemFact.determinant.undefined": "un movimento di un oggetto",
  "models.ItemFact.determinants.defined": "movimenti degli oggetti",
  "models.ItemFact.determinants.undefined": "movimenti degli oggetti",
  "models.Item.singular": "oggetto",
  "models.Item.plural": "oggetti",
  "models.Item.determinant.defined": "l'oggetto",
  "models.Item.determinant.undefined": "un oggetto",
  "models.Item.determinants.defined": "Elementi",
  "models.Item.determinants.undefined": "Oggetti",
  "models.Item.views.dq-item-not-in-workplace-room.label": "Spazi oggetto diversi dagli spazi workstation",
  "models.Item.views.dq-item-not-in-workplace-room.help": "Elenco di oggetti fisici nelle workstation che si trovano in spazi diversi dagli spazi della workstation",
  "models.Item.properties.id.label": "ID oggetto",
  "models.Item.properties.price.label": "Prezzo",
  "models.Item.properties.price.description": "Il prezzo di acquisto dell'articolo se è diverso dal prezzo del tipo di articolo",
  "models.Item.properties.reference.label": "Riferimento all'oggetto",
  "models.Item.properties.reference.description": "Il riferimento dell'oggetto viene utilizzato per trovarlo e per differenziare questo oggetto dagli altri",
  "models.Item.properties.code.label": "Codice immobilizzatore",
  "models.Item.properties.code.description": "Il numero cespite viene utilizzato per memorizzare il numero contabile",
  "models.Item.properties.purchaseDate.label": "Data di acquisto",
  "models.Item.properties.purchaseDate.description": "La data di acquisto dell'oggetto",
  "models.Item.properties.room.label": "Spazio oggetto",
  "models.Item.properties.itemAffectationsCount.label": "Numero di associazioni alle persone",
  "models.Item.properties.itemAffectationsCount.description": "Il numero di associazioni di questo oggetto con le persone",
  "models.Floor.singular": "piano",
  "models.Floor.plural": "piani",
  "models.Floor.determinant.defined": "al piano superiore",
  "models.Floor.determinant.undefined": "un piano",
  "models.Floor.determinants.defined": "I piani",
  "models.Floor.determinants.undefined": "piani",
  "models.Floor.description": "I piani rappresentano un piano di lavoro o un livello di un edificio",
  "models.Floor.views.map.help": "La planimetria %{name} in 2d",
  "models.Floor.views.map.label": "progetto 2D",
  "models.Floor.views.3d.help": "La planimetria %{name} in 3d",
  "models.Floor.views.3d.label": "progetto 3d",
  "models.Floor.views.cuby.help": "La planimetria %{name} in 3d",
  "models.Floor.views.cuby.label": "3d",
  "models.Floor.views.simple-list.help": "Elenca i piani con pochi dettagli",
  "models.Floor.views.simple-list.label": "Elenco unico",
  "models.Floor.views.geojson.help": "Visualizza le informazioni in GeoJson",
  "models.Floor.views.geojson.label": "Copia le coordinate GeoJson",
  "models.Floor.views.standalone-2d-map.help": "La planimetria %{name} in 2D senza menu",
  "models.Floor.views.standalone-2d-map.label": "Solo piano 2d",
  "models.Floor.properties.id.label": "ID piano",
  "models.Floor.properties.name.label": "Nome del piano",
  "models.Floor.properties.name.description": "Il nome del piano serve per trovarlo facilmente.",
  "models.Floor.properties.level.label": "Livello",
  "models.Floor.properties.level.description": "Il livello del piano permette di definirne la posizione rispetto agli altri piani, ad esempio utilizzare 0 per il piano terra o -1 per i parcheggi",
  "models.Floor.properties.backgroundLayout.label": "Sfondo",
  "models.Floor.properties.backgroundLayout.description": "Il piano di base consente di avere un livello di primo livello per poter ridisegnare i piani, deve essere in scala",
  "models.Floor.properties.backgroundLayoutOpacity.label": "Opacità della mappa di base",
  "models.Floor.properties.backgroundLayoutOpacity.description": "L'opacità permette di vedere più o meno lo sfondo",
  "models.Floor.properties.regulatoryCapacity.label": "Capacità normativa",
  "models.Floor.properties.regulatoryCapacity.description": "La capacità normativa del set, permette di gestire l'evacuazione del pubblico e dei dipendenti",
  "models.Floor.properties.pathfindingGraph.label": "Grafico di navigazione del piano",
  "models.Floor.properties.pathfindingGraph.description": "Il grafico di navigazione consente di calcolare i percorsi più brevi tra i punti sul pavimento",
  "models.Floor.properties.workplacesCount.label": "Numero di postazioni di lavoro",
  "models.Floor.properties.workplacesCount.description": "Il numero di postazioni di lavoro nel piano viene calcolato automaticamente",
  "models.Floor.properties.workplacesRatio.label": "Rapporto di postazioni di lavoro",
  "models.Floor.properties.workplacesRatio.description": "Il rapporto delle postazioni è il numero di metri quadrati del piano diviso per il numero delle postazioni, questo valore viene calcolato automaticamente",
  "models.Floor.properties.peopleCount.label": "Numero di incarichi",
  "models.Floor.properties.peopleCount.description": "Il numero di persone assegnate al piano, assegnate direttamente agli spazi o tramite una postazione di lavoro",
  "models.Floor.properties.totalPeopleCount.label": "Numero di incarichi totali",
  "models.Floor.properties.totalPeopleCount.description": "Il numero di persone assegnate al piano, assegnate direttamente agli spazi o tramite una postazione di lavoro",
  "models.Floor.properties.peopleRatio.label": "Rapporto di occupazione",
  "models.Floor.properties.peopleRatio.description": "Il rapporto di occupazione è il numero di metri quadrati al piano diviso per il numero di persone assegnate direttamente agli spazi o tramite postazione di lavoro, questo valore viene calcolato",
  "models.Floor.properties.freeWorkplacesCount.label": "Numero di posti vacanti",
  "models.Floor.properties.freeWorkplacesCount.description": "Numero di estensioni libere sul pavimento",
  "models.Floor.properties.flexWorkplacesCount.label": "Numero di posizioni flessibili",
  "models.Floor.properties.flexWorkplacesCount.description": "Numero di pali flessibili nel pavimento",
  "models.Floor.properties.roomsArea.label": "Zona qualificata",
  "models.Floor.properties.roomsArea.description": "La superficie qualificata è la somma delle superfici dei vani",
  "models.Floor.properties.roomsCount.label": "Numero di spazi",
  "models.Floor.properties.roomsCount.description": "Il numero di vani presenti in questo piano",
  "models.Floor.properties.sharedWorkplacesCount.label": "Numero di postazioni condivise",
  "models.Floor.properties.sharedWorkplacesCount.description": "Numero di postazioni condivise al piano da almeno 2 persone",
  "models.Floor.properties.sharedWorkplacesRatio.label": "Tasso di postazioni di lavoro condivise",
  "models.Floor.properties.sharedWorkplacesRatio.description": "Percentuale di postazioni condivise da almeno 2 persone rispetto a tutte le postazioni a terra",
  "models.Floor.properties.flexRatio.label": "Tasso di postazioni di lavoro flessibili",
  "models.Floor.properties.flexRatio.description": "La tariffa per workstation flessibili viene calcolata dividendo il numero di workstation flessibili per il numero totale di workstation",
  "models.Floor.properties.transitWorkplacesCount.label": "Numero di postazioni di transito",
  "models.Floor.properties.transitWorkplacesCount.description": "Numero di postazioni temporanee, queste posizioni non sono conteggiate nelle posizioni libere e non sono in flex",
  "models.Floor.properties.height.label": "Altezza del soffitto",
  "models.Floor.properties.height.description": "L'altezza sotto il soffitto del pavimento",
  "models.Floor.properties.mapScale.label": "Scala del piano",
  "models.Floor.properties.mapScale.description": "La scala ci consente di calcolare in proporzione le aree e le dimensioni effettive degli oggetti",
  "models.FactType.singular": "Tipo di fatto",
  "models.FactType.plural": "Tipi di fatto",
  "models.FactType.determinant.defined": "il tipo di fatto",
  "models.FactType.determinant.undefined": "un tipo di fatto",
  "models.FactType.determinants.defined": "tipi di fatto",
  "models.FactType.determinants.undefined": "tipi di fatto",
  "models.Fact.singular": "Fare",
  "models.Fact.plural": "Fatti",
  "models.Fact.determinant.defined": "il fatto",
  "models.Fact.determinant.undefined": "un fatto",
  "models.Fact.determinants.defined": "fatti",
  "models.Fact.determinants.undefined": "fatti",
  "models.DistributionCostType.singular": "tipo di distribuzione dei costi",
  "models.DistributionCostType.plural": "tipi di distribuzione dei costi",
  "models.DistributionCostType.determinant.defined": "il tipo di distribuzione dei costi",
  "models.DistributionCostType.determinant.undefined": "un tipo di distribuzione dei costi",
  "models.DistributionCostType.determinants.defined": "tipi di distribuzione dei costi",
  "models.DistributionCostType.determinants.undefined": "tipi di distribuzione dei costi",
  "models.DistributionCostType.properties.name.label": "Nome del tipo di distribuzione dei costi",
  "models.DistributionCostType.properties.code.labe": "codificato",
  "models.DistributionCostType.properties.code.description": "Il codice viene utilizzato per poter calcolare automaticamente i costi associati",
  "models.DimensionTypeToBuilding.singular": "Tipo di livello di assegnazione dell'edificio",
  "models.DimensionTypeToBuilding.plural": "Tipi di livelli di assegnazione degli edifici",
  "models.DimensionTypeToBuilding.determinant.defined": "il tipo di livello di assegnazione dell'edificio",
  "models.DimensionTypeToBuilding.determinant.undefined": "un tipo di livello di assegnazione degli edifici",
  "models.DimensionTypeToBuilding.determinants.defined": "i tipi di livelli di assegnazione degli edifici",
  "models.DimensionTypeToBuilding.determinants.undefined": "tipi di livelli di assegnazione degli edifici",
  "models.DimensionTypeToBuilding.description": "I tipi di layer di assegnazione degli edifici consentono di definire i diversi tipi di layer di assegnazione degli edifici. Associando una tipologia di layer di assegnazione ad un edificio, è possibile trasformare un layer di analisi in un layer di assegnazione.",
  "models.DimensionType.singular": "Tipo di livello",
  "models.DimensionType.plural": "Tipi di livello",
  "models.DimensionType.determinant.defined": "il tipo di strato",
  "models.DimensionType.determinant.undefined": "un tipo di strato",
  "models.DimensionType.determinants.defined": "tipi di livelli",
  "models.DimensionType.determinants.undefined": "tipi di strato per piano",
  "models.DimensionType.properties.id.label": "Identificatore del tipo di dimensione",
  "models.DimensionType.properties.order.label": "ordine di apparizione",
  "models.DimensionType.properties.order.description": "Consente di ordinare i tipi di layer per visualizzarli",
  "models.DimensionType.properties.name.label": "Nome del tipo di dimensione",
  "models.DimensionType.properties.code.label": "Codice tipo dimensione",
  "models.DimensionType.properties.code.description": "Il codice identifica il tipo di dimensione, viene utilizzato quando si applicano calcoli specifici al tipo di dimensione",
  "models.DimensionToPerson.singular": "Assegnazione al livello di assegnazione",
  "models.DimensionToPerson.plural": "Assegnazioni ai livelli di assegnazione",
  "models.DimensionToPerson.description": "Ti permette di assegnare una persona a un distretto, territorio o villaggio",
  "models.DimensionToPerson.determinant.defined": "l'assegnazione al livello di assegnazione",
  "models.DimensionToPerson.determinant.undefined": "un'assegnazione al livello di assegnazione",
  "models.DimensionToPerson.determinants.defined": "assegnazioni ai livelli di assegnazione",
  "models.DimensionToPerson.determinants.undefined": "assegnazioni ai livelli di assegnazione",
  "models.DimensionRoom.singular": "Livello di analisi spaziale",
  "models.DimensionRoom.plural": "Strati di analisi spaziale",
  "models.DimensionRoom.determinant.defined": "il livello di analisi spaziale",
  "models.DimensionRoom.determinant.undefined": "uno strato di analisi spaziale",
  "models.DimensionRoom.determinants.defined": "strati di analisi spaziale",
  "models.DimensionRoom.determinants.undefined": "strati di analisi spaziale",
  "models.DimensionRoom.properties.id.label": "Identificatore del layer di analisi spaziale",
  "models.DimensionFloor.singular": "Analisi strato per pavimento",
  "models.DimensionFloor.plural": "Strati di analisi per piano",
  "models.DimensionFloor.determinant.defined": "l'analisi strato per piano",
  "models.DimensionFloor.determinant.undefined": "uno strato di analisi per piano",
  "models.DimensionFloor.determinants.defined": "strati di analisi per piano",
  "models.DimensionFloor.determinants.undefined": "strati di analisi per piano",
  "models.DimensionFloor.properties.id.label": "Identificatore dello strato di analisi per piano",
  "models.DimensionFloor.properties.peopleCount.label": "Numero di incarichi",
  "models.DimensionFloor.properties.peopleCount.description": "Il numero di persone assegnate, assegnate direttamente agli spazi o tramite una postazione di lavoro per questo piano",
  "models.DimensionFloor.properties.totalPeopleCount.label": "Numero totale di incarichi indiretti sul piano",
  "models.DimensionFloor.properties.totalPeopleCount.description": "Il numero totale di persone assegnate indirettamente al piano, assegnate direttamente agli spazi o tramite una postazione di lavoro, ma non tramite i livelli di assegnazione che si trovano solo a livello di edificio",
  "models.DimensionBuilding.singular": "Livello di analisi dell'edificio",
  "models.DimensionBuilding.plural": "Livelli di analisi per edificio",
  "models.DimensionBuilding.determinant.defined": "il livello di analisi per edificio",
  "models.DimensionBuilding.determinant.undefined": "un livello di analisi per edificio",
  "models.DimensionBuilding.determinants.defined": "livelli di analisi per costruzione",
  "models.DimensionBuilding.determinants.undefined": "costruzione di livelli di analisi",
  "models.DimensionBuilding.properties.id.label": "Identificatore del livello di analisi per edificio",
  "models.DimensionBuilding.properties.dimensionPeopleCount.label": "Numero di assegnazioni direttamente a questo livello di assegnazione",
  "models.DimensionBuilding.properties.dimensionPeopleCount.description": "Il numero di persone assegnate a questo livello di assegnazione per l'intero edificio",
  "models.DimensionBuilding.properties.totalPeopleCount.label": "Numero totale di incarichi",
  "models.DimensionBuilding.properties.totalPeopleCount.description": "Il numero totale di persone assegnate, assegnate direttamente agli spazi, tramite una workstation o tramite un livello di assegnazione",
  "models.Dimension.singular": "Livello di analisi",
  "models.Dimension.plural": "Livelli di analisi",
  "models.Dimension.determinant.defined": "il livello di analisi",
  "models.Dimension.determinant.undefined": "uno strato di analisi",
  "models.Dimension.determinants.defined": "livelli di analisi",
  "models.Dimension.determinants.undefined": "livelli di analisi",
  "models.Dimension.properties.id.label": "Identificatore del livello di analisi",
  "models.Dimension.properties.id.description": "Identificatore interno di Surfy",
  "models.Dimension.properties.name.label": "Nome del livello di analisi",
  "models.Dimension.properties.name.description": "Utile per differenziare lo strato tra gli altri",
  "models.Dimension.properties.color.label": "Colore",
  "models.Dimension.properties.color.description": "Il colore del livello di analisi consente di differenziare gli spazi sulla pianta",
  "models.Dimension.properties.value.label": "Valore numerico",
  "models.Dimension.properties.value.description": "Il valore può essere utilizzato per associare il layer ad un valore numerico in modo da poter eseguire statistiche analitiche",
  "models.Dimension.properties.peopleCount.label": "Numero di incarichi diretti",
  "models.Dimension.properties.peopleCount.description": "Il numero di persone assegnate direttamente a questo livello di assegnazione nell'edificio",
  "models.Dimension.properties.manualPeopleCount.label": "Numero di assegnazioni manuali dirette",
  "models.Dimension.properties.manualPeopleCount.description": "Il numero di persone assegnate direttamente a questo livello di assegnazione senza considerare le assegnazioni con persone reali",
  "models.Dimension.properties.totalPeopleCount.label": "Numero totale di incarichi diretti",
  "models.Dimension.properties.totalPeopleCount.description": "Il numero totale di persone assegnate direttamente a questo livello di assegnazione nell'edificio, la somma delle persone effettive assegnate e il numero di persone assegnate manualmente",
  "models.Dimension.properties.carbonFootprintPerMeter.label": "Impronta di carbonio per metro quadrato",
  "models.Dimension.properties.carbonFootprintPerMeter.description": "L'impronta di carbonio per metro quadrato calcola l'impronta di carbonio in chilogrammi di CO2 di uno strato di analisi per metro quadrato",
  "models.CostCenterFloor.singular": "centro di costo del piano",
  "models.CostCenterFloor.plural": "centri di costo iniziali",
  "models.CostCenterFloor.determinant.defined": "il centro di costo dei piani",
  "models.CostCenterFloor.determinant.undefined": "un centro di costo a pavimento",
  "models.CostCenterFloor.determinants.defined": "i centri di costo dei piani",
  "models.CostCenterFloor.determinants.undefined": "centri di costo del piano",
  "models.CostCenterBuilding.singular": "centro di costo edilizio",
  "models.CostCenterBuilding.plural": "centri di costo edilizio",
  "models.CostCenterBuilding.determinant.defined": "centro di costo edilizio",
  "models.CostCenterBuilding.determinant.undefined": "un centro di costo edilizio",
  "models.CostCenterBuilding.determinants.defined": "costruire centri di costo",
  "models.CostCenterBuilding.determinants.undefined": "costruendo centri di costo",
  "models.CostCenter.singular": "centro di costo",
  "models.CostCenter.plural": "centri di costo",
  "models.CostCenter.description": "Il centro di costo consente di distribuire dinamicamente gli spazi per la rifatturazione",
  "models.CostCenter.determinant.defined": "il centro di costo",
  "models.CostCenter.determinant.undefined": "un centro di costo",
  "models.CostCenter.determinants.defined": "centri di costo",
  "models.CostCenter.determinants.undefined": "centri di costo",
  "models.CostCenter.properties.id.label": "Identificatore del centro di costo",
  "models.CostCenter.properties.name.label": "Nome del centro di costo",
  "models.CostCenter.properties.color.label": "Colore",
  "models.CostCenter.properties.distributeByFloor.label": "Distribuire per piano",
  "models.CostCenter.properties.distributeByFloor.description": "Ripartire proporzionalmente lo spazio utilizzato da questo centro di costo sul piano agli altri centri di costo sullo stesso piano",
  "models.CostCenter.properties.distributeByBuilding.label": "Distribuire per edificio",
  "models.CostCenter.properties.distributeByBuilding.description": "Ripartire proporzionalmente lo spazio utilizzato da questo centro di costo nell'edificio agli altri centri di costo nell'edificio",
  "models.ContentRoleToUserCompany.singular": "Ruolo contenuto utente aziendale",
  "models.ContentRoleToUserCompany.plural": "Ruoli dei contenuti degli utenti aziendali",
  "models.ContentRoleToUserCompany.determinant.defined": "il ruolo del contenuto dell'utente aziendale",
  "models.ContentRoleToUserCompany.determinant.undefined": "un ruolo di contenuto utente aziendale",
  "models.ContentRoleToUserCompany.determinants.defined": "ruoli dei contenuti degli utenti aziendali",
  "models.ContentRoleToUserCompany.determinants.undefined": "ruoli dei contenuti degli utenti aziendali",
  "models.ContentRoleToJupUiTenantOperation.singular": "Associazione del ruolo del contenuto alle operazioni di interfaccia per un'azienda",
  "models.ContentRoleToJupUiTenantOperation.plural": "Associazione del ruolo del contenuto alle operazioni di interfaccia per un'azienda",
  "models.ContentRoleToJupUiTenantOperation.determinant.defined": "associare il ruolo del contenuto con le operazioni di interfaccia per un'azienda",
  "models.ContentRoleToJupUiTenantOperation.determinant.undefined": "un'associazione del ruolo del contenuto per interfacciare le operazioni per un'azienda",
  "models.ContentRoleToJupUiTenantOperation.determinants.defined": "associazioni di ruoli di contenuto per interfacciare le operazioni per un'azienda",
  "models.ContentRoleToJupUiTenantOperation.determinants.undefined": "associazioni di ruoli di contenuto per interfacciare le operazioni per un'azienda",
  "models.ContentRoleToFloor.singular": "Associazione del ruolo del contenuto alle storie",
  "models.ContentRoleToFloor.plural": "Associazioni dei ruoli dei contenuti alle storie",
  "models.ContentRoleToFloor.determinant.defined": "l'associazione del ruolo di contenuto ai piani",
  "models.ContentRoleToFloor.determinant.undefined": "un'associazione del ruolo del contenuto ai piani",
  "models.ContentRoleToFloor.determinants.defined": "associazioni di ruoli di contenuto ai piani",
  "models.ContentRoleToFloor.determinants.undefined": "associazioni di ruolo del contenuto alle storie",
  "models.ContentRoleToBuilding.singular": "Associazione del ruolo del contenuto agli edifici",
  "models.ContentRoleToBuilding.plural": "Associazioni di ruolo del contenuto agli edifici",
  "models.ContentRoleToBuilding.determinant.defined": "associare il ruolo del contenuto agli edifici",
  "models.ContentRoleToBuilding.determinant.undefined": "un'associazione del ruolo del contenuto agli edifici",
  "models.ContentRoleToBuilding.determinants.defined": "associazioni di ruolo del contenuto agli edifici",
  "models.ContentRoleToBuilding.determinants.undefined": "associazioni di ruolo del contenuto agli edifici",
  "models.ContentRole.singular": "Ruolo dei contenuti",
  "models.ContentRole.plural": "Ruoli del contenuto",
  "models.ContentRole.determinant.defined": "il ruolo del contenuto",
  "models.ContentRole.determinant.undefined": "un ruolo di contenuto",
  "models.ContentRole.determinants.defined": "ruoli di contenuto",
  "models.ContentRole.determinants.undefined": "ruoli di contenuto",
  "models.CompanyType.singular": "Tipo di Compagnia",
  "models.CompanyType.plural": "tipo di imprese",
  "models.CompanyType.determinant.defined": "il tipo di attività",
  "models.CompanyType.determinant.undefined": "un tipo di attività",
  "models.CompanyType.determinants.defined": "tipi di imprese",
  "models.CompanyType.determinants.undefined": "tipi di imprese",
  "models.CompanyType.properties.name.label": "Nome del tipo di attività",
  "models.Company.singular": "azienda",
  "models.Company.plural": "aziende",
  "models.Company.determinant.defined": "l'azienda",
  "models.Company.determinant.undefined": "una società",
  "models.Company.determinants.defined": "imprese",
  "models.Company.determinants.undefined": "imprese",
  "models.Company.properties.id.label": "Codice Identificativo dell'azienda",
  "models.Company.properties.logoPath.label": "Logo",
  "models.Company.properties.logoPath.description": "Il percorso verso il logo della tua azienda",
  "models.Company.properties.iconPath.label": "icona",
  "models.Company.properties.iconPath.description": "Il logo aziendale quadrato",
  "models.Company.properties.name.label": "Nome della ditta",
  "models.Company.properties.workingDaysCount.label": "Numero di giorni lavorativi alla settimana",
  "models.Company.properties.workingDaysCount.description": "Il numero di giorni lavorativi settimanali può essere 5 per i giorni lavorativi, 6 compreso il sabato e 7 compresa la domenica",
  "models.Company.views.usage.label": "Utilizzo delle piattaforme",
  "models.Company.views.usage.help": "Comprendere l'utilizzo delle piattaforme disponibili",
  "models.Company.views.cards.help": "Veduta delle aziende produttrici di piastrelle",
  "models.Company.views.cards.label": "Tegole",
  "models.Company.views.dq-fix-inventory.label": "Coerenza dell'inventario",
  "models.Company.views.dq-fix-inventory.help": "Trova e ripara le incongruenze dell'inventario fisico e virtuale per le workstation",
  "models.Company.views.dq-shapes-position.label": "Posizionamento delle forme",
  "models.Company.views.dq-shapes-position.help": "Trova e riposiziona le forme che si trovano sulla pianta in uno spazio diverso da quello nel database",
  "models.Company.views.people-info.label": "Statistiche sulla creazione di compiti da parte delle persone",
  "models.Company.views.people-info.help": "Visualizza le statistiche delle assegnazioni",
  "models.Company.reports.export-all.fileName": "backup",
  "models.Company.reports.export-all.help": "Esegui il backup di tutti i dati di Surfy",
  "models.Company.reports.export-all-duplicate.fileName": "duplicazione",
  "models.Company.reports.export-all-duplicate.help": "Eseguire il backup dei dati aziendali per creare una copia della piattaforma",
  "models.Campus.singular": "campus",
  "models.Campus.plural": "campus",
  "models.Campus.description": "Campus viene utilizzato per raggruppare edifici che si trovano nella stessa posizione.",
  "models.Campus.determinant.defined": "il campus",
  "models.Campus.determinant.undefined": "un campus",
  "models.Campus.determinants.defined": "campus",
  "models.Campus.determinants.undefined": "campus",
  "models.Campus.views.cards.help": "Veduta di gruppo degli edifici",
  "models.Campus.views.cards.label": "Informazioni",
  "models.Campus.properties.id.label": "Identificativo del campus",
  "models.Campus.properties.name.label": "Nome del campus",
  "models.Campus.properties.name.description": "Nome del campus",
  "models.Campus.properties.color.label": "Colore",
  "models.Campus.properties.color.description": "Colore del campus",
  "models.Campus.properties.externalId.label": "Identificatore esterno",
  "models.BuildingType.singular": "tipo di edificio",
  "models.BuildingType.plural": "tipi di edifici",
  "models.BuildingType.determinant.defined": "il tipo di edificio",
  "models.BuildingType.determinant.undefined": "un tipo di edificio",
  "models.BuildingType.determinants.defined": "tipi di edificio",
  "models.BuildingType.determinants.undefined": "tipi di edificio",
  "models.BuildingType.properties.id.label": "Identificatore del tipo di edificio",
  "models.BuildingType.properties.name.label": "Nome del tipo di edificio",
  "models.BuildingType.properties.name.description": "Nome del tipo di edificio",
  "models.BuildingType.properties.code.label": "codificato",
  "models.BuildingType.properties.code.description": "???",
  "models.BuildingType.properties.externalId.label": "Identificatore esterno",
  "models.BuildingType.properties.externalId.description": "???",
  "models.Building.singular": "edificio",
  "models.Building.plural": "edifici",
  "models.Building.determinant.defined": "edificio",
  "models.Building.determinant.undefined": "un edificio",
  "models.Building.determinants.defined": "gli edifici",
  "models.Building.determinants.undefined": "edifici",
  "models.Building.description": "L'edificio è utilizzato per raggruppare i piani",
  "models.Building.reports.workplaces.fileName": "Posti di lavoro personali",
  "models.Building.reports.workplaces.help": "Rapporto sulle stazioni di lavoro edilizie",
  "models.Building.reports.allWorkplaces.fileName": "Postazioni di lavoro con compiti",
  "models.Building.reports.allWorkplaces.help": "Report di tutte le postazioni di lavoro nell'edificio, compresi gli incarichi",
  "models.Building.reports.workplaceAffectations.fileName": "Compiti della postazione di lavoro",
  "models.Building.reports.workplaceAffectations.help": "Report sull'assegnazione della postazione di lavoro dell'edificio",
  "models.Building.reports.buildingPeople.fileName": "Persone",
  "models.Building.reports.buildingPeople.help": "Segnalazione delle persone interessate nell'edificio",
  "models.Building.reports.organizations.fileName": "Organizzazioni",
  "models.Building.reports.organizations.help": "Rapporto delle organizzazioni edilizie",
  "models.Building.reports.buildingItems.fileName": "Inventario",
  "models.Building.reports.buildingItems.help": "Rapporto sull'inventario degli edifici",
  "models.Building.reports.area.fileName": "Spazi",
  "models.Building.reports.area.help": "Rapporto sugli spazi edificabili",
  "models.Building.reports.buildingCleaning.fileName": "Benefici",
  "models.Building.reports.buildingCleaning.help": "Report dei servizi di pulizia degli edifici",
  "models.Building.reports.buildingDimensions.fileName": "Livelli di analisi",
  "models.Building.reports.buildingDimensions.help": "Rapporto sui livelli di analisi dello spazio dell'edificio",
  "models.Building.views.cards.help": "Veduta di edifici piastrellati",
  "models.Building.views.cards.label": "Informazioni",
  "models.Building.views.pictures.help": "Visualizza gli edifici con le foto",
  "models.Building.views.pictures.label": "Immagini",
  "models.Building.views.gmap.help": "Visualizza gli edifici su una mappa",
  "models.Building.views.gmap.label": "Carta",
  "models.Building.views.cost-distribution-by-cost-center.help": "<b>Chiavi di distribuzione</b> e superficie qualificata per centro di costo per l'edificio %{name}",
  "models.Building.views.cost-distribution-by-cost-center.label": "Chiavi di distribuzione",
  "models.Building.views.3d-cards.help": "Guarda gli edifici in 3d",
  "models.Building.views.3d-cards.label": "3d",
  "models.Building.views.assets.help": "Patrimonio immobiliare",
  "models.Building.views.assets.label": "Immobiliare",
  "models.Building.views.cuby.help": "La pianta <b>3D</b> interattiva dell'edificio %{name}",
  "models.Building.views.cuby.label": "progetto 3d",
  "models.Building.views.3d.help": "La pianta 3d dell'edificio %{name} (cuby)",
  "models.Building.views.3d.label": "progetto 3d",
  "models.Building.views.clone.help": "Costruire <b>scenari</b> e progetti %{name}",
  "models.Building.views.clone.label": "Scenari",
  "models.Building.views.building-ifc.help": "Esporta questo edificio in IFC per BIM",
  "models.Building.views.building-ifc.label": "IFC",
  "models.Building.views.zbre-sync.help": "Sincronizza l'edificio con la piattaforma Zbre",
  "models.Building.views.zbre-sync.label": "Sincronizzazione Zebra",
  "models.Building.views.inventory.help": "Creazione <b>dell'inventario</b> %{name}",
  "models.Building.views.inventory.label": "Inventario",
  "models.Building.views.list-simple.help": "Elenca gli edifici con pochi dettagli",
  "models.Building.views.list-simple.label": "Elenco semplice",
  "models.Building.views.building-3d-gmap.label": "Costruzione 3d sul piano",
  "models.Building.views.building-3d-gmap.help": "Guarda l'edificio in 3d su una pianta",
  "models.Building.properties.id.label": "ID edificio",
  "models.Building.properties.name.label": "nome dell'edificio",
  "models.Building.properties.name.description": "Nome dell'edificio o dello scenario",
  "models.Building.properties.picture.label": "Foto dell'edificio",
  "models.Building.properties.picture.description": "Puoi utilizzare una foto del tuo edificio per ritrovarlo velocemente dalla home page (vedi edifici con foto) o per illustrare il punto di vista dei collaboratori",
  "models.Building.properties.documents.label": "Documenti correlati",
  "models.Building.properties.documents.description": "Mantieni un collegamento alla posizione dei documenti associati a questo edificio nel tuo GED",
  "models.Building.properties.securityDeposit.label": "Deposito di sicurezza",
  "models.Building.properties.securityDeposit.description": "Importo della cauzione depositata al momento della firma del contratto di locazione",
  "models.Building.properties.buildings.label": "Scenari di edifici",
  "models.Building.properties.buildings.description": "Scenari generati da questo edificio",
  "models.Building.properties.constructionYear.label": "Anno di costruzione dell'immobile",
  "models.Building.properties.constructionYear.description": "Anno di costruzione dell'edificio che consente di misurarne l'obsolescenza",
  "models.Building.properties.parkingSpaceCount.label": "Numero di posti auto",
  "models.Building.properties.parkingSpaceCount.description": "Numero di posti auto disponibili",
  "models.Building.properties.yearlyParkingRent.label": "Affitto annuale del parcheggio",
  "models.Building.properties.yearlyParkingRent.description": "Quota di canone destinata al parcheggio",
  "models.Building.properties.yearlyTaxFees.label": "Importo delle tasse annuali",
  "models.Building.properties.yearlyTaxFees.description": "Importo totale delle tasse",
  "models.Building.properties.yearlyExploitationFees.label": "Spese operative annuali",
  "models.Building.properties.yearlyExploitationFees.description": "Importo annuo delle spese operative (esempio: acqua, elettricità)",
  "models.Building.properties.rentReferenceIndex.label": "Indice di riferimento per gli affitti",
  "models.Building.properties.rentReferenceIndex.description": "L'indice di riferimento dell'affitto (IRL) serve come base per la revisione degli affitti di alloggi vuoti o arredati",
  "models.Building.properties.color.label": "Colore",
  "models.Building.properties.color.description": "Il colore dell'edificio viene utilizzato per definire il colore di sfondo nelle presentazioni dei piani o dell'edificio e per poter distinguere questo edificio dagli altri",
  "models.Building.properties.roomsCount.label": "Numero di spazi",
  "models.Building.properties.roomsCount.description": "Il numero di spazi creati in questo edificio",
  "models.Building.properties.roomsArea.label": "Zona qualificata",
  "models.Building.properties.roomsArea.description": "La superficie qualificata rappresenta tutte le aree modellate in Surfy",
  "models.Building.properties.workplacesCount.label": "Numero di postazioni di lavoro",
  "models.Building.properties.workplacesCount.description": "Il numero di postazioni di lavoro nell'edificio viene calcolato automaticamente",
  "models.Building.properties.workplacesRatio.label": "Rapporto di postazioni di lavoro",
  "models.Building.properties.workplacesRatio.description": "Il rapporto per postazione di lavoro è il numero di metri quadrati dell'edificio diviso per il numero di postazioni di lavoro, questo valore viene calcolato automaticamente",
  "models.Building.properties.peopleCount.label": "Numero di incarichi",
  "models.Building.properties.peopleCount.description": "Il numero di persone assegnate all'edificio, ai quartieri, agli spazi o alle postazioni di lavoro",
  "models.Building.properties.peopleRatio.label": "Rapporto di occupazione",
  "models.Building.properties.peopleRatio.description": "Il rapporto di occupazione è il numero di metri quadrati nell'edificio diviso per il numero di persone assegnate direttamente ai quartieri, agli spazi o alle postazioni di lavoro, questo valore viene calcolato",
  "models.Building.properties.freeWorkplacesCount.label": "Numero di posti vacanti",
  "models.Building.properties.freeWorkplacesCount.description": "Numero di posti liberi nell'edificio",
  "models.Building.properties.flexWorkplacesCount.label": "Numero di posizioni flessibili",
  "models.Building.properties.flexWorkplacesCount.description": "Numero di postazioni di lavoro flessibili nell'edificio",
  "models.Building.properties.address.label": "Indirizzo",
  "models.Building.properties.address.description": "L'indirizzo dell'edificio per individuarlo sulla mappa",
  "models.Building.properties.yearlyCondominiumFees.label": "Spese annuali",
  "models.Building.properties.yearlyCondominiumFees.description": "Importo delle spese annuali di gestione o di comproprietà, ad esempio",
  "models.Building.properties.yearlyRent.label": "Affitto annuale",
  "models.Building.properties.yearlyRent.description": "Importo dell'affitto annuo per questo edificio",
  "models.Building.properties.leaseStartDate.label": "Data inizio locazione",
  "models.Building.properties.leaseStartDate.description": "Data inizio locazione",
  "models.Building.properties.leaseEndDate.label": "Data di scadenza del contratto di locazione",
  "models.Building.properties.leaseEndDate.description": "Data di scadenza del contratto di locazione",
  "models.Building.properties.purchaseDate.label": "Data di acquisto dell'immobile",
  "models.Building.properties.purchaseDate.description": "Data di acquisto dell'immobile",
  "models.Building.properties.buildingId.label": "Identificativo edificio di riferimento",
  "models.Building.properties.buildingId.description": "L'identificativo dell'edificio di riferimento viene utilizzato nell'ambito della creazione degli scenari, l'identificativo permette l'associazione con questo edificio",
  "models.Building.properties.building.label": "edificio originale",
  "models.Building.properties.building.description": "L'edificio originale o di riferimento viene utilizzato nella creazione degli scenari, permette di identificare l'edificio originale da cui è stato creato l'edificio",
  "models.Building.properties.jupUiLayout.label": "Visione del piano predefinito",
  "models.Building.properties.jupUiLayout.description": "Alla prima apertura della pianta di questo edificio verrà selezionata la visione predefinita, dopo la prima apertura verrà applicata la visione attuale",
  "models.Building.properties.sharedWorkplacesCount.label": "Numero di postazioni condivise",
  "models.Building.properties.sharedWorkplacesCount.description": "Numero di postazioni condivise nell'edificio da almeno 2 persone",
  "models.Building.properties.sharedWorkplacesRatio.label": "Tasso di postazioni di lavoro condivise",
  "models.Building.properties.sharedWorkplacesRatio.description": "Percentuale di postazioni condivise da almeno 2 persone rispetto a tutte le postazioni presenti nell'edificio",
  "models.Building.properties.flexRatio.label": "Tasso di postazioni di lavoro flessibili",
  "models.Building.properties.flexRatio.description": "La tariffa per workstation flessibili viene calcolata dividendo il numero di workstation flessibili per il numero totale di workstation",
  "models.Building.properties.transitWorkplacesCount.label": "Numero di postazioni di transito",
  "models.Building.properties.transitWorkplacesCount.description": "Numero di postazioni temporanee, queste posizioni non sono conteggiate nelle posizioni libere e non sono in flex",
  "models.Building.properties.regulatoryCapacity.label": "Capacità normativa",
  "models.Building.properties.regulatoryCapacity.description": "La capacità normativa del set, permette di gestire l'evacuazione del pubblico e dei dipendenti",
  "models.Building.properties.dimensionPeopleCount.label": "Numero di assegnazioni di layer",
  "models.Building.properties.dimensionPeopleCount.description": "Il numero di persone assegnate ai livelli di assegnazione associati a questo edificio",
  "models.Building.properties.userCompanyOwner.label": "Utente proprietario dell'edificio",
  "models.Building.properties.userCompanyOwner.description": "L'utente che possiede l'edificio vede sempre l'edificio anche in presenza di un ruolo di contenuto, in caso di creazione di uno scenario, l'utente che ha creato lo scenario diventa il proprietario, il proprietario può essere cambiato successivamente",
  "models.AuthentificationConnection.singular": "Accesso di autenticazione",
  "models.AuthentificationConnection.plural": "Connessioni di autenticazione",
  "models.AuthentificationConnection.determinant.defined": "la connessione di autenticazione",
  "models.AuthentificationConnection.determinant.undefined": "una connessione di autenticazione",
  "models.AuthentificationConnection.determinants.defined": "connessioni di autenticazione",
  "models.AuthentificationConnection.determinants.undefined": "connessioni di autenticazione",
  "models.ApiUserToJupRole.singular": "Associazione dell'utente API al ruolo",
  "models.ApiUserToJupRole.plural": "Utente API alle associazioni di ruoli",
  "models.ApiUserToJupRole.determinant.defined": "associazione utente API al ruolo",
  "models.ApiUserToJupRole.determinant.undefined": "un'associazione utente API al ruolo",
  "models.ApiUserToJupRole.determinants.defined": "associazioni utente API al ruolo",
  "models.ApiUserToJupRole.determinants.undefined": "Associazioni utente API al ruolo",
  "models.ApiUserToContentRole.singular": "Associazione dell'utente API al ruolo contenuto",
  "models.ApiUserToContentRole.plural": "Utente API per associazioni di ruoli di contenuto",
  "models.ApiUserToContentRole.determinant.defined": "associazione utente API al ruolo contenuto",
  "models.ApiUserToContentRole.determinant.undefined": "un'associazione utente API al ruolo contenuto",
  "models.ApiUserToContentRole.determinants.defined": "associazioni utente API al ruolo contenuto",
  "models.ApiUserToContentRole.determinants.undefined": "Associazioni utente API al ruolo contenuto",
  "models.ApiUser.singular": "Utente API",
  "models.ApiUser.plural": "Utenti API",
  "models.ApiUser.determinant.defined": "utente API",
  "models.ApiUser.determinant.undefined": "un utente API",
  "models.ApiUser.determinants.defined": "utenti API",
  "models.ApiUser.determinants.undefined": "Utenti API",
  "models.ApiUser.properties.clientSecret.label": "Codice segreto",
  "models.ApiUser.properties.clientSecret.description": "la password segreta del tuo account API può essere generata e non dovrebbe mai essere condivisa",
  "ToggleZbreSyncCheckbox.label": "Sincronizza con le occupazioni in tempo reale in Z#ber",
  "ToggleZbreSyncCheckbox.help": "La sincronizzazione consente di colorare gli spazi e le postazioni di lavoro in base ai sensori posizionati in Z#ber",
  "FloorSpaceSlider.title": "Spazio tra ogni piano in centimetri",
  "FloorSelector.title": "Seleziona i piani",
  "FloorSelector.focus": "Seleziona solo questo piano",
  "FloorSelector.selectAll.false": "Seleziona tutti i piani",
  "FloorSelector.selectAll.true": "Deseleziona tutti i piani",
  "ToggleEnableMissingFloors.label": "Mostra pavimenti fantasma",
  "ToggleEnableMissingFloors.help": "Mostra i piani fantasma per i piani mancanti tra il livello 0 e il piano più alto in base ai livelli reali",
  "RoomGraphHandler.buttons.generateGraph.label": "Generare il grafico di orientamento",
  "RoomGraphHandler.buttons.generateGraph.description": "Generando il grafico di orientamento si calcolano i nodi attraverso i quali il pathfinder può trovare gli spazi e gli arredi. Se è possibile selezionare lo spazio originale, il grafico è già stato generato.",
  "RoomGraphHandler.buttons.selectOriginRoom.label": "Seleziona lo spazio originale",
  "RoomGraphHandler.buttons.selectOriginRoom.description": "Seleziona uno spazio, quindi potrai utilizzare questa opzione per definirlo come spazio iniziale",
  "RoomGraphHandler.icons.displayNodes.description": "Mostra i percorsi nelle stanze",
  "RoomGraphHandler.icons.displayBoundingBoxes.description": "Mostra gli spazi di esclusione dei mobili",
  "RoomGraphHandler.icons.enablePathfinding.description": "Attiva il disegno del percorso dallo spazio di origine con la forma sotto il mouse",
  "RoomGraphHandler.rooms.origin": "Spazio originale",
  "ThemeModeSwitchMenuItem.dark.label": "Passa alla modalità luminosa",
  "ThemeModeSwitchMenuItem.dark.help": "L'uso della modalità luminosa consente di lavorare con uno sfondo bianco",
  "ThemeModeSwitchMenuItem.light.label": "Passa alla modalità oscura",
  "ThemeModeSwitchMenuItem.light.help": "L'uso della modalità scura consente di lavorare con i colori scuri sullo sfondo per ridurre l'affaticamento degli occhi",
  "copilot.actions.add.door": "Una porta è stata appena aggiunta da Surfy Copilot",
  "generateDocumentation.properties.technicalName": "Nome tecnico",
  "generateDocumentation.properties.belongsTo": "Enti associati (singoli)",
  "generateDocumentation.properties.hasMany": "Enti associati (elenco)",
  "generateDocumentation.properties.base": "Proprietà di base",
  "generateDocumentation.properties.mandatory": "Proprietà obbligatorie",
  "help.key1": "Ciao %{name}",
  "help.key2": "ciao %{name}"
};
const nl = {
  "ImportUpdateOption.label": "Update",
  "ImportUpdateOption.help": "Geselecteerde objecten bijwerken",
  "ImportUpdateEntitiesTable.description": "Lijst met objecten die moeten worden bijgewerkt",
  "PropertyTypeErrors.title": "De volgende waarden bestaan ​​niet voor eigenschap <b>%{propertyTypeLabel}</b> in <b>%{objectTypeLabel}</b>",
  "ImportDeleteOption.label": "verwijderen",
  "ImportDeleteOption.help": "Voer het verwijderen van geselecteerde objecten uit in Surfy",
  "ImportDeleteEntitiesTable.description": "Lijst met objecten die moeten worden verwijderd in Surfy",
  "ImportCreateOption.label": "scheppen",
  "ImportCreateOption.help": "Maak de geselecteerde objecten in Surfy",
  "ImportCreateEntitiesTable.description": "Lijst met objecten die moeten worden gemaakt",
  "ImportCreateEntitiesTable.open.label": "Bekijk de entiteiten die u wilt maken",
  "ImportCreateEntitiesTable.open.help": "Bekijk de details van de entiteiten die moeten worden aangemaakt, omdat er meer dan 500 regels zijn. Om prestatieredenen zijn de regels standaard verborgen",
  "ImportCreateAllOption.label": "Maak alles",
  "ImportCreateAllOption.help": "Voer de creatie van alle objecten uit zonder ze afzonderlijk te selecteren",
  "entitiesImportType.date.wrongImportFormat": "Het formaat van de datum %{value} is niet correct, het verwachte formaat is %{excelImportDateFormat}",
  "InfoTabContent.description": "Opmerkelijke fouten of informatie tijdens het importeren",
  "InfoTabContent.noChange": "In de vergelijking zijn geen veranderingen waargenomen",
  "InfoTabContent.copyIds": "Kopieer entiteits-ID's naar het klembord",
  "InfoTabContent.equals.multiple": "%{count} bestaande en ongewijzigde objecten",
  "InfoTabContent.equals.one": "Eén enkel object bestaat al en is niet gewijzigd",
  "InfoTabContent.open.label": "Bekijk importdetails",
  "InfoTabContent.open.help": "Zie importdetails voor identieke vergelijkingen",
  "ImportObjectType.tabs.create.label": "Creatie",
  "ImportObjectType.tabs.update.label": "Update",
  "ImportObjectType.tabs.errors.label": "Info",
  "ImportObjectType.tabs.delete.label": "Verwijdering",
  "ImportObjectType.usedKeys": "De gebruikte afstemmingssleutel is:",
  "ImportObjectType.errors.noChange": "Bij de vergelijking werd geen wijziging waargenomen",
  "CompareEntities.buttons.reset.label": "Herstarten",
  "CompareEntities.buttons.reset.help": "Start het importeren opnieuw",
  "ObjectTypeImportKeys.title": "De beschikbare sleutels voor het afstemmen van %{determinants.undefined} in de volgorde van uw keuze. Als u een van de sleuteleigenschappen wilt wijzigen, moet u de ID als sleutel gebruiken",
  "ObjectTypeImportScalarProperties.help": "Kopieer naar klembord",
  "ImportHelpDrawerIconButton.icon.help": "Zie hulp bij het importeren van gegevens voor %{determinants.defined}",
  "ImportHelpDrawerIconButton.drawer.title": "Hulp bij het importeren %{determinants.undefined}",
  "ImportHelpDrawerIconButton.drawer.tabLabel": "Hulp bij importeren",
  "DownloadObjectTypeImportTemplateFileButton.label": "Download het importsjabloon",
  "DownloadObjectTypeImportTemplateFileButton.help": "Download een importsjabloon in execl met de namen van de kolommen die u kunt kiezen",
  "ImportHelpDrawer.tab": "Help bij het importeren van %{objectTypeLabel}",
  "BelongsToListItem.clipboard": "Kopieer de kolomtitel naar het klembord",
  "BelongsToListItem.noKeys": "Geen unieke sleutel beschikbaar",
  "BelongsToImportHelp.title": "Objecttypen geassocieerd met %{objectTypeLabel} gesorteerd op beschikbare importsleutels",
  "FileDropZone.dropZone": "Verplaats en sleep het importbestand naar dit gebied of klik in het gebied om uw bestand te selecteren",
  "EntitiesImporter.tabs.file": "Bestand",
  "EntitiesImporter.tabs.copypaste": "Knippen en plakken",
  "TextAreaImporter.errors.title": "Er zijn fouten opgetreden tijdens het importeren",
  "TextAreaImporter.textarea.placeholder": "Kopieer en plak uw kolommen vanuit Excel met de titel om de eigenschappen te vinden die u wilt bijwerken",
  "TextAreaImporter.help": "Gebruik het tabblad tussen elke kolom door de naam van elke kolom in de eerste rij op te nemen of rechtstreeks vanuit Excel te plakken",
  "ImportOptionsBar.buttons.compare.label": "Vergelijken",
  "ImportOptionsBar.buttons.compare.help": "Start de vergelijking met de gegevens in surfy om de te importeren wijzigingen te bepalen",
  "ImportErrors.errors.title": "Er zijn fouten opgetreden tijdens het importeren",
  "DashboardView.tabs.reports": "Excel-rapporten",
  "IconShape.values.circle": "Cirkel",
  "IconShape.values.rectangle": "Rechthoek",
  "IconShape.values.triangle": "Driehoek",
  "EntityDialogSearchList.NoResult": "Er zijn geen resultaten gevonden. Wis uw filters of wijzig uw zoekopdracht",
  "FieldTypeEntity.edit": "Wijzig %{determinant.defined}",
  "FieldTypeEntity.remove": "Verwijder %{determinant.defined}",
  "FieldTypeEntity.add": "%{determinant.undefined} toevoegen",
  "LegendSelector.title": "Legenda selecteren",
  "LegendSelector.labels.default": "Standaardlegenda",
  "HasManyStandaloneNoData.noData": "Er is geen %{targetObjectTypeLabel} gekoppeld voor %{determinant.defined}",
  "FieldTypeAddress.edit": "Adres wijzigen",
  "FieldTypeAddress.remove": "Adres verwijderen",
  "AutocompleteAddress.autocomplete.placeholder": "Vind hier uw adres",
  "AddressDialog.search": "Vind adres",
  "AddressDialog.validate": "bevestigen",
  "FieldTypePassword.icons.copy": "Kopieer de inhoud van het wachtwoord naar het klembord",
  "FieldTypePassword.icons.generate": "Genereer een uniek wachtwoord",
  "FieldTypeModel3d.Remove": "3D-model verwijderen",
  "FieldTypeModel3d.Upload": "Wijzig het 3D-model",
  "FieldTypeImage.Remove": "Afbeelding verwijderen",
  "FieldTypeImage.Upload": "Verander afbeelding",
  "FieldTypeIcon.Edit": "Verander icoon",
  "FieldTypeIcon.Remove": "Pictogram verwijderen",
  "FieldTypeColor.Remove": "Kleur verwijderen",
  "FieldTypeColor.NoColorHelp": "Selecteer een kleur",
  "FieldTypeColor.NotHexMatchError": "Het veld respecteert het hexadecimale formaat van een kleur niet",
  "CopyImagePathToClipboard.CopyUrl": "Kopie URL",
  "ColorBox.NoColorHelp": "Selecteer een kleur via het palet",
  "ChangeColor.classic": "Selecteer een kleur met de geavanceerde plaat",
  "weight.kilogram": "Kilogram",
  "weight.gram": "Gram",
  "distance.meter": "Meters",
  "distance.centimeter": "Centimeter",
  "FieldTypeIndexBoolean.help": "Wijzig de waarde rechtstreeks",
  "FieldTypeIndexBoolean.values.true": "Ja",
  "FieldTypeIndexBoolean.values.false": "Neen",
  "calculatedProperties.properties.workplacesCount.label": "Aantal werkstations",
  "calculatedProperties.properties.workplacesCount.description": "Het totaal aantal werkplekken in de ruimtes",
  "calculatedProperties.properties.workplacesRatio.label": "Werkstationverhouding",
  "calculatedProperties.properties.workplacesRatio.description": "De werkplekverhouding is het aantal vierkante meters gedeeld door het aantal werkplekken",
  "calculatedProperties.properties.peopleCount.label": "Aantal opdrachten",
  "calculatedProperties.properties.peopleCount.description": "Het aantal toegewezen personen, hetzij direct toegewezen aan ruimtes, hetzij via een werkstation",
  "calculatedProperties.properties.totalPeopleCount.label": "Totaal aantal opdrachten",
  "calculatedProperties.properties.totalPeopleCount.description": "Het totale aantal toegewezen personen, rechtstreeks toegewezen aan ruimtes of via een werkstation",
  "calculatedProperties.properties.peopleRatio.label": "Bezettingsgraad",
  "calculatedProperties.properties.peopleRatio.description": "De bezettingsgraad is het aantal vierkante meters gedeeld door het aantal personen dat direct of via een werkplek aan de ruimtes wordt toegewezen",
  "calculatedProperties.properties.freeWorkplacesCount.label": "Aantal vrije posities",
  "calculatedProperties.properties.freeWorkplacesCount.description": "Totaal aantal vrije posities",
  "calculatedProperties.properties.flexWorkplacesCount.label": "Aantal flexposities",
  "calculatedProperties.properties.flexWorkplacesCount.description": "Totaal aantal flexposities",
  "calculatedProperties.properties.occupancyRate.label": "Bezettingsgraad",
  "calculatedProperties.properties.occupancyRate.description": "Hiermee kunt u de bezettingsgraad van werkstations kennen. Dit is het aantal getroffen personen gedeeld door het aantal werkstations",
  "calculatedProperties.properties.expansionRatio.label": "Overgroeisnelheid",
  "calculatedProperties.properties.expansionRatio.description": "Hiermee kunt u het gebruikspercentage van werkstations kennen. Dit is het omgekeerde van het aantal getroffen mensen gedeeld door het aantal werkstations",
  "calculatedProperties.properties.roomsArea.label": "Gekwalificeerd oppervlak",
  "calculatedProperties.properties.roomsArea.description": "Het gekwalificeerde oppervlak is de som van de oppervlakken van de ruimtes",
  "calculatedProperties.properties.roomsCount.label": "Aantal spaties",
  "calculatedProperties.properties.roomsCount.description": "Het totale aantal spaties",
  "calculatedProperties.properties.sharedWorkplacesCount.label": "Aantal gedeelde werkstations",
  "calculatedProperties.properties.sharedWorkplacesCount.description": "Totaal aantal werkplekken gedeeld door minimaal 2 personen",
  "calculatedProperties.properties.sharedWorkplacesRatio.label": "Tarief gedeeld werkstation",
  "calculatedProperties.properties.sharedWorkplacesRatio.description": "Percentage werkstations gedeeld door minimaal 2 personen vergeleken met alle werkstations",
  "calculatedProperties.properties.flexRatio.label": "Tarief flexwerkplekken",
  "calculatedProperties.properties.flexRatio.description": "Het flexwerkplektarief wordt berekend door het aantal flexwerkplekken te delen door het totaal aantal werkplekken",
  "calculatedProperties.properties.transitWorkplacesCount.label": "Aantal passerende werkplekken",
  "calculatedProperties.properties.transitWorkplacesCount.description": "Aantal tijdelijke werkplekken, deze posities worden niet meegeteld in de vrije posities en zijn niet in flex",
  "calculatedProperties.properties.seatsCount.label": "aantal zitplaatsen",
  "calculatedProperties.properties.seatsCount.description": "Het totaal aantal zetels",
  "calculatedProperties.properties.seatsPeopleRatio.label": "Zitplaatstarief per toewijzing",
  "calculatedProperties.properties.seatsPeopleRatio.description": "Het aantal zetels per getroffen persoon",
  "calculatedProperties.properties.carbonFootprint.label": "Koolstofvoetafdruk",
  "calculatedProperties.properties.carbonFootprint.description": "De CO2-voetafdruk is de hoeveelheid CO2 die wordt uitgestoten",
  "calculatedProperties.properties.totalCapacityCount.label": "Totale capaciteit",
  "calculatedProperties.properties.totalCapacityCount.description": "De totale stoelcapaciteit is de som van het aantal zitplaatsen en de niet-zittende capaciteit op ruimteniveau.",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.label": "Aantal zitplaatsen per werkplek",
  "calculatedProperties.properties.totalCapacityWorkplaceCountRatio.description": "Het aantal plaatsen per werkplek is de totale capaciteit van de ruimtes gedeeld door het aantal werkstations. Hierdoor kunnen we het aantal plaatsen begrijpen op basis van het aantal werkstations",
  "DeleteMultipleDialog.title": "Verwijder %{determinants.undefined}",
  "DeleteMultipleDialog.content": "U staat op het punt <b>%{determinants.undefined}</b> te verwijderen. Deze actie is niet ongedaan te maken en kan gevolgen hebben. Weet u zeker dat u deze actie wilt uitvoeren?",
  "DeleteMultipleDialog.cancel.label": "Annuleren",
  "DeleteMultipleDialog.cancel.help": "Verwijdering ongedaan maken",
  "DeleteMultipleDialog.delete.label": "verwijderen",
  "DeleteMultipleDialog.delete.help": "%{determinants.defined} definitief verwijderen",
  "DownloadTableToExcelIconButton.help": "Exporteren %{determinants.defined} geselecteerd",
  "DeleteMultipleEntities.help": "Verwijder geselecteerde %{determinants.defined}",
  "EntityCreateModeSelect.open-on-create.text": "Open na creatie",
  "EntityCreateModeSelect.open-on-create.help": "Zodra uw object is gemaakt, wordt u doorgestuurd naar de objectvisualisatiepagina om de eigenschappen en associaties ervan te bekijken",
  "EntityCreateModeSelect.keep-creating.text": "Ga door met creëren",
  "EntityCreateModeSelect.keep-creating.help": "Met deze optie kunt u meerdere objecten achter elkaar blijven maken, terwijl u de eigenschappen van de oude creatie behoudt.",
  "EntityCreateModeSelect.edit-on-create.text": "Bewerken na creatie",
  "EntityCreateModeSelect.edit-on-create.help": "Zodra uw object is gemaakt, wordt u doorgestuurd naar de objectbewerkingspagina om de eigenschappen en koppelingen ervan te voltooien.",
  "TableView.options": "Opties",
  "ErrorImpossibleToFindTheEntity.text": "De gezochte %{determinant.defined} kan niet worden gevonden",
  "ErrorImpossibleToFindTheEntities.text": "Kon het gezochte %{determinants.defined} niet vinden",
  "EntityPropertyTypesMandatoryNotRespected.title": "De volgende eigenschappen zijn vereist",
  "entity.properties.mandatory": "De eigenschap %{name} is vereist.",
  "entity.properties.calculated": "De eigenschap %{name} wordt automatisch berekend.",
  "entity.properties.readonly-lock": "De eigenschap %{name} is alleen-lezen en kan niet vanaf deze pagina worden gewijzigd.",
  "EntityHasManyProperties.associations.others": "Associaties voor %{determinant.defined}",
  "EntityHasManyProperties.associations.reporting": "Rapportageassociaties voor %{determinant.defined}",
  "EntityHasManyProperties.associations.security": "Beveiligingsassociaties voor %{determinant.defined}",
  "EntitiesView.NoItem": "Er is geen %{objectType} . U kunt uw eerste %{objectType} maken met behulp van de onderstaande knop",
  "DeleteDialog.title": "Verwijder %{determinant.undefined}",
  "DeleteDialog.content": "U staat op het punt <b>%{determinant.undefined}</b> te verwijderen. Deze actie is niet ongedaan te maken en kan gevolgen hebben. Weet u zeker dat u deze actie wilt uitvoeren?",
  "DeleteDialog.cancel.label": "Annuleren",
  "DeleteDialog.cancel.help": "Verwijdering ongedaan maken",
  "DeleteDialog.delete.label": "verwijderen",
  "DeleteDialog.delete.help": "%{determinant.defined} definitief verwijderen",
  "ExportQueryNodeToFileButton.help.list": "Downloaden in Excel %{determinants.defined}",
  "entity.excel.headers.count": "%{label} :Nummer",
  "entity.properties.externalId.label": "Externe sleutel",
  "entity.properties.externalId.description": "Dit veld kan worden gebruikt om de correspondentiesleutel in andere software te onthouden",
  "entity.properties.createdAt.label": "Aanmaakdatum",
  "entity.properties.createdAt.description": "Datum van creatie in Surfy, hiermee kunt u de geschiedenis van creatie in Surfy kennen",
  "entity.properties.userCompanyCreatedBy.label": "Gemaakt door gebruiker",
  "entity.properties.userCompanyCreatedBy.description": "Gemaakt door deze gebruiker in Surfy, kunt u de aanmaakgeschiedenis in Surfy kennen",
  "entity.properties.userCompanyCreatedById.label": "ID van de gebruiker die het heeft gemaakt",
  "entity.properties.userCompanyCreatedById.description": "Aangemaakt op basis van de identificatie van deze gebruiker in Surfy, kunt u de aanmaakgeschiedenis in Surfy kennen",
  "entity.properties.userCompanyUpdatedById.label": "Identificatie van de gebruiker die heeft gewijzigd",
  "entity.properties.userCompanyUpdatedById.description": "Bijgewerkt door de identificatie van deze gebruiker in Surfy, kunt u de aanmaakgeschiedenis in Surfy kennen",
  "entity.properties.userCompanyUpdatedBy.label": "Bijgewerkt door gebruiker",
  "entity.properties.userCompanyUpdatedBy.description": "Bijgewerkt door deze gebruiker in Surfy, kunt u de geschiedenis van de wijziging in Surfy kennen",
  "entity.properties.updatedAt.label": "Updatedatum",
  "entity.properties.updatedAt.description": "Updatedatum in Surfy, hiermee kunt u de geschiedenis van wijzigingen kennen",
  "entity.delete.button.label": "verwijderen",
  "entity.delete.button.help": "Verwijder %{determinant.defined} %{name}",
  "entity.cancel": "Annuleren",
  "entity.see.label": "zien",
  "entity.see.help": "Zie %{determinant.defined} %{name}",
  "entity.views.dataquality.help": "Rapporten en acties voor datakwaliteit voor %{determinants.defined}",
  "entity.views.dataquality.label": "Data kwaliteit",
  "entity.views.list.help": "Lijst %{determinants.defined}",
  "entity.views.list.label": "Oplijsten",
  "entity.views.import.help": "Importeer %{determinants.undefined}",
  "entity.views.import.label": "Importeren",
  "entity.views.details.help": "Zie %{determinant.defined} %{name}",
  "entity.views.details.label": "zien",
  "entity.views.create.help": "Maak %{determinant.undefined} aan",
  "entity.views.create.label": "scheppen",
  "entity.views.edit.help": "Bewerk %{determinant.defined} %{name}",
  "entity.views.edit.label": "Bewerken",
  "entity.views.dashboard.help": "Dashboard voor %{determinant.defined} %{name}",
  "entity.views.dashboard.label": "Dashboard",
  "entity.create.validate.help": "Valideer de creatie voor %{determinant.defined}",
  "entity.create.validate.label": "Valideer de creatie",
  "entity.create.button.help": "Begin met creëren voor %{determinant.defined}",
  "entity.create.button.label": "Maak %{determinant.defined}",
  "entity.create.association.help": "Begin met creëren voor %{determinant.undefined}",
  "entity.create.association.label": "Maak %{determinant.undefined} aan",
  "entity.update.button.label": "Besparen",
  "entity.update.button.help": "Bespaar %{determinant.defined} %{name}",
  "entity.createAndAssociate.button.label": "Creëer en associeer",
  "entity.createAndAssociate.button.help": "Maak en koppel %{determinant.undefined}",
  "entity.associate.button.label": "Associëren",
  "entity.associate.button.help": "Associatie %{determinant.undefined}",
  "entity.back": "Rug",
  "WorkCanvas.Options.ZoomCanvasOption.label.enable": "Activeer het vergrootglas rond de muis",
  "WorkCanvas.Options.ZoomCanvasOption.label.disable": "Schakel het vergrootglas rond de muis uit",
  "WorkCanvas.Options.ZoomCanvasOption.help.enable": "Door het vergrootglas te activeren, houdt u het overzicht over een gebied of verdieping en ziet u het muisgedrag nauwkeurig",
  "WorkCanvas.Options.ZoomCanvasOption.help.disable": "Stop het muisvergrootglas",
  "WorkCanvas.Options.AddSegmentPointOption.label.enable": "Voeg een hoekpunt toe aan een segment",
  "WorkCanvas.Options.AddSegmentPointOption.label.disable": "Stop met het toevoegen van een hoekpunt aan een segment",
  "WorkCanvas.Options.AddSegmentPointOption.help.enable": "Door een hoekpunt aan een segment toe te voegen, kunt u overal een punt plaatsen zonder rekening te houden met andere punten",
  "WorkCanvas.Options.AddSegmentPointOption.help.disable": "Stop met het maken van hoekpunten op segmenten",
  "WorkCanvas.Options.AddSegmentPointOption.description": "Selecteer een spatie om een ​​hoekpunt op een van de segmenten te kunnen maken",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.enable": "Schakel omkering van de oriëntatie van het maken van hoekpunten in",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.label.disable": "Schakel de inversie van de oriëntatie voor het maken van hoekpunten uit",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.enable": "Als u de omkering van de oriëntatie voor het maken van hoekpunten inschakelt, kunt u de richting van het maken van hoekpunten wijzigen",
  "WorkCanvas.Options.ReversePointCreationOrientationOption.help.disable": "Schakel inversie uit om de initiële richting van het maken van de hoekpunten te vinden",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.enable": "Schakel inversie van de rechte hoek in voor het maken van hoekpunten",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.label.disable": "Schakel de omkering van de rechte hoek uit voor het maken van hoekpunten",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.enable": "Als u inversie inschakelt, kunt u de rechte hoek gebruiken terwijl u hoekpunten op het andere segment maakt",
  "WorkCanvas.Options.ReverseOrthogonalPointOption.help.disable": "Als u de inversie uitschakelt, kunt u de rechte hoek op het initiële segment gebruiken",
  "LoadingSvgCircle.pleaseWait": "Een ogenblik geduld tijdens het synchroniseren",
  "WorkCanvas.Options.AddRoomPointOption.label.enable": "Voeg een hoekpunt toe",
  "WorkCanvas.Options.AddRoomPointOption.label.disable": "Stop met het toevoegen van een hoekpunt",
  "WorkCanvas.Options.AddRoomPointOption.help.enable": "Door een hoekpunt toe te voegen, kunt u een vorm nauwkeuriger bewerken",
  "WorkCanvas.Options.AddRoomPointOption.help.disable": "Stop met het maken van hoekpunten",
  "WorkCanvas.Options.SplitPolygoneOption.label": "Scheid de ruimte",
  "WorkCanvas.Options.SplitPolygoneOption.help": "Creëer 2 ruimtes vanuit een andere ruimte door 2 hoekpunten te kiezen",
  "WorkCanvas.Options.SplitRoomPointOption.help": "Door de hoekpunten te scheiden, kunt u voor elk segment meerdere hoekpunten hergebruiken en zo afzonderlijke ruimtes creëren",
  "WorkCanvas.Options.SplitRoomPointOption.label": "Splits de bovenkant",
  "WorkCanvas.Options.MergeRoomPointsOption.help": "Door hoekpunten samen te voegen, kunt u hetzelfde hoekpunt voor verschillende ruimtes hergebruiken",
  "WorkCanvas.Options.MergeRoomPointsOption.label": "Hoekpunten samenvoegen",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.help": "Verwijder hoekpunten uit de ruimte",
  "WorkCanvas.Options.DeleteRoomPointRoomOption.label": "Verwijder geselecteerde hoekpunten",
  "WorkCanvas.Options.ZoomOnEdgePoints.help": "Zoom in op één of meerdere punten, zodat je rustig kunt werken",
  "WorkCanvas.Options.ZoomOnEdgePoints.label": "Zoom in op punten",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.enable": "Objecttype verplaatsen",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.label.disable": "Stop met bewegen",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.enable": "Verplaats objecttype op plan",
  "WorkCanvas.Options.MoveWorkplaceTypeItemTypeOption.help.disable": "Stop met het verplaatsen van het objecttype",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.help": "Verwijder het objecttype van het werkstationtype",
  "WorkCanvas.Options.DeleteWorkplaceTypeItemTypeOption.label": "Objecttype verwijderen",
  "WorkCanvas.Options.DeleteItemTypePointsOption.help": "Verwijder hoekpunten uit het objecttype",
  "WorkCanvas.Options.DeleteItemTypePointsOption.label": "Verwijder geselecteerde hoekpunten",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.enable": "Voeg een vorm toe",
  "WorkCanvas.Options.AddItemTypeShapeOption.label.disable": "Stop met het toevoegen van vorm",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.enable": "Voeg een vorm voor een objecttype toe aan het plan",
  "WorkCanvas.Options.AddItemTypeShapeOption.help.disable": "Stop met het maken van de vorm",
  "WorkCanvas.Options.AddItemTypeShapeSaveOption.help": "Sla het type object op dat wordt gemaakt",
  "WorkCanvas.Options.AddItemTypePointOption.label.enable": "Voeg een hoekpunt toe",
  "WorkCanvas.Options.AddItemTypePointOption.label.disable": "Stop met het toevoegen van een hoekpunt",
  "WorkCanvas.Options.AddItemTypePointOption.help.enable": "Door een hoekpunt toe te voegen, kunt u een vorm nauwkeuriger bewerken",
  "WorkCanvas.Options.AddItemTypePointOption.help.disable": "Stop met het maken van hoekpunten",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.enable": "Verplaats spaties",
  "WorkCanvas.Options.ToggleMoveRoomOption.label.disable": "Stop met reizen",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.enable": "Schakel bewegende ruimtes in op het plan",
  "WorkCanvas.Options.ToggleMoveRoomOption.help.disable": "Stop met het verplaatsen van ruimtes",
  "WorkCanvas.Options.ToggleMoveRoomOption.description": "Eenmaal geactiveerd, selecteert u een ruimte en kunt u deze verplaatsen",
  "WorkCanvas.Options.DuplicateShapesOption.label": "Dubbele vormen",
  "WorkCanvas.Options.DuplicateShapesOption.help": "Dupliceer vormen zonder eigenschappen om snel objecten of werkstations op het plan te maken",
  "CancelDuplicateShapsToRoomMouse.help": "Vormduplicatie ongedaan maken",
  "ToggleWorkplaceFreeConditionTypeIconButton.or": "Bekijk vrije werkplekken voor alle aangevraagde dagen",
  "ToggleWorkplaceFreeConditionTypeIconButton.and": "Bekijk vrije werkplekken voor minimaal één van de aangevraagde dagen",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.false": "Kleur de vrije posities %{day}",
  "FreeWorkplacesDayListItem.updateFreeWorkplaceVisibleDay.true": "Stop met het kleuren van gratis berichten %{day}",
  "FreeWorkplacesDayList.title": "Bekijk vrije plaatsen %{days}",
  "FreeWorkplacesDayList.conditions.and": "En",
  "FreeWorkplacesDayList.conditions.or": "Of",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.enable": "Kleur de kruispunten",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.label.disable": "Stop met het kleuren van kruispunten",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.enable": "Bekijk op het kleurplan de werkplekken die passeren",
  "WorkCanvas.Options.ToggleColorizeIsTransitWorkplacesOption.help.disable": "Zie passerende werkplekken niet meer anders op het plan",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.enable": "Kleur gedeelde berichten",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.label.disable": "Stop met het kleuren van gedeelde berichten",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.enable": "Zie op het kleurplan de werkplekken die gedeeld worden door minimaal 2 personen",
  "WorkCanvas.Options.ToggleColorizeIsSharedWorkplacesOption.help.disable": "Zie gedeelde werkplekken niet meer anders in termen van",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.enable": "Kleur objecten zonder associatie",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.label.disable": "Stop met het kleuren van objecten zonder associatie",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.enable": "Bekijk de vrije objecten op de kaart",
  "WorkCanvas.Options.ToggleColorizeFreeItemOption.help.disable": "Zie vrije objecten niet langer anders op de kaart",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.enable": "Kleur de reserveerbare posities",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.label.disable": "Stop met het inkleuren van reserveerbare posities",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.enable": "Bekijk op het kleurplan de werkplekken die reserveerbaar zijn",
  "WorkCanvas.Options.ToggleColorizeBookableWorkplacesOption.help.disable": "Zie reserveerbare werkplekken niet meer anders qua",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.enable": "Kleur de vrije posities",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.label.disable": "Stop met het inkleuren van open posities",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.enable": "Bekijk beschikbare posities op de kaart",
  "WorkCanvas.Options.ToggleColorizeFreeWorkplacesOption.help.disable": "Vrije posities niet meer anders zien qua plan",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.enable": "Kleurflexposities",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.label.disable": "Stop met het kleuren van flexposities",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.enable": "Bekijk de flexposities op de kaart",
  "WorkCanvas.Options.ToggleColorizeFlexWorkplacesOption.help.disable": "Flexposities niet meer anders zien qua plan",
  "WorkCanvas.Options.CalibrateLayoutOption.help.enable": "Met Calibrate Plan kunt u alle ruimtes vergroten of verkleinen, of ze allemaal op het plan verplaatsen",
  "WorkCanvas.Options.CalibrateLayoutOption.help.disable": "Stop met het kalibreren van het plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.enable": "Kalibreer het plan",
  "WorkCanvas.Options.CalibrateLayoutOption.label.disable": "Stop met het kalibreren van het plan",
  "CalibrateLayoutDrawer.title": "Kalibreer het plan",
  "CalibrateLayoutDrawer.options.mapScale.label": "Planschaal uitlijnen",
  "CalibrateLayoutDrawer.options.mapScale.help": "Past de schaalfactor toe op de schaalelementen (tekstlengte en -grootte)",
  "CalibrateLayoutDrawer.options.inputs.scale.label": "Schaal factor",
  "CalibrateLayoutDrawer.options.inputs.step.label": "Vertaalwaarde",
  "CalibrateLayoutDrawer.options.inputs.translate.x.label": "X-as",
  "CalibrateLayoutDrawer.options.inputs.translate.y.label": "Y-as",
  "CalibrateLayoutDrawer.options.reduce.label": "Verminderen",
  "CalibrateLayoutDrawer.options.save.label": "Opnemen",
  "CalibrateLayoutDrawer.options.save.help": "Sla de kalibratie op in de planning",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.enable": "Schakel de weergave van pictogrammen op de 2D-kaart in",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.label.disable": "Schakel de weergave van pictogrammen op de kaart uit",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.enable": "De iconen die bij de soorten ruimtes horen, maken het makkelijker om de soorten ruimtes op de plattegrond te visualiseren",
  "WorkCanvas.Options.ToggleIconizedRoomTypeOption.help.disable": "Ruimte-informatie weergeven",
  "WorkCanvasToggleOptionHelp.shortcut": "Sneltoets: <b>%{shortcut}</b>",
  "WorkCanvasShortcutTooltipHelp.help": "Sneltoets: <b>%{shortcut}</b>",
  "WorkCanvas.Options.ZoomOutOption.label": "Zoom uit op de kaart",
  "WorkCanvas.Options.ZoomOutOption.help": "Zoom uit op de kaart door de muispositie te centreren",
  "WorkCanvas.Options.ZoomOutOption.description": "U kunt het muiswiel en uw touchpad gebruiken om uit te zoomen",
  "WorkCanvas.Options.ZoomOnMousePosition.help": "Zoom in op de muispositie om nauwkeuriger op een gebied te kunnen werken",
  "WorkCanvas.Options.ZoomOnMousePosition.label": "Zoom naar muispositie",
  "WorkCanvasLoadingIcon.title": "Het plan laden",
  "WorkCanvas.Options.ZoomOnItemsOption.help": "Zoom in op één of meerdere objecten om preciezer te werken",
  "WorkCanvas.Options.ZoomOnItemsOption.label": "Zoom in op de selectie",
  "WorkCanvas.Options.ZoomOnDimensionsOption.label": "Zoom in op toewijzingslagen",
  "WorkCanvas.Options.ZoomOnDimensionsOption.help": "Zoom direct naar de opdrachtlagen waarin je kunt reserveren op het plan",
  "WorkCanvas.Options.ZoomInOption.label": "Zoom in op de kaart",
  "WorkCanvas.Options.ZoomInOption.help": "Zoom in op de kaart door naar de linkerbovenhoek van het scherm te centreren",
  "WorkCanvas.Options.ZoomInOption.description": "U kunt het muiswiel en uw touchpad gebruiken om te zoomen",
  "WorkCanvas.Options.ToggleSelectModeOption.help.enable": "Verkrijg de planopties om te kunnen inzoomen of de details van de vormen te bekijken en de sneltoetsen te activeren. U kunt ook in het plan klikken om de manipulatie te activeren",
  "WorkCanvas.Options.ToggleSelectModeOption.help.disable": "???",
  "WorkCanvas.Options.ToggleSelectModeOption.label.enable": "Begin met manipulatie van de werkruimte",
  "WorkCanvas.Options.ToggleSelectModeOption.label.disable": "Stop manipulatie van de werkruimte",
  "WorkCanvas.Options.ToggleSelectModeOption.description": "U kunt meerdere vormen selecteren door <b>SHIFT</b> ingedrukt te houden en op de vormen te klikken",
  "WorkCanvas.Options.ToggleEditModeOption.label.enable": "Schakel de planbewerkingsmodus in",
  "WorkCanvas.Options.ToggleEditModeOption.label.disable": "Schakel de planbewerkingsmodus uit",
  "WorkCanvas.Options.ToggleEditModeOption.help.enable": "Door de planbewerkingsmodus te activeren, kunt u vormen maken en verplaatsen of ruimtes creëren",
  "WorkCanvas.Options.ToggleEditModeOption.help.disable": "Schakel de planbewerkingsmodus uit om terug te keren naar de planleesmodus",
  "WorkCanvas.Options.ToggleEditModeOption.description": "Bij het roteren van objecten en werkstations wordt standaard een hoek van 45° toegepast. Om deze te deactiveren gebruikt u de <b>SHIFT-</b> toetsenbordtoets",
  "WorkCanvas.Options.FitToViewOption.label": "Centreer het plan om alles te zien",
  "WorkCanvas.Options.FitToViewOption.help": "Hiermee krijgt u een overzicht van het plan",
  "HeatMapSelection.title": "Kleur de ruimtes met een hittekaart om de dichtheden te begrijpen. De hittekaarten kunnen momenteel niet als afbeeldingen worden geëxporteerd",
  "HeatMapSelection.heatmaps.seatsCount.label": "Zitdichtheid",
  "HeatMapSelection.heatmaps.seatsCount.description": "Kleur de ruimtes volgens het aantal zitplaatsen",
  "HeatMapSelection.heatmaps.workplacesCount.label": "Dichtheid van werkstations",
  "HeatMapSelection.heatmaps.workplacesCount.description": "Kleur de ruimtes volgens het aantal werkplekken",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.label": "Dichtheid van werkstationtoewijzingen",
  "HeatMapSelection.heatmaps.workplaceAffectationsCount.description": "Kleur de ruimtes volgens het aantal werkplekopdrachten",
  "HeatMapSelection.heatmaps.carbonFootprintCount.label": "Koolstofvoetafdrukdichtheid van meubilair",
  "HeatMapSelection.heatmaps.carbonFootprintCount.description": "Kleurruimtes volgens de ecologische voetafdruk van het meubilair",
  "FurnituresSelectionDragZone.help": "Groep verplaatsen",
  "FurnituresSelection.move": "Verplaats de hele groep",
  "WorkCanvas.Options.TextAnchorOption.label.enable": "Stel de weergavetekstlocatie in",
  "WorkCanvas.Options.TextAnchorOption.label.disable": "Stop met het beheren van de displaytekst",
  "WorkCanvas.Options.TextAnchorOption.help.enable": "Displaytekst verplaatsen",
  "WorkCanvas.Options.TextAnchorOption.help.disable": "Stop met het verplaatsen van de displaytekst",
  "TextAnchorDrawer.title": "Wijzig de weergavetekstlocatie voor %{determinant.defined} %{name}",
  "WorkCanvas.Options.TextAnchorDrawer.label.enable": "Displaytekst verplaatsen",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.label": "Pas de tekstpositie aan",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.createAnchor.help": "Hiermee kunt u de aanpassing van de positie van de tekst van het plan activeren",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.label": "Ankerweergave inschakelen",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.enableAnchor.help": "Hiermee kunt u de weergave van het segment en het ankerpunt voor deze ruimte activeren",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.label": "Tekstpositie opnieuw instellen",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textPosition.help": "Met deze optie wordt de tekstpositie voor deze ruimte teruggezet naar de oorspronkelijke locatie",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.label": "Ankerpositie opnieuw instellen",
  "WorkCanvas.Options.TextAnchorDrawer.buttons.reset.textAnchor.help": "Deze optie retourneert de ankerpositie voor deze ruimte naar de oorspronkelijke locatie",
  "ShapeTextAnchorDrawer.empty": "Selecteer een compatibele vorm om de displaytekst te verplaatsen",
  "IconsPicker.DisplayAll.text": "Toon alles",
  "IconsPicker.DisplayAll.help": "Wees voorzichtig, het laden kan een beetje lang duren.",
  "IconsPicker.close": "Pictogramselectie sluiten",
  "IconPickerSearch.SearchPlaceholder": "Zoek naar een pictogram met minimaal 3 letters",
  "EntitiesAutocomplete.searchEmpty.help.false": "Selecteer %{determinants.defined} zonder %{objectTypeName}",
  "EntitiesAutocomplete.searchEmpty.help.true": "Keer terug naar de standaard zoekmodus",
  "SearchFieldString.searchEmpty.help.false": "Zoek naar lege of waardeloze elementen",
  "SearchFieldString.searchEmpty.help.true": "Schakel standaard zoeken opnieuw in",
  "SearchFilters.buttons.clear.label": "Wis alle filters",
  "SearchFilters.buttons.clear.help": "Wis alle filters en breng ze terug naar hun oorspronkelijke staat om ervoor te zorgen dat u alle beschikbare entiteiten kunt zien",
  "RightSearchFilterDrawer.filter": "Filter %{determinants.defined}",
  "RightSearchFilterDrawer.tabLabel": "Filter",
  "RightSearchFilterDrawer.buttons.clear.label": "Wis alle filters",
  "RightSearchFilterDrawer.buttons.clear.help": "Wis alle filters en breng ze terug naar hun oorspronkelijke staat om ervoor te zorgen dat u alle beschikbare entiteiten kunt zien",
  "PropertSelectorDrawer.help": "Selecteer de eigenschappen die u in de tabel wilt weergeven",
  "PropertSelectorDrawer.options.reset.label": "Selectie opnieuw instellen",
  "PropertSelectorDrawer.options.reset.help": "Breng de selectie van eigenschappen terug naar hun oorspronkelijke staat",
  "PropertSelectorDrawer.tabLabel": "Eigenschappen",
  "TableSelectionAllCheckbox.checked.true": "Deselecteer alles",
  "TableSelectionAllCheckbox.checked.false": "Selecteer alles",
  "TableSelectionAllCheckbox.help": "Selecteer of deselecteer alle rijen (inclusief de rijen die niet zichtbaar zijn in de gepagineerde lijst)",
  "TableOptionsRow.checked.true": "Deselecteer alles",
  "TableOptionsRow.checked.false": "Selecteer alles",
  "TableOptionsRow.help": "Selecteer of deselecteer alle lijnen",
  "ErrorTextZone.reload": "Herhaal de handeling",
  "ReportErrorSteps.report.title": "Er is zojuist een fout opgetreden",
  "ReportErrorSteps.report.description": "Deze fout is aan onze teams gemeld en we zullen proberen deze zo snel mogelijk te corrigeren.",
  "ReportErrorSteps.report.steps.title": "Je kunt het in volgorde proberen",
  "ReportErrorSteps.report.steps.reload": "Laad de pagina opnieuw en kijk of de fout is opgelost",
  "ReportErrorSteps.report.steps.logout": "Verbreek de verbinding en keer terug naar deze pagina nadat u opnieuw verbinding heeft gemaakt",
  "ReportErrorSteps.report.steps.contact": "Neem contact met ons op, zodat wij u zo snel mogelijk een alternatief kunnen bieden",
  "ReportErrorByMailButton.label": "Neem contact met ons op",
  "RefreshPageButton.label": "Herlaad pagina",
  "Errors.networkError": "Er zijn verbindings- of netwerkproblemen gedetecteerd. Wacht even en probeer het over een paar seconden opnieuw",
  "ShowEntityDrawer.title.show": "Zie %{determinant.defined}",
  "ShowEntityDrawer.title.listItem": "Zie informatie voor %{determinant.defined} in de zijbalk",
  "EditEntityDrawer.title.edit": "Bewerk %{determinant.defined}",
  "RightDrawerContent.close": "Sluit het rechterpaneel door op het kruisje te klikken.",
  "DropDownOptions.moreOptions": "Bekijk meer opties voor %{determinant.defined} %{name}",
  "BuildingFloorsList.title": "Navigeer door de verdiepingen",
  "RefetchEntityButton.refetch": "Gegevens opnieuw laden",
  "RefetchEntitiesButton.refetch": "Herlaad zichtbare objectgegevens",
  "RefetchObjectTypeIcon.help": "Gegevens voor %{determinant.defined} opnieuw laden",
  "ImpactButtonReload.help.single": "Berekende gegevens bijwerken voor %{determinant.defined}",
  "ImpactButtonReload.help.list": "Berekende gegevens bijwerken voor %{determinants.defined}",
  "EditInlineToggleIconButton.edit.label": "Bewerken",
  "EditInlineToggleIconButton.edit.help": "Wijzig de eigenschappen voor %{determinant.defined} rechtstreeks op deze pagina",
  "EditInlineToggleIconButton.cancel.help": "Stop met bewerken zonder op te slaan",
  "ConfirmationButtons.confirm": "Bevestig de voltooiing van de actie",
  "ConfirmationButtons.cancel": "Annuleren",
  "ConfirmationButtons.loading": "De actie wordt uitgevoerd, een ogenblik geduld",
  "EmailNotVerified.errorMessage": "Valideer uw e-mailadres ( %{email} ). Eenmaal gevalideerd kunt u de verbinding verbreken en vervolgens opnieuw verbinding maken om toegang te krijgen tot Surfy",
  "NoRoleAssociated.noRole": "Er lijkt geen rol te zijn gekoppeld aan uw gebruiker voor het bedrijf %{tenant} . Neem contact op met uw beheerder",
  "NoCompanies.title.whatIsSurfy": "Wat is Surfy?",
  "NoCompanies.NoCompanyAssigned": "Je bent aan geen enkel platform gekoppeld, je kunt surfy momenteel niet gebruiken",
  "NoCompanies.whatIsSurfy": "Surfy biedt aan om bouwplannen te digitaliseren om het beheer van de werkomgeving te vergemakkelijken.<br/> Je kunt de Surfy-app gebruiken om<ul><li> ruimtes regelen</li><li> medewerkers toewijzen</li><li> ruimtes opnieuw factureren</li><li> ruimtes analyseren</li><li> het beheren van compliance en regelgeving</li><li> ruimtes verbinden</li><li> aanwezigheidsschema's beheren</li><li> werkplekken reserveren</li></ul>",
  "NoCompanies.whatIsSurfyForTeams": "Surfy biedt aan om bouwplannen te digitaliseren om het beheer van de werkomgeving te vergemakkelijken. Je kunt de Surfy-app gebruiken om<ul><li> beheer uw aanwezigheidsschema</li><li> meld uw aanwezigheid op kantoor</li><li> reserveer een werkplek</li><li> Geef aan dat u telewerkt</li><li> bekijk welke collega's een werkplek op het abonnement hebben gereserveerd</li></ul>",
  "NoCompanies.ContactUs.text": "Log in op uw bedrijfsplatform",
  "NoCompanies.ContactUs.subject": "Toegang tot Surfy",
  "NoCompanies.ContactUs.body": "Hallo, kunt u mij toegang geven tot de Surfy-applicatie? Dankjewel.",
  "NoCompanies.accessSurfy.title": "Waarom heb ik geen toegang tot Surfy?",
  "NoCompanies.accessSurfy.alreadyUsing": "Indien uw bedrijf Surfy al gebruikt, neem dan contact op met uw werkomgevingsmanager om toegang aan te vragen of neem contact met ons op via de volgende link",
  "NoCompanies.accessSurfy.joinTenant": "Sluit u aan bij het platform van uw bedrijf",
  "NoCompanies.notUsing.title": "Maakt jouw bedrijf nog geen gebruik van Surfy?",
  "NoCompanies.knowMore": "Meer informatie over Surfy",
  "AuthenticationButton.connections.google-oauth2.label": "Googlen",
  "AuthenticationButton.connections.google-oauth2.help": "Log in met je Google account",
  "AuthenticationButton.connections.AzureADv2.label": "Office 365",
  "AuthenticationButton.connections.AzureADv2.help": "Meld u aan met uw Microsoft Professional-account via Office 365",
  "AuthenticationButton.connections.auth0.label": "Surfy-account",
  "AuthenticationButton.connections.auth0.help": "Log in met je Surfy-account",
  "Auth0AuthenticationButton.connections.auth0.label": "Surfy-account (open id)",
  "Auth0AuthenticationButton.connections.auth0.help": "Log in met je Surfy-account",
  "EnterpriseConnectionButton.label": "Onderneming",
  "EnterpriseConnectionButton.help": "Log in met uw bedrijfsaccount via speciale authenticatie zoals OKTA of DigitalP@ss",
  "EnterpriseConnectionForm.title": "Voer uw e-mailadres in, zodat wij uw bedrijf kunnen herkennen",
  "EnterpriseConnectionForm.forms.email.placeholder": "E-mail",
  "EnterpriseConnectionForm.error": "Kan uw bedrijf niet identificeren met uw e-mailadres",
  "EnterpriseConnectionForm.buttons.validate.label": "bevestigen",
  "EnterpriseConnectionForm.buttons.validate.help": "Door de e-mail te valideren, leert u uw bedrijf kennen en wordt u naar het juiste authenticatieplatform geleid",
  "EnterpriseConnectionForm.buttons.back.label": "Rug",
  "EnterpriseConnectionForm.buttons.back.help": "Keer terug naar de authenticatiepagina met alle opties",
  "LoginView.loadingPage": "De authenticatiepagina laden",
  "LoginView.connections.google-oauth2.label": "Googlen",
  "LoginView.connections.google-oauth2.help": "Log in met je Google account",
  "LoginView.connections.AzureADv2.label": "Office 365",
  "LoginView.connections.AzureADv2.help": "Meld u aan met uw Microsoft Professional-account via Office 365",
  "LoginView.connections.Username-Password-Authentication.label": "Surfy-account",
  "LoginView.connections.Username-Password-Authentication.help": "Log in met je Surfy-account",
  "LoginView.texts.title": "Verbinding",
  "LoginView.texts.description": "Toegang tot Surfy",
  "LoginView.helpers.register": "Registreer uw bedrijf bij Surfy",
  "LoginView.helpers.moreInfo": "Meer informatie over Surfy",
  "LoginView.helpers.privacy": "Privacybeleid",
  "CustomUserRegisterForm.tabs.login": "Inloggen",
  "CustomUserRegisterForm.tabs.signup": "Register",
  "CustomUserRegisterForm.form.email": "E-mail",
  "CustomUserRegisterForm.form.password": "Wachtwoord",
  "CustomUserRegisterForm.form.firstName": "Voornaam",
  "CustomUserRegisterForm.form.lastName": "Achternaam",
  "CustomUserRegisterForm.form.confirmPassword": "wachtwoordbevestiging",
  "CustomUserRegisterForm.buttons.login.label": "bevestigen",
  "CustomUserRegisterForm.buttons.login.help": "Log in als u al een account heeft",
  "CustomUserRegisterForm.buttons.signup.label": "bevestigen",
  "CustomUserRegisterForm.buttons.signup.help": "Meld je aan voor Surfy als je nog geen account hebt",
  "ReportChart.NoValue": "Geen waarde",
  "ChangeLanguage.title": "Verander de taal",
  "ChangeLanguage.help": "Wijzig de app-taal",
  "DataQualityTable.numberOfLines": "Aantal regels",
  "AllTenantsDataQualityTable.enableAllTenants.label": "Neem alle platforms op",
  "SingleNodeQuery.refetch": "Gegevens opnieuw laden",
  "ListRefetchButton.refetch": "Herlaad zichtbare objectgegevens",
  "ImpactObjectTypeIconButton.refetch": "Herlaad alle gegevens zonder rekening te houden met filters",
  "CollapseSwitchButton.help.true": "Details verbergen",
  "CollapseSwitchButton.help.false": "Zie de details",
  "menu.logout": "Afmelden",
  "menu.tenantOperations": "Synchronisatie",
  "menu.menuLeft.shoppingCart": "Mand",
  "menu.menuLeft.personCompanies": "Aanbieders",
  "menu.menuLeft.workplace": "Persoonlijke werkplekken",
  "menu.menuLeft.security": "Beveiliging",
  "menu.menuLeft.globalSecurity": "Algemene veiligheid",
  "menu.menuLeft.all": "Administratie",
  "menu.menuLeft.operations": "Activiteiten",
  "menu.menuLeft.types": "Typologieën",
  "menu.menuLeft.roomTypes": "Ruimtetypologieën",
  "menu.menuLeft.inventory": "Voorraden",
  "menu.menuLeft.people": "Mensen",
  "menu.menuLeft.spaces": "Spaties",
  "menu.menuLeft.organizations": "Organisaties",
  "menu.menuLeft.dimensions": "Analyse lagen",
  "menu.menuLeft.api": "API",
  "menu.menuLeft.authentification": "Authenticatie",
  "menu.menuLeft.globalAdmin": "Algemene administratie",
  "menu.menuLeft.human": "Medewerkers",
  "menu.menuLeft.things": "Meubilair",
  "menu.menuLeft.admin": "Administratie",
  "menu.menuLeft.surfy": "Surfen",
  "menu.menuLeft.partnerExportMapping": "Partners",
  "menu.menuLeft.personType": "Typologieën",
  "menu.menuLeft.personRelations": "Relaties",
  "menu.menuLeft.affectations": "Opdrachten",
  "menu.menuLeft.buildings": "Gebouwen",
  "menu.menuLeft.thingsType": "Typologieën",
  "menu.menuLeft.spacePoints": "Punten",
  "menu.menuLeft.adminReporting": "Rapportage",
  "menu.menuLeft.adminCostCenterReporting": "Kostenplaats",
  "menu.menuLeft.adminDimensionReporting": "Dimensies",
  "menu.menuLeft.adminRoomTypeReporting": "Soort ruimtes",
  "menu.menuLeft.adminOrganizationReporting": "Organisaties",
  "menu.menuLeft.adminRoomTypeGroupReporting": "Ruimtetypologiegroepen",
  "menu.menuLeft.buildingFacts": "Gebouwgegevens met tijdstempel",
  "menu.menuLeft.itemsFact": "Objectgegevens met tijdstempel",
  "menu.menuLeft.segments": "Segmenten",
  "menu.menuLeft.connectors": "Connectoren",
  "menu.menuLeft.planning": "Schema's",
  "menu.menuLeft.bookings": "Reserveringen",
  "menu.menuLeft.help": "Hulp",
  "menu.menuLeft.company": "Platformen",
  "ReduceMenuSwitch.open.true": "Vouw menu uit",
  "ReduceMenuSwitch.open.false": "Vouw het menu samen om te profiteren van de werkruimte",
  "LogoutMenuLink.logout": "Afmelden",
  "HelpPortalListItemLink.label": "Hulpportaal",
  "HelpPortalListItemLink.help": "Ontdek het Surfy-helpportaal met al onze tutorials en gebruikershandleidingen",
  "ChangeLogListItemLink.label": "nieuwtjes",
  "ChangeLogListItemLink.help": "Ken de nieuwe functies en veranderingen in Surfy",
  "DisplayRoomTexts.dragOption": "Houd ingedrukt en wijzig de volgorde van weergave van eigenschappen op het plan door de velden naar boven of beneden te verplaatsen",
  "DisplayRoomTexts.roomPeopleDimensions.label": "Buurt",
  "DisplayRoomTexts.roomPeopleDimensions.help": "Toon de buurt wel of niet op de kaart",
  "DisplayRoomTexts.roomSeatsCount.label": "aantal zitplaatsen",
  "DisplayRoomTexts.roomSeatsCount.help": "Toon wel of niet het aantal zitplaatsen op de kaart",
  "DisplayRoomTexts.roomCapacity.label": "Ruimtecapaciteit",
  "DisplayRoomTexts.roomCapacity.help": "Toon wel of niet de ruimtecapaciteit op het plan",
  "DisplayRoomTexts.roomCostCenter.label": "Kostenplaats",
  "DisplayRoomTexts.roomCostCenter.help": "Toon wel of niet de ruimtekostenplaats op het plan",
  "DisplayRoomTexts.roomMergedName.label": "Samengevoegde naam",
  "DisplayRoomTexts.roomMergedName.help": "Wel of niet de samengevoegde naam van de ruimte op het plan weergeven, deze naam combineert de weergavenaam en de naam van de ruimte",
  "DisplayRoomTexts.roomName.label": "Naam van de ruimte",
  "DisplayRoomTexts.roomName.help": "Toon wel of niet de naam van de ruimte op het plan",
  "DisplayRoomTexts.roomPrettyName.label": "Weergavenaam",
  "DisplayRoomTexts.roomPrettyName.help": "Toon of niet de weergavenaam van de ruimte op het plan",
  "DisplayRoomTexts.roomArea.label": "Oppervlak",
  "DisplayRoomTexts.roomArea.help": "Toon wel of niet de oppervlakte van de ruimte op de plattegrond",
  "DisplayRoomTexts.roomType.label": "Typologie van de ruimte",
  "DisplayRoomTexts.roomType.help": "Toon of niet de ruimtetypologie",
  "DisplayRoomTexts.roomPerimeter.label": "Omtrek",
  "DisplayRoomTexts.roomPerimeter.help": "Toon of niet de omtrek van de ruimte op het plan",
  "DisplayRoomTexts.roomOrganizationLevel1.label": "Dienst",
  "DisplayRoomTexts.roomOrganizationLevel1.help": "Geef de naam van de ruimtedienst wel of niet weer op het plan",
  "DisplayRoomTexts.roomOrganizationTopLevel.label": "Richting",
  "DisplayRoomTexts.roomOrganizationTopLevel.help": "Toon wel of niet de naam van de richting van de ruimte op de plattegrond",
  "DisplayRoomTexts.roomPeople.label": "Mensen toegewezen aan ruimtes",
  "DisplayRoomTexts.roomPeople.help": "Geef op het plan de namen weer van de mensen die aan deze ruimte zijn toegewezen of niet",
  "DisplayRoomTexts.roomWorkplaceAffectations.label": "Mensen die aan werkstations zijn toegewezen",
  "DisplayRoomTexts.roomWorkplaceAffectations.help": "Geef al dan niet de namen weer van de mensen die zijn toegewezen aan werkstations in deze ruimte op het plan",
  "DisplayRoomTexts.roomPeopleCount.label": "Aantal opdrachten",
  "DisplayRoomTexts.roomPeopleCount.help": "Geef op het plan het aantal mensen weer dat aan deze ruimte is toegewezen of niet",
  "DisplayRoomTexts.roomPeopleRatio.label": "Bezettingsgraad",
  "DisplayRoomTexts.roomPeopleRatio.help": "Toon wel of niet de ruimtebezettingsgraad op het plan",
  "DisplayRoomTexts.roomWorkplacesCount.label": "Aantal werkstations",
  "DisplayRoomTexts.roomWorkplacesCount.help": "Toon wel of niet het aantal werkplekken in de ruimte op het plan",
  "DisplayRoomTexts.roomWorkplacesRatio.label": "Werkstationverhouding",
  "DisplayRoomTexts.roomWorkplacesRatio.help": "Toon wel of niet de verhouding tussen werkplekken en de ruimte op het plan",
  "DisplayRoomTexts.roomOccupancyRate.label": "Bezettingsgraad",
  "DisplayRoomTexts.roomOccupancyRate.help": "Geef de bezettingsgraad van de ruimte wel of niet weer op het plan",
  "DisplayRoomTexts.roomExpansionRatio.label": "Overgroeisnelheid",
  "DisplayRoomTexts.roomExpansionRatio.help": "Toon wel of niet het uitbreidingspercentage van de ruimte op het plan",
  "DisplayRoomTexts.roomFreeWorkplacesCount.label": "Aantal vrije posities",
  "DisplayRoomTexts.roomFreeWorkplacesCount.help": "Geef het aantal vrije posities op het plan wel of niet weer",
  "DisplayRoomTexts.roomFlexWorkplacesCount.label": "Aantal flexposities",
  "DisplayRoomTexts.roomFlexWorkplacesCount.help": "Geef het aantal flexposities op het plan wel of niet weer",
  "DisplayRoomOptions.roomSeatsCount.one": "%{value} stoel",
  "DisplayRoomOptions.roomSeatsCount.more": "%{value} zetels",
  "DisplayRoomOptions.roomCapacity.one": "Capaciteit: %{value} plaats",
  "DisplayRoomOptions.roomCapacity.more": "Capaciteit: %{value} plaatsen",
  "DisplayRoomOptions.roomFreeWorkplacesCount.one": "%{value} vrije positie",
  "DisplayRoomOptions.roomFreeWorkplacesCount.more": "%{value} vrije posities",
  "DisplayRoomOptions.roomFlexWorkplacesCount.one": "%{value} flexpositie",
  "DisplayRoomOptions.roomFlexWorkplacesCount.more": "%{value} flexposities",
  "DisplayRoomOptions.roomWorkplacesCount.one": "%{value} werkstation",
  "DisplayRoomOptions.roomWorkplacesCount.more": "%{value} werkstations",
  "DisplayRoomOptions.roomPeopleCount.one": "%{value} getroffen persoon",
  "DisplayRoomOptions.roomPeopleCount.more": "%{value} mensen getroffen",
  "DisplayRoomOptions.roomOccupancyRate": "Bezetting: %{value}",
  "DisplayRoomOptions.roomExpansionRatio": "Overloop: %{value}",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.enable": "Beheer ruimteweergaveteksten",
  "WorkCanvas.Options.DisplayRoomTextsOption.label.disable": "Schermtekstbeheer sluiten",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.enable": "Hiermee kunt u voor elke ruimte de teksten configureren die op het plan worden weergegeven",
  "WorkCanvas.Options.DisplayRoomTextsOption.help.disable": "Keer terug naar de normale planbewerkingsmodus.",
  "DisplayRoomTextsDrawer.tabs.map": "Plan",
  "DisplayRoomTextsDrawer.tabs.tooltip": "Tooltip",
  "DisplayRoomTextsDrawer.tabs.base.tabs.rooms": "Spaties",
  "DisplayRoomTextsDrawer.tabs.base.tabs.people": "Mensen",
  "DisplayRoomTextsDrawer.tabs.base.people.description": "Om de eigenschappen van de mensen te definiëren die op de kaart moeten worden weergegeven, kiest u op het tabblad Ruimten de mensen die aan de ruimtes of werkstations zijn toegewezen en kiest u vervolgens de eigenschappen op dit tabblad",
  "DisplayWorkplaceTexts.workplaceName.label": "Naam van werkstation",
  "DisplayWorkplaceTexts.workplaceName.help": "Toon of niet de naam van het werkstation op het plan",
  "DisplayWorkplaceTexts.workplaceCostCenter.label": "Kostenplaats",
  "DisplayWorkplaceTexts.workplaceCostCenter.help": "Toon wel of niet de kostenplaats van de werkplek op het plan",
  "DisplayWorkplaceTexts.people.label": "Laat mensen zien",
  "DisplayWorkplaceTexts.people.help": "Toon wel of niet de mensen die op het plan aan het werkstation zijn toegewezen",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.label": "Richting",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel0.help": "Toon wel of niet de aanwijzingen van de werkplekken op het plan",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.label": "Dienst",
  "DisplayWorkplaceTexts.workplaceOrganizationLevel1.help": "Werkstationservices wel of niet weergeven in het abonnement",
  "DisplayPersonTexts.personPicture.label": "Foto van mensen",
  "DisplayPersonTexts.personPicture.help": "Geef wel of niet de foto weer van de mensen die op het plan aan de werkstations zijn toegewezen",
  "DisplayPersonTexts.personName.label": "Naam van mensen",
  "DisplayPersonTexts.personName.help": "Geef wel of niet de namen weer van mensen die zijn toegewezen aan werkstations in het plan",
  "DisplayPersonTexts.personSecurityProfile.label": "Beveiligingsprofiel",
  "DisplayPersonTexts.personSecurityProfile.help": "Geef wel of niet het beveiligingsprofiel weer van de mensen die zijn toegewezen aan de werkstations in het plan",
  "DisplayPersonTexts.personOrganizationLevel0.label": "Richting",
  "DisplayPersonTexts.personOrganizationLevel0.help": "Toon wel of niet de richting van de mensen die op het plan aan werkstations zijn toegewezen",
  "DisplayPersonTexts.personOrganizationLevel1.label": "Dienst",
  "DisplayPersonTexts.personOrganizationLevel1.help": "Toon wel of niet de service van de mensen die zijn toegewezen aan de werkstations op het plan",
  "DisplayPersonTexts.personOrganizationHierarchy.label": "Organisatiehiërarchie",
  "DisplayPersonTexts.personOrganizationHierarchy.help": "Toon wel of niet de afdeling en richting van de mensen die op het plan aan de werkplekken zijn toegewezen",
  "DisplayPersonTexts.personCostCenter.label": "Kostenplaats",
  "DisplayPersonTexts.personCostCenter.help": "Toon wel of niet de kostenplaats van de mensen die zijn toegewezen aan de werkstations in het plan",
  "DisplayPersonTexts.personCode.label": "Registratie nummer",
  "DisplayPersonTexts.personCode.help": "Wel of niet het personeelsnummer weergeven van de mensen die op het plan aan de werkstations zijn toegewezen",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.enable": "Beheer de displayteksten van het werkstation",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.label.disable": "Schermtekstbeheer sluiten",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.enable": "Hiermee kunt u voor elk werkstation de teksten configureren die op het plan worden weergegeven",
  "WorkCanvas.Options.DisplayWorkplaceTextsOption.help.disable": "Keer terug naar de normale planbewerkingsmodus.",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.enable": "Schakel transparantie van achtergrondkleuren van de ruimte in",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.label.disable": "Schakel kleurtransparantie uit",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.enable": "Door kleurtransparantie te activeren, kunt u de achtergrond door spaties heen zien",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.help.disable": "Als u kleurtransparantie uitschakelt, worden ruimtekleuren geretourneerd",
  "WorkCanvas.Options.EnableRoomColorTransparencyOption.description": "Door de transparantie van de kleuren van de ruimtes kun je de achtergrond zien",
  "WorkCanvas.Options.MapScaleOption.label.enable": "Beheer schaal",
  "WorkCanvas.Options.MapScaleOption.label.disable": "Schaal sluiten",
  "WorkCanvas.Options.MapScaleOption.help.enable": "Verplicht configureer de schaal op uw plan om de ruimtes en objecten op de juiste schaal te hebben",
  "WorkCanvas.Options.MapScaleOption.help.disable": "Keer terug naar de normale planbewerkingsmodus.",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.label": "Schaal verwijderen",
  "WorkCanvas.Options.MapScaleOption.buttons.delete.help": "Het verwijderen van de schaal komt neer op het verwijderen van de schaal uit de plattegrond en deze verwijderen van de basis, deze zal niet meer toegankelijk zijn via andere plannen. Het is niet mogelijk om een ​​schaal te verwijderen die zich op meerdere verdiepingen bevindt.",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.label": "Degroepeer schaal",
  "WorkCanvas.Options.MapScaleOption.buttons.unlink.help": "Als u de weegschaal ontkoppelt van dit plan, wordt deze uit het plan verwijderd, maar blijft de weegschaal in de database staan ​​voor toekomstig gebruik",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.label": "Zoom in op de schaal",
  "WorkCanvas.Options.MapScaleOption.buttons.zoom.help": "Door te zoomen kunt u gemakkelijk de schaal op de plattegrond vinden.",
  "WorkCanvas.Options.DrawMapScaleOption.help": "U moet de weegschaal op uw plan configureren, op het begin en einde van de weegschaal op het plan klikken om deze te kalibreren",
  "ToggleCopilotEnable.label.false": "Activeer Surfy Copilot",
  "ToggleCopilotEnable.label.true": "Schakel Surfy Copilot uit",
  "ToggleCopilotEnable.help.false": "Activeer Surfy Copilot om automatische deurherkenning in te schakelen",
  "ToggleCopilotEnable.help.true": "Schakel Surfy Copilot uit en ga terug naar handmatige modellering",
  "WorkCanvas.Options.CopilotOption.label.enable": "Surfy copiloot",
  "WorkCanvas.Options.CopilotOption.label.disable": "Sluit de Surfy Copilot-opties ",
  "WorkCanvas.Options.CopilotOption.help.enable": "Activeer en pas de Surfy Copilot-opties aan",
  "WorkCanvas.Options.CopilotOption.help.disable": "Keer terug naar de normale planmodus.",
  "WorkCanvas.Options.AddRoomShapeOption.label.enable": "Voeg een spatie toe",
  "WorkCanvas.Options.AddRoomShapeOption.label.disable": "Het toevoegen van een spatie ongedaan maken",
  "WorkCanvas.Options.AddRoomShapeOption.help.enable": "Voeg ruimte toe aan het plan",
  "WorkCanvas.Options.AddRoomShapeOption.help.disable": "Maak het maken van ruimte ongedaan",
  "WorkCanvas.Options.AddRoomShapeOption.description": "De creatiehoeken zijn geblokkeerd op 45°. Om ze te ontgrendelen, houdt u de <b>SHIFT-</b> toetsenbordtoets ingedrukt en gaat u door met creëren. Om uw hoekpunt te creëren, plaatst u de muis in de cirkel op het snijpunt van de driehoek. Om een ​​spatie te starten door een bestaand hoekpunt te hergebruiken, houdt u ingedrukt Houd de <b>ALT-</b> toetsenbordtoets ingedrukt en klik op het hoekpunt.",
  "WorkCanvas.Options.AddRoomShapeSaveOption.label": "Sla de ruimte op die momenteel wordt gemodelleerd",
  "WorkCanvas.Options.AddRoomShapeSaveOption.help": "Ruimte besparen sluit de ruimte automatisch en slaat deze op, zodat u er objecten of werkstations aan kunt toevoegen",
  "WorkCanvas.Options.ViewLegendOption.label.enable": "Voorbeeldlegenda",
  "WorkCanvas.Options.ViewLegendOption.label.disable": "Sluit het bijschrift voor het opslaan van het plan",
  "WorkCanvas.Options.ViewLegendOption.help.enable": "Kijk waar het gedeelte met de kaartlegenda voor bedoeld is",
  "WorkCanvas.Options.ViewLegendOption.help.disable": "Keer terug naar de normale planmodus.",
  "DownloadImageQualitySlider.label": "Kwaliteit van de geëxporteerde afbeelding",
  "DownloadImagePdfButton.label": "Download het plan zonder legenda (PDF)",
  "DownloadImagePdfButton.help": "Download het plan in PDF zonder legenda, deze functionaliteit is in bèta",
  "WorkCanvas.Options.DownloadImageOption.label.enable": "Opslaan als afbeelding",
  "WorkCanvas.Options.DownloadImageOption.label.disable": "Sluit de opslagopties voor planafbeeldingen",
  "WorkCanvas.Options.DownloadImageOption.help.enable": "Sla het plan op als afbeelding met deze optie",
  "WorkCanvas.Options.DownloadImageOption.help.disable": "Keer terug naar de normale planmodus.",
  "DownloadImageDrawer.ViewImage.text": "Download het plan met legenda (PNG)",
  "DownloadImageDrawer.ViewImage.help": "Download het gehele plan in goede kwaliteit met de legenda, de export kan langer duren.",
  "DownloadImageDrawer.ViewImageNoLegend.text": "Download het plan zonder legenda (PNG)",
  "DownloadImageDrawer.ViewImageNoLegend.help": "Download het volledige plan in goede kwaliteit zonder de legenda, de export kan langer duren.",
  "DownloadImageDrawer.ScreenshotNoLegend.text": "Screenshot zonder onderschrift",
  "DownloadImageDrawer.ScreenshotNoLegend.help": "Download de afbeelding van wat u op het scherm ziet zonder bijschrift. De uitvoer zal snel zijn, maar de kwaliteit van de export zal niet optimaal zijn",
  "DownloadBuildingImagesAccordion.accordion.title": "Exporteer afbeeldingen van het hele gebouw",
  "DownloadBuildingImagesAccordion.buttons.download.help": "Download alle plattegronden van alle verdiepingen van het gebouw in png-formaat in een zip, de wachttijd voor deze uittreksel kan lang zijn",
  "DownloadBuildingImagesAccordion.buttons.download.label": "Download de ZIP",
  "DisplayTexts.dragOption": "U kunt de weergave van eigenschappen op het plan sorteren en kiezen door de kleine balken op de velden naar boven of beneden te verplaatsen",
  "DisplayRoomTextsPeople.roomPeopleFullName.label": "Volledige naam van mensen",
  "DisplayRoomTextsPeople.roomPeopleFullName.help": "Toon of niet de volledige naam van de persoon op de kaart",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.label": "Beveiligingsprofiel",
  "DisplayRoomTextsPeople.roomPeopleSecurityProfile.help": "Geef al dan niet het beveiligingsprofiel weer van de mensen die aan de ruimtes in het plan zijn toegewezen",
  "NumberOfPeoplePerRowField.label": "Aantal personen per lijn voor ruimtetoewijzingen",
  "WorkCanvas.Options.BackgroundLayoutOption.label.enable": "Beheer de achtergrond",
  "WorkCanvas.Options.BackgroundLayoutOption.label.disable": "Sluit het beheer van achtergrondafbeeldingen",
  "WorkCanvas.Options.BackgroundLayoutOption.help.enable": "Hiermee kunt u de achtergrond beheren",
  "WorkCanvas.Options.BackgroundLayoutOption.help.disable": "Keer terug naar de normale planbewerkingsmodus.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.label": "Schaal verwijderen",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.delete.help": "Het verwijderen van de schaal komt neer op het verwijderen van de schaal uit de plattegrond en deze verwijderen van de basis, deze zal niet meer toegankelijk zijn via andere plannen. Het is niet mogelijk om een ​​schaal te verwijderen die zich op meerdere verdiepingen bevindt.",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.label": "Degroepeer schaal",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.unlink.help": "Als u de weegschaal ontkoppelt van dit plan, wordt deze uit het plan verwijderd, maar blijft de weegschaal in de database staan ​​voor toekomstig gebruik",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.label": "Zoom in op de schaal",
  "WorkCanvas.Options.BackgroundLayoutOption.buttons.zoom.help": "Door te zoomen kunt u gemakkelijk de schaal op de plattegrond vinden.",
  "WorkplaceCanvasItem.workplace.free": "De werkplek is niet bezet",
  "WorkplaceCanvasItem.workplace.isFlex": "De werkplek is in flex",
  "WorkplaceCanvasItem.workplace.isTransit": "Het werkstation passeert",
  "WorkplaceCanvasItem.workplace.isBookable": "De werkplek is te reserveren",
  "WrongRoomsTable.table.headers.objectType": "Natuur",
  "WrongRoomsTable.table.headers.type": "Vriendelijk",
  "WrongRoomsTable.table.headers.identity": "Identificeren",
  "WrongRoomsTable.table.headers.currentRoom": "Huidige ruimte",
  "WrongRoomsTable.table.headers.newRoom": "Nieuwe ruimte",
  "WrongRoomsTable.SelectAll.checked.true": "Deselecteer alles",
  "WrongRoomsTable.SelectAll.checked.false": "Selecteer alles",
  "WrongRoomsTable.SelectAll.help": "Selecteer of deselecteer alle lijnen",
  "WrongRoomsListner.dialog.title": "Valideer de keuze van de ruimtes",
  "WrongRoomsListner.dialog.description": "Er zijn vormen die zich niet in hun startvak bevinden",
  "WrongRoomsListner.close.label": "sluiten",
  "WrongRoomsListner.close.help": "sluit dit venster",
  "MoveShapestoNewRoomAsyncButton.label": "Pas ruimteverandering toe",
  "MoveShapestoNewRoomAsyncButton.help": "Wijzig de ruimtes van de geselecteerde vormen om ze in de ruimtes te plaatsen waarin ze zich in het vlak bevinden",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.enable": "Objecttype verplaatsen",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.label.disable": "Stop met het verplaatsen van het objecttype",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.enable": "Verplaats een type object op het plan",
  "WorkCanvas.Options.ToggleMoveItemTypeOption.help.disable": "Stop met het verplaatsen van het objecttype",
  "ResetRotationAngle.resetRotationAngle": "Reset de rotatiehoek naar 0°, momenteel %{initialRotation}",
  "TenantOperations.sephora-sync-sap-success-factors.label": "MSC-synchronisatie",
  "TenantOperations.st-grenoble-import-hr-file.label": "Het RH-bestand importeren",
  "TenantOperations.egis-import-hr-file.label": "HR-bestand importeren",
  "TenantOperations.essilor-import-hr-file.label": "HR-bestand importeren",
  "TenantOperations.agpm-import-hr-file.label": "Importeren van het HR-bestand (STILOG)",
  "ConnectedPartnerContext.title": "U bent verbonden met <b>%{label}</b> ( %{host} )",
  "Operations.talentsoft-import.label": "Talentsoft importeren",
  "Operations.zbre-sync.label": "Z#bre-synchronisatie",
  "Operations.exportZbre.label": "Exporteer Z#bre",
  "GenericNoChangeTable.open.label": "Bekijk de gegevens",
  "GenericNoChangeTable.open.help": "Bekijk details van identieke gegevens",
  "Operations.sharingcloud-sync.label": "Sharingcloud-synchronisatie",
  "Operations.moffi-sync.label": "Moffi-synchronisatie",
  "Operations.lucca-sync.label": "Lucca synchronisatie",
  "CompareObjectTypeUpdateIcon.help": "Deze synchronisatie zal de entiteiten bijwerken",
  "CompareObjectTypeDeleteIcon.help": "Deze synchronisatie verwijdert entiteiten die niet afkomstig zijn van de bron",
  "CompareObjectTypeCreateIcon.help": "Door deze synchronisatie worden entiteiten gemaakt die niet in het doel bestaan",
  "RoomTooltip.roomWorkplaceAffectations": "Werkstationopdrachten",
  "RoomSegmentRoomsList.title": "De ruimtes die aan dit segment zijn gekoppeld",
  "MeetingRoomCard.seats.1": "%{count} stoel",
  "MeetingRoomCard.seats.n": "%{count}",
  "MeetingRoomCard.locateSpace": "Zoek de ruimte op het plan",
  "MeetingRoomCard.viewPicture": "Zie ruimtefoto",
  "days.monday": "Maandag",
  "days.tuesday": "Dinsdag",
  "days.wednesday": "Woensdag",
  "days.thursday": "DONDERDAG",
  "days.friday": "Vrijdag",
  "days.saturday": "ZATERDAG",
  "days.sunday": "Zondag",
  "WorkplaceAffectationDailyTitle.all": "Deze persoon wordt elke dag getroffen",
  "WorkplaceAffectationDailyTitle.person.affected": "Deze persoon is %{daysText} toegewezen",
  "WorkplaceAffectationDailyTitle.person.notAffected": "Deze persoon wordt niet beïnvloed ",
  "WorkplaceAffectationDailyTitle.calculatedRate": "Het gemiddelde toewijzingspercentage is %{calculatedRate}",
  "WorkplaceNestedList.title": "Mensen die aan werkstations zijn toegewezen",
  "WorkplaceList.workplace.free": "Dit werkstation is gratis",
  "WorkplaceList.workplace.flex": "Deze werkplek is flex",
  "WorkplaceList.workplace.transit": "Dit werkstation wordt gedeeld",
  "WorkplaceList.zoomOnWorkplace": "Zoom in op de werkplek op de plattegrond",
  "WorkplaceAffectionPersonListItem.remove.help": "Verwijder de toewijzing van de persoon aan het werkstation",
  "WorkplaceAffectations.edit.help": "Wijs een persoon toe aan dit werkstation",
  "WorkplaceAffectationDays.all": "Deze persoon wordt elke dag getroffen",
  "WorkplaceAffectationDays.and": "de %{days} en %{lastDay}",
  "WorkplaceAffectationDays.one": "op %{day}",
  "WorkplaceAffectationDays.person.affected": "Deze persoon is %{daysText} toegewezen",
  "WorkplaceAffectationDays.person.notAffected": "Deze persoon wordt niet beïnvloed ",
  "RoomWorkplaceList.EmptyList": "In deze ruimte zijn geen werkplekken aanwezig",
  "RoomCard.buttons.edit.false": "Ruimte-eigenschappen bewerken",
  "RoomCard.buttons.edit.true": "Stop met bewerken",
  "RoomCard.tabs.people": "Opdrachten",
  "RoomCard.tabs.inventory": "Inventaris",
  "RoomCard.tabs.room": "Ruimte",
  "RoomAffectationsOnlyList.title": "Mensen toegewezen aan ruimtes",
  "RoomAffectationsList.title": "Mensen toegewezen aan ruimtes",
  "RoomAffectationsList.EmptyList": "Er is niemand toegewezen aan deze ruimte",
  "ItemsInventory.EmptyList": "Er bevinden zich geen objecten in deze ruimte",
  "MovePersonFromWorkplaceToRoomListButtonItem.label": "Verplaats deze persoon van zijn/haar werkplek naar de werkplekruimte",
  "MovePersonFromWorkplaceToRoomListButtonItem.help": "Deze optie vereist het vernieuwen van de pagina om het resultaat te zien. Het is mogelijk om meerdere bewegingen aan elkaar te koppelen zonder te vernieuwen",
  "CollapseWorkplaceAffectationList.title": "Wijs deze persoon alleen toe voor de volgende dagen",
  "CollapseWorkplaceAffectationList.updateAffectationDay.true": "Wijs deze persoon toe %{day}",
  "CollapseWorkplaceAffectationList.updateAffectationDay.false": "Verwijder de opdracht van deze persoon %{day}",
  "CancelAddWorkplaceToRoom.help": "Het toevoegen van een werkstation ongedaan maken",
  "CancelAddItemToRoom.help": "Maak het toevoegen van het object ongedaan",
  "AddPersonToRoom.help": "Wijs een persoon toe aan ruimte %{name}",
  "SecurityComplianceModeSwitch.label": "Filter mensen met beveiligingsprofielen",
  "SecurityComplianceModeSwitch.description": "Zie alleen mensen met beveiligingsprofielen op de kaart",
  "layoutViewSets.roomType.label": "Ruimtetypologieën",
  "layoutViewSets.roomType.description": "Zie de plattegrond volgens de typologie van ruimtes",
  "layoutViewSets.costCenter.label": "Opnieuw factureren",
  "layoutViewSets.costCenter.description": "Analyseer de sleutels tot de financiële verdeling van ruimtes",
  "layoutViewSets.workplaces.label": "Beroepen",
  "layoutViewSets.workplaces.description": "Focus op het bezetten van werkplekken",
  "layoutViewSets.organizationLevel0.label": "Routebeschrijving",
  "layoutViewSets.organizationLevel0.description": "Bezetting per richting",
  "layoutViewSets.flex.label": "Buigen",
  "layoutViewSets.flex.description": "Flexbezetting van ruimtes",
  "layoutViewSets.walls.label": "Partities",
  "layoutViewSets.walls.description": "Focus op ruimtes en scheidingswanden",
  "layoutViewSets.securityCompliance.label": "Beveiligingsnaleving",
  "layoutViewSets.securityCompliance.description": "Analyseer de naleving van uw beveiligingspreventieplan en de beveiligingsprofielen van de getroffen mensen",
  "layoutViewSets.peopleDimensionTypes.label": "Buurten",
  "layoutViewSets.peopleDimensionTypes.description": "Analyseer opdrachtlagen en navigeer per buurt of zone",
  "LayoutViewSwitch.title": "Verander de visie op het plan",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.viewSet": "Visie",
  "CustomEntityBreadcrumbWorkCanvasLayoutViewLabel.help": "Via de planmenu's kunt u de visie wijzigen",
  "SurfyLegendBottomLogo.text": "Kaart gegenereerd door Surfy",
  "SurfyLegendBottomLogo.caption": "https://www.surfy.pro",
  "MapLegendWorkplace.title": "Werkplek",
  "MapLegendWorkplace.workplaces.free": "Werkstations zijn gratis",
  "MapLegendWorkplace.workplaces.flex": "De werkplekken zijn flex",
  "MapLegendRoom.title": "Spaties",
  "MapLegendPersonSecurityProfile.title": "Beveiligingsprofielen",
  "MapLegendFloor.title.building": "Gebouw",
  "MapLegendFloor.title.floor": "Vloer",
  "MapLegend.workplaces": "Persoonlijke werkplekken",
  "MapLegend.rooms": "Spaties",
  "PersonSecurityProfileTabContent.tabs.merged": "Via beveiligingsprofielen",
  "PersonSecurityProfileTabContent.tabs.split": "Door opdrachten",
  "DimensionInfo.infos.building": "Berekende gebouwinformatie",
  "DimensionInfo.infos.impactBuildings": "Berekende gebouwgegevens opnieuw laden",
  "DimensionToPeopleList.title": "Mensen toegewezen aan %{name}",
  "DimensionToPeopleList.noDimensionPerson": "Er is niemand rechtstreeks aan deze analyselaag toegewezen",
  "DimensionPeople.title": "Mensen toegewezen aan ruimtes",
  "AddPersonToDimension.help": "Wijs iemand toe aan %{name}",
  "CubyWallModeSelect.label": "Weergave van partities",
  "CubyWallModeSelect.options.no": "Geen",
  "CubyWallModeSelect.options.half": "Halve scheidingswanden",
  "CubyWallModeSelect.options.reality": "Realiteit",
  "CubyWallModeSelect.options.cuby": "Kubus",
  "CubySaveAsImageButton.label": "Afbeelding opslaan",
  "CubySaveAsImageButton.help": "Afbeelding van de plattegrond opslaan",
  "CubyFitToViewIsometricButtonOption.label": "Centreer het plan in isometrisch aanzicht",
  "CubyFitToViewIsometricButtonOption.help": "Centreer de plattegrond op de ruimtes in isometrisch aanzicht",
  "CubyFitToViewZenithalButtonOption.label": "Centreer het plan in zenitaanzicht",
  "CubyFitToViewZenithalButtonOption.help": "Centreer de plattegrond op de ruimtes in zenitaanzicht",
  "RefetchFloorLayoutButton.refetch": "Plangegevens opnieuw laden",
  "ItemTypesMapFilterZone.tabs.options": "Opties",
  "FloorMap.tabs.layout": "Verander de visie op het plan. De huidige weergave is <b>%{layoutName}</b>",
  "FloorMap.tabs.floor": "Bekijk verdiepingsinformatie",
  "FloorMap.tabs.building": "Bekijk gebouwinformatie",
  "FloorMap.tabs.roomTypes": "Kleur de ruimtes op de plattegrond volgens de <b>ruimtetypologieën</b>",
  "FloorMap.tabs.roomTypeGroups": "Zie de ruimte-indicatoren op het plan volgens de <b>groepen ruimtetypologieën</b>",
  "FloorMap.tabs.analyticsDimensionTypes": "Kleur de ruimtes op het plan volgens de <b>analyselagen</b>",
  "FloorMap.tabs.itemTypes": "Geef <b>objecten</b> op de kaart weer per objectfamilie en type",
  "FloorMap.tabs.workplaceTypes": "Geef <b>werkstations</b> per werkstationtype weer op de kaart",
  "FloorMap.tabs.organizations": "Kleur de ruimtes op het plan volgens de <b>organisaties</b>",
  "FloorMap.tabs.costCenters": "Kleurruimtes en werkplekken in relatie tot <b>kostenplaatsen</b>",
  "FloorMap.tabs.users": "Kleurwerkplekken in relatie tot mensen",
  "FloorMap.tabs.selection": "Bekijk de details van de geselecteerde elementen op het plan",
  "FloorMap.tabs.rooms": "Details van geselecteerde <b>ruimtes</b>",
  "FloorMap.tabs.items": "Details van geselecteerde <b>objecten</b>",
  "FloorMap.tabs.workplaces": "Details van geselecteerde <b>werkstations</b>",
  "FloorMap.tabs.all": "Bekijk alle geselecteerde vormen in de lijst",
  "FloorMap.tabs.peopleDimensionTypes": "Kleur de ruimtes op de plattegrond volgens de <b>opdrachtlagen</b>",
  "FloorMap.tabs.workplaceUsage": "Kleur werkstations volgens hun <b>staat</b>",
  "FloorMap.tabs.options": "Bekijk abonnementsopties",
  "FloorMap.tabs.heatmap": "Kleuren met hittekaarten",
  "FloorMap.tabs.pathFinding": "Je weg vinden in ruimtes",
  "DateDimensionSelect.options.day": "Dag",
  "DateDimensionSelect.options.week": "Week",
  "DateDimensionSelect.options.month": "Maand",
  "DateDimensionSelect.options.year": "Jaar",
  "DateDimensionSelect.options.quarter": "Kwartaal",
  "JupDateRangePicker.chooseRange": "Kies een periode",
  "WorkpaceBookingPeopleCountByDate.title": "Aantal geboekte personen op datum",
  "WorkpaceBookingPeopleCountByDate.labels.line": "Aantal mensen",
  "WorkpaceBookingCountByDate.title": "Werkplekreserveringen op datum",
  "WorkpaceBookingCountByDate.labels.line": "Aantal reserveringen",
  "WorkpaceBookingAverageByWeekDay.title": "Reservering van werkplekken per dag van de week",
  "WorkpaceBookingAverageByWeekDay.labels.line": "Gemiddeld per week",
  "WorkpaceBookingAverageByWeekDay.labels.bar": "Aantal reserveringen",
  "PersonPanelWorkplaceAffectations.title": "Werkstationopdrachten",
  "PersonPanelRoomAffectations.title": "Ruimte opdrachten",
  "PersonPanelDimensionToPeople.title": "Toewijzingen aan %{dimensionTypeName}",
  "PersonPanelBuildingAffectations.title": "Bouwopdrachten",
  "PersonPanelBuildingAffectations.addToPeopleCount.false": "Deze persoon is geen accountant in het gebouw",
  "PersonAffectationsPanel.title": "Opdrachten",
  "PersonAffectationsPanel.description": "De opdrachten van de persoon",
  "PersonSecurityPanel.title": "Beveiliging",
  "PersonSecurityPanel.description": "Veiligheids- en evacuatie-informatie",
  "PersonRelationsPanel.title": "Relaties",
  "PersonRelationsPanel.description": "De relaties van deze persoon",
  "PersonInventoryPanel.title": "Inventaris",
  "PersonInventoryPanel.description": "Voorraadinformatie",
  "PersonInventoryPanel.items.subheader": "Lijst met bijbehorende objecten",
  "PersonInfoPanel.title": "Persoonlijke informatie",
  "PersonContractPanel.title": "CONTRACT",
  "PersonContractPanel.description": "Contractinformatie",
  "PersonContactPanel.title": "Contact",
  "PersonContactPanel.description": "Hoe kunt u contact opnemen met deze persoon?",
  "PersonBadgePanel.title": "Gemengd",
  "PersonBadgePanel.description": "Diverse informatie over de persoon",
  "AvatarPersonDrawer.help": "Bekijk meer informatie over %{name}",
  "TopLevelOrganizationFilter.Empty": "Er is geen organisatie gekoppeld aan ruimtes. U kunt meer toevoegen door een ruimte te wijzigen en deze aan een organisatie te koppelen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "OrganizationTabsFilter.tabs.topLevel": "Routebeschrijving",
  "OrganizationTabsFilter.tabs.hierarchy": "Hiërarchie",
  "OrganizationTabsFilter.tabs.level1": "Diensten",
  "OrganizationFloorMapFilter.TooltipTitle.notSelected": "Selecteer %{organization} om de ruimtes op het plan te kleuren",
  "OrganizationFloorMapFilter.TooltipTitle.selected": "Als u %{organization} deselecteert, worden de kleuren uit het vlak verwijderd",
  "OrganizationFloorMapFilter.tooltip.true": "Selecteer hieronder alle objecttypen om ze op de kaart in te kleuren",
  "OrganizationFloorMapFilter.tooltip.false": "Deselecteer hieronder alle organisaties",
  "Level1OrganizationFilter.Empty": "Er is geen organisatie gekoppeld aan ruimtes. U kunt er meer toevoegen door een ruimte te wijzigen en deze aan een organisatie te koppelen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "HierarchyOrganizationFilter.Empty": "Er is geen organisatie gekoppeld aan ruimtes. U kunt meer toevoegen door een ruimte te wijzigen en deze aan een organisatie te koppelen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "CompanyDashboard.dashboards.workplace": "Werkstationdashboard",
  "CompanyDashboard.dashboards.area": "Dashboard voor oppervlakken",
  "ChangeCompanyMenu.ChangeCompany": "Bekijk een ander bedrijf op een nieuwe pagina",
  "WorkplaceTypeDataQualityNotUsed.columns.name": "Naam van het werkstationtype",
  "WorkplaceTypeDataQualityNotUsed.columns.shape": "Vorm",
  "workplaceTypeLayoutFilter.Empty": "Er zijn momenteel geen werkstations in ruimtes. U kunt er meer toevoegen door een ruimte te wijzigen en er werkstations aan toe te voegen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "WorkplaceTypeInfo.help": "Het aantal werkstations is %{count}",
  "CopyWorkplaceTypeToCart.help": "Kopieer werkstationtypen naar winkelwagen",
  "WorkCanvas.Options.ZoomOnWorkplaceType.label": "Zoom in op het type werkplek",
  "WorkCanvas.Options.ZoomOnWorkplaceType.help": "Door in te zoomen op het type werkplek kunt u deze in het werkgebied lokaliseren",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.enable": "Lijst met objecttypen",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.label.disable": "Sluit de lijst met objecttypen",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.enable": "Zie de lijst met objecttypen voor dit type werkstation",
  "WorkCanvas.Options.WorkplaceTypeItemTypesOption.help.disable": "Sluit de lijst met objecttypen voor dit werkstationtype",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.open": "Vouw opties uit",
  "WorkplaceTypeItemTypesDrawerSortableItem.info.close": "Opties samenvouwen",
  "WorkplaceTypeItemTypesDrawer.title": "Lijst met objecttypen",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.help": "Voeg een objecttype toe om het werkplektype te kunnen samenstellen",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeOption.label": "Voeg een objecttype toe",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.help": "Maak het toevoegen van een objecttype aan dit werkstation ongedaan",
  "WorkCanvas.Options.AddItemTypeToWorkplaceTypeCancelOption.label": "Het toevoegen van een objecttype ongedaan maken",
  "WorkCanvas.Options.DeleteStructureShapeOption.help": "Verwijder de vorm van de machtsstructuur volledig, teken deze bijvoorbeeld volledig opnieuw",
  "WorkCanvas.Options.DeleteStructureShapeOption.label": "Vorm verwijderen",
  "WorkCanvas.Options.AddStructurePointOption.label.enable": "Voeg een hoekpunt toe",
  "WorkCanvas.Options.AddStructurePointOption.label.disable": "Stop met het toevoegen van een hoekpunt",
  "WorkCanvas.Options.AddStructurePointOption.help.enable": "Door een hoekpunt toe te voegen, kunt u een vorm nauwkeuriger bewerken",
  "WorkCanvas.Options.AddStructurePointOption.help.disable": "Stop met het maken van hoekpunten",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloorButton.label": "Reserveer een werkstation op %{floorName}",
  "BookPersonBuildingWorkplace.bookWorkplaceOnFloor": "Reserveer een werkplek op %{floorName} voor de periode %{slotString}",
  "BookPersonBuildingWorkplace.availableWorkplaces": "%{freeWorkplaces} plaatsen beschikbaar",
  "BookPersonBuildingWorkplace.help": "%{bookedWorkplaces} reservering(en), %{freeWorkplaces} werkstations beschikbaar op %{totalFloorWorkplacesCount}",
  "booking.snackbar.delete.workplace": "De reservering op werkstation %{workplaceName} is geannuleerd voor de periode %{slot}",
  "booking.snackbar.delete.room": "De reservering bij ruimte %{roomName} is geannuleerd voor de periode %{slot}",
  "BookingWorkplaceTitle.booked": "Deze werkplek is al gereserveerd",
  "BookingWorkplaceTitle.userBooked": "U heeft deze werkplek gereserveerd",
  "BookingWorkplaceTitle.free": "Reserveer deze werkplek",
  "PlanningPersonAffectations.alerts.noAffectation.title": "Kan geen werkplek reserveren",
  "PlanningPersonAffectations.alerts.noAffectation.message": "U bent aan geen enkel gebied gekoppeld. Neem contact op met uw opdrachtmanager om een ​​werkruimte te kunnen reserveren",
  "WorkingLocationToggle.locations.OFFICE": "Bureau",
  "WorkingLocationToggle.locations.REMOTE": "Telewerk",
  "PersonBookingListItem.workplaceBookedOnFloor": "Zie werkplek %{workplaceName} op de plattegrond %{floorName}",
  "PersonBookingList.noBooking": "Er zal voorlopig geen collega op hetzelfde slot op kantoor aanwezig zijn",
  "PersonBookingList.bookings.one": "Op hetzelfde slot zal een collega aanwezig zijn",
  "PersonBookingList.bookings.more": "%{count} collega's zullen op hetzelfde tijdstip aanwezig zijn",
  "ParkingBookIcon.parking.booked": "Uw parkeerplaats is gereserveerd",
  "ParkingBookIcon.parking.release.help": "Parkeerreservering vrijgeven",
  "ParkingBookIcon.parking.viewOnMap": "Zie gereserveerde parkeerplaats op de kaart",
  "ParkingBookIcon.parking.book.label": "Parkeerplaats reserveren",
  "ParkingBookIcon.parking.book.help": "Reserveer een parkeerplaats die automatisch aan het slot wordt toegewezen",
  "HalfDayWorkingLocationToggle.am.label": "Ochtend",
  "HalfDayWorkingLocationToggle.am.help": "De ochtenduren zijn van 8.00 uur tot 13.30 uur.",
  "HalfDayWorkingLocationToggle.pm.label": "Middag",
  "HalfDayWorkingLocationToggle.pm.help": "De middaguren zijn van 14.00 uur.",
  "DirectBuildingPlanningLabel.youAreAssigned": "Je bent toegewezen aan gebouw %{buildingName}",
  "DimensionBuildingPlanningLabel.youAreAssigned": "U bent toegewezen aan %{dimensionTypeName} %{dimensionName}",
  "BookedBuildingWorkplaceList.noWorkplaceBooked": "Geen gereserveerde werkplek",
  "BookedBuildingWorkplaceList.workplaceIsBooked": "Uw werkplek is gereserveerd",
  "BookedBuildingWorkplaceList.viewBookedWorkplaceOnMap": "Bekijk het werkstation %{workplaceName} dat is gereserveerd in het abonnement",
  "BookedBuildingWorkplaceList.freeWorkplaceBooking": "Geef deze reservering vrij",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.noFloor": "De grootte is op geen enkele verdieping onmogelijk te boeken op dit moment vanuit het plan",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.errors.moreThanOneFloor": "De grootte is op verschillende verdiepingen onmogelijk te reserveren op dit moment sinds het plan",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.drawer.title": "Reserveer een specifiek werkstation voor de periode %{slotString}",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.help": "Reserveer een specifiek werkstation volgens het abonnement voor dit slot",
  "BookWorkplaceOnDimensionWithSlotOpenDrawerButton.button.label": "Reserveer een werkstation in %{dimensionName}",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.peopleCount": "Er zijn %{count} perso(o)n(en) met beveiligingsprofiel %{name} toegewezen aan de werkstations",
  "PersonSecurityProfileWorkplaceInfo.nodeInfo.workplaceCount": "Er zijn %{count} werkstation(s) met minstens één persoon met %{name} beveiligingsprofiel",
  "PersonSecurityProfileWorkplaceFilter.Empty": "Uw mensen hebben geen beveiligingsprofielen of zijn niet toegewezen aan werkstations, het is niet mogelijk om werkstations in te kleuren op basis van de beveiligingsprofielen van mensen",
  "PersonSecurityProfileWorkplaceFilter.title": "Beveiligingsprofielen van mensen die aan werkstations zijn toegewezen",
  "PersonSecurityProfileMerged.title": "Lijst met beveiligingsprofielen gegroepeerd op profieltype",
  "PersonSecurityProfileMerged.empty": "Er is geen profiel gekoppeld aan ruimtes of werkstations",
  "PersonSecurityProfileInRooms.title": "De beveiligingsprofielen van de mensen die aan de ruimtes zijn toegewezen",
  "PersonSecurityProfileInRoomListItem.peopleCount": "Er zijn %{count} persoon(en) met beveiligingsprofiel %{name} toegewezen aan ruimtes",
  "PersonSecurityProfileInRoomListItem.roomsCount": "Er zijn %{count} ruimte(s) met minstens één persoon met beveiligingsprofiel %{name}",
  "ToggleAllOpenInfoState.true": "Sluit alle details en indicatoren",
  "ToggleAllOpenInfoState.false": "Open alle details en indicatoren",
  "MapFiltersNodesToggleAll.help.true": "Selecteer alles",
  "MapFiltersNodesToggleAll.help.false": "deselecteer alles",
  "MapFiltersNode.info.open": "Bekijk details en indicatoren voor %{label}",
  "MapFiltersNode.info.close": "Sluit aanvullende informatie",
  "MapFiltersCategory.CategoryHasChildrenSelected": "Artikelen zijn geselecteerd",
  "MapFilterNodeToggleAll.action.true": "Selecteer alles",
  "MapFilterNodeToggleAll.action.false": "deselecteer alles",
  "MapFilterNodeIsAllSelected.help": "De gehele selectie hieronder wordt geladen, zelfs als er nieuwe objecten worden aangemaakt",
  "JupRoleToObjectTypeMatrix.views.help.true": "Interfaceweergave verbergen",
  "JupRoleToObjectTypeMatrix.views.help.false": "Interfaceweergave tonen",
  "JupRoleToObjectTypeMatrix.objectTypes.help.checkbox": "Eigenschap bijwerken ( %{name} )",
  "GlobalOptions.CartCopyItemTypeOption.help": "Kopieer itemtypen naar winkelwagen",
  "GlobalOptions.CartCopyWorkplaceTypeOption.help": "Kopieer werkstationtypen naar winkelwagen",
  "GlobalOptions.CartCopyBuildingOption.help": "Kopieer gebouwen naar winkelwagen",
  "CheckAllDefaultViews.shortcuts.title": "Configuratiesnelkoppelingen",
  "CheckAllDefaultViews.shortcuts.views.title": "Snelkoppelingen voor standaardinterfaceweergaven",
  "CheckAllDefaultViews.shortcuts.views.buttonsHelp": "Controleer deze weergave voor alle entiteitstypen",
  "CheckAllDefaultViews.shortcuts.objectTypes.title": "Snelkoppelingen voor entiteitstypen",
  "CheckAllDefaultViews.shortcuts.objectTypes.buttonsHelp": "Controleer deze regel voor alle objecttypen",
  "RemoveItemColorsOption.label": "Kleur geen voorwerpen",
  "RemoveItemColorsOption.help": "Kleur objecten wit, zodat u zich kunt concentreren op andere elementen op de kaart",
  "ItemTypeOptions.help": "Het aantal objecten is %{count}",
  "ItemTypeMapFilter.TooltipTitle.notSelected": "Selecteer %{itemType} om objecten op de kaart te bekijken",
  "ItemTypeMapFilter.TooltipTitle.selected": "Als u %{itemType} deselecteert, wordt de bijbehorende kleur van de kaart verwijderd",
  "ItemTypeMapFilter.tooltip.true": "Selecteer hieronder alle objecttypen om ze op de kaart weer te geven",
  "ItemTypeMapFilter.tooltip.false": "Deselecteer hieronder alle objecttypen",
  "ItemTypeMapFilter.NoNode": "Er zijn momenteel geen objecten in ruimtes. Je kunt er meer toevoegen door een ruimte te wijzigen en er objecten aan toe te voegen. Vervolgens kun je de weergave ervan vanuit deze sectie regelen",
  "ItemTypeMapFilter.NoCategory": "Er zijn momenteel geen objecten in ruimtes. Je kunt er meer toevoegen door een ruimte te wijzigen en er objecten aan toe te voegen. Vervolgens kun je de weergave ervan vanuit deze sectie regelen",
  "ItemTypeDataQualityNotUsed.columns.name": "Naam objecttype",
  "ItemTypeDataQualityNotUsed.columns.shape": "Vorm",
  "ItemTypeDataQualityNotUsed.columns.workplaceTypeCount": "Aantal werkplektypes",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.help": "Kies een referentievlak om de vorm te creëren, zodat u uw type object als referentie op een vlak kunt tekenen en de juiste schaal hebt",
  "WorkCanvas.Options.ChooseBackgroundFloorItemTypeOption.label": "Kies een referentievlak om de vorm te maken",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.help": "Kies een referentieplan om het type werkstation samen te stellen met bestaande typen objecten door ze op een plattegrond te lokaliseren en de juiste schaal te hebben en de typen objecten correct te positioneren",
  "WorkCanvas.Options.ChooseBackgroundFloorWorkplaceTypeOption.label": "Kies een referentievlak om de vorm van het type werkstation samen te stellen",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.help": "Kies een referentievlak om de vorm te creëren, zodat u de structuur kunt tekenen aan de hand van een plan en de juiste schaal hebt",
  "WorkCanvas.Options.ChooseBackgroundFloorStructureOption.label": "Kies een referentievlak om de structuur te maken",
  "ItemTypeAvatarSingleView.copy": "Kopieer punten naar het klembord",
  "ItemTypeAvatarSingleView.debug.label": "Schakel de geavanceerde modus voor 3D in",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.help": "Verwijder de vorm van het objecttype volledig, zodat u deze bijvoorbeeld volledig opnieuw kunt tekenen of in een pictogram kunt transformeren",
  "WorkCanvas.Options.DeleteItemTypeShapeOption.label": "Vorm verwijderen",
  "CopyItemTypesToCart.help": "Kopieer itemtypen naar winkelwagen",
  "PhysicalItemNotInsideWorkplaceRoom.alignRooms": "Wijzig de objectruimten naar die van het werkstation",
  "AddPersonToItem.text": "Koppel een persoon aan dit object",
  "AddPersonToItem.help": "Koppel een persoon aan dit object, u kunt meerdere personen toevoegen aan hetzelfde object",
  "DimensionTypeDescription.NoDescription": "Er is geen beschrijving voor dit type analyselaag. U kunt er meer toevoegen door deze aan te passen",
  "dimensionTypes.room_ground_type.one": "Aard van de bodem",
  "dimensionTypes.room_ground_type.description": "Hiermee kunt u de samenstelling van de grond in de ruimte kennen",
  "dimensionTypes.room_usage.one": "Aard van ruimtes",
  "dimensionTypes.room_usage.description": "Hiermee kunt u ruimtes identificeren op basis van hun gebruik",
  "dimensionTypes.frequency.one": "Frequentie",
  "dimensionTypes.frequency.description": "Hiermee kunt u de frequentie van passage in de ruimte kennen",
  "dimensionTypes.evacuation_zone.one": "Beveiliging",
  "dimensionTypes.evacuation_zone.description": "Hiermee kunt u beveiligings- en evacuatiezones beheren",
  "dimensionTypes.referent.one": "Referent",
  "dimensionTypes.referent.description": "Hiermee kunt u weten wie is belast met het onderhoud van deze ruimte",
  "DimensionTypesByTab.action.true": "Selecteer alles",
  "DimensionTypesByTab.action.false": "deselecteer alles",
  "DimensionTypesByTab.ListItemHasChildrenSelected": "Afmetingen zijn geselecteerd",
  "DimensionListItem.notSelected": "Selecteer %{dimension} om de ruimtes op de plattegrond met de bijbehorende kleur te zien",
  "DimensionListItem.selected": "Deselecteer %{dimension}",
  "DimensionInfo.roomsArea.help": "De oppervlakte voor %{dimensionType} %{dimension} is %{value} m²",
  "DimensionInfo.roomsCount.help": "Er zijn %{value} spatie(s) voor %{dimensionType} %{dimension}",
  "DimensionInfo.peopleCount.help": "Er zijn %{value} persoon(en) toegewezen voor %{dimensionType} %{dimension}",
  "DimensionInfo.totalPeopleCount.help": "Er zijn in totaal %{value} persoon(en) toegewezen voor %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesCount.help": "Er zijn %{value} werkstation(s) voor %{dimensionType} %{dimension}",
  "DimensionInfo.peopleRatio.help": "Er zijn %{value} m² per getroffen persoon voor %{dimensionType} %{dimension}",
  "DimensionInfo.workplacesRatio.help": "Er zijn %{value} m² per werkstation voor %{dimensionType} %{dimension}",
  "DimensionInfo.occupancyRate.help": "De bezettingsgraad is %{value} % voor %{dimensionType} %{dimension}",
  "DimensionInfo.expansionRatio.help": "Het uitbreidingspercentage is %{value} voor %{dimensionType} %{dimension}",
  "DimensionInfo.freeWorkplacesCount.help": "Er zijn %{value} vrije werkstation(s) voor %{dimensionType} %{dimension}",
  "DimensionInfo.flexWorkplacesCount.help": "Er zijn %{value} flexwerkstation(s) voor %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesCount.help": "Er zijn %{value} gedeelde werkstations voor %{dimensionType} %{dimension}",
  "DimensionInfo.sharedWorkplacesRatio.help": "Het tarief voor gedeelde desktops is %{value} voor %{dimensionType} %{dimension}",
  "DimensionInfo.flexRatio.help": "Het tarief van flexwerkplekken",
  "DimensionInfo.transitWorkplacesCount.help": "Er zijn %{value} transitwerkstation(s) voor %{dimensionType} %{dimension}",
  "DimensionInfo.dimensionPeopleCount.help": "Er zijn %{value} persoon(en) toegewezen in %{dimensionType} %{dimension}",
  "DimensionInfo.seatsCount.help": "Er zijn %{value} zitplaatsen voor %{dimensionType} %{dimension}",
  "DimensionInfo.seatsPeopleRatio.help": "Het aantal zitplaatsen is %{value} beschikbare plaatsen per persoon voor %{dimensionType} %{dimension}",
  "DimensionInfo.carbonFootprint.help": "De CO2-voetafdruk is %{value} van de CO2-uitstoot voor %{dimensionType} %{dimension}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.peopleCount": "Er zijn %{count} mensen met kostenplaats %{costCenterName}",
  "PersonCostCenterWorkplaceInfo.nodeInfo.workplaceCount": "Er zijn %{count} werkstations met minstens één persoon met kostenplaats %{costCenterName}",
  "PersonCostCenterWorkplaceFilter.Empty": "Er zijn geen kostenplaatsen verbonden aan mensen",
  "NoDataOnBuildingInfo.noData": "Selecteer alle verdiepingen in de planopties om gegevens te hebben. Er mogen geen gegevens zijn voor de verdiepingen die u hebt geselecteerd",
  "CostCenterWorkplaceMapFilter.nodeInfo.workplacesCount": "Er zijn %{count} werkstations met kostenplaats %{name}",
  "CostCenterMapFilterTabs.tabs.rooms": "Spaties",
  "CostCenterMapFilterTabs.tabs.workplaces": "Persoonlijke werkplekken",
  "CostCenterMapFilterTabs.tabs.people": "Mensen",
  "CostCenterMapFilter.Empty": "Er zijn momenteel geen kostenplaatsen gekoppeld aan ruimtes. U kunt er meer toevoegen door een ruimte te wijzigen en er een kostenplaats aan te koppelen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "CostCenterWorkplaceMapFilter.Empty": "Er zijn momenteel geen kostenplaatsen gekoppeld aan werkstations. U kunt er meer toevoegen door een werkstation te wijzigen en er een kostenplaats aan te koppelen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "BuildingReports.items.sheets.physicals": "Fysieke objecten",
  "BuildingReports.items.sheets.virtuals": "Virtuele objecten",
  "BuildingReports.items.sheets.merged": "Fusie",
  "BuildingInventory.floor": "Vloer",
  "BuildingInventory.quantity": "hoeveelheid",
  "BuildingInventory.price": "Prijs",
  "BuildingInventory.manufacturer": "Maker",
  "BuildingInventory.quantityTotal": "Totaal",
  "BuildingInventory.title": "De inventaris van het gebouw %{building.name}",
  "BuildingInventory.buttons.viewPDF.help": "Download het bestand als PDF zodat u het kunt downloaden of delen",
  "BuildingInventory.buttons.viewPDF.label": "Download de PDF-versie",
  "BuildingInventory.itemTypesFamilySectionTitle": "Voorraadcategorieën",
  "BuildingInventory.fileNamePrefix": "inventaris",
  "BuildingLabel.scenario": "Dit gebouw is een scenario van het gebouw %{name}",
  "CopyBuildingToCart.help": "Kopieer de gebouwstructuur",
  "BuildingClonePropertiesSelector.properties.clone.workplaces": "Kopieer werkstations",
  "BuildingClonePropertiesSelector.properties.clone.items": "Kopieer objecten",
  "BuildingDistributionCost.floors.excel.tabs.floors": "Verdeling sleutels per verdieping",
  "BuildingDistributionCost.floors.excel.tabs.building": "Verdeelsleutels voor het gebouw",
  "BuildingDistributionCost.floors.excel.tabs.buildingDetailed": "Gebouwdetails per kostenplaats",
  "BuildingDistributionCost.floors.excel.download.label": "Download het Excel-bestand met de uitsplitsingen",
  "BuildingDistributionCost.floors.excel.download.help": "Download het Excel-bestand om de distributiesleutels en gekwalificeerde gebieden per kostenplaats en per verdieping te kunnen delen en exporteren. De export omvat de verdeling per verdieping of per gebouw van de kostenplaatsen",
  "BuildingDistributionCost.floors.excel.headers.floors.floorName": "Naam verdieping",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterName": "Kostenplaats",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterArea": "Oppervlakte van ruimtes inclusief vloerverdelingen",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterRoomsArea": "Gebied met kostenplaatsruimten",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterDistributedFloorRatio": "Verbruiksverhouding op de vloer",
  "BuildingDistributionCost.floors.excel.headers.floors.costCenterFloorDistributedArea": "Totale oppervlakte van de over de verdieping te verdelen ruimtes voor deze kostenplaats",
  "BuildingDistributionCost.floors.excel.headers.floors.floorArea": "Totaal vloeroppervlak inclusief vloerverdelingen",
  "BuildingDistributionCost.floors.excel.headers.floors.totalFloorDistributedArea": "Oppervlak om over de vloer te verdelen",
  "BuildingDistributionCost.floors.excel.headers.floors.totalBuildingDistributedArea": "Vloeroppervlak te verdelen in het gebouw",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterName": "Kostenplaats",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterArea": "Totale oppervlakte van de kostenplaats",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterBuildingRatio": "Gebruiksratio van gebouwen",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterDistributedBuildingArea": "Totale oppervlakte van de verdeelde ruimtes van het gebouw",
  "BuildingDistributionCost.floors.excel.headers.building.costCenterRoomsArea": "Gebied met kostenplaatsruimten",
  "BuildingDistributionCost.floors.excel.headers.building.buildingArea": "Totale oppervlakte van de bouwruimtes",
  "BuildingDistributionCost.floors.excel.headers.building.buildingDistributedArea": "Te verdelen oppervlakte in het gebouw",
  "BuildingDistributionCost.floors.excel.headers.building.totalBuildingArea": "Totale bouwoppervlakte",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.buildingName": "Gebouw",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterName": "Kostenplaats",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterArea": "Kostenplaatsgebied",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterBuildingRatio": "Distributiesleutel in het gebouw",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.distributedCostCenterArea": "Verdeling van kostenplaats %{costCenterName}",
  "BuildingDistributionCost.floors.excel.headers.buildingDetailed.costCenterTotalArea": "Totale oppervlakte die opnieuw moet worden gefactureerd",
  "BuildingDistributionCost.excel.tabs.distributionCost": "Distributiesleutels",
  "BuildingDistributionCost.excel.tabs.distributionCostDetails": "Details",
  "BuildingDistributionCost.excel.download.label": "Download het Excel-bestand zonder de storingen",
  "BuildingDistributionCost.excel.download.help": "Download het Excel-bestand om de distributiesleutels en gekwalificeerde gebieden per kostenplaats te kunnen delen en exporteren",
  "BuildingDistributionCost.Title": "Verdeelsleutels en gekwalificeerde gebieden per kostenplaats zonder storingen",
  "BuildingDistributionCost.table.type": "Vriendelijk",
  "BuildingDistributionCost.table.distributionKey": "Distributie sleutel",
  "BuildingDistributionCost.table.costCenterDistributionKey": "Verdeelsleutel voor kostenplaats",
  "BuildingDistributionCost.table.workplacesCount": "Aantal werkstations",
  "BuildingDistributionCost.table.workplaceTotalCount": "Totaal aantal werkstations",
  "BuildingFloorSelection.title": "De verdiepingen die u in uw scenario moet dupliceren",
  "BuildingFloorSelection.all.select": "Selecteer alle verdiepingen",
  "BuildingFloorSelection.all.unselect": "Deselecteer alle verdiepingen",
  "BuildingCloneFloorSelection.title": "De verdiepingen die u in uw scenario moet dupliceren",
  "BuildingCloneFloorSelection.all.select": "Selecteer alle verdiepingen",
  "BuildingCloneFloorSelection.all.unselect": "Deselecteer alle verdiepingen",
  "BuildingClone.noClone": "Er is nog geen scenario gemaakt. U kunt uw eerste scenario voor dit gebouw maken",
  "BuildingClone.buttons.CreateClone.label": "Creëer een scenario",
  "BuildingClone.buttons.CreateClone.help": "Het scenario dupliceert het gebouw met de aangevinkte eigenschappen",
  "BuildingClone.accordion.title": "Creëer een nieuw scenario",
  "BuildingClone.properties.clone.people": "Dubbele opdrachten",
  "BuildingClone.properties.clone.workplaces": "Dubbele werkstations",
  "BuildingClone.properties.clone.items": "Dubbele objecten",
  "BuildingClone.properties.clone.dimensions": "Koppel analyse- en toewijzingslagen aan spaties",
  "BuildingClone.properties.clone.organization": "Koppel organisaties aan ruimtes",
  "BuildingDashboard.dashboards.workplace": "Werkstationdashboard",
  "BuildingDashboard.dashboards.area": "Dashboard voor oppervlakken",
  "CampusBuildingsAccordion.buildingCount": "Het aantal gebouwen",
  "CalculatedPropertiesAccordions.mesures": "Maatregelen",
  "CalculatedPropertiesAccordions.kpi": "Indicatoren",
  "DimensionMapFilter.TooltipTitle.notSelected": "Selecteer %{dimension} om de ruimtes op de plattegrond met de bijbehorende kleur te zien",
  "DimensionMapFilter.TooltipTitle.selected": "Als u %{dimension} deselecteert, wordt de bijbehorende kleur uit het vlak verwijderd",
  "DimensionMapFilter.tooltip.true": "Selecteer alle onderstaande filters om ze op de kaart in te kleuren",
  "DimensionMapFilter.tooltip.false": "Deselecteer alle onderstaande filters",
  "DimensionMapFilter.NoNode": "Er zijn momenteel geen analyselagen. U kunt er meer toevoegen door een ruimte te bewerken en er analyselagen aan toe te voegen",
  "DimensionMapFilter.NoCategory": "Er zijn geen analyselagen beschikbaar. U moet deze eerst aan spaties koppelen",
  "SelectDimensionTypeNavigationLayoutIcon.select": "Selecteer dit laagtype voor navigatie",
  "SelectDimensionTypeNavigationLayoutIcon.unselect": "Verwijder navigatie per analyselaag en keer terug naar navigatie per spaties",
  "SelectDimensionTypeNavigationLayoutIcon.help": "Door te navigeren per analyselaag kunt u op een ruimte klikken, de bijbehorende laag selecteren en door de ruimtes heen de mensen bekijken die aan deze laag zijn toegewezen of de werkstations en objecten die aan deze laag zijn gekoppeld",
  "DimensionTypeNavigationWarning.message": "U bladert op %{name} , spaties worden tijdens de selectie gegroepeerd. Klik om te annuleren en terug te keren naar ruimtenavigatie",
  "RoomCardSelectDimensions.needSave": "Bewaar of annuleer uw wijzigingen voordat u de analyselagen van deze ruimte kunt wijzigen",
  "AssignPersonToWorkplaceCheckListDialogTitle.title": "U heeft %{personName} toegewezen aan werkstation %{workplaceName}",
  "AssignPersonToRoomCheckListDialogTitle.title": "Je hebt %{personName} toegewezen aan ruimte %{roomName}",
  "WorkplaceFullName.noName": "Naamloze werkstation",
  "RoomFullName.noName": "Naamloze ruimte",
  "AssignPersonCheckListWorkplaceTransit.title": "Werkstation %{workplaceName} is een transitwerkstation",
  "AssignPersonCheckListWorkplaceTransit.RemoveIsTransit": "Verwijder het type “gaat door” van het werkstation",
  "AssignPersonCheckListWorkplaceAffectations.title": "Deze persoon is al toegewezen aan andere werkstations, wil je de volgende toewijzingen voor %{personFullname} verwijderen",
  "AssignPersonCheckListRoomAffectations.title": "Deze persoon is al direct toegewezen aan andere ruimtes, wil je de volgende toewijzingen voor %{personFullname} verwijderen",
  "AssignPersonCheckListDialogApplyButton.help": "Verwijder geselecteerde opdrachten die mogelijk overeenkomen met de oude opdrachten van de persoon",
  "AssignPersonCheckListDialogApplyButton.label": "Geselecteerde toewijzingen verwijderen",
  "AssignPersonCheckListDialog.actions.close.label": "sluiten",
  "AssignPersonCheckListDialog.actions.close.help": "Sluit en verwijder geen andere toewijzingen",
  "AssignPersonCheckListBuildingAffectations.title": "Deze persoon is al direct toegewezen aan andere gebouwen, wil je de volgende toewijzingen voor %{personFullname} verwijderen",
  "WorkplaceVirtualInventory.title": "Virtuele werkplekinventaris",
  "WorkplacePhysicalInventory.title": "Fysieke inventaris van de werkplek",
  "WorkplaceTypeSeatsCount.label": "aantal zitplaatsen",
  "WorkplaceTypeSeatsCount.help": "Het aantal zitplaatsen dat voor dit type werkplek wordt geteld",
  "WorkplaceTypeCarbonFootprintCount.label": "Koolstofvoetafdruk",
  "WorkplaceTypeCarbonFootprintCount.help": "De CO2-voetafdruk is de hoeveelheid broeikasgassen die worden uitgestoten door de meubelobjecten van dit type werkplek",
  "DeleteWorkplace.help": "Werkstation verwijderen: [ %{name} ], opdrachten worden ook verwijderd",
  "AddPersonToWorkplace.text": "Wijs een persoon toe",
  "AddPersonToWorkplace.help": "Voeg een opdracht toe aan dit werkstation, je kunt meerdere opdrachten toevoegen voor hetzelfde werkstation",
  "MouvementMatrixImport.errors.noSheet": "Kan Excel-blad met naam %{name} [ %{objectTypeName} ] niet vinden",
  "RoomTypeGroupMapFilter.Empty": "Er is geen ruimtetypegroep gekoppeld aan ruimtes via ruimtetypen. U kunt er meer toevoegen door een ruimtetypegroep te bewerken en er een ruimtetype aan toe te voegen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "RoomTypeGroupLabel.exclude.tooltip": "De ruimtetypologiegroep sluit bijbehorende ruimtetypen uit",
  "RoomTypeGroupHelpTitle.exclude": "De groepering van het ruimtetype %{name} is van het uitsluitingstype. Het brengt alle ruimtes samen, met uitzondering van de volgende ruimtetypologieën:",
  "RoomTypeGroupHelpTitle.include": "De ruimtetypegroepering %{name} brengt de volgende ruimtetypologieën samen:",
  "RoomTypeGroupToRoomTypeLabel.exclude.tooltip": "De ruimtetypologie is uitgesloten",
  "RoomMapFilter.Empty": "Er is geen ruimtetype gekoppeld aan ruimtes. U kunt er meer toevoegen door een ruimte te wijzigen en er een bijbehorend type aan toe te voegen. Vervolgens kunt u de weergave ervan vanuit deze sectie beheren",
  "LayoutFiltersTabZone.collapse.help": "Het menu is gesloten, u kunt het openen door op het eerste pictogram te klikken om het te openen en de details van de planelementen te bekijken",
  "LayoutFiltersTabOpenToggleIcon.open.true": "Sluit het kaartmenu om de ruimte van de kaartweergave te optimaliseren",
  "LayoutFiltersTabOpenToggleIcon.open.false": "Open het planmenu om gedetailleerde informatie over het plan te bekijken",
  "CompanyTypeLabel.notClassified": "Niet-geclassificeerd platform",
  "BuildingMenuItem.menu.scenario": "Scenario's ( %{count} )",
  "SearchMenuItem.icon.tooltip": "Zoeken",
  "RemoveFromCartIconButton.help": "Uit winkelwagen verwijderen",
  "CopyCartContentIntoTenant.buttons.single.paste.help": "Importeer in dit bedrijf",
  "IndexContextMenuItem.navigation": "Navigatie",
  "GlobalSearchIncludeScenarios.label": "Scenario's opnemen in zoeken",
  "GlobalSearch.Input.placeholder": "Zoeken",
  "GlobalSearch.Start": "U kunt zoeken op bijvoorbeeld mensen, ruimtes, werkstations, objecten of andere entiteiten, de zoekopdracht begint vanaf het 2e teken",
  "GlobalSearch.NoResult": "Er zijn geen resultaten gevonden voor uw zoekopdracht",
  "GlobalSearch.close.help": "Duidelijke zoek",
  "models.PartnerExportMappingConfigurationToFloor.singular": "Fase opgenomen in de configuratie van de transformatie van partnerexporten",
  "models.PartnerExportMappingConfigurationToFloor.plural": "Fasen die zijn opgenomen in de partnerexporttransformatieconfiguratie",
  "models.PartnerExportMappingConfigurationToFloor.determinant.defined": "de fase die is opgenomen in de configuratie van de transformatie van partnerexporten",
  "models.PartnerExportMappingConfigurationToFloor.determinant.undefined": "een fase die is opgenomen in de configuratie van de transformatie van partnerexporten",
  "models.PartnerExportMappingConfigurationToFloor.determinants.defined": "de fasen die zijn opgenomen in de configuraties van partnerexporttransformaties",
  "models.PartnerExportMappingConfigurationToFloor.determinants.undefined": "fasen die zijn opgenomen in de configuraties van partnerexporttransformaties",
  "models.PartnerExportMappingToRoomType.singular": "Transformatie van partnerexporten voor ruimtetypen",
  "models.PartnerExportMappingToRoomType.plural": "Transformaties van partnerexporten voor ruimtetypen",
  "models.PartnerExportMappingToRoomType.determinant.defined": "de transformatie van partnerexporten voor ruimtetypen",
  "models.PartnerExportMappingToRoomType.determinant.undefined": "een transformatie van partnerexporten voor soorten ruimtes",
  "models.PartnerExportMappingToRoomType.determinants.defined": "transformaties van partnerexporten voor ruimtetypen",
  "models.PartnerExportMappingToRoomType.determinants.undefined": "transformaties van partnerexporten voor ruimtetypen",
  "models.PartnerExportMappingConfiguration.singular": "Partnerexporttransformatie configureren",
  "models.PartnerExportMappingConfiguration.plural": "Configuraties van partnerexporttransformaties",
  "models.PartnerExportMappingConfiguration.determinant.defined": "het configureren van de transformatie van partnerexporten",
  "models.PartnerExportMappingConfiguration.determinant.undefined": "een configuratie van de transformatie van partnerexporten",
  "models.PartnerExportMappingConfiguration.determinants.defined": "configuraties van partnerexporttransformaties",
  "models.PartnerExportMappingConfiguration.determinants.undefined": "configuraties van partnerexporttransformaties",
  "models.PartnerExportMapping.singular": "Transformatie van partnerexport",
  "models.PartnerExportMapping.plural": "Transformaties van partnerexport",
  "models.PartnerExportMapping.determinant.defined": "de transformatie van de partnerexport",
  "models.PartnerExportMapping.determinant.undefined": "een transformatie van de partnerexport",
  "models.PartnerExportMapping.determinants.defined": "transformaties van de partnerexport",
  "models.PartnerExportMapping.determinants.undefined": "transformaties van de partnerexport",
  "models.WorkplaceTypeItemType.singular": "objecttype in werkstationtype",
  "models.WorkplaceTypeItemType.plural": "objecttypen in werkstationtype",
  "models.WorkplaceTypeItemType.determinant.defined": "het objecttype in het werkstationtype",
  "models.WorkplaceTypeItemType.determinant.undefined": "een objecttype in een werkstationtype",
  "models.WorkplaceTypeItemType.determinants.defined": "objecttypen in werkstationtypen",
  "models.WorkplaceTypeItemType.determinants.undefined": "objecttypen in werkstationtypen",
  "models.WorkplaceTypeItemType.properties.id.label": "Identificatie van het objecttype in het werkstationtype",
  "models.WorkplaceTypeItemType.properties.zIndex.label": "Hoogte-index",
  "models.WorkplaceTypeItemType.properties.zIndex.description": "Met de hoogte-index kunt u de volgorde van weergave van objecttypen definiëren: hoe groter de index, hoe meer het object boven de andere zal staan",
  "models.WorkplaceTypeItemType.properties.physicalInventory.label": "Fysieke voorraad",
  "models.WorkplaceTypeItemType.properties.physicalInventory.description": "Als deze optie is aangevinkt wordt er per werkplek een fysiek object aangemaakt in Surfy, dit object mag een unieke referentie hebben, in alle gevallen is de bouwinventaris up-to-date",
  "models.WorkplaceTypeItemType.properties.seatsCount.label": "aantal zitplaatsen",
  "models.WorkplaceTypeItemType.properties.seatsCount.description": "Hiermee kunt u het aantal beschikbare zitplaatsen definiëren in het type werkstation voor dit type object",
  "models.WorkplaceType.singular": "soort werkstation",
  "models.WorkplaceType.plural": "soorten werkstations",
  "models.WorkplaceType.determinant.defined": "het type werkstation",
  "models.WorkplaceType.determinant.undefined": "een soort werkstation",
  "models.WorkplaceType.determinants.defined": "soorten werkstations",
  "models.WorkplaceType.determinants.undefined": "soorten werkstations",
  "models.WorkplaceType.properties.id.label": "Identificatie van de werkstationtypologie",
  "models.WorkplaceType.properties.id.description": "???",
  "models.WorkplaceType.properties.name.label": "Naam van het werkstationtype",
  "models.WorkplaceType.properties.name.description": "???",
  "models.WorkplaceType.views.editor.help": "Vormen en locaties van objecttypen bewerken voor werkstationtype %{name}",
  "models.WorkplaceType.views.editor.label": "Vormen bewerken",
  "models.WorkplaceType.views.avatar.help": "Vorm van werkstationtype %{name} bekijken",
  "models.WorkplaceType.views.avatar.label": "Zie de vorm",
  "models.WorkplaceType.views.dq-not-used.label": "Niet gebruikt",
  "models.WorkplaceType.views.dq-not-used.help": "Vermeld alle ongebruikte typen werkstations via werkstations",
  "models.WorkplaceAffectation.singular": "Toewijzing aan werkstation",
  "models.WorkplaceAffectation.plural": "Werkstationopdrachten",
  "models.WorkplaceAffectation.description": "Hiermee kunt u een vaste werkplek aan een persoon toewijzen",
  "models.WorkplaceAffectation.determinant.defined": "toewijzing aan het werkstation",
  "models.WorkplaceAffectation.determinant.undefined": "een opdracht aan de werkplek",
  "models.WorkplaceAffectation.determinants.defined": "werkstation opdrachten",
  "models.WorkplaceAffectation.determinants.undefined": "werkstation opdrachten",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.help": "Importeer werkstationoverdrachtsmatrices",
  "models.WorkplaceAffectation.views.workplace-mouvement-matrix-import.label": "Overdrachtsmatrix importeren",
  "models.Workplace.singular": "werkplek",
  "models.Workplace.plural": "persoonlijke werkplekken",
  "models.Workplace.determinant.defined": "bureaublad",
  "models.Workplace.determinant.undefined": "een werkstation",
  "models.Workplace.determinants.defined": "werkstations",
  "models.Workplace.determinants.undefined": "werkstations",
  "models.Workplace.views.assign-current-user.label": "Bezet het werkstation",
  "models.Workplace.views.assign-current-user.help": "Bezet werkstation %{name}",
  "models.Workplace.properties.id.label": "Werkstation-ID",
  "models.Workplace.properties.id.description": "???",
  "models.Workplace.properties.color.label": "Kleur",
  "models.Workplace.properties.color.description": "De kleur die het type werkplek op het plan krijgt",
  "models.Workplace.properties.name.label": "Naam van werkstation",
  "models.Workplace.properties.name.description": "De naam van het werkstation wordt gebruikt om het eenvoudiger te identificeren",
  "models.Workplace.properties.isFlex.label": "Is het in flex?",
  "models.Workplace.properties.isFlex.description": "Als dit station in Flex-modus wordt gebruikt",
  "models.Workplace.properties.isShared.label": "Is gedeeld ?",
  "models.Workplace.properties.isShared.description": "Indien dit werkstation door meerdere personen gedeeld wordt, wordt dit automatisch veld gevalideerd zodra er minimaal 2 opdrachten op het werkstation staan",
  "models.Workplace.properties.isTransit.label": "Komt er doorheen?",
  "models.Workplace.properties.isTransit.description": "Indien deze functie van voorbijgaande aard is, wordt deze functie uitgesloten van vrije werkplekken zonder in flex te reserveren, een tijdelijke functie maakt het mogelijk om voor iedereen die er gebruik van wil maken een werkplek beschikbaar te hebben zonder opgenomen te zijn in een reserveringssysteem",
  "models.Workplace.properties.isBookable.label": "Is het boekbaar?",
  "models.Workplace.properties.isBookable.description": "Als deze werkplek reserveerbaar is in een reserveringssysteem",
  "models.Workplace.properties.position.label": "Positie",
  "models.Workplace.properties.position.description": "De positie van het werkstation in de ruimte",
  "models.Workplace.properties.rotation.label": "Rotatie",
  "models.Workplace.properties.rotation.description": "De rotatiehoek van het werkstation in de ruimte",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.label": "Gemiddeld toewijzingspercentage",
  "models.Workplace.properties.workplaceAffectationsCalculatedRateSum.description": "Gemiddelde toewijzingssnelheid van de werkplek, afhankelijk van de toewijzing van aanwezigheidsdagen van personen",
  "models.Workplace.properties.workplaceAffectationsCount.label": "Aantal opdrachten",
  "models.Workplace.properties.workplaceAffectationsCount.description": "Aantal opdrachten op de werkplek",
  "models.Workplace.properties.comment.label": "Opmerking",
  "models.Workplace.properties.comment.description": "Aanvullende informatie over de werkplek",
  "models.Workplace.properties.room.label": "Werkplek ruimte",
  "models.UserRegistrationTenantRuleToJupRole.singular": "Op rollen gebaseerde associatie van authenticatieregels",
  "models.UserRegistrationTenantRuleToJupRole.plural": "Op rollen gebaseerde authenticatieregelassociaties",
  "models.UserRegistrationTenantRuleToJupRole.determinant.defined": "de associatie van authenticatieregel met rol",
  "models.UserRegistrationTenantRuleToJupRole.determinant.undefined": "een op rollen gebaseerde authenticatieregelkoppeling",
  "models.UserRegistrationTenantRuleToJupRole.determinants.defined": "authenticatieregelkoppelingen aan rollen",
  "models.UserRegistrationTenantRuleToJupRole.determinants.undefined": "authenticatieregelkoppelingen aan rollen",
  "models.UserRegistrationTenantRuleToContentRole.singular": "Associatie van authenticatieregel met inhoudsrol",
  "models.UserRegistrationTenantRuleToContentRole.plural": "Authenticatieregel voor associaties met inhoudsrollen",
  "models.UserRegistrationTenantRuleToContentRole.determinant.defined": "koppeling van authenticatieregel aan inhoudsrol",
  "models.UserRegistrationTenantRuleToContentRole.determinant.undefined": "een authenticatieregelkoppeling met inhoudsrol",
  "models.UserRegistrationTenantRuleToContentRole.determinants.defined": "authenticatieregel aan inhoudrolassociaties",
  "models.UserRegistrationTenantRuleToContentRole.determinants.undefined": "authenticatieregel aan contentrolassociaties",
  "models.UserRegistrationTenantRule.singular": "Authenticatieregel",
  "models.UserRegistrationTenantRule.plural": "Authenticatieregels",
  "models.UserRegistrationTenantRule.determinant.defined": "de authenticatieregel",
  "models.UserRegistrationTenantRule.determinant.undefined": "een authenticatieregel",
  "models.UserRegistrationTenantRule.determinants.defined": "authenticatieregels",
  "models.UserRegistrationTenantRule.determinants.undefined": "authenticatieregels",
  "models.UserRegistrationTenantRule.properties.domains.label": "Gebieden",
  "models.UserRegistrationTenantRule.properties.domains.description": "Scheid domeinen met spaties en plaats het apenstaartje",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.label": "Automatisch rollen koppelen",
  "models.UserRegistrationTenantRule.properties.automaticUserToRoleMapping.description": "Koppel automatisch rollen en inhoudsrollen aan gebruikers die aan deze regel voldoen",
  "models.UserCompany.singular": "bedrijfsgebruiker",
  "models.UserCompany.plural": "zakelijke gebruikers",
  "models.UserCompany.description": "Zakelijke gebruikers hebben toegang tot het Surfy-platform van hun bedrijf",
  "models.UserCompany.determinant.defined": "zakelijke gebruiker",
  "models.UserCompany.determinant.undefined": "een bedrijfsgebruiker",
  "models.UserCompany.determinants.defined": "zakelijke gebruikers",
  "models.UserCompany.determinants.undefined": "van bedrijfsgebruikers",
  "models.UserCompany.properties.id.label": "Bedrijfsgebruikers-ID",
  "models.UserCompany.properties.buildingOwners.label": "Eigen gebouwen",
  "models.UserCompany.properties.buildingOwners.description": "Gebouwen die eigendom zijn van de gebruiker",
  "models.User.singular": "gebruiker",
  "models.User.plural": "gebruikers",
  "models.User.determinant.defined": "de gebruiker",
  "models.User.determinant.undefined": "een gebruiker",
  "models.User.determinants.defined": "de gebruikers",
  "models.User.determinants.undefined": "gebruikers",
  "models.User.properties.id.label": "gebruikersnaam",
  "models.User.properties.id.description": "???",
  "models.User.properties.firstname.label": "Voornaam",
  "models.User.properties.firstname.description": "De voornaam van de gebruiker",
  "models.User.properties.lastname.label": "Achternaam",
  "models.User.properties.lastname.description": "De achternaam van de gebruiker",
  "models.User.properties.email.label": "E-mail",
  "models.User.properties.email.description": "Het e-mailadres dat door de gebruiker wordt gebruikt voor correspondentie of authenticatie",
  "models.Structure.singular": "structuur",
  "models.Structure.plural": "structuren",
  "models.Structure.determinant.defined": "de structuur",
  "models.Structure.determinant.undefined": "een structuur",
  "models.Structure.determinants.defined": "de structuren",
  "models.Structure.determinants.undefined": "structuren",
  "models.Structure.properties.nom.label": "Naam van de structuur",
  "models.Structure.properties.nom.description": "Om de structuur gemakkelijk te vinden en opnieuw te gebruiken",
  "models.Structure.properties.transform.label": "Transformatie",
  "models.Structure.properties.transform.description": "Transformatie van de structuur om deze op een kaart te kalibreren",
  "models.Structure.views.editor.label": "Vorm bewerken",
  "models.Structure.views.editor.help": "Verander de vorm van de structuur",
  "models.Structure.views.gmap-calibrate.label": "Kalibreer de structuur op een kaart",
  "models.Structure.views.gmap-calibrate.help": "Kalibreer de structuur op een kaart om geografische coördinaten te associëren",
  "models.RoomTypeGroupToRoomType.singular": "associatie van ruimtetypologiegroep met ruimtetypologie",
  "models.RoomTypeGroupToRoomType.plural": "associaties van groepen ruimtetypologieën met ruimtetypologieën",
  "models.RoomTypeGroupToRoomType.determinant.defined": "de associatie van ruimtetypologiegroep met ruimtetypologie",
  "models.RoomTypeGroupToRoomType.determinant.undefined": "een groepsassociatie van ruimtetypologie met ruimtetypologie",
  "models.RoomTypeGroupToRoomType.determinants.defined": "groepsassociaties van ruimtetypologieën met ruimtetypologieën",
  "models.RoomTypeGroupToRoomType.determinants.undefined": "groepsassociaties van ruimtetypologieën met ruimtetypologieën",
  "models.RoomTypeGroupFloor.singular": "typologiegroep vloeroppervlak",
  "models.RoomTypeGroupFloor.plural": "typologiegroepen voor vloeroppervlakken",
  "models.RoomTypeGroupFloor.determinant.defined": "de vloeroppervlaktypologiegroep",
  "models.RoomTypeGroupFloor.determinant.undefined": "een groep vloeroppervlaktypologieën",
  "models.RoomTypeGroupFloor.determinants.defined": "de vloeroppervlaktypologiegroep",
  "models.RoomTypeGroupFloor.determinants.undefined": "groepen vloeroppervlaktypologieën",
  "models.RoomTypeGroupBuilding.singular": "ruimtetypologie groep gebouwen",
  "models.RoomTypeGroupBuilding.plural": "groepen typologieën van gebouwruimten",
  "models.RoomTypeGroupBuilding.determinant.defined": "de typologiegroep gebouwruimte",
  "models.RoomTypeGroupBuilding.determinant.undefined": "een groep typologieën van bouwruimtes",
  "models.RoomTypeGroupBuilding.determinants.defined": "de typologiegroep gebouwruimte",
  "models.RoomTypeGroupBuilding.determinants.undefined": "groepen typologieën van gebouwruimten",
  "models.RoomTypeGroup.singular": "groep ruimtetypologie",
  "models.RoomTypeGroup.plural": "ruimtetypologiegroepen",
  "models.RoomTypeGroup.determinant.defined": "de ruimtetypologiegroep",
  "models.RoomTypeGroup.determinant.undefined": "een ruimtetypologiegroep",
  "models.RoomTypeGroup.determinants.defined": "ruimtetypologiegroepen",
  "models.RoomTypeGroup.determinants.undefined": "groepen ruimtetypologieën",
  "models.RoomTypeGroup.properties.id.label": "Groepsidentificatie voor ruimtetypologie",
  "models.RoomTypeGroup.properties.name.label": "Groepsnaam van ruimtetypologie",
  "models.RoomTypeGroup.properties.code.label": "Gecodeerd",
  "models.RoomTypeGroup.properties.color.label": "Kleur",
  "models.RoomTypeGroup.properties.exclude.label": "Uitsluiten",
  "models.RoomTypeGroup.properties.exclude.description": "Sluit ruimtetypologieën uit van deze groep",
  "models.RoomTypeFloor.singular": "typologie van de vloeroppervlakte",
  "models.RoomTypeFloor.plural": "typologieën van vloeroppervlakken",
  "models.RoomTypeFloor.determinant.defined": "de typologie van vloeroppervlak",
  "models.RoomTypeFloor.determinant.undefined": "een typologie van vloeroppervlak",
  "models.RoomTypeFloor.determinants.defined": "typologieën van vloeroppervlakken",
  "models.RoomTypeFloor.determinants.undefined": "typologieën van vloeroppervlakken",
  "models.RoomTypeBuilding.singular": "typologie van de bouwruimte",
  "models.RoomTypeBuilding.plural": "typologieën van de bouwruimte",
  "models.RoomTypeBuilding.determinant.defined": "de typologie van de bouwruimte",
  "models.RoomTypeBuilding.determinant.undefined": "een typologie van bouwruimte",
  "models.RoomTypeBuilding.determinants.defined": "typologieën van de bouwruimte",
  "models.RoomTypeBuilding.determinants.undefined": "typologieën van de bouwruimte",
  "models.RoomType.singular": "typologie van de ruimte",
  "models.RoomType.plural": "typologieën van de ruimte",
  "models.RoomType.determinant.defined": "typologie van de ruimte",
  "models.RoomType.determinant.undefined": "een typologie van de ruimte",
  "models.RoomType.determinants.defined": "typologieën van de ruimte",
  "models.RoomType.determinants.undefined": "typologieën van de ruimte",
  "models.RoomType.properties.id.label": "Identificatie voor ruimtetypologie",
  "models.RoomType.properties.name.label": "Naam van de ruimtetypologie",
  "models.RoomType.properties.color.label": "Kleur in 2d",
  "models.RoomType.properties.color.description": "De kleur van het type ruimte maakt het mogelijk om elk type op het 2D-plan te onderscheiden",
  "models.RoomType.properties.color3d.label": "Kleur in 3D",
  "models.RoomType.properties.color3d.description": "Hiermee kunt u de kleur van het type ruimte in 3D beheren, deze optie is alleen van toepassing op de 3D-visie van de vloer",
  "models.RoomType.properties.displayWallsOn3d.label": "Laat muren zien",
  "models.RoomType.properties.displayWallsOn3d.description": "Hiermee kunt u de wanden van de ruimte al dan niet in het 3D-plan van de vloer weergeven. De niet weergegeven muren zijn in 2D gestippeld, waardoor u een aangenamer zicht krijgt, vooral in open ruimtes",
  "models.RoomType.properties.icon.label": "Icoon",
  "models.RoomType.properties.icon.description": "Met het icoon voor het type ruimte kunt u in de 2D- en 3D-plannen een icoon voor dit type ruimte weergeven in plaats van de klassieke informatie op het plan, gekoppeld aan de achtergrondkleur maakt dit het lezen van het plan aangenamer",
  "models.RoomType.properties.cadence.label": "Cadans",
  "models.RoomType.properties.cadence.description": "Het tarief is een numerieke waarde die wordt gebruikt om de moeilijkheidsgraad van het opschonen van de ruimtetypologie aan te geven. Het is gelijk aan het aantal m² dat in één uur kan worden behandeld in deze typologie (circulatie, laboratorium, enz.)",
  "models.RoomType.properties.isBookable.label": "Is het boekbaar?",
  "models.RoomType.properties.isBookable.description": "Vink dit vakje aan als dit type ruimte reserveerbaar is",
  "models.RoomPointSegmentType.singular": "Segmenttype",
  "models.RoomPointSegmentType.plural": "Segmenttypen",
  "models.RoomPointSegmentType.determinant.defined": "het type segment",
  "models.RoomPointSegmentType.determinant.undefined": "een soort segment",
  "models.RoomPointSegmentType.determinants.defined": "segmenttypen",
  "models.RoomPointSegmentType.determinants.undefined": "segmenttypen",
  "models.RoomPointSegment.singular": "segmentkwalificatie",
  "models.RoomPointSegment.plural": "segmentkwalificaties",
  "models.RoomPointSegment.determinant.defined": "segmentkwalificatie",
  "models.RoomPointSegment.determinant.undefined": "een segmentkwalificatie",
  "models.RoomPointSegment.determinants.defined": "segmentkwalificaties",
  "models.RoomPointSegment.determinants.undefined": "segmentkwalificaties",
  "models.RoomPointSegment.properties.reversePoints.label": "Omgekeerde punten",
  "models.RoomPointSegment.properties.reversePoints.description": "Draai de punten van het segment om, zodat bijvoorbeeld deuren in de juiste richting worden weergegeven",
  "models.RoomPointSegment.properties.displayBothSides.label": "Aan beide kanten laten zien",
  "models.RoomPointSegment.properties.displayBothSides.description": "Toon segment aan beide zijden van het segment",
  "models.RoomPointSegment.views.dq-not-uniq.label": "Niet-unieke puntsegmenten",
  "models.RoomPointSegment.views.dq-not-uniq.help": "Hiermee kunt u controleren of er geen exact duplicaatsegment op dezelfde punten is",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.label": "De segmentpunten bevinden zich op 2 verschillende verdiepingen",
  "models.RoomPointSegment.views.dq-point-not-on-same-floor.help": "Hiermee kunt u controleren of de segmentpunten zich op dezelfde verdieping bevinden",
  "models.RoomPointRoom.singular": "Associatie tussen een punt en een spatie",
  "models.RoomPointRoom.plural": "Associaties tussen een punt en een ruimte",
  "models.RoomPointRoom.determinant.defined": "de associatie tussen een punt en een ruimte",
  "models.RoomPointRoom.determinant.undefined": "een punt",
  "models.RoomPointRoom.description": "De associatie tussen een punt en een ruimte maakt het mogelijk om de volgorde van de punten in een ruimte te behouden om zo een polyon te vormen",
  "models.RoomPointRoom.properties.id.label": "Identificatie van de associatie tussen een punt en een spatie",
  "models.RoomPointRoom.properties.id.description": "???",
  "models.RoomPointRoom.properties.roomId.label": "Ruimte-ID",
  "models.RoomPointRoom.properties.roomId.description": "???",
  "models.RoomPointRoom.properties.externalId.label": "Externe identificatie",
  "models.RoomPointRoom.properties.externalId.description": "???",
  "models.RoomPointRoom.properties.sortIndex.label": "Sorteerindex",
  "models.RoomPointRoom.properties.sortIndex.description": "???",
  "models.RoomPointRoom.properties.roomPointId.label": "Punt-ID",
  "models.RoomPointRoom.properties.roomPointId.description": "???",
  "models.RoomPoint.singular": "punt van spaties",
  "models.RoomPoint.plural": "punten van spaties",
  "models.RoomPoint.determinant.defined": "het punt van spaties",
  "models.RoomPoint.determinant.undefined": "een punt van spaties",
  "models.RoomPoint.properties.id.label": "Identificatie van het ruimtepunt",
  "models.RoomPoint.properties.x.label": "X",
  "models.RoomPoint.properties.x.description": "Coördinaat X-as",
  "models.RoomPoint.properties.y.label": "j",
  "models.RoomPoint.properties.y.description": "Y-as coördinaat",
  "models.RoomPoint.properties.sort_index.label": "Volgorde",
  "models.RoomPoint.properties.sort_index.description": "De index die wordt gebruikt voor het sorteren",
  "models.RoomPoint.properties.room.description": "???",
  "models.RoomPoint.properties.externalId.label": "Externe identificatie",
  "models.RoomPoint.properties.externalId.description": "???",
  "models.RoomPoint.views.dq-uniq-position.label": "Unieke steekpositie",
  "models.RoomPoint.views.dq-uniq-position.help": "Hiermee kunt u controleren of er geen exacte dubbele positie op de punten is",
  "models.RoomPoint.views.dq-not-used.label": "Ongebruikte punten",
  "models.RoomPoint.views.dq-not-used.help": "Hiermee kunt u punten zien die niet in ruimtes worden gebruikt",
  "models.RoomConnector.singular": "Ruimteconnector",
  "models.RoomConnector.plural": "Ruimteconnectoren",
  "models.RoomConnector.determinant.defined": "de ruimteconnector",
  "models.RoomConnector.determinant.undefined": "een ruimteconnector",
  "models.RoomConnector.determinants.defined": "ruimte connectoren",
  "models.RoomConnector.determinants.undefined": "ruimte connectoren",
  "models.RoomConnector.description": "Met ruimteverbinders kunt u een koppeling creëren tussen meerdere ruimtes op verschillende verdiepingen",
  "models.RoomConnector.properties.id.label": "Space Connector-ID",
  "models.RoomConnector.properties.name.label": "Naam van ruimteconnector",
  "models.RoomConnector.properties.waitTime.label": "Gemiddelde wachttijd",
  "models.RoomConnector.properties.waitTime.description": "De gemiddelde wachttijd voordat de ruimteconnector beschikbaar komt",
  "models.RoomConnector.properties.timePerFloor.label": "Tijd tussen elke verdieping",
  "models.RoomConnector.properties.timePerFloor.description": "De tijd die nodig is om van de ene verdieping naar de volgende te gaan",
  "models.RoomAffectation.singular": "Toewijzing van ruimte",
  "models.RoomAffectation.plural": "Ruimte opdrachten",
  "models.RoomAffectation.description": "Hiermee kunt u een persoon aan één ruimte toewijzen",
  "models.RoomAffectation.determinant.defined": "toewijzing van ruimte",
  "models.RoomAffectation.determinant.undefined": "een ruimteverdeling",
  "models.RoomAffectation.determinants.defined": "ruimte opdrachten",
  "models.RoomAffectation.determinants.undefined": "ruimte opdrachten",
  "models.RoomAffectation.views.room-mouvement-matrix-import.help": "Importeer ruimteoverdrachtsmatrices",
  "models.RoomAffectation.views.room-mouvement-matrix-import.label": "Overdrachtsmatrix importeren",
  "models.Room.singular": "ruimte",
  "models.Room.plural": "ruimtes",
  "models.Room.determinant.defined": "ruimte",
  "models.Room.determinant.undefined": "een gebied",
  "models.Room.determinants.defined": "de ruimtes",
  "models.Room.determinants.undefined": "ruimtes",
  "models.Room.description": "Ruimtes zijn werkplekken of zones om een ​​verdieping in deelruimtes te verdelen",
  "models.Room.views.map.help": "Bekijk het ruimteplan %{name}",
  "models.Room.views.map.label": "Plan",
  "models.Room.views.dq-uniq-name.help": "Stelt namen voor voor ruimtes die geen naam hebben of de naam is niet uniek op dezelfde verdieping",
  "models.Room.views.dq-uniq-name.label": "Voorgestelde namen voor spaties",
  "models.Room.views.dq-no-point.help": "Ruimtes die 0, 1 of 2 punten hebben en daarom een ​​oppervlakte nul moeten hebben",
  "models.Room.views.dq-no-point.label": "Spaties zonder voldoende punten",
  "models.Room.views.dq-capacity-equals-seats-count.help": "Ruimten met een capaciteit exclusief zitplaatsen gelijk aan het aantal zitplaatsen en met een totale capaciteit verdubbeld",
  "models.Room.views.dq-capacity-equals-seats-count.label": "Ruimtes met een capaciteit exclusief zitplaatsen gelijk aan het aantal zitplaatsen",
  "models.Room.views.dq-capacity-gt-0.help": "Hiermee kunt u zien of er inconsistenties zijn in de capaciteiten van ruimtes of bijvoorbeeld meubels detecteren die nog geen zitplaatsen hebben",
  "models.Room.views.dq-capacity-gt-0.label": "Ruimtes met een capaciteit exclusief stoelen verschillend van 0",
  "models.Room.views.meeting-rooms.help": "Bekijk en navigeer door vergaderruimtes",
  "models.Room.views.meeting-rooms.label": "Vergaderzalen",
  "models.Room.properties.prettyName.label": "Weergavenaam",
  "models.Room.properties.prettyName.description": "Hiermee kunt u naast de technische naam van de ruimte ook een weergavenaam gebruiken, bijvoorbeeld voor vergaderruimtes",
  "models.Room.properties.id.label": "Ruimte-ID",
  "models.Room.properties.livePeopleCount.label": "Aantal mensen in de ruimte in realtime",
  "models.Room.properties.livePeopleCount.description": "Deze waarde wordt bijgewerkt door de mensentelsensoren die in de ruimte aanwezig zijn en geeft het aantal mensen weer dat in realtime in de ruimte aanwezig is",
  "models.Room.properties.picture.label": "Ruimte foto",
  "models.Room.properties.picture.description": "De foto van de ruimte maakt het gemakkelijk te visualiseren",
  "models.Room.properties.capacity.label": "Capaciteit exclusief zitplaatsen",
  "models.Room.properties.capacity.description": "De opgegeven capaciteit kan worden gebruikt om het aantal beschikbare zitplaatsen in een ruimte te bepalen of om het maximale aantal mensen te kennen dat in een ruimte kan worden geplaatst. Dit cijfer wordt opgeteld bij het aantal zitplaatsen om de totale capaciteit te verkrijgen",
  "models.Room.properties.workplacesCount.label": "Aantal werkstations",
  "models.Room.properties.workplacesCount.description": "Het aantal werkplekken in de ruimte wordt automatisch berekend",
  "models.Room.properties.workplacesRatio.label": "Verhouding per werkplek",
  "models.Room.properties.workplacesRatio.description": "De verhouding per werkplek is het aantal vierkante meter ruimte gedeeld door het aantal werkplekken, deze waarde wordt automatisch berekend",
  "models.Room.properties.peopleCount.label": "Aantal opdrachten",
  "models.Room.properties.peopleCount.description": "Het aantal mensen dat rechtstreeks of via een werkplek aan de ruimte is toegewezen",
  "models.Room.properties.peopleRatio.label": "Bezettingsgraad",
  "models.Room.properties.peopleRatio.description": "De bezettingsgraad is het aantal vierkante meters van de ruimte gedeeld door het aantal personen dat aan de ruimtes is toegewezen, direct of via een werkplek, deze waarde wordt berekend",
  "models.Room.properties.freeWorkplacesCount.label": "Aantal vrije posities",
  "models.Room.properties.freeWorkplacesCount.description": "Aantal vrije posities in de ruimte",
  "models.Room.properties.flexWorkplacesCount.label": "Aantal flexposities",
  "models.Room.properties.flexWorkplacesCount.description": "Aantal flexposities in de ruimte",
  "models.Room.properties.sharedWorkplacesCount.label": "Aantal gedeelde werkstations",
  "models.Room.properties.sharedWorkplacesCount.description": "Aantal werkplekken gedeeld door minimaal 2 personen",
  "models.Room.properties.transitWorkplacesCount.label": "Aantal passerende werkplekken",
  "models.Room.properties.transitWorkplacesCount.description": "Aantal tijdelijke werkplekken, deze posities worden niet meegeteld in de vrije posities en zijn niet in flex",
  "models.Room.properties.sharedWorkplacesRatio.label": "Tarief gedeeld werkstation",
  "models.Room.properties.sharedWorkplacesRatio.description": "Percentage werkstations gedeeld door minimaal 2 personen, vergeleken met alle werkstations in de ruimte",
  "models.Room.properties.flexRatio.label": "Tarief flexwerkplekken",
  "models.Room.properties.flexRatio.description": "Het flexwerkplektarief wordt berekend door het aantal flexwerkplekken te delen door het totaal aantal werkplekken",
  "models.Room.properties.name.label": "Naam van de ruimte",
  "models.Room.properties.name.description": "De ruimtenaam wordt gebruikt om deze te definiëren en gemakkelijk te vinden.",
  "models.Room.properties.area.label": "Oppervlak",
  "models.Room.properties.area.description": "Het gekwalificeerde vloeroppervlak voor deze ruimte",
  "models.Room.properties.perimeter.label": "Omtrek",
  "models.Room.properties.perimeter.description": "De omtrek van de ruimte vertegenwoordigt de omtrek ervan",
  "models.Room.properties.costCenter.description": "Hiermee kunt u weten aan welke kostenplaats u de ruimte moet koppelen als het gaat om het beheren van de herfacturering naar de kostenplaats per ruimte",
  "models.Room.properties.distributionCostType.description": "Hiermee kunt u de methode bepalen voor het berekenen van de kostenverdeelsleutel",
  "models.Room.properties.info.label": "Extra informatie",
  "models.Room.properties.info.description": "Hiermee kunt u aanvullende teksttype-informatie over de ruimte behouden",
  "models.Room.properties.bookingEmail.label": "E-mailadres gebruikt om deze ruimte te reserveren",
  "models.Room.properties.bookingEmail.description": "Met deze e-mail kunt u deze kamer reserveren via het berichtensysteem",
  "models.Room.properties.keyCylinderCode.label": "Cilinder nummer",
  "models.Room.properties.keyCylinderCode.description": "Met het cilindernummer kunt u het cilindernummer van het ruimtedeurslot of een element dat verband houdt met de fysieke toegang tot de ruimte definiëren",
  "models.Room.reports.mouvementMatrix.fileName": "Overdrachtsmatrix",
  "models.Room.reports.mouvementMatrix.help": "Maak een overdrachtsmatrix aan in Excel waarmee u eenvoudig de verplaatsingen van uw medewerkers kunt uitvoeren",
  "models.PersonWorkingLocation.singular": "Werklocatie van mensen",
  "models.PersonWorkingLocation.plural": "Werklocaties van mensen",
  "models.PersonWorkingLocation.determinant.defined": "de werkplek van mensen",
  "models.PersonWorkingLocation.determinant.undefined": "een plek waar mensen werken",
  "models.PersonWorkingLocation.determinants.defined": "werklocaties van mensen",
  "models.PersonWorkingLocation.determinants.undefined": "werklocaties van mensen",
  "models.PersonWorkingLocation.description": "Een werkplek van mensen definieert de werkplek van mensen",
  "models.PersonWorkingLocation.views.my-planning.help": "Beheer mijn agenda voor de komende weken",
  "models.PersonWorkingLocation.views.my-planning.label": "Beheer mijn agenda",
  "models.PersonToWorkplaceBooking.singular": "Reserveren op de werkplek van mensen",
  "models.PersonToWorkplaceBooking.plural": "Reserveringen op de werkplekken van mensen",
  "models.PersonToWorkplaceBooking.description": "Werkplekreserveringen van mensen worden vastgelegd en zijn beschikbaar met de begin- en einddatum van de reservering",
  "models.PersonToWorkplaceBooking.determinant.defined": "reservering op de werkplek van mensen",
  "models.PersonToWorkplaceBooking.determinant.undefined": "een reservering op de mensenwerkplek",
  "models.PersonToWorkplaceBooking.determinants.defined": "reserveringen op de werkplekken van mensen",
  "models.PersonToWorkplaceBooking.determinants.undefined": "reserveringen op de werkplekken van mensen",
  "models.PersonToWorkplaceBooking.properties.startDatetime.label": "Begin van de boeking",
  "models.PersonToWorkplaceBooking.properties.startDatetime.description": "De startdatum en -tijd van de reservering",
  "models.PersonToWorkplaceBooking.properties.endDatetime.label": "Einde reservering",
  "models.PersonToWorkplaceBooking.properties.endDatetime.description": "De datum en tijd waarop de reservering eindigt",
  "models.PersonToWorkplaceBooking.views.dashboard-index.label": "Dashboard",
  "models.PersonToWorkplaceBooking.views.dashboard-index.help": "Dashboard van reserveringen op de werkplekken van mensen",
  "models.PersonToRoomBooking.singular": "Reservering voor het mensengedeelte",
  "models.PersonToRoomBooking.plural": "Reserveringen voor het mensengedeelte",
  "models.PersonToRoomBooking.description": "Reserveringen voor ruimtes van personen worden vastgelegd en zijn beschikbaar met de begin- en einddatum van de reservering",
  "models.PersonToRoomBooking.determinant.defined": "reserveren in de volksruimte",
  "models.PersonToRoomBooking.determinant.undefined": "een reservering voor het personengedeelte",
  "models.PersonToRoomBooking.determinants.defined": "reserveringen voor het mensengedeelte",
  "models.PersonToRoomBooking.determinants.undefined": "reserveringen voor het mensengedeelte",
  "models.PersonToRoomBooking.properties.startDatetime.label": "Begin van de boeking",
  "models.PersonToRoomBooking.properties.startDatetime.description": "De startdatum en -tijd van de reservering",
  "models.PersonToRoomBooking.properties.endDatetime.label": "Einde reservering",
  "models.PersonToRoomBooking.properties.endDatetime.description": "De datum en tijd waarop de reservering eindigt",
  "models.PersonToPersonType.singular": "Soort relatie tussen mensen",
  "models.PersonToPersonType.plural": "Soorten relaties tussen mensen",
  "models.PersonToPersonType.determinant.defined": "het soort relatie tussen mensen",
  "models.PersonToPersonType.determinant.undefined": "een soort relatie tussen mensen",
  "models.PersonToPersonType.determinants.defined": "soorten relaties tussen mensen",
  "models.PersonToPersonType.determinants.undefined": "soorten relaties tussen mensen",
  "models.PersonToPersonType.properties.labelForward.label": "Natuurlijke relatie [vooruit]",
  "models.PersonToPersonType.properties.labelForward.description": "De definitie van relatie in de natuurlijke zin, bijvoorbeeld tussen een vader en zijn zoon, de natuurlijke definitie is 'is de vader van'",
  "models.PersonToPersonType.properties.labelBackward.label": "Omgekeerde relatie",
  "models.PersonToPersonType.properties.labelBackward.description": "De definitie van relatie in de omgekeerde zin van de natuurlijke zin, bijvoorbeeld tussen een vader en zijn zoon, de omgekeerde definitie van de natuurlijke zin is 'is de zoon van'",
  "models.PersonToPerson.singular": "Persoon tot persoon relatie",
  "models.PersonToPerson.plural": "Relaties van persoon tot persoon",
  "models.PersonToPerson.determinant.defined": "relatie van persoon tot persoon",
  "models.PersonToPerson.determinant.undefined": "een relatie van persoon tot persoon",
  "models.PersonToPerson.determinants.defined": "relaties van persoon tot persoon",
  "models.PersonToPerson.determinants.undefined": "relaties van persoon tot persoon",
  "models.PersonToPerson.properties.personSource.label": "Bron persoon",
  "models.PersonToPerson.properties.personTarget.label": "Bestemmingspersoon",
  "models.PersonToDimensionBooking.singular": "Reservering voor de laag voor personentoewijzing",
  "models.PersonToDimensionBooking.plural": "Reserveringen op de laag voor personentoewijzing",
  "models.PersonToDimensionBooking.description": "Reserveringen voor toewijzingslagen voor mensen worden opgeslagen en zijn beschikbaar met begin- en einddatums voor reserveringen",
  "models.PersonToDimensionBooking.determinant.defined": "reservering op de laag voor personentoewijzing",
  "models.PersonToDimensionBooking.determinant.undefined": "een reservering op de laag voor personentoewijzing",
  "models.PersonToDimensionBooking.determinants.defined": "reserveringen op de laag voor personentoewijzing",
  "models.PersonToDimensionBooking.determinants.undefined": "reserveringen naar de laag voor personentoewijzing",
  "models.PersonToDimensionBooking.properties.startDatetime.label": "Begin van de boeking",
  "models.PersonToDimensionBooking.properties.startDatetime.description": "De startdatum en -tijd van de reservering",
  "models.PersonToDimensionBooking.properties.endDatetime.label": "Einde reservering",
  "models.PersonToDimensionBooking.properties.endDatetime.description": "De datum en tijd waarop de reservering eindigt",
  "models.PersonState.singular": "status van mensen",
  "models.PersonState.plural": "status van mensen",
  "models.PersonState.description": "Hiermee kunt u alle soorten contracten tussen mensen en het bedrijf definiëren",
  "models.PersonState.determinant.defined": "de status van mensen",
  "models.PersonState.determinant.undefined": "een status van mensen",
  "models.PersonState.determinants.defined": "de status van mensen",
  "models.PersonState.determinants.undefined": "statussen van mensen",
  "models.PersonState.properties.id.label": "Identificatie van de status van de persoon",
  "models.PersonState.properties.name.label": "Naam van persoonsstatus",
  "models.PersonToBuilding.singular": "Opdracht aan het gebouw",
  "models.PersonToBuilding.plural": "bouwopdrachten",
  "models.PersonToBuilding.description": "Hiermee kunt u een persoon aan een gebouw toewijzen, zonder aanvullende informatie. De toewijzing kan wel of niet worden meegeteld.",
  "models.PersonToBuilding.determinant.defined": "genegenheid voor het gebouw",
  "models.PersonToBuilding.determinant.undefined": "een genegenheid voor het gebouw",
  "models.PersonToBuilding.determinants.defined": "bouwomstandigheden",
  "models.PersonToBuilding.determinants.undefined": "schade aan het gebouw",
  "models.PersonToBuilding.properties.addToPeopleCount.label": "Verantwoord de toewijzing",
  "models.PersonToBuilding.properties.addToPeopleCount.description": "Voeg deze toewijzing toe aan het totaal aantal personen dat aan het gebouw is toegewezen",
  "models.PersonSecurityProfile.singular": "persoonlijk veiligheidsprofiel",
  "models.PersonSecurityProfile.plural": "levensveiligheidsprofielen",
  "models.PersonSecurityProfile.description": "Hiermee kunt u de verschillende beveiligingsprofielen definiëren die aan personen kunnen worden gekoppeld",
  "models.PersonSecurityProfile.determinant.defined": "het persoonlijke veiligheidsprofiel",
  "models.PersonSecurityProfile.determinant.undefined": "een persoonlijk veiligheidsprofiel",
  "models.PersonSecurityProfile.determinants.defined": "persoonlijke veiligheidsprofielen",
  "models.PersonSecurityProfile.determinants.undefined": "persoonlijke veiligheidsprofielen",
  "models.PersonSecurityProfile.properties.id.label": "Persoonlijke beveiligingsprofiel-ID",
  "models.PersonSecurityProfile.properties.name.label": "Naam beveiligingsprofiel",
  "models.PersonSecurityProfile.properties.name.description": "Hiermee kunt u de verschillende beveiligingsprofielen definiëren die aan personen kunnen worden gekoppeld",
  "models.PersonSecurityProfile.properties.color.label": "Kleur beveiligingsprofiel",
  "models.PersonSecurityProfile.properties.color.description": "Hiermee kunt u het toegewezen werkstation en het beveiligingspictogram van de persoon inkleuren op basis van zijn of haar beveiligingsprofiel",
  "models.PersonSecurityProfile.properties.icon.label": "Beveiligingsprofielpictogram",
  "models.PersonSecurityProfile.properties.icon.description": "Hiermee kunt u een pictogram aan een beveiligingsprofiel toewijzen om de beveiligingsprofielen op het plan of in de lijsten duidelijk te visualiseren",
  "models.PersonCompanyToRoomType.singular": "Type providerruimte",
  "models.PersonCompanyToRoomType.plural": "Soorten providerruimten",
  "models.PersonCompanyToRoomType.description": "De typen ruimtes van de dienstverleners maken het mogelijk om een ​​relatie tussen een type ruimte en de dienstverlener te definiëren en een missie te definiëren.",
  "models.PersonCompanyToRoomType.determinant.defined": "het type ruimte van de dienstverlener",
  "models.PersonCompanyToRoomType.determinant.undefined": "een type ruimte van de dienstverlener",
  "models.PersonCompanyToRoomType.determinants.defined": "de soorten ruimtes van dienstverleners",
  "models.PersonCompanyToRoomType.determinants.undefined": "soorten ruimtes van dienstverleners",
  "models.PersonGender.singular": "Geslacht van persoon",
  "models.PersonGender.plural": "Soorten mensen",
  "models.PersonGender.description": "Hiermee kunt u elk type tellen, bijvoorbeeld voor sanitairbeheer",
  "models.PersonGender.determinant.defined": "het geslacht van de persoon",
  "models.PersonGender.determinant.undefined": "een soort persoon",
  "models.PersonGender.determinants.defined": "soorten mensen",
  "models.PersonGender.determinants.undefined": "soorten mensen",
  "models.PersonGender.properties.name.label": "Naam",
  "models.PersonGender.properties.name.description": "De naam van het geslacht van de persoon",
  "models.PersonCompanyToItemType.singular": "Objecttype provider",
  "models.PersonCompanyToItemType.plural": "Objecttypen van provider",
  "models.PersonCompanyToItemType.description": "De serviceprovider-objecttypen maken het mogelijk om een ​​relatie tussen het objecttype en de serviceprovider te definiëren en de missie te definiëren.",
  "models.PersonCompanyToItemType.determinant.defined": "het type object van de dienstverlener",
  "models.PersonCompanyToItemType.determinant.undefined": "een type providerobject",
  "models.PersonCompanyToItemType.determinants.defined": "de typen objecten van dienstverleners",
  "models.PersonCompanyToItemType.determinants.undefined": "soorten objecten van dienstverleners",
  "models.PersonCompanyToItem.singular": "Interventie op een object",
  "models.PersonCompanyToItem.plural": "Interventies op objecten",
  "models.PersonCompanyToItem.description": "De interventies van dienstverleners op objecten maken het mogelijk om bijvoorbeeld de datum van een bezoek aan een brandblusser te definiëren",
  "models.PersonCompanyToItem.determinant.defined": "ingrijpen op een object",
  "models.PersonCompanyToItem.determinant.undefined": "een interventie op een object",
  "models.PersonCompanyToItem.determinants.defined": "interventies op objecten",
  "models.PersonCompanyToItem.determinants.undefined": "interventies op objecten",
  "models.PersonCompanyToItem.properties.datetime.label": "Datum en tijdstip van interventie",
  "models.PersonCompanyToItem.properties.datetime.description": "Toen de interventie plaatsvond",
  "models.PersonCompanyToItem.properties.comment.label": "Opmerking",
  "models.PersonCompanyToItem.properties.comment.description": "Een reactie op de interventie",
  "models.PersonCompanyMission.singular": "missie van de dienstverlener",
  "models.PersonCompanyMission.plural": "missies van dienstverleners",
  "models.PersonCompanyMission.description": "De missies van de dienstverleners maken het mogelijk om het interventiegebied van de dienstverleners te kennen",
  "models.PersonCompanyMission.determinant.defined": "de missie van de dienstverlener",
  "models.PersonCompanyMission.determinant.undefined": "een missie van de dienstverlener",
  "models.PersonCompanyMission.determinants.defined": "de missies van de dienstverleners",
  "models.PersonCompanyMission.determinants.undefined": "missies van dienstverleners",
  "models.PersonCompanyMission.properties.name.label": "Naam",
  "models.PersonCompanyMission.properties.name.description": "De naam van de missie van de dienstverlener",
  "models.PersonCompany.singular": "dienstverlener bedrijf",
  "models.PersonCompany.plural": "dienstverlenende bedrijven",
  "models.PersonCompany.description": "Met het dienstverlenerbedrijf kunt u het personeel van de dienstverlener per bedrijf beheren.",
  "models.PersonCompany.determinant.defined": "het dienstverlenerbedrijf",
  "models.PersonCompany.determinant.undefined": "een dienstverlenend bedrijf",
  "models.PersonCompany.determinants.defined": "dienstverlenende bedrijven",
  "models.PersonCompany.determinants.undefined": "dienstverlenende bedrijven",
  "models.PersonCompany.properties.name.label": "Naam",
  "models.PersonCompany.properties.name.description": "De naam van de dienstverlener, bijvoorbeeld de bedrijfsnaam van een dienstverlener",
  "models.PersonCompany.properties.comment.label": "Verdere informatie",
  "models.PersonCompany.properties.comment.description": "Aanvullende informatie over de dienstverlener, zoals zijn missie, zijn waarden, de functionele reikwijdte van zijn dienst, enz.",
  "models.PersonCompany.properties.contact.label": "Contact",
  "models.PersonCompany.properties.contact.description": "Contactgegevens van de dienstverlener",
  "models.PersonCompany.properties.documents.label": "Gerelateerde documenten",
  "models.PersonCompany.properties.documents.description": "De link naar de documenten die bij deze dienstverlener horen",
  "models.Person.singular": "persoon",
  "models.Person.plural": "mensen",
  "models.Person.description": "Dit zijn de personen die in de Surfy-database zijn ingevoerd",
  "models.Person.determinant.defined": "de persoon",
  "models.Person.determinant.undefined": "een persoon",
  "models.Person.determinants.defined": "de mensen",
  "models.Person.determinants.undefined": "mensen",
  "models.Person.properties.id.label": "Surfy-ID",
  "models.Person.properties.fullname.label": "Voor-en achternaam",
  "models.Person.properties.fullname.description": "De volledige naam van de persoon maakt het makkelijker om hem te vinden",
  "models.Person.properties.personState.label": "Toestand",
  "models.Person.properties.personState.description": "Hiermee kunt u aangeven welk type contract de persoon heeft met het bedrijf",
  "models.Person.properties.personSecurityProfile.label": "Beveiligingsprofiel",
  "models.Person.properties.personSecurityProfile.description": "Hiermee kunt u het beveiligingsprofiel van de persoon aangeven voor beveiligingsbeheer",
  "models.Person.properties.firstname.label": "Voornaam",
  "models.Person.properties.firstname.description": "De voornaam van de persoon",
  "models.Person.properties.lastname.label": "Achternaam",
  "models.Person.properties.lastname.description": "De achternaam van de persoon",
  "models.Person.properties.email.label": "E-mail",
  "models.Person.properties.email.description": "Het e-mailadres van de persoon",
  "models.Person.properties.picture.label": "Profielfoto",
  "models.Person.properties.picture.description": "De foto van de persoon om hem in de trombinoscoop of bij het zoeken te hebben",
  "models.Person.properties.monitorReference.label": "Schermreferentie",
  "models.Person.properties.monitorReference.description": "De referentie van het computerscherm dat bij deze persoon hoort",
  "models.Person.properties.computerReference.label": "Computerreferentie",
  "models.Person.properties.computerReference.description": "De referentie van de computer die aan deze persoon is gekoppeld",
  "models.Person.properties.cellphone.label": "Mobiele telefoon",
  "models.Person.properties.cellphone.description": "De mobiele telefoon van de persoon",
  "models.Person.properties.telephone.label": "Telefoon",
  "models.Person.properties.telephone.description": "De vaste lijn van de persoon",
  "models.Person.properties.title.label": "Titel",
  "models.Person.properties.title.description": "De titel van de persoon",
  "models.Person.properties.badgeNumber.label": "Badgenummer",
  "models.Person.properties.badgeNumber.description": "Het badgenummer van de persoon",
  "models.Person.properties.boxNumber.label": "Lockernummer",
  "models.Person.properties.boxNumber.description": "Het lockernummer van de persoon",
  "models.Person.properties.badgeRestaurant.label": "RIE-badge",
  "models.Person.properties.badgeRestaurant.description": "Dé referentie voor de RIE of bedrijfsrestaurantbadge",
  "models.Person.properties.registrationNumber.label": "Registratie",
  "models.Person.properties.registrationNumber.description": "Het registratienummer van de persoon",
  "models.Person.properties.startDate.label": "Datum van binnenkomst",
  "models.Person.properties.startDate.description": "De datum waarop de persoon bij het bedrijf is gekomen",
  "models.Person.properties.endDate.label": "Datum van publicatie",
  "models.Person.properties.endDate.description": "De datum waarop de persoon het bedrijf verlaat",
  "models.Person.properties.code.label": "Registratie nummer",
  "models.Person.properties.code.description": "Het HR-nummer van de persoon",
  "models.Person.properties.personToPersonTargets.label": "Relaties met deze persoon",
  "models.Person.properties.personToPersonTargets.description": "Hiermee kunt u de oplopende relatie tussen twee mensen kennen, bijvoorbeeld de hiërarchische relatie",
  "models.Person.properties.personToPersonSources.label": "Relaties van deze persoon",
  "models.Person.properties.personToPersonSources.description": "Hiermee kunt u de aflopende relatie tussen twee mensen kennen, bijvoorbeeld de hiërarchische relatie",
  "models.Person.properties.organization.label": "De organisatie van de persoon",
  "models.Person.properties.organization.description": "De verbindingsservice van de persoon",
  "models.Person.properties.info.label": "Opmerking",
  "models.Person.properties.info.description": "Geef commentaar op de persoon die toestaat dat aanvullende of diverse informatie wordt bewaard",
  "models.Person.properties.notAffectable.label": "Niet toewijsbaar",
  "models.Person.properties.notAffectable.description": "De persoon kan niet worden toegewezen aan een werkstation-, ruimte-, gebouw- of opdrachtlaag",
  "models.Person.views.home.help": "Bekijk het bestand van de persoon <b>%{name}</b> met zijn/haar informatie en opdrachten",
  "models.Person.views.home.label": "Persoonsbestand",
  "models.Person.views.relationship-list.help": "Maak een lijst van relaties tussen mensen",
  "models.Person.views.relationship-list.label": "Lijst met relaties",
  "models.Person.views.dq-only-associated-to-building.help": "Lijst van de toewijsbare personen die aan een gebouw zijn toegewezen en geteld zonder te zijn toegewezen (werkplek, toewijzingslaag, ruimte)",
  "models.Person.views.dq-only-associated-to-building.label": "Personen die zonder andere opdracht aan een gebouw zijn toegewezen",
  "models.Person.views.dq-near-end-date.help": "Vermeld de mensen met een einddatum van het contract na vandaag en die aan een werkplek zijn toegewezen",
  "models.Person.views.dq-near-end-date.label": "Mensen die het bedrijf verlaten",
  "models.Person.views.dq-no-affectations.label": "Mensen zonder opdrachten",
  "models.Person.views.dq-no-affectations.help": "Maak een lijst van de toewijsbare personen die geen opdrachten hebben (gebouw, werkplek, opdrachtlaag, ruimte)",
  "models.Person.views.dq-person-duplicate.label": "Dubbele mensen",
  "models.Person.views.dq-person-duplicate.help": "Maak een lijst van dubbele mensen",
  "models.PartnerApiCredential.singular": "Partner-API-sleutel",
  "models.PartnerApiCredential.plural": "Partner-API-sleutels",
  "models.PartnerApiCredential.determinant.defined": "de partner-API-sleutel",
  "models.PartnerApiCredential.determinant.undefined": "een partner-API-sleutel",
  "models.PartnerApiCredential.determinants.defined": "partner-API-sleutels",
  "models.PartnerApiCredential.determinants.undefined": "partner-API-sleutels",
  "models.PartnerApiCredential.properties.enable.label": "Ingeschakeld",
  "models.PartnerApiCredential.properties.enable.description": "U moet de sleutel activeren om deze te kunnen gebruiken",
  "models.OrganizationFloor.singular": "Organisatie van verdiepingen",
  "models.OrganizationFloor.plural": "Verdiepingsorganisaties",
  "models.OrganizationFloor.determinant.defined": "de organisatie van de verdiepingen",
  "models.OrganizationFloor.determinant.undefined": "een organisatie van verdiepingen",
  "models.OrganizationFloor.determinants.defined": "organisaties op de vloer",
  "models.OrganizationFloor.determinants.undefined": "organisaties op de vloer",
  "models.OrganizationBuilding.singular": "Organisatie van gebouwen",
  "models.OrganizationBuilding.plural": "Organisaties bouwen",
  "models.OrganizationBuilding.determinant.defined": "organisatie van gebouwen",
  "models.OrganizationBuilding.determinant.undefined": "een organisatie van gebouwen",
  "models.OrganizationBuilding.determinants.defined": "organisaties bouwen",
  "models.OrganizationBuilding.determinants.undefined": "organisaties bouwen",
  "models.Organization.singular": "organisatie",
  "models.Organization.plural": "organisaties",
  "models.Organization.determinant.defined": "de organisatie",
  "models.Organization.determinant.undefined": "een organisatie",
  "models.Organization.determinants.defined": "organisaties",
  "models.Organization.determinants.undefined": "organisaties",
  "models.Organization.description": "Organisaties hebben twee hiërarchische niveaus: directoraten en afdelingen, en maken het mogelijk om de organisatiestructuur van het bedrijf te definiëren",
  "models.Organization.properties.id.label": "Organisatie-ID",
  "models.Organization.properties.name.label": "Naam",
  "models.Organization.properties.name.description": "Naam die de organisatie definieert",
  "models.Organization.properties.code.label": "Gecodeerd",
  "models.Organization.properties.code.description": "Deze code kan worden gebruikt om de organisatiecodering te bevatten of de sleutel voor identificatie via software van derden",
  "models.Organization.properties.organizationId.label": "Beheer-ID",
  "models.Organization.properties.organizationId.description": "Dankzij deze identificatie is het mogelijk om de organisatiehiërarchie te creëren",
  "models.Organization.properties.organization.label": "Richting",
  "models.Organization.properties.organizations.label": "Diensten",
  "models.Organization.views.hierarchy.label": "Hiërarchie",
  "models.Organization.views.hierarchy.help": "Bekijk de organisatiehiërarchie",
  "models.Organization.views.dq-organization-to-room.label": "Fouten in de organisatie van ruimtes",
  "models.Organization.views.dq-organization-to-room.help": "Detecteer ruimteassociaties met organisaties die niet geldig zijn",
  "models.Organization.views.dq-organization-hierarchy.label": "Fouten in de hiërarchie van organisaties",
  "models.Organization.views.dq-organization-hierarchy.help": "Detecteer organisaties die niet in de juiste hiërarchie staan",
  "models.OpenerPostMessageHost.singular": "Berichthost voor pop-up",
  "models.OpenerPostMessageHost.plural": "Berichthosts voor pop-up",
  "models.OpenerPostMessageHost.determinant.defined": "pop-upberichthost",
  "models.OpenerPostMessageHost.determinant.undefined": "een pop-upberichthost",
  "models.OpenerPostMessageHost.determinants.defined": "hosts voor pop-upberichten",
  "models.OpenerPostMessageHost.determinants.undefined": "hosts voor pop-upberichten",
  "models.OpenerPostMessageHost.description": "Een pop-upberichthost is een element dat communiceert met een open pop-up over planacties",
  "models.OccupancyStatus.singular": "bezettingsstatus",
  "models.OccupancyStatus.plural": "bezettingstoestanden",
  "models.OccupancyStatus.determinant.defined": "de bezettingstoestand",
  "models.OccupancyStatus.determinant.undefined": "een bezettingsstaat",
  "models.OccupancyStatus.determinants.defined": "bezettingstoestanden",
  "models.OccupancyStatus.determinants.undefined": "bezettingstoestanden",
  "models.OccupancyStatus.description": "De bezettingsstatus maakt het mogelijk om de real-time status van een ruimte of werkplek te identificeren, bijvoorbeeld of deze vrij, bezet of gekraakt is, de bezettingsstatus wordt dagelijks bijgewerkt door verbonden objecten die in de ruimte aanwezig zijn",
  "models.OccupancyStatus.properties.id.label": "Identificatie van de bezettingsstatus",
  "models.OccupancyStatus.properties.name.label": "Naam van de bezettingsstatus",
  "models.OccupancyStatus.properties.color.label": "Kleur",
  "models.OccupancyStatus.properties.color.description": "Met Kleur kunt u ruimtes of werkstations op plattegronden kleuren op basis van hun bezettingsstatus",
  "models.OccupancyStatus.properties.code.label": "Bezettingsstatuscode",
  "models.OccupancyStatus.properties.code.description": "De code maakt het mogelijk om technische handelingen op de bezettingstoestand te identificeren en uit te voeren",
  "models.Object3dModel.singular": "3d model",
  "models.Object3dModel.plural": "3D-modellen",
  "models.Object3dModel.determinant.defined": "het 3D-model",
  "models.Object3dModel.determinant.undefined": "een 3D-model",
  "models.Object3dModel.determinants.defined": "3D-modellen",
  "models.Object3dModel.determinants.undefined": "3D-modellen",
  "models.Object3dModel.description": "Het 3D-model maakt een realistische 3D-weergave mogelijk van objecten die op het plan zijn geplaatst; Bij gebrek aan een 3D-model worden de objecten in volledige vorm weergegeven in de 3D-weergave",
  "models.Object3dModel.properties.origin.label": "Oriëntatie",
  "models.Object3dModel.properties.origin.description": "Gebruik X als het object naar rechts is gericht, of Y als het object naar beneden is gericht",
  "models.MapScale.singular": "vlakke schaal",
  "models.MapScale.plural": "vliegtuig schalen",
  "models.MapScale.determinant.defined": "de schaal",
  "models.MapScale.determinant.undefined": "een weegschaal",
  "models.MapScale.determinants.defined": "de weegschaal",
  "models.MapScale.determinants.undefined": "schubben",
  "models.MapScale.properties.id.label": "Schaal-ID",
  "models.MapScale.properties.p1.description": "Uitgangspunt",
  "models.MapScale.properties.p2.description": "Aankomstpunt",
  "models.MapScale.properties.name.label": "Naam van schaal",
  "models.MapScale.properties.name.description": "Om de naam te onthouden en op andere verdiepingen te hergebruiken",
  "models.MapScale.properties.length.label": "Afstand",
  "models.MapScale.properties.length.description": "De afstand weergegeven op de plattegrond tussen de 2 punten in meters",
  "models.MapScale.properties.roomTextSize.label": "Tekstgrootte van de ruimte",
  "models.MapScale.properties.roomTextSize.description": "De grootte van de tekst van de ruimtes op het plan om de weergave te optimaliseren",
  "models.MapScale.properties.workplaceTextSize.label": "Grootte van tekst op objecten",
  "models.MapScale.properties.workplaceTextSize.description": "De grootte van de tekst op werkstations en op objecten op het plan om de weergave te optimaliseren",
  "models.MapScale.properties.segmentDistanceTextSize.label": "Tekstgrootte segmenteren",
  "models.MapScale.properties.segmentDistanceTextSize.description": "De grootte van de tekst op de afstanden tussen punten op de plattegrond om de weergave te optimaliseren",
  "models.MapScale.properties.itemTypeIconSize.label": "Grootte van objecttypepictogrammen",
  "models.MapScale.properties.itemTypeIconSize.description": "De grootte van de objecttypepictogrammen op de kaart, de grootte wordt beperkt door de grootte van de ruimte",
  "models.MapScale.properties.roomIconSize.label": "Grootte van pictogrammen voor het ruimtetype",
  "models.MapScale.properties.roomIconSize.description": "De grootte van pictogrammen op de kaart in ruimtes in verhouding tot ruimtetypes",
  "models.MapScale.properties.strokeWidth.label": "Lijndikte",
  "models.MapScale.properties.strokeWidth.description": "Het is mogelijk om de dikte van de lijnen te verminderen om de leesbaarheid van de plattegrond te vergroten",
  "models.MapScale.views.dq-not-used.label": "Ongebruikte schalen",
  "models.MapScale.views.dq-not-used.help": "Bekijk schalen die niet op vloeren gebruikt worden en verwijderd kunnen worden",
  "models.MapScale.views.dq-uniq-name.label": "Voorgestelde namen voor schalen",
  "models.MapScale.views.dq-uniq-name.help": "Biedt unieke namen voor weegschalen, inclusief de verdiepingen en gebouwen waar ze worden gebruikt",
  "models.Manufacturer.singular": "Fabrikant van objecttype",
  "models.Manufacturer.plural": "Artikeltype Fabrikanten",
  "models.Manufacturer.determinant.defined": "de fabrikant van het objecttype",
  "models.Manufacturer.determinant.undefined": "een fabrikant van het objecttype",
  "models.Manufacturer.determinants.defined": "fabrikanten van objecttypen",
  "models.Manufacturer.determinants.undefined": "fabrikanten soorten objecten",
  "models.Manufacturer.properties.name.label": "Naam van de fabrikant van het objecttype",
  "models.Manufacturer.properties.name.description": "Hiermee kunt u de naam van de fabrikant of het merk identificeren",
  "models.Manufacturer.properties.website.label": "Website",
  "models.Manufacturer.properties.website.description": "Het websiteadres van de fabrikant",
  "models.Legend.singular": "Legende",
  "models.Legend.plural": "Legende",
  "models.Legend.determinant.defined": "de legende",
  "models.Legend.determinant.undefined": "een legende",
  "models.Legend.determinants.defined": "de legendes",
  "models.Legend.determinants.undefined": "legendes",
  "models.Legend.description": "Met de legenda kunt u de eigenschappen configureren die zichtbaar zijn wanneer het plan als afbeelding wordt opgeslagen",
  "models.JupUserCompanyToJupRole.singular": "Rol van de zakelijke gebruiker",
  "models.JupUserCompanyToJupRole.plural": "Enterprise-gebruikersrollen",
  "models.JupUserCompanyToJupRole.determinant.defined": "de rol van de zakelijke gebruiker",
  "models.JupUserCompanyToJupRole.determinant.undefined": "een zakelijke gebruikersrol",
  "models.JupUserCompanyToJupRole.determinants.defined": "zakelijke gebruikersrollen",
  "models.JupUserCompanyToJupRole.determinants.undefined": "zakelijke gebruikersrollen",
  "models.JupUiView.singular": "Interface-weergave",
  "models.JupUiView.plural": "Interface-weergaven",
  "models.JupUiView.determinant.defined": "de interfaceweergave",
  "models.JupUiView.determinant.undefined": "een interfaceweergave",
  "models.JupUiView.determinants.defined": "interface-weergaven",
  "models.JupUiView.determinants.undefined": "interface-weergaven",
  "models.JupUiTenantOperation.singular": "Interfacebediening voor een bedrijf",
  "models.JupUiTenantOperation.plural": "Interfacebewerkingen voor een bedrijf",
  "models.JupUiTenantOperation.determinant.defined": "de interfacewerking voor een bedrijf",
  "models.JupUiTenantOperation.determinant.undefined": "een interfaceoperatie voor een bedrijf",
  "models.JupUiTenantOperation.determinants.defined": "interfacebewerkingen voor een bedrijf",
  "models.JupUiTenantOperation.determinants.undefined": "interfacebewerkingen voor een bedrijf",
  "models.JupUiOption.singular": "Interface-optie",
  "models.JupUiOption.plural": "Interface-opties",
  "models.JupUiOption.determinant.defined": "interface-optie",
  "models.JupUiOption.determinant.undefined": "een interface-optie",
  "models.JupUiOption.determinants.defined": "interface-opties",
  "models.JupUiOption.determinants.undefined": "interface-opties",
  "models.JupUiOperation.singular": "Interface-bediening",
  "models.JupUiOperation.plural": "Interface-bewerkingen",
  "models.JupUiOperation.determinant.defined": "interface-bediening",
  "models.JupUiOperation.determinant.undefined": "een interfaceoperatie",
  "models.JupUiOperation.determinants.defined": "interface-operaties",
  "models.JupUiOperation.determinants.undefined": "interface-bewerkingen",
  "models.JupUiLayout.singular": "Visie op het plan",
  "models.JupUiLayout.plural": "Visies op het plan",
  "models.JupUiLayout.determinant.defined": "de visie op het plan",
  "models.JupUiLayout.determinant.undefined": "een visie op het plan",
  "models.JupUiLayout.determinants.defined": "de visies van het plan",
  "models.JupUiLayout.determinants.undefined": "visies op het plan",
  "models.JupRoleToJupUiView.singular": "Rollen koppelen aan interfaceweergaven",
  "models.JupRoleToJupUiView.plural": "Rolassociaties aan interfaceweergaven",
  "models.JupRoleToJupUiView.determinant.defined": "het koppelen van de rol aan interfaceweergaven",
  "models.JupRoleToJupUiView.determinant.undefined": "een koppeling van de rol aan interfaceweergaven",
  "models.JupRoleToJupUiView.determinants.defined": "Rolassociaties aan interfaceweergaven",
  "models.JupRoleToJupUiView.determinants.undefined": "rolassociaties aan interfaceweergaven",
  "models.JupRoleToJupUiView.properties.canSee.label": "Kan het uitzicht zien",
  "models.JupRoleToJupUiView.properties.canSee.description": "Zorg ervoor dat de weergave zichtbaar is voor de rol",
  "models.JupRoleToJupUiOption.singular": "Associatierol bij planvisies",
  "models.JupRoleToJupUiOption.plural": "Rolassociaties om visies te plannen",
  "models.JupRoleToJupUiOption.determinant.defined": "de associatie van de rol met de visies van het plan",
  "models.JupRoleToJupUiOption.determinant.undefined": "een associatie van de rol met de visies van het plan",
  "models.JupRoleToJupUiOption.determinants.defined": "associaties van de rol met de visies van het plan",
  "models.JupRoleToJupUiOption.determinants.undefined": "associaties van de rol met de visies van het plan",
  "models.JupRoleToJupUiOption.properties.canSee.label": "Kan optie zien",
  "models.JupRoleToJupUiOption.properties.canSee.description": "Zorg ervoor dat de optie zichtbaar is voor de rol",
  "models.JupRoleToJupUiOperation.singular": "Rolassociatie met interfacebewerkingen",
  "models.JupRoleToJupUiOperation.plural": "Rolassociatie met interfacebewerkingen",
  "models.JupRoleToJupUiOperation.determinant.defined": "het koppelen van de rol aan interfacebewerkingen",
  "models.JupRoleToJupUiOperation.determinant.undefined": "een associatie van de rol met interfacebewerkingen",
  "models.JupRoleToJupUiOperation.determinants.defined": "rolassociaties voor interfacebewerkingen",
  "models.JupRoleToJupUiOperation.determinants.undefined": "rolassociaties voor interfacebewerkingen",
  "models.JupRoleToJupObjectType.singular": "Rol-naar-objecttype-associatie",
  "models.JupRoleToJupObjectType.plural": "Rol-naar-objecttype-associaties",
  "models.JupRoleToJupObjectType.determinant.defined": "de associatie van de rol met het type object",
  "models.JupRoleToJupObjectType.determinant.undefined": "een associatie van de rol met het type object",
  "models.JupRoleToJupObjectType.determinants.defined": "de associaties van de rol met het type object",
  "models.JupRoleToJupObjectType.determinants.undefined": "associaties van de rol met het type object",
  "models.JupRoleToJupObjectType.properties.arCreate.label": "Schepping (C)",
  "models.JupRoleToJupObjectType.properties.arCreate.description": "Autoriseert het maken van entiteiten",
  "models.JupRoleToJupObjectType.properties.arRead.label": "Lezen (R)",
  "models.JupRoleToJupObjectType.properties.arRead.description": "Maakt het lezen van entiteiten mogelijk",
  "models.JupRoleToJupObjectType.properties.arUpdate.label": "Bijwerken (U)",
  "models.JupRoleToJupObjectType.properties.arUpdate.description": "Maakt het bijwerken van entiteiten mogelijk",
  "models.JupRoleToJupObjectType.properties.arDelete.label": "Verwijdering (D)",
  "models.JupRoleToJupObjectType.properties.arDelete.description": "Maakt het verwijderen van entiteiten mogelijk",
  "models.JupRole.singular": "Rol",
  "models.JupRole.plural": "Rollen",
  "models.JupRole.determinant.defined": "de rol",
  "models.JupRole.determinant.undefined": "een rol",
  "models.JupRole.determinants.defined": "de rollen",
  "models.JupRole.determinants.undefined": "rollen",
  "models.JupRole.views.matrix.help": "De %{name} rolbeveiligingsmatrix",
  "models.JupRole.views.matrix.label": "Matrix",
  "models.JupRole.views.help.help": "Samenvatting van rolrechten",
  "models.JupRole.views.help.label": "Hulp",
  "models.JupObjectType.singular": "Entiteitstype",
  "models.JupObjectType.plural": "Entiteitstypen",
  "models.JupObjectType.determinant.defined": "het entiteitstype",
  "models.JupObjectType.determinant.undefined": "een soort entiteit",
  "models.JupObjectType.determinants.defined": "entiteitstypen",
  "models.JupObjectType.determinants.undefined": "entiteitstypen",
  "models.ItemTypePoint.singular": "Punt van objecttypen",
  "models.ItemTypePoint.plural": "Punten van objecttypen",
  "models.ItemTypePoint.determinant.defined": "punt van objecttypen",
  "models.ItemTypePoint.determinant.undefined": "een punt van objecttypen",
  "models.ItemTypePoint.determinants.defined": "punten van objecttypen",
  "models.ItemTypePoint.determinants.undefined": "punten van objecttypen",
  "models.ItemTypePoint.properties.id.label": "Identificatie",
  "models.ItemTypePoint.properties.id.description": "???",
  "models.ItemTypePoint.properties.x.label": "X",
  "models.ItemTypePoint.properties.x.description": "???",
  "models.ItemTypePoint.properties.y.label": "j",
  "models.ItemTypePoint.properties.y.description": "???",
  "models.ItemTypePoint.properties.externalId.label": "Externe identificatie",
  "models.ItemTypePoint.properties.externalId.description": "???",
  "models.ItemTypePoint.properties.itemTypeId.label": "Objecttype-ID",
  "models.ItemTypePoint.properties.itemTypeId.description": "???",
  "models.ItemTypePoint.properties.sortIndex.label": "Sorteerindex",
  "models.ItemTypePoint.properties.sortIndex.description": "???",
  "models.ItemTypePoint.properties.itemType.label": "Object type",
  "models.ItemTypePoint.properties.itemType.description": "???",
  "models.ItemTypeFamily.singular": "familie van objecttypen",
  "models.ItemTypeFamily.plural": "objecttypefamilies",
  "models.ItemTypeFamily.determinant.defined": "de familie van objecttypen",
  "models.ItemTypeFamily.determinant.undefined": "een familie van objecttypen",
  "models.ItemTypeFamily.determinants.defined": "objecttypefamilies",
  "models.ItemTypeFamily.determinants.undefined": "families van objecttypen",
  "models.ItemTypeFamily.description": "Hiermee kunt u objecten per Familie weergeven op de plattegronden en in de pdf-inventaris",
  "models.ItemTypeFamily.properties.id.label": "Identificatie van de typefamilie van het object",
  "models.ItemTypeFamily.properties.name.label": "Naam van de typefamilie van het object",
  "models.ItemTypeFamily.properties.name.description": "De naam van de familie maakt identificatie mogelijk, deze naam wordt gebruikt om de soorten objecten te groeperen",
  "models.ItemType.singular": "object type",
  "models.ItemType.plural": "objecttypen",
  "models.ItemType.determinant.defined": "het soort voorwerp",
  "models.ItemType.determinant.undefined": "een soort voorwerp",
  "models.ItemType.determinants.defined": "objecttypen",
  "models.ItemType.determinants.undefined": "objecttypen",
  "models.ItemType.properties.id.label": "Objecttype-ID",
  "models.ItemType.properties.id.description": "Objecttype-ID",
  "models.ItemType.properties.description.label": "Beschrijving",
  "models.ItemType.properties.description.description": "Hiermee kunt u aanvullende informatie krijgen over het type object",
  "models.ItemType.properties.name.label": "Naam objecttype",
  "models.ItemType.properties.name.description": "Hiermee kunt u snel het type object identificeren met een volledige, logische en beschrijvende naam; De afmetingen kun je aangeven, bijvoorbeeld: Vergadertafel 340x120; Tip: begin altijd met de grootste maat",
  "models.ItemType.properties.zIndex.label": "Hoogte-index",
  "models.ItemType.properties.zIndex.description": "Hoe hoger de hoogte-index, hoe meer het object boven de andere zal worden gepositioneerd; Het kan negatief zijn; bijvoorbeeld voor een stoel: -1; Tip: voor pictogrammen stelt u de index in op 9",
  "models.ItemType.properties.picture.label": "Foto",
  "models.ItemType.properties.picture.description": "Hiermee kunt u de foto van het type object laden, die zichtbaar zal zijn in de inventaris in PDF en op het blad van het object dat op het plan is geselecteerd",
  "models.ItemType.properties.iconShape.label": "Pictogramvorm",
  "models.ItemType.properties.iconShape.description": "Door de vorm van het pictogram kunt u de weergave ervan op de kaart beïnvloeden",
  "models.ItemType.properties.displayItemReferenceInMap.label": "Toon planinformatie",
  "models.ItemType.properties.displayItemReferenceInMap.description": "Hiermee kunt u het veld “Referentie” van elk object op het plan weergeven",
  "models.ItemType.properties.code.label": "Gecodeerd",
  "models.ItemType.properties.code.description": "Hiermee kunt u snel toegang krijgen tot het objecttype door de code in de zoekopdracht te typen tijdens het maken van het object",
  "models.ItemType.properties.icon.label": "Icoon",
  "models.ItemType.properties.icon.description": "Geeft u toegang tot drie soorten pictogrammen: 1) “Fontawsome”-pictogrammen, zichtbaar door “alles weergeven” aan te vinken of door in het zoekvak op trefwoord in het Engels te zoeken; 2) “SURFY”-iconen bedoeld voor illustraties toegevoegd aan plannen op strategische locaties (toiletten, trappen, liften, kopieerpunten, enz.) maar die ook kunnen worden gebruikt als klassieke iconen; 3) De “SURFY 2”-pictogrammen met de wettelijke pictogrammen van de ISO 7010-veiligheidsnorm; Hun vorm kan rond, vierkant of driehoekig zijn",
  "models.ItemType.properties.color.label": "Kleur",
  "models.ItemType.properties.color.description": "Kan worden gekozen uit een voorselectie, of uit een geavanceerde selectie via Hexa- of RGB-code om uw grafische charter te respecteren",
  "models.ItemType.properties.height.label": "Hoogte",
  "models.ItemType.properties.height.description": "Hiermee kunt u de hoogte in centimeters van het type object in 3D-weergave weergeven",
  "models.ItemType.properties.price.label": "Prijs",
  "models.ItemType.properties.price.description": "De aankoopprijs van het artikeltype",
  "models.ItemType.properties.seatsCount.label": "aantal zitplaatsen",
  "models.ItemType.properties.seatsCount.description": "Het aantal zitplaatsen voor dit type object (fauteuil, stoel, bank etc.) wordt in Surfy opgeteld per ruimte, verdieping en gebouw",
  "models.ItemType.properties.manufacturer.description": "Hiermee kunt u de fabrikant van het objecttype identificeren",
  "models.ItemType.properties.carbonFootprint.label": "Koolstofvoetafdruk",
  "models.ItemType.properties.carbonFootprint.description": "De CO2-voetafdruk is het gewicht in kilogram CO2 dat wordt uitgestoten door elk object van dit type object; het wordt gegeven door de fabrikant",
  "models.ItemType.properties.iconBackgroundColor.label": "Achtergrondkleur van het pictogram",
  "models.ItemType.properties.iconBackgroundColor.description": "Met de achtergrondkleur kunt u meerkleurige pictogrammen, vooral driehoekige, correct configureren.",
  "models.ItemType.properties.iconBorderColor.label": "Randkleur van het pictogram",
  "models.ItemType.properties.iconBorderColor.description": "Met de randkleur kunt u meerkleurige pictogrammen correct configureren, vooral driehoekige.",
  "models.ItemType.properties.isAffectable.label": "Is het te associëren met een persoon?",
  "models.ItemType.properties.isAffectable.description": "Hiermee kunt u weten of het type object aan een persoon kan worden gekoppeld",
  "models.ItemType.properties.excludeFromPathfinding.label": "Schakel navigatie in",
  "models.ItemType.properties.excludeFromPathfinding.description": "Hiermee kunt u navigatie voor dit type object inschakelen",
  "models.ItemType.views.shape-editor.help": "Vorm van objecttype %{name} bewerken",
  "models.ItemType.views.shape-editor.label": "Vorm bewerken",
  "models.ItemType.views.avatar.help": "Zie de vorm van %{name}",
  "models.ItemType.views.avatar.label": "Vorm",
  "models.ItemType.views.dq-not-used.label": "Niet gebruikt",
  "models.ItemType.views.dq-not-used.help": "Maak een lijst van alle ongebruikte objecttypen via objecten of via ongebruikte werkstationtypen",
  "models.ItemToPerson.singular": "Associatie van object tot persoon",
  "models.ItemToPerson.plural": "Object-tot-persoon-associaties",
  "models.ItemToPerson.description": "Hiermee kunt u een object aan een persoon koppelen (ergonomische stoel, kluisje)",
  "models.ItemToPerson.determinant.defined": "de associatie van object met persoon",
  "models.ItemToPerson.determinant.undefined": "een associatie van object met persoon",
  "models.ItemToPerson.determinants.defined": "object-tot-persoon associaties",
  "models.ItemToPerson.determinants.undefined": "object-tot-persoon associaties",
  "models.ItemFact.singular": "Objectbeweging",
  "models.ItemFact.plural": "Objectbewegingen",
  "models.ItemFact.determinant.defined": "de beweging van een object",
  "models.ItemFact.determinant.undefined": "een beweging van een object",
  "models.ItemFact.determinants.defined": "objectbewegingen",
  "models.ItemFact.determinants.undefined": "objectbewegingen",
  "models.Item.singular": "voorwerp",
  "models.Item.plural": "voorwerpen",
  "models.Item.determinant.defined": "het object",
  "models.Item.determinant.undefined": "een voorwerp",
  "models.Item.determinants.defined": "Artikelen",
  "models.Item.determinants.undefined": "Voorwerpen",
  "models.Item.views.dq-item-not-in-workplace-room.label": "Objectruimten verschillen van werkstationruimten",
  "models.Item.views.dq-item-not-in-workplace-room.help": "Lijst met fysieke objecten op werkstations die zich in ruimtes bevinden die verschillen van de werkstationruimten",
  "models.Item.properties.id.label": "Object-ID",
  "models.Item.properties.price.label": "Prijs",
  "models.Item.properties.price.description": "De aankoopprijs van het artikel als deze afwijkt van de prijs van het artikeltype",
  "models.Item.properties.reference.label": "Objectreferentie",
  "models.Item.properties.reference.description": "De objectreferentie wordt gebruikt om het te vinden en om dit object van anderen te onderscheiden",
  "models.Item.properties.code.label": "Startonderbrekercode",
  "models.Item.properties.code.description": "Het activanummer wordt gebruikt om het boekhoudnummer bij te houden",
  "models.Item.properties.purchaseDate.label": "Aankoopdatum",
  "models.Item.properties.purchaseDate.description": "De datum waarop het artikel is gekocht",
  "models.Item.properties.room.label": "Objectruimte",
  "models.Item.properties.itemAffectationsCount.label": "Aantal associaties met mensen",
  "models.Item.properties.itemAffectationsCount.description": "Het aantal associaties van dit object met mensen",
  "models.Floor.singular": "vloer",
  "models.Floor.plural": "vloeren",
  "models.Floor.determinant.defined": "de vloer",
  "models.Floor.determinant.undefined": "een vloer",
  "models.Floor.determinants.defined": "De vloeren",
  "models.Floor.determinants.undefined": "vloeren",
  "models.Floor.description": "De vloeren vertegenwoordigen een werkoppervlak of een niveau van een gebouw",
  "models.Floor.views.map.help": "De plattegrond %{name} in 2d",
  "models.Floor.views.map.label": "2d vliegtuig",
  "models.Floor.views.3d.help": "De plattegrond %{name} in 3d",
  "models.Floor.views.3d.label": "3D-plan",
  "models.Floor.views.cuby.help": "De plattegrond %{name} in 3d",
  "models.Floor.views.cuby.label": "3d",
  "models.Floor.views.simple-list.help": "Maak een lijst van de verdiepingen met weinig details",
  "models.Floor.views.simple-list.label": "Eenvoudige lijst",
  "models.Floor.views.geojson.help": "Zie de informatie in GeoJson",
  "models.Floor.views.geojson.label": "Kopieer GeoJson-coördinaten",
  "models.Floor.views.standalone-2d-map.help": "De plattegrond %{name} in 2d zonder menu",
  "models.Floor.views.standalone-2d-map.label": "Alleen 2D-plan",
  "models.Floor.properties.id.label": "Verdieping-ID",
  "models.Floor.properties.name.label": "Naam verdieping",
  "models.Floor.properties.name.description": "De naam van de verdieping wordt gebruikt om deze gemakkelijk vindbaar te maken.",
  "models.Floor.properties.level.label": "Niveau",
  "models.Floor.properties.level.description": "Dankzij het niveau van de verdieping kunt u de positie ervan ten opzichte van de andere verdiepingen bepalen, gebruik bijvoorbeeld 0 voor de begane grond of -1 voor de parkeerplaatsen",
  "models.Floor.properties.backgroundLayout.label": "Achtergrond",
  "models.Floor.properties.backgroundLayout.description": "Met het achtergrondplan kunt u een eerste laagniveau hebben om de plannen opnieuw te kunnen tekenen, het moet op schaal zijn",
  "models.Floor.properties.backgroundLayoutOpacity.label": "Achtergronddekking",
  "models.Floor.properties.backgroundLayoutOpacity.description": "Met dekking kunt u meer of minder van de achtergrond zien",
  "models.Floor.properties.regulatoryCapacity.label": "Regelgevende capaciteit",
  "models.Floor.properties.regulatoryCapacity.description": "De regelgevende capaciteit van het platform maakt het mogelijk om de evacuatie van publiek en werknemers te beheren",
  "models.Floor.properties.pathfindingGraph.label": "Vloernavigatiegrafiek",
  "models.Floor.properties.pathfindingGraph.description": "Met de navigatiegrafiek kunt u de kortste paden tussen punten op de vloer berekenen",
  "models.Floor.properties.workplacesCount.label": "Aantal werkstations",
  "models.Floor.properties.workplacesCount.description": "Het aantal werkplekken op de verdieping wordt automatisch berekend",
  "models.Floor.properties.workplacesRatio.label": "Werkstationverhouding",
  "models.Floor.properties.workplacesRatio.description": "De werkplekverhouding is het aantal vierkante meters op de verdieping gedeeld door het aantal werkplekken, deze waarde wordt automatisch berekend",
  "models.Floor.properties.peopleCount.label": "Aantal opdrachten",
  "models.Floor.properties.peopleCount.description": "Het aantal mensen dat aan de verdieping is toegewezen, hetzij rechtstreeks aan ruimtes, hetzij via een werkstation",
  "models.Floor.properties.totalPeopleCount.label": "Totaal aantal opdrachten",
  "models.Floor.properties.totalPeopleCount.description": "Het aantal mensen dat aan de verdieping is toegewezen, hetzij rechtstreeks aan ruimtes, hetzij via een werkstation",
  "models.Floor.properties.peopleRatio.label": "Bezettingsgraad",
  "models.Floor.properties.peopleRatio.description": "De bezettingsgraad is het aantal vierkante meters op de verdieping gedeeld door het aantal personen dat direct of via een werkplek aan de ruimtes is toegewezen, deze waarde wordt berekend",
  "models.Floor.properties.freeWorkplacesCount.label": "Aantal vrije posities",
  "models.Floor.properties.freeWorkplacesCount.description": "Aantal vrije posities op de vloer",
  "models.Floor.properties.flexWorkplacesCount.label": "Aantal flexposities",
  "models.Floor.properties.flexWorkplacesCount.description": "Aantal flexposities op de vloer",
  "models.Floor.properties.roomsArea.label": "Gekwalificeerd oppervlak",
  "models.Floor.properties.roomsArea.description": "Het gekwalificeerde oppervlak is de som van de oppervlakken van de ruimtes",
  "models.Floor.properties.roomsCount.label": "Aantal spaties",
  "models.Floor.properties.roomsCount.description": "Het aantal aanwezige ruimtes op deze verdieping",
  "models.Floor.properties.sharedWorkplacesCount.label": "Aantal gedeelde werkstations",
  "models.Floor.properties.sharedWorkplacesCount.description": "Aantal werkplekken gedeeld op de verdieping door minimaal 2 personen",
  "models.Floor.properties.sharedWorkplacesRatio.label": "Tarief gedeeld werkstation",
  "models.Floor.properties.sharedWorkplacesRatio.description": "Percentage werkplekken gedeeld door minimaal 2 personen vergeleken met alle werkplekken op de verdieping",
  "models.Floor.properties.flexRatio.label": "Tarief flexwerkplekken",
  "models.Floor.properties.flexRatio.description": "Het flexwerkplektarief wordt berekend door het aantal flexwerkplekken te delen door het totaal aantal werkplekken",
  "models.Floor.properties.transitWorkplacesCount.label": "Aantal passerende werkplekken",
  "models.Floor.properties.transitWorkplacesCount.description": "Aantal tijdelijke werkplekken, deze posities worden niet meegeteld in de vrije posities en zijn niet in flex",
  "models.Floor.properties.height.label": "Plafondhoogte",
  "models.Floor.properties.height.description": "Plafondhoogte van de eerste verdieping",
  "models.Floor.properties.mapScale.label": "Schaal plannen",
  "models.Floor.properties.mapScale.description": "Dankzij de schaal kunnen we de werkelijke oppervlakten en afmetingen van objecten proportioneel berekenen",
  "models.FactType.singular": "Soort feit",
  "models.FactType.plural": "Feittypen",
  "models.FactType.determinant.defined": "het soort feit",
  "models.FactType.determinant.undefined": "een soort feit",
  "models.FactType.determinants.defined": "soorten feiten",
  "models.FactType.determinants.undefined": "soorten feiten",
  "models.Fact.singular": "Doen",
  "models.Fact.plural": "Feiten",
  "models.Fact.determinant.defined": "het feit",
  "models.Fact.determinant.undefined": "een feit",
  "models.Fact.determinants.defined": "feiten",
  "models.Fact.determinants.undefined": "feiten",
  "models.DistributionCostType.singular": "soort kostenverdeling",
  "models.DistributionCostType.plural": "soorten kostenverdeling",
  "models.DistributionCostType.determinant.defined": "het type kostenverdeling",
  "models.DistributionCostType.determinant.undefined": "een vorm van kostenverdeling",
  "models.DistributionCostType.determinants.defined": "soorten kostenverdeling",
  "models.DistributionCostType.determinants.undefined": "soorten kostenverdeling",
  "models.DistributionCostType.properties.name.label": "Naam van het type kostenverdeling",
  "models.DistributionCostType.properties.code.labe": "Gecodeerd",
  "models.DistributionCostType.properties.code.description": "De code wordt gebruikt om automatisch de bijbehorende kosten te kunnen berekenen",
  "models.DimensionTypeToBuilding.singular": "Type bouwopdrachtlaag",
  "models.DimensionTypeToBuilding.plural": "Soorten bouwopgavelagen",
  "models.DimensionTypeToBuilding.determinant.defined": "het type bouwopgavelaag",
  "models.DimensionTypeToBuilding.determinant.undefined": "een soort bouwopdrachtlaag",
  "models.DimensionTypeToBuilding.determinants.defined": "de typen bouwopgavelagen",
  "models.DimensionTypeToBuilding.determinants.undefined": "soorten bouwopgavelagen",
  "models.DimensionTypeToBuilding.description": "Met de typen bouwopgavelagen kunt u de verschillende typen bouwopgavelagen definiëren. Door een type toewijzingslaag aan een gebouw te koppelen, kunt u een analyselaag transformeren in een toewijzingslaag.",
  "models.DimensionType.singular": "Laagtype",
  "models.DimensionType.plural": "Laagtypen",
  "models.DimensionType.determinant.defined": "het type laag",
  "models.DimensionType.determinant.undefined": "een soort laag",
  "models.DimensionType.determinants.defined": "soorten lagen",
  "models.DimensionType.determinants.undefined": "laagsoorten per verdieping",
  "models.DimensionType.properties.id.label": "Identificatie van het dimensietype",
  "models.DimensionType.properties.order.label": "volgorde van verschijnen",
  "models.DimensionType.properties.order.description": "Hiermee kunt u laagtypen sorteren om ze weer te geven",
  "models.DimensionType.properties.name.label": "Naam van dimensietype",
  "models.DimensionType.properties.code.label": "Code van het dimensietype",
  "models.DimensionType.properties.code.description": "Met de code kunt u het type dimensie identificeren. Deze wordt gebruikt wanneer specifieke berekeningen van toepassing zijn op het type dimensie",
  "models.DimensionToPerson.singular": "Toewijzing aan toewijzingslaag",
  "models.DimensionToPerson.plural": "Toewijzingen aan toewijzingslagen",
  "models.DimensionToPerson.description": "Hiermee kunt u een persoon toewijzen aan een district, gebied of dorp",
  "models.DimensionToPerson.determinant.defined": "toewijzing naar toewijzingslaag",
  "models.DimensionToPerson.determinant.undefined": "een toewijzing aan de toewijzingslaag ",
  "models.DimensionToPerson.determinants.defined": "toewijzingen aan toewijzingslagen",
  "models.DimensionToPerson.determinants.undefined": "toewijzingen aan toewijzingslagen",
  "models.DimensionRoom.singular": "Ruimteanalyselaag",
  "models.DimensionRoom.plural": "Lagen voor ruimteanalyse",
  "models.DimensionRoom.determinant.defined": "de ruimteanalyselaag",
  "models.DimensionRoom.determinant.undefined": "een ruimteanalyselaag",
  "models.DimensionRoom.determinants.defined": "lagen voor ruimteanalyse",
  "models.DimensionRoom.determinants.undefined": "lagen voor ruimteanalyse",
  "models.DimensionRoom.properties.id.label": "Identificatie van de ruimteanalyselaag",
  "models.DimensionFloor.singular": "Analyselaag per verdieping",
  "models.DimensionFloor.plural": "Analyselagen per verdieping",
  "models.DimensionFloor.determinant.defined": "de analyse laag voor verdieping",
  "models.DimensionFloor.determinant.undefined": "één analyselaag per verdieping",
  "models.DimensionFloor.determinants.defined": "analyselagen per verdieping",
  "models.DimensionFloor.determinants.undefined": "analyselagen per verdieping",
  "models.DimensionFloor.properties.id.label": "Identificatie van de analyselaag per verdieping",
  "models.DimensionFloor.properties.peopleCount.label": "Aantal opdrachten",
  "models.DimensionFloor.properties.peopleCount.description": "Het aantal toegewezen personen, hetzij rechtstreeks toegewezen aan ruimtes, hetzij via een werkplek voor deze verdieping",
  "models.DimensionFloor.properties.totalPeopleCount.label": "Totaal aantal indirecte opdrachten op de vloer",
  "models.DimensionFloor.properties.totalPeopleCount.description": "Het totale aantal mensen dat indirect aan de verdieping is toegewezen, hetzij rechtstreeks aan ruimtes, hetzij via een werkstation, maar niet via de toewijzingslagen die zich alleen op gebouwniveau bevinden",
  "models.DimensionBuilding.singular": "Analyse laag per gebouw",
  "models.DimensionBuilding.plural": "Analyselagen per gebouw",
  "models.DimensionBuilding.determinant.defined": "de analyselaag door te bouwen",
  "models.DimensionBuilding.determinant.undefined": "één analyselaag per gebouw",
  "models.DimensionBuilding.determinants.defined": "analyselagen door te bouwen",
  "models.DimensionBuilding.determinants.undefined": "analyselagen per gebouw",
  "models.DimensionBuilding.properties.id.label": "Identificatie van de analyselaag per gebouw",
  "models.DimensionBuilding.properties.dimensionPeopleCount.label": "Aantal toewijzingen rechtstreeks naar deze toewijzingslaag",
  "models.DimensionBuilding.properties.dimensionPeopleCount.description": "Het aantal mensen dat voor het gehele gebouw aan deze opdrachtlaag is toegewezen",
  "models.DimensionBuilding.properties.totalPeopleCount.label": "Totaal aantal opdrachten",
  "models.DimensionBuilding.properties.totalPeopleCount.description": "Het totale aantal toegewezen personen, hetzij direct toegewezen aan ruimtes, hetzij via een werkstation, of via een toewijzingslaag",
  "models.Dimension.singular": "Analyse laag",
  "models.Dimension.plural": "Analyse lagen",
  "models.Dimension.determinant.defined": "de analyselaag",
  "models.Dimension.determinant.undefined": "een analyselaag",
  "models.Dimension.determinants.defined": "analyse lagen",
  "models.Dimension.determinants.undefined": "analyse lagen",
  "models.Dimension.properties.id.label": "Identificatie van analyselaag",
  "models.Dimension.properties.id.description": "Surfy interne identificatie",
  "models.Dimension.properties.name.label": "Naam van analyselaag",
  "models.Dimension.properties.name.description": "Handig om onder andere de laag te differentiëren",
  "models.Dimension.properties.color.label": "Kleur",
  "models.Dimension.properties.color.description": "Met de kleur van de analyselaag kunt u ruimtes op het plan onderscheiden",
  "models.Dimension.properties.value.label": "Numerieke waarde",
  "models.Dimension.properties.value.description": "De waarde kan worden gebruikt om de laag te associëren met een numerieke waarde om analytische statistieken te kunnen produceren",
  "models.Dimension.properties.peopleCount.label": "Aantal directe opdrachten",
  "models.Dimension.properties.peopleCount.description": "Het aantal mensen dat rechtstreeks aan deze opdrachtlaag in het gebouw is toegewezen",
  "models.Dimension.properties.manualPeopleCount.label": "Aantal directe handmatige opdrachten",
  "models.Dimension.properties.manualPeopleCount.description": "Het aantal mensen dat rechtstreeks aan deze opdrachtlaag is toegewezen zonder rekening te houden met opdrachten met echte mensen",
  "models.Dimension.properties.totalPeopleCount.label": "Totaal aantal directe opdrachten",
  "models.Dimension.properties.totalPeopleCount.description": "Het totaal aantal mensen dat direct aan deze toewijzingslaag in het gebouw is toegewezen, de optelling van de daadwerkelijk toegewezen mensen en het aantal handmatig toegewezen mensen",
  "models.Dimension.properties.carbonFootprintPerMeter.label": "Koolstofvoetafdruk per vierkante meter",
  "models.Dimension.properties.carbonFootprintPerMeter.description": "Met de CO2-voetafdruk per vierkante meter kunt u de CO2-voetafdruk in kilogrammen CO2 van een analyselaag per vierkante meter berekenen",
  "models.CostCenterFloor.singular": "kostenplaats van de verdieping",
  "models.CostCenterFloor.plural": "kostenplaatsen op de vloer",
  "models.CostCenterFloor.determinant.defined": "de kostenplaats van de vloeren ",
  "models.CostCenterFloor.determinant.undefined": "een vloerkostenplaats",
  "models.CostCenterFloor.determinants.defined": "kostenplaatsen op de vloer",
  "models.CostCenterFloor.determinants.undefined": "kostenplaatsen op de vloer",
  "models.CostCenterBuilding.singular": "kostenplaats bouwen",
  "models.CostCenterBuilding.plural": "kostenplaatsen bouwen",
  "models.CostCenterBuilding.determinant.defined": "de kostenplaats van gebouwen ",
  "models.CostCenterBuilding.determinant.undefined": "een bouwkostenpost",
  "models.CostCenterBuilding.determinants.defined": "kostenplaatsen bouwen",
  "models.CostCenterBuilding.determinants.undefined": "kostenplaatsen bouwen",
  "models.CostCenter.singular": "kostenplaats",
  "models.CostCenter.plural": "kostencentra",
  "models.CostCenter.description": "Met de kostenplaats kunt u ruimtes dynamisch verdelen voor herfacturatie",
  "models.CostCenter.determinant.defined": "de kostenplaats",
  "models.CostCenter.determinant.undefined": "een kostenplaats",
  "models.CostCenter.determinants.defined": "kostencentra",
  "models.CostCenter.determinants.undefined": "kostencentra",
  "models.CostCenter.properties.id.label": "Identificatie van de kostenplaats",
  "models.CostCenter.properties.name.label": "Naam kostenplaats",
  "models.CostCenter.properties.color.label": "Kleur",
  "models.CostCenter.properties.distributeByFloor.label": "Verdeel per verdieping",
  "models.CostCenter.properties.distributeByFloor.description": "Verdeel de ruimte die deze kostenplaats op de verdieping in beslag neemt, evenredig aan die van andere kostenplaatsen op dezelfde verdieping",
  "models.CostCenter.properties.distributeByBuilding.label": "Verdeel door te bouwen",
  "models.CostCenter.properties.distributeByBuilding.description": "Verdeel de ruimte die deze kostenplaats in het gebouw in beslag neemt evenredig aan de andere kostenplaatsen in het gebouw",
  "models.ContentRoleToUserCompany.singular": "Rol zakelijke gebruikersinhoud",
  "models.ContentRoleToUserCompany.plural": "Inhoudsrollen voor zakelijke gebruikers",
  "models.ContentRoleToUserCompany.determinant.defined": "de inhoudsrol van zakelijke gebruikers",
  "models.ContentRoleToUserCompany.determinant.undefined": "een inhoudsrol voor zakelijke gebruikers",
  "models.ContentRoleToUserCompany.determinants.defined": "Inhoudsrollen voor zakelijke gebruikers",
  "models.ContentRoleToUserCompany.determinants.undefined": "inhoudsrollen voor zakelijke gebruikers",
  "models.ContentRoleToJupUiTenantOperation.singular": "De inhoudsrol koppelen aan interfacebewerkingen voor een onderneming",
  "models.ContentRoleToJupUiTenantOperation.plural": "De inhoudsrol koppelen aan interfacebewerkingen voor een onderneming",
  "models.ContentRoleToJupUiTenantOperation.determinant.defined": "het koppelen van de inhoudsrol aan interfacebewerkingen voor een onderneming",
  "models.ContentRoleToJupUiTenantOperation.determinant.undefined": "een koppeling van de inhoudsrol met interfacebewerkingen voor een onderneming",
  "models.ContentRoleToJupUiTenantOperation.determinants.defined": "inhoudsrolassociaties om bewerkingen voor een onderneming te interfacen",
  "models.ContentRoleToJupUiTenantOperation.determinants.undefined": "associaties van inhoudsrollen met interface-activiteiten voor een onderneming",
  "models.ContentRoleToFloor.singular": "Associatierol van inhoud aan verhalen",
  "models.ContentRoleToFloor.plural": "Associaties van inhoudsrollen met verhalen",
  "models.ContentRoleToFloor.determinant.defined": "de associatie van de inhoudsrol met de verhalen",
  "models.ContentRoleToFloor.determinant.undefined": "een koppeling van de inhoudsrol aan de verdiepingen",
  "models.ContentRoleToFloor.determinants.defined": "associaties van de inhoudsrol met de verdiepingen",
  "models.ContentRoleToFloor.determinants.undefined": "associaties van de inhoudsrol met de verdiepingen",
  "models.ContentRoleToBuilding.singular": "Associatie-inhoudsrol voor gebouwen",
  "models.ContentRoleToBuilding.plural": "Associaties van inhoudsrollen aan gebouwen",
  "models.ContentRoleToBuilding.determinant.defined": "het associëren van de inhoudsrol met gebouwen",
  "models.ContentRoleToBuilding.determinant.undefined": "een associatie van de inhoudsrol met gebouwen",
  "models.ContentRoleToBuilding.determinants.defined": "associaties van de inhoudsrol met gebouwen",
  "models.ContentRoleToBuilding.determinants.undefined": "associaties van de inhoudsrol met gebouwen",
  "models.ContentRole.singular": "Inhoudelijke rol",
  "models.ContentRole.plural": "Inhoudelijke rollen",
  "models.ContentRole.determinant.defined": "de rol van de inhoud",
  "models.ContentRole.determinant.undefined": "een inhoudelijke rol",
  "models.ContentRole.determinants.defined": "inhoud rollen",
  "models.ContentRole.determinants.undefined": "inhoud rollen",
  "models.CompanyType.singular": "type bedrijf",
  "models.CompanyType.plural": "soort bedrijven",
  "models.CompanyType.determinant.defined": "het soort bedrijf",
  "models.CompanyType.determinant.undefined": "een soort bedrijf",
  "models.CompanyType.determinants.defined": "soorten bedrijven",
  "models.CompanyType.determinants.undefined": "soorten bedrijven",
  "models.CompanyType.properties.name.label": "Naam bedrijfstype",
  "models.Company.singular": "onderneming",
  "models.Company.plural": "bedrijven",
  "models.Company.determinant.defined": "het bedrijf",
  "models.Company.determinant.undefined": "een bedrijf",
  "models.Company.determinants.defined": "ondernemingen",
  "models.Company.determinants.undefined": "bedrijven",
  "models.Company.properties.id.label": "bedrijfs ID",
  "models.Company.properties.logoPath.label": "Logo",
  "models.Company.properties.logoPath.description": "Het pad naar uw bedrijfslogo",
  "models.Company.properties.iconPath.label": "icoon",
  "models.Company.properties.iconPath.description": "Het bedrijfslogo in vierkant",
  "models.Company.properties.name.label": "Bedrijfsnaam",
  "models.Company.properties.workingDaysCount.label": "Aantal werkdagen per week",
  "models.Company.properties.workingDaysCount.description": "Het aantal werkdagen per week kan voor werkdagen 5 bedragen, 6 inclusief zaterdag en 7 inclusief zondag",
  "models.Company.views.usage.label": "Gebruik van platformen",
  "models.Company.views.usage.help": "Inzicht in het gebruik van beschikbare platforms",
  "models.Company.views.cards.help": "Uitzicht op tegelbedrijven",
  "models.Company.views.cards.label": "Dakpannen",
  "models.Company.views.dq-fix-inventory.label": "Consistentie van de voorraad",
  "models.Company.views.dq-fix-inventory.help": "Vind en repareer inconsistenties in de fysieke en virtuele voorraad voor werkstations",
  "models.Company.views.dq-shapes-position.label": "Locatie van vormen",
  "models.Company.views.dq-shapes-position.help": "Zoek en verplaats vormen die op het plan staan ​​in een andere ruimte dan die in de database",
  "models.Company.views.people-info.label": "Statistieken over de creaties van opdrachten door mensen",
  "models.Company.views.people-info.help": "Bekijk opdrachtstatistieken",
  "models.Company.reports.export-all.fileName": "back-up",
  "models.Company.reports.export-all.help": "Maak een back-up van alle Surfy-gegevens",
  "models.Company.reports.export-all-duplicate.fileName": "duplicatie",
  "models.Company.reports.export-all-duplicate.help": "Maak een back-up van bedrijfsgegevens om een ​​kopie van het platform te maken",
  "models.Campus.singular": "campus",
  "models.Campus.plural": "campus",
  "models.Campus.description": "Campus wordt gebruikt om gebouwen te groeperen die zich op dezelfde locatie bevinden.",
  "models.Campus.determinant.defined": "de campus",
  "models.Campus.determinant.undefined": "een campus",
  "models.Campus.determinants.defined": "campussen",
  "models.Campus.determinants.undefined": "campussen",
  "models.Campus.views.cards.help": "Groepsaanzicht van gebouwen",
  "models.Campus.views.cards.label": "Info",
  "models.Campus.properties.id.label": "Campus-ID",
  "models.Campus.properties.name.label": "Campusnaam",
  "models.Campus.properties.name.description": "Campusnaam",
  "models.Campus.properties.color.label": "Kleur",
  "models.Campus.properties.color.description": "Campuskleur",
  "models.Campus.properties.externalId.label": "Externe identificatie",
  "models.BuildingType.singular": "soort gebouw",
  "models.BuildingType.plural": "soorten gebouwen",
  "models.BuildingType.determinant.defined": "het type gebouw",
  "models.BuildingType.determinant.undefined": "een type gebouw",
  "models.BuildingType.determinants.defined": "soorten gebouwen",
  "models.BuildingType.determinants.undefined": "soorten gebouwen",
  "models.BuildingType.properties.id.label": "Identificatie van het gebouwtype",
  "models.BuildingType.properties.name.label": "Naam gebouwtype",
  "models.BuildingType.properties.name.description": "Naam gebouwtype",
  "models.BuildingType.properties.code.label": "Gecodeerd",
  "models.BuildingType.properties.code.description": "???",
  "models.BuildingType.properties.externalId.label": "Externe identificatie",
  "models.BuildingType.properties.externalId.description": "???",
  "models.Building.singular": "gebouw",
  "models.Building.plural": "gebouwen",
  "models.Building.determinant.defined": "gebouw",
  "models.Building.determinant.undefined": "een gebouw",
  "models.Building.determinants.defined": "de gebouwen",
  "models.Building.determinants.undefined": "gebouwen",
  "models.Building.description": "Het gebouw wordt gebruikt om de verdiepingen te groeperen",
  "models.Building.reports.workplaces.fileName": "Persoonlijke werkplekken",
  "models.Building.reports.workplaces.help": "Rapport bouwwerkplek",
  "models.Building.reports.allWorkplaces.fileName": "Werkplekken met opdrachten",
  "models.Building.reports.allWorkplaces.help": "Rapportage van alle werkplekken in het gebouw inclusief opdrachten",
  "models.Building.reports.workplaceAffectations.fileName": "Werkstationopdrachten",
  "models.Building.reports.workplaceAffectations.help": "Toewijzingsrapport voor het bouwen van een werkstation",
  "models.Building.reports.buildingPeople.fileName": "Mensen",
  "models.Building.reports.buildingPeople.help": "Melding van getroffen personen in het gebouw",
  "models.Building.reports.organizations.fileName": "Organisaties",
  "models.Building.reports.organizations.help": "Verslag van bouworganisaties",
  "models.Building.reports.buildingItems.fileName": "Inventaris",
  "models.Building.reports.buildingItems.help": "Rapport van de bouwinventaris",
  "models.Building.reports.area.fileName": "Spaties",
  "models.Building.reports.area.help": "Rapport bouwruimte",
  "models.Building.reports.buildingCleaning.fileName": "Diensten",
  "models.Building.reports.buildingCleaning.help": "Verslag over schoonmaakdiensten voor gebouwen",
  "models.Building.reports.buildingDimensions.fileName": "Analyse lagen",
  "models.Building.reports.buildingDimensions.help": "Rapport van analyselagen van gebouwruimten",
  "models.Building.views.cards.help": "Uitzicht op betegelde gebouwen",
  "models.Building.views.cards.label": "Info",
  "models.Building.views.pictures.help": "Bekijk gebouwen met foto's",
  "models.Building.views.pictures.label": "Foto's",
  "models.Building.views.gmap.help": "Bekijk gebouwen op een kaart",
  "models.Building.views.gmap.label": "Kaart",
  "models.Building.views.cost-distribution-by-cost-center.help": "<b>Verdeelsleutels</b> en gekwalificeerde oppervlakte per kostenplaats voor het gebouw %{name}",
  "models.Building.views.cost-distribution-by-cost-center.label": "Distributiesleutels",
  "models.Building.views.3d-cards.help": "Bekijk gebouwen in 3D",
  "models.Building.views.3d-cards.label": "3d",
  "models.Building.views.assets.help": "Onroerende goederen",
  "models.Building.views.assets.label": "Vastgoed",
  "models.Building.views.cuby.help": "Het interactieve <b>3D-</b> plan van het gebouw %{name}",
  "models.Building.views.cuby.label": "3D-plan",
  "models.Building.views.3d.help": "Het 3D-plan van het gebouw %{name} (cuby)",
  "models.Building.views.3d.label": "3D-plan",
  "models.Building.views.clone.help": "<b>Scenario's</b> en projecten bouwen %{name}",
  "models.Building.views.clone.label": "Scenario's",
  "models.Building.views.building-ifc.help": "Exporteer dit gebouw in IFC voor BIM",
  "models.Building.views.building-ifc.label": "IFC",
  "models.Building.views.zbre-sync.help": "Synchroniseer het gebouw met het Zbre-platform",
  "models.Building.views.zbre-sync.label": "Zbre-synchronisatie",
  "models.Building.views.inventory.help": "<b>Gebouwinventaris</b> %{name}",
  "models.Building.views.inventory.label": "Inventaris",
  "models.Building.views.list-simple.help": "Noem gebouwen met weinig details",
  "models.Building.views.list-simple.label": "Simpele lijst",
  "models.Building.views.building-3d-gmap.label": "3D-gebouw op het plan",
  "models.Building.views.building-3d-gmap.help": "Bekijk het gebouw in 3D op een kaart",
  "models.Building.properties.id.label": "Gebouw-ID",
  "models.Building.properties.name.label": "naam van gebouw",
  "models.Building.properties.name.description": "Naam van gebouw of scenario",
  "models.Building.properties.picture.label": "Foto van het gebouw",
  "models.Building.properties.picture.description": "U kunt een foto van uw gebouw gebruiken om het snel te vinden vanaf de startpagina (zie gebouwen met foto's) of om de mening van medewerkers te illustreren",
  "models.Building.properties.documents.label": "Gerelateerde documenten",
  "models.Building.properties.documents.description": "Onderhoud een link naar de locatie van documenten die aan dit gebouw zijn gekoppeld in uw GED",
  "models.Building.properties.securityDeposit.label": "Borg",
  "models.Building.properties.securityDeposit.description": "Bedrag van de aanbetaling die is gestort bij ondertekening van het huurcontract",
  "models.Building.properties.buildings.label": "Gebouwscenario's",
  "models.Building.properties.buildings.description": "Scenario's gegenereerd vanuit dit gebouw",
  "models.Building.properties.constructionYear.label": "Bouwjaar van het gebouw",
  "models.Building.properties.constructionYear.description": "Bouwjaar van het gebouw waardoor de veroudering kan worden gemeten",
  "models.Building.properties.parkingSpaceCount.label": "Aantal parkeerplaatsen",
  "models.Building.properties.parkingSpaceCount.description": "Aantal beschikbare parkeerplaatsen",
  "models.Building.properties.yearlyParkingRent.label": "Jaarlijkse parkeerhuur",
  "models.Building.properties.yearlyParkingRent.description": "Aandeel van de huur bestemd voor parkeren",
  "models.Building.properties.yearlyTaxFees.label": "Bedrag van de jaarlijkse belastingen",
  "models.Building.properties.yearlyTaxFees.description": "Totaalbedrag aan belastingen",
  "models.Building.properties.yearlyExploitationFees.label": "Jaarlijkse bedrijfskosten",
  "models.Building.properties.yearlyExploitationFees.description": "Jaarlijks bedrag aan bedrijfskosten (bijvoorbeeld: water, elektriciteit)",
  "models.Building.properties.rentReferenceIndex.label": "Huurbenchmarkindex",
  "models.Building.properties.rentReferenceIndex.description": "De huurreferentie-index (IRL) dient als basis voor de herziening van de huurprijzen van leegstaande of gemeubileerde woonruimte",
  "models.Building.properties.color.label": "Kleur",
  "models.Building.properties.color.description": "De kleur van het gebouw wordt gebruikt om de achtergrondkleur in de presentaties van de verdiepingen of het gebouw te definiëren en om dit gebouw van de anderen te kunnen onderscheiden",
  "models.Building.properties.roomsCount.label": "Aantal spaties",
  "models.Building.properties.roomsCount.description": "Het aantal ruimtes dat in dit gebouw is gecreëerd",
  "models.Building.properties.roomsArea.label": "Gekwalificeerd oppervlak",
  "models.Building.properties.roomsArea.description": "Het gekwalificeerde oppervlak vertegenwoordigt alle gebieden die in Surfy zijn gemodelleerd",
  "models.Building.properties.workplacesCount.label": "Aantal werkstations",
  "models.Building.properties.workplacesCount.description": "Het aantal werkplekken in het gebouw wordt automatisch berekend",
  "models.Building.properties.workplacesRatio.label": "Werkstationverhouding",
  "models.Building.properties.workplacesRatio.description": "De verhouding per werkplek is het aantal vierkante meters in het pand gedeeld door het aantal werkplekken, deze waarde wordt automatisch berekend",
  "models.Building.properties.peopleCount.label": "Aantal opdrachten",
  "models.Building.properties.peopleCount.description": "Het aantal personen dat is toegewezen aan het gebouw, de buurt, de ruimte of de werkplek",
  "models.Building.properties.peopleRatio.label": "Bezettingsgraad",
  "models.Building.properties.peopleRatio.description": "De bezettingsgraad is het aantal vierkante meters in het gebouw gedeeld door het aantal mensen dat direct aan de wijken, ruimtes of werkplekken is toegewezen. Deze waarde wordt berekend",
  "models.Building.properties.freeWorkplacesCount.label": "Aantal vrije posities",
  "models.Building.properties.freeWorkplacesCount.description": "Aantal vacante posities in het gebouw",
  "models.Building.properties.flexWorkplacesCount.label": "Aantal flexposities",
  "models.Building.properties.flexWorkplacesCount.description": "Aantal flexwerkplekken in het gebouw",
  "models.Building.properties.address.label": "Adres",
  "models.Building.properties.address.description": "Het adres van het gebouw om het op de kaart te lokaliseren",
  "models.Building.properties.yearlyCondominiumFees.label": "Jaarlijkse kosten",
  "models.Building.properties.yearlyCondominiumFees.description": "Bijvoorbeeld het bedrag van de jaarlijkse beheer- of mede-eigendomskosten",
  "models.Building.properties.yearlyRent.label": "Jaarlijkse huur",
  "models.Building.properties.yearlyRent.description": "Bedrag van de jaarlijkse huur voor dit gebouw",
  "models.Building.properties.leaseStartDate.label": "Ingangsdatum huurcontract",
  "models.Building.properties.leaseStartDate.description": "Ingangsdatum huurcontract",
  "models.Building.properties.leaseEndDate.label": "Einddatum huurcontract",
  "models.Building.properties.leaseEndDate.description": "Einddatum huurcontract",
  "models.Building.properties.purchaseDate.label": "Datum van aankoop van het gebouw",
  "models.Building.properties.purchaseDate.description": "Datum van aankoop van het gebouw",
  "models.Building.properties.buildingId.label": "Referentiegebouw-ID",
  "models.Building.properties.buildingId.description": "De identificatiecode van het referentiegebouw wordt gebruikt als onderdeel van het maken van scenario's, de identificatiecode maakt de associatie met dit gebouw mogelijk",
  "models.Building.properties.building.label": "Origineel gebouw",
  "models.Building.properties.building.description": "Het originele of referentiegebouw wordt gebruikt bij het maken van scenario's. Hiermee kunt u het oorspronkelijke gebouw identificeren waaruit het gebouw is gemaakt",
  "models.Building.properties.jupUiLayout.label": "Standaard planweergave",
  "models.Building.properties.jupUiLayout.description": "Wanneer een plattegrond van dit gebouw voor het eerst wordt geopend, wordt de standaardvisie geselecteerd. Na de eerste opening wordt de huidige visie toegepast.",
  "models.Building.properties.sharedWorkplacesCount.label": "Aantal gedeelde werkstations",
  "models.Building.properties.sharedWorkplacesCount.description": "Aantal werkplekken gedeeld in het gebouw door minimaal 2 personen",
  "models.Building.properties.sharedWorkplacesRatio.label": "Tarief gedeeld werkstation",
  "models.Building.properties.sharedWorkplacesRatio.description": "Percentage werkplekken gedeeld door minimaal 2 personen vergeleken met alle werkplekken in het gebouw",
  "models.Building.properties.flexRatio.label": "Tarief flexwerkplekken",
  "models.Building.properties.flexRatio.description": "Het flexwerkplektarief wordt berekend door het aantal flexwerkplekken te delen door het totaal aantal werkplekken",
  "models.Building.properties.transitWorkplacesCount.label": "Aantal passerende werkplekken",
  "models.Building.properties.transitWorkplacesCount.description": "Aantal tijdelijke werkplekken, deze posities worden niet meegeteld in de vrije posities en zijn niet in flex",
  "models.Building.properties.regulatoryCapacity.label": "Regelgevende capaciteit",
  "models.Building.properties.regulatoryCapacity.description": "De regelgevende capaciteit van het platform maakt het mogelijk om de evacuatie van publiek en werknemers te beheren",
  "models.Building.properties.dimensionPeopleCount.label": "Aantal laagtoewijzingen",
  "models.Building.properties.dimensionPeopleCount.description": "Het aantal mensen dat is toegewezen aan de opdrachtlagen die bij dit gebouw horen",
  "models.Building.properties.userCompanyOwner.label": "Gebruiker die eigenaar is van het gebouw",
  "models.Building.properties.userCompanyOwner.description": "De gebruiker die eigenaar is van het gebouw ziet het gebouw altijd, zelfs als er een inhoudsrol aanwezig is. In het geval van het maken van een scenario wordt de gebruiker die het scenario heeft gemaakt de eigenaar, de eigenaar kan later worden gewijzigd",
  "models.AuthentificationConnection.singular": "Authenticatie verbinding",
  "models.AuthentificationConnection.plural": "Authenticatieverbindingen",
  "models.AuthentificationConnection.determinant.defined": "de authenticatieverbinding",
  "models.AuthentificationConnection.determinant.undefined": "een authenticatieverbinding",
  "models.AuthentificationConnection.determinants.defined": "authenticatie verbindingen",
  "models.AuthentificationConnection.determinants.undefined": "authenticatie verbindingen",
  "models.ApiUserToJupRole.singular": "API-gebruikerskoppeling aan rol",
  "models.ApiUserToJupRole.plural": "API-gebruikerskoppelingen aan rol",
  "models.ApiUserToJupRole.determinant.defined": "API-gebruikerskoppeling aan rol",
  "models.ApiUserToJupRole.determinant.undefined": "een API-gebruikerskoppeling aan de rol",
  "models.ApiUserToJupRole.determinants.defined": "API-gebruikersassociaties aan de rol",
  "models.ApiUserToJupRole.determinants.undefined": "API-gebruikersassociaties aan de rol",
  "models.ApiUserToContentRole.singular": "API-gebruikerskoppeling aan inhoudsrol",
  "models.ApiUserToContentRole.plural": "API-gebruikersassociaties met inhoudsrol",
  "models.ApiUserToContentRole.determinant.defined": "API-gebruikerskoppeling aan inhoudsrol",
  "models.ApiUserToContentRole.determinant.undefined": "een API-gebruikerskoppeling aan de inhoudsrol",
  "models.ApiUserToContentRole.determinants.defined": "API-gebruikerskoppelingen aan inhoudsrol",
  "models.ApiUserToContentRole.determinants.undefined": "API-gebruikerskoppelingen aan inhoudsrol",
  "models.ApiUser.singular": "API-gebruiker",
  "models.ApiUser.plural": "API-gebruikers",
  "models.ApiUser.determinant.defined": "API-gebruiker",
  "models.ApiUser.determinant.undefined": "een API-gebruiker",
  "models.ApiUser.determinants.defined": "API-gebruikers",
  "models.ApiUser.determinants.undefined": "API-gebruikers",
  "models.ApiUser.properties.clientSecret.label": "Geheime code",
  "models.ApiUser.properties.clientSecret.description": "het geheime wachtwoord voor uw API-account kan worden gegenereerd en mag nooit worden gedeeld",
  "ToggleZbreSyncCheckbox.label": "Synchroniseer met realtime bezigheden in Z#bre",
  "ToggleZbreSyncCheckbox.help": "Door synchronisatie kunnen ruimtes en werkplekken worden gekleurd op basis van de in Z#bre geplaatste sensoren",
  "FloorSpaceSlider.title": "Ruimte tussen elke verdieping in centimeters",
  "FloorSelector.title": "Selecteer verdiepingen",
  "FloorSelector.focus": "Selecteer alleen deze verdieping",
  "FloorSelector.selectAll.false": "Selecteer alle verdiepingen",
  "FloorSelector.selectAll.true": "Deselecteer alle verdiepingen",
  "ToggleEnableMissingFloors.label": "Laat spookvloeren zien",
  "ToggleEnableMissingFloors.help": "Toon spookvloeren voor ontbrekende verdiepingen tussen niveau 0 en de hoogste verdieping op basis van echte vloerniveaus",
  "RoomGraphHandler.buttons.generateGraph.label": "Genereer de oriëntatiegrafiek",
  "RoomGraphHandler.buttons.generateGraph.description": "Door de oriëntatiegrafiek te genereren, worden de knooppunten berekend waarlangs de verkenner de ruimtes en meubels kan vinden. Als de oorspronkelijke ruimte kan worden geselecteerd, is de grafiek al gegenereerd.",
  "RoomGraphHandler.buttons.selectOriginRoom.label": "Selecteer originele ruimte",
  "RoomGraphHandler.buttons.selectOriginRoom.description": "Selecteer een ruimte en gebruik deze optie om deze als startruimte te definiëren",
  "RoomGraphHandler.icons.displayNodes.description": "Toon paden in kamers",
  "RoomGraphHandler.icons.displayBoundingBoxes.description": "Toon uitsluitingsruimten voor meubels",
  "RoomGraphHandler.icons.enablePathfinding.description": "Activeer padtekening vanuit de bronruimte met vorm onder de muis",
  "RoomGraphHandler.rooms.origin": "Originele ruimte",
  "ThemeModeSwitchMenuItem.dark.label": "Schakel over naar de heldere modus",
  "ThemeModeSwitchMenuItem.dark.help": "Door de heldere modus te gebruiken, kunt u met een witte achtergrond werken",
  "ThemeModeSwitchMenuItem.light.label": "Schakel over naar de donkere modus",
  "ThemeModeSwitchMenuItem.light.help": "Door de donkere modus te gebruiken, kunt u met donkere kleuren op de achtergrond werken om vermoeide ogen te verminderen.",
  "copilot.actions.add.door": "Er is zojuist een deur toegevoegd door Surfy Copilot",
  "generateDocumentation.properties.technicalName": "Technische naam",
  "generateDocumentation.properties.belongsTo": "Geassocieerde entiteiten (enkel)",
  "generateDocumentation.properties.hasMany": "Geassocieerde entiteiten (lijst)",
  "generateDocumentation.properties.base": "Basiseigenschappen",
  "generateDocumentation.properties.mandatory": "Verplichte eigenschappen",
  "help.key1": "Hallo %{name}",
  "help.key2": "doei %{name}"
};
const jsonTranslationsFiles = { fr, en, es, it, nl };
class PolyglotHelpApi extends PolyglotApi {
  async setLocale(locale) {
    const phrases = jsonTranslationsFiles[locale];
    const polyglot2 = new Polyglot({ locale, phrases, allowMissing: true });
    this.setPolyglot(polyglot2);
    updateGlobalLanguageSettings(polyglot2.locale());
  }
}
function I18NHelpContext(props) {
  const { defaultLanguage } = props;
  const [i18n, setI18n] = useRecoilState(polyglotApiAtom);
  useEffect(() => {
    const api2 = new PolyglotHelpApi();
    api2.setup(defaultLanguage).then(setI18n);
  }, []);
  if (i18n) {
    return props.children;
  }
  return null;
}
function isTenantObjectType(objecTypeName) {
  return objecTypeName === tenantInfo.objectType;
}
function entityToString(modelName, e) {
  if (!e) {
    return `${modelName}|?`;
  }
  const eWithName = e;
  if (eWithName.name) {
    return eWithName.name;
  }
  return `${modelName}|${e.id}`;
}
function getObjectType(singular) {
  return {
    definition: getObjectTypeDefinitionByName(singular),
    entityToString: (i18n, e) => entityToString(singular, e),
    entityToStringWithContext: (i18n, masterData, e) => entityToString(singular, e),
    key: (e) => `${singular}-${e.id}`,
    // breadcrumb: getDefaultBreadcrumb<TQueryNode>(singular),
    appBarBackgroundColor: () => void 0,
    pathToBuilding: [],
    reports: []
  };
}
const generatedObjectTypes = [
  getObjectType("occupancyStatus"),
  getObjectType("user"),
  getObjectType("userRefreshToken"),
  getObjectType("companyType"),
  getObjectType("company"),
  getObjectType("campus"),
  getObjectType("roomConnectorType"),
  getObjectType("roomConnector"),
  getObjectType("userCompany"),
  getObjectType("personGender"),
  getObjectType("personCompany"),
  getObjectType("jupUiLayout"),
  getObjectType("buildingType"),
  getObjectType("organization"),
  getObjectType("itemTypeFamily"),
  getObjectType("manufacturer"),
  getObjectType("object3dModel"),
  getObjectType("itemType"),
  getObjectType("building"),
  getObjectType("mapScale"),
  getObjectType("structure"),
  getObjectType("structurePoint"),
  getObjectType("floor"),
  getObjectType("distributionCostType"),
  getObjectType("roomTypeGroup"),
  getObjectType("roomType"),
  getObjectType("roomTypeGroupToRoomType"),
  getObjectType("roomTypeGroupFloor"),
  getObjectType("roomTypeGroupBuilding"),
  getObjectType("costCenter"),
  getObjectType("costCenterBuilding"),
  getObjectType("costCenterFloor"),
  getObjectType("room"),
  getObjectType("roomPoint"),
  getObjectType("roomPointRoom"),
  getObjectType("roomPointSegmentType"),
  getObjectType("roomPointSegment"),
  getObjectType("itemTypePoint"),
  getObjectType("dimensionType"),
  getObjectType("dimension"),
  getObjectType("dimensionRoom"),
  getObjectType("dimensionFloor"),
  getObjectType("dimensionBuilding"),
  getObjectType("factType"),
  getObjectType("fact"),
  getObjectType("personState"),
  getObjectType("personSecurityProfile"),
  getObjectType("person"),
  getObjectType("personToPersonType"),
  getObjectType("personToPerson"),
  getObjectType("roomAffectation"),
  getObjectType("workplaceType"),
  getObjectType("workplaceTypeItemType"),
  getObjectType("workplace"),
  getObjectType("item"),
  getObjectType("workplaceAffectation"),
  getObjectType("organizationFloor"),
  getObjectType("organizationBuilding"),
  getObjectType("roomTypeFloor"),
  getObjectType("roomTypeBuilding"),
  getObjectType("itemToPerson"),
  getObjectType("personToBuilding"),
  getObjectType("dimensionToPerson"),
  getObjectType("dimensionTypeToBuilding"),
  getObjectType("workingLocation"),
  getObjectType("personWorkingLocation"),
  getObjectType("personToWorkplaceBooking"),
  getObjectType("personToRoomBooking"),
  getObjectType("personToDimensionBooking"),
  getObjectType("personCompanyMission"),
  getObjectType("personCompanyToItemType"),
  getObjectType("personCompanyToRoomType"),
  getObjectType("personCompanyToItem"),
  getObjectType("legend"),
  getObjectType("openerPostMessageHost"),
  getObjectType("jupObjectType"),
  getObjectType("jupUiView"),
  getObjectType("jupRole"),
  getObjectType("jupUiOption"),
  getObjectType("jupUiOperation"),
  getObjectType("contentRole"),
  getObjectType("jupUserCompanyToJupRole"),
  getObjectType("jupRoleToJupUiView"),
  getObjectType("jupRoleToJupObjectType"),
  getObjectType("jupRoleToJupUiOption"),
  getObjectType("jupRoleToJupUiOperation"),
  getObjectType("contentRoleToBuilding"),
  getObjectType("contentRoleToUserCompany"),
  getObjectType("contentRoleToFloor"),
  getObjectType("partnerApiCredential"),
  getObjectType("apiUser"),
  getObjectType("apiUserToJupRole"),
  getObjectType("apiUserToContentRole"),
  getObjectType("jupUiTenantOperation"),
  getObjectType("contentRoleToJupUiTenantOperation"),
  getObjectType("authentificationConnection"),
  getObjectType("userRegistrationTenantRule"),
  getObjectType("userRegistrationTenantRuleToJupRole"),
  getObjectType("userRegistrationTenantRuleToContentRole"),
  getObjectType("partnerExportMappingConfiguration"),
  getObjectType("partnerExportMapping"),
  getObjectType("partnerExportMappingToRoomType"),
  getObjectType("partnerExportMappingConfigurationToFloor"),
  getObjectType("jupRoleToJupUiLayout"),
  getObjectType("itemFact"),
  getObjectType("featureFamily"),
  getObjectType("featureGroup"),
  getObjectType("feature")
];
function createFilter(operator, column2, value) {
  return { operator, column: column2, value };
}
function getAllExportableProperties(objectTypeName) {
  const otDef = getObjectTypeDefinitionByName(objectTypeName);
  const properties2 = Object.values(otDef.propertiesByName).filter((p) => {
    if (isPropertyTypeId(p) || isPropertyTypeBelongsTo(p) || isPropertyTypeHasMany(p)) {
      return false;
    }
    return true;
  });
  return properties2;
}
function getAllPropertyNamesExportWithoutTechnicals(objectTypeName) {
  const properties2 = getAllExportableProperties(objectTypeName);
  return properties2.filter((p) => !p.options.technical).map((p) => p.name);
}
const exludeFromWorkplaces = ["position", "textAnchor", "rotation", "externalId"];
const workplaceAllProperties = jupDifferenceWith(getAllPropertyNamesExportWithoutTechnicals("workplace"), exludeFromWorkplaces);
const workplacesExportQueryNode = (translation, buildingIds) => [{
  exportType: "hasManyCount",
  objectTypeName: "building",
  queryNode: {
    name: "workplace",
    required: true,
    _: [
      "id",
      ...jupUniq(["name", ...workplaceAllProperties]),
      roomToBuildingQueryNode(buildingIds, true),
      { name: "costCenter", _: ["name"] },
      { name: "organization", _: ["name", { name: "organization", _: ["name"] }] },
      { name: "workplaceAffectations", _: ["id"] },
      { name: "workplaceType", _: ["name"] }
    ]
  }
}];
function roomToBuildingQueryNode(buildingIds, required, roomProperties) {
  return {
    name: "room",
    required,
    _: [
      "name",
      {
        name: "floor",
        required,
        _: ["name", {
          name: "building",
          required,
          _: ["name"],
          filters: [createFilter("in", "id", buildingIds)]
        }]
      },
      ...roomProperties || []
    ]
  };
}
const personAllProperties = getAllPropertyNamesExportWithoutTechnicals("person");
const personWorkplace = (personProperties2) => ({
  name: "person",
  _: [
    ...jupUniq(["firstname", "lastname", "code", ...personProperties2]),
    { name: "organization", _: ["name", { name: "organization", _: ["name"] }] },
    { name: "costCenter", _: ["name"] },
    { name: "personSecurityProfile", _: ["name"] },
    { name: "personState", _: ["name"] }
  ]
});
const allWorkplacesQueryNode = (translation, buildingIds) => [{
  exportType: "hasManyRec",
  objectTypeName: "building",
  queryNode: {
    name: "workplace",
    _: [
      ...jupUniq(["id", "name", ...workplaceAllProperties]),
      roomToBuildingQueryNode(buildingIds, true),
      { name: "organization", _: ["name", { name: "organization", _: ["name"] }] },
      { name: "costCenter", _: ["name"] },
      { name: "workplaceType", _: ["name"] },
      { name: "workplaceAffectations", _: ["id", personWorkplace(jupDifferenceWith(personAllProperties, ["picture"]))] }
    ]
  }
}];
const workplacesAffectationsQueryNode = (translation, buildingIds) => [{
  exportType: "hasManyCount",
  objectTypeName: "building",
  queryNode: {
    name: "workplaceAffectation",
    _: [
      "id",
      {
        name: "workplace",
        required: true,
        _: ["id", "name", roomToBuildingQueryNode(buildingIds, true)]
      },
      {
        name: "person",
        _: [
          ...jupUniq(["firstname", "lastname", "email", ...personAllProperties]),
          { name: "organization", _: ["name", { name: "organization", _: ["name"] }] },
          { name: "costCenter", _: ["name"] },
          { name: "personSecurityProfile", _: ["name"] },
          { name: "personState", _: ["name"] }
        ]
      }
    ]
  }
}];
const exludeFromRooms = ["textAnchor", "externalId"];
const roomAllProperties = jupDifferenceWith(getAllPropertyNamesExportWithoutTechnicals("room"), exludeFromRooms);
const roomStarEntities = [
  { name: "costCenter", _: ["name"] },
  { name: "organization", _: ["name", { name: "organization", _: ["name"] }] },
  { name: "distributionCostType", _: ["name"] },
  { name: "roomType", _: ["name"] }
];
const roomAreaReportProperties = [
  "id",
  ...roomAllProperties,
  ...roomStarEntities
];
const buildingAreaExportQueryNode = (translation, buildingIds) => [{
  exportType: "hasManyCount",
  objectTypeName: "building",
  queryNode: {
    name: "room",
    required: true,
    _: [
      ...roomAreaReportProperties,
      {
        name: "floor",
        required: true,
        _: ["name", {
          name: "building",
          required: true,
          _: ["name"],
          filters: [createFilter("in", "id", buildingIds)]
        }]
      }
    ]
  }
}];
const buildingAreaReport = { name: "area", iconObjectTypeName: "room", exportQueryNodes: buildingAreaExportQueryNode };
const buildingCleaningReportName = "buildingCleaning";
const buildingCleaningQueryNode = (translation, buildingIds) => [{
  exportType: "hasManyRec",
  objectTypeName: "building",
  queryNode: roomToBuildingQueryNode(buildingIds, true, [
    "id",
    "area",
    "info",
    {
      name: "roomType",
      _: ["name", "cadence"]
    }
  ])
}];
const buildingCleaningReport = { name: buildingCleaningReportName, iconObjectTypeName: "room", exportQueryNodes: buildingCleaningQueryNode };
const buildingDimensionsReportName = "buildingDimensions";
const buildingDimensionsQueryNode = (translation, buildingIds) => [{
  exportType: "hasManyRec",
  objectTypeName: "building",
  queryNode: {
    name: "room",
    _: [
      ...roomAreaReportProperties,
      {
        name: "floor",
        required: true,
        _: ["name", {
          name: "building",
          required: true,
          _: ["name"],
          filters: [createFilter("in", "id", buildingIds)]
        }]
      }
    ]
  }
}];
const buildingDimensionsReport = { name: buildingDimensionsReportName, iconObjectTypeName: "room", exportQueryNodes: buildingDimensionsQueryNode };
const buildingItemsReportName = "buildingItems";
const exludeFromItems = ["position", "textAnchor", "rotation", "externalId"];
const itemsAllProperties = jupDifferenceWith(getAllPropertyNamesExportWithoutTechnicals("item"), exludeFromItems);
const itemsExportQueryNode = (translation, buildingIds) => {
  const items = {
    exportType: "hasManyCount",
    objectTypeName: "building",
    queryNode: {
      name: "item",
      required: true,
      _: [
        "id",
        roomToBuildingQueryNode(buildingIds, true, ["id"]),
        { name: "itemType", _: ["name", "seatsCount", "carbonFootprint", { name: "itemTypeFamily", _: ["name"] }] },
        ...itemsAllProperties
      ]
    }
  };
  return [items];
};
const buildingItemReport = { name: buildingItemsReportName, iconObjectTypeName: "item", exportQueryNodes: itemsExportQueryNode };
const roomBelongsToProperties = [
  { name: "organization", _: ["name", { name: "organization", _: ["name"] }] },
  { name: "costCenter", _: ["name"] }
];
function personProperties$1(extraProperties) {
  const exclude = ["createdAt", "updatedAt"];
  const personProperties2 = jupDifferenceWith(getAllPropertyNamesExportWithoutTechnicals("person"), exclude);
  return [
    "id",
    ...personProperties2,
    ...[],
    {
      name: "organization",
      _: ["name", { name: "organization", _: ["name"] }]
    },
    { name: "costCenter", _: ["name"] },
    { name: "personSecurityProfile", _: ["name"] },
    { name: "personState", _: ["name"] },
    { name: "personGender", _: ["name"] }
  ];
}
function peopleDimensionAffectations(translation, buildingIds) {
  return {
    exportType: "hasManyRec",
    objectTypeName: "building",
    worksheetName: objectTypeCapitalizedPluralLabel(translation, "dimensionToPerson"),
    queryNode: {
      name: "person",
      required: true,
      _: [...personProperties$1(), {
        name: "dimensionToPeople",
        required: true,
        _: ["id", {
          name: "dimension",
          required: true,
          _: ["name", {
            name: "dimensionType",
            required: true,
            _: ["name", {
              name: "dimensionTypeToBuildings",
              _: [],
              required: true,
              filters: [createFilter("in", "buildingId", buildingIds)]
            }]
          }]
        }]
      }]
    }
  };
}
function peopleRoomAffectations(translation, buildingIds) {
  return {
    exportType: "hasManyRec",
    objectTypeName: "building",
    worksheetName: objectTypeCapitalizedPluralLabel(translation, "roomAffectation"),
    queryNode: {
      name: "person",
      required: true,
      _: [...personProperties$1(), {
        name: "roomAffectations",
        required: true,
        _: ["id", roomToBuildingQueryNode(buildingIds, true, ["id", ...roomBelongsToProperties])]
      }]
    }
  };
}
function peopleWorkplaceAffectations(translation, buildingIds) {
  return {
    exportType: "hasManyRec",
    objectTypeName: "building",
    worksheetName: objectTypeCapitalizedPluralLabel(translation, "workplaceAffectation"),
    queryNode: {
      name: "person",
      required: true,
      _: [...personProperties$1(), {
        name: "workplaceAffectations",
        required: true,
        _: [{
          name: "workplace",
          required: true,
          _: [
            "name",
            roomToBuildingQueryNode(buildingIds, true, ["id", ...roomBelongsToProperties]),
            { name: "costCenter", _: ["name"] }
          ]
        }, "id"]
      }]
    }
  };
}
const peopleBuildingsExportQueryNodes = (translation, buildingIds) => [
  peopleRoomAffectations(translation, buildingIds),
  peopleWorkplaceAffectations(translation, buildingIds),
  peopleDimensionAffectations(translation, buildingIds)
];
const buildingPeopleReportName = "buildingPeople";
const buildingPeopleReport = { name: buildingPeopleReportName, iconObjectTypeName: "person", exportQueryNodes: peopleBuildingsExportQueryNodes };
function sortOnNameOptional(a2, b2) {
  return a2.name && b2.name ? a2.name.localeCompare(b2.name) : 0;
}
const currentCompanyAtom = atom({
  key: "currentCompany",
  default: null
});
function useCurrentCompanyOptional() {
  return useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(currentCompanyAtom);
}
function useCurrentCompany() {
  const company2 = useCurrentCompanyOptional();
  if (!company2) {
    throw new Error("current company is not set");
  }
  return company2;
}
const buildingStoreAtom = atomFamily({
  key: "buildingStore",
  default: void 0
});
const atom_$8 = buildingStoreAtom;
function useBuildings() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$8(currentCompany.name));
  if (!store) {
    throw new Error("BuildingStore is not loaded");
  }
  return store;
}
function useBuilding(buildingId) {
  const e = useBuildingOptional(buildingId);
  if (!e) {
    throw new Error(`building is missing in store for id : ${buildingId}`);
  }
  return e;
}
function useBuildingOptional(buildingId) {
  const store = useBuildings();
  if (buildingId) {
    const e = store.get(buildingId);
    return e;
  }
}
const buildingBreadcrumb = {
  queryNode: {
    _: [
      "id",
      "name",
      "color",
      {
        name: "company",
        _: ["name", "id"]
      },
      { name: "floors", _: ["level"] }
    ],
    name: "building"
  },
  path: ["company"],
  useData: (id) => {
    const building2 = useBuilding(id);
    const company2 = useCurrentCompany();
    return { ...building2, company: company2 };
  }
};
const building = {
  breadcrumb: buildingBreadcrumb,
  appBarBackgroundColor: (masterData, e) => e.color,
  reports: [
    buildingPeopleReport,
    { name: "workplaces", iconObjectTypeName: "workplace", exportQueryNodes: workplacesExportQueryNode },
    { name: "workplaceAffectations", iconObjectTypeName: "workplaceAffectation", exportQueryNodes: workplacesAffectationsQueryNode },
    { name: "allWorkplaces", iconObjectTypeName: "workplace", exportQueryNodes: allWorkplacesQueryNode },
    buildingItemReport,
    // buildingOrganizationReport,
    buildingAreaReport,
    buildingCleaningReport,
    buildingDimensionsReport
  ],
  defaultSortOrder: () => sortOnNameOptional,
  entityToString: buildingToEntityString,
  entityToStringWithContext: (i18n, masterData, e) => buildingToEntityString(i18n, e)
};
function buildingToEntityString(i18n, e) {
  if (!e) {
    return entityToString("building", e);
  }
  return e.name;
}
function getPersonFullName(person2) {
  var _a2, _b;
  if (person2 == null ? void 0 : person2.fullname) {
    return person2.fullname;
  }
  return person2 ? `${(_a2 = person2.firstname) == null ? void 0 : _a2.trim()} ${(_b = person2.lastname) == null ? void 0 : _b.trim()}` : entityToString("person", person2);
}
const breadcrumb$a = {
  queryNode: {
    _: [
      "id",
      "firstname",
      "lastname"
    ],
    name: "person"
  },
  path: []
};
const personEntityToString = (i18n, e) => {
  return getPersonFullName(e);
};
const person = {
  breadcrumb: breadcrumb$a,
  entityToString: personEntityToString
};
function userDisplayName(u, addEmail) {
  const i = [];
  if (u.firstname) {
    i.push(u.firstname);
  }
  if (u.lastname) {
    i.push(u.lastname);
  }
  if (u.email) {
    if (i.length === 0) {
      i.push(u.email);
    } else {
      i.push(`(${u.email})`);
    }
  }
  return i.join(" ");
}
const userCompanyBreadcrumbQueryNode = {
  _: [
    "id",
    {
      name: "user",
      _: ["firstname", "lastname", "id", "picture", "sub"]
    },
    { name: "company", _: ["name"] }
  ],
  name: "userCompany"
};
const userCompanyBreadcrumb = {
  queryNode: userCompanyBreadcrumbQueryNode,
  path: ["user"]
};
function userCompanyEntityToString(i18n, r2) {
  var _a2;
  if (!r2) {
    return entityToString("userCompany", r2);
  }
  const { user: user2, company: company2 } = r2;
  if (user2 && company2) {
    return `${userDisplayName(user2)} - ${company2.name}`;
  }
  if (user2) {
    return userDisplayName(user2);
  }
  return (_a2 = r2.id) == null ? void 0 : _a2.toString();
}
function userCompanyEntityToStringWithContext(i18n, masterData, r2) {
  return userCompanyEntityToString(i18n, r2);
}
const userCompany = {
  breadcrumb: userCompanyBreadcrumb,
  entityToStringWithContext: userCompanyEntityToStringWithContext,
  entityToString: userCompanyEntityToString
};
const roomAffectation = {
  entityToString: (i18n, ra) => {
    if (ra) {
      const { person: person2, room: room2 } = ra;
      if (person2 && room2) {
        return `${personEntityToString(i18n, person2)} - ${entityToString("room", room2)}`;
      }
    }
    return entityToString("roomAffectation", ra);
  },
  pathToBuilding: ["room", "floor", "building"]
};
var thenBy_module;
var hasRequiredThenBy_module;
function requireThenBy_module() {
  if (hasRequiredThenBy_module) return thenBy_module;
  hasRequiredThenBy_module = 1;
  thenBy_module = function() {
    function identity(v) {
      return v;
    }
    function ignoreCase(v) {
      return typeof v === "string" ? v.toLowerCase() : v;
    }
    function makeCompareFunction(f, opt) {
      opt = typeof opt === "object" ? opt : { direction: opt };
      if (typeof f != "function") {
        var prop2 = f;
        f = function(v1) {
          return !!v1[prop2] ? v1[prop2] : "";
        };
      }
      if (f.length === 1) {
        var uf = f;
        var preprocess = opt.ignoreCase ? ignoreCase : identity;
        var cmp = opt.cmp || function(v1, v2) {
          return v1 < v2 ? -1 : v1 > v2 ? 1 : 0;
        };
        f = function(v1, v2) {
          return cmp(preprocess(uf(v1)), preprocess(uf(v2)));
        };
      }
      const descTokens = { "-1": "", desc: "" };
      if (opt.direction in descTokens) return function(v1, v2) {
        return -f(v1, v2);
      };
      return f;
    }
    function tb(func, opt) {
      var x = typeof this == "function" && !this.firstBy ? this : false;
      var y = makeCompareFunction(func, opt);
      var f = x ? function(a2, b2) {
        return x(a2, b2) || y(a2, b2);
      } : y;
      f.thenBy = tb;
      return f;
    }
    tb.firstBy = tb;
    return tb;
  }();
  return thenBy_module;
}
var thenBy_moduleExports = requireThenBy_module();
function sortFloorWithMasterData(masterData) {
  return thenBy_moduleExports.firstBy((fA, fB) => {
    const bA = masterData.buildings.get((fA == null ? void 0 : fA.buildingId) || 0);
    const bB = masterData.buildings.get((fB == null ? void 0 : fB.buildingId) || 0);
    return bA && bB ? sortOnName(bA, bB) : 0;
  }).thenBy((fA, fB) => {
    return fA && fB ? sortOnLevel(fA, fB) : 0;
  });
}
const floorStoreAtom = atomFamily({
  key: "floorStore",
  default: void 0
});
const atom_$7 = floorStoreAtom;
function useFloors() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$7(currentCompany.name));
  if (!store) {
    throw new Error("FloorStore is not loaded");
  }
  return store;
}
function useFloor(floorId) {
  const e = useFloorOptional(floorId);
  if (!e) {
    throw new Error(`floor is missing in store for id : ${floorId}`);
  }
  return e;
}
function useFloorOptional(floorId) {
  const store = useFloors();
  if (floorId) {
    const e = store.get(floorId);
    return e;
  }
}
const breadcrumb$9 = {
  queryNode: {
    _: [
      "id",
      "name",
      {
        name: "building",
        _: ["name", "id", "color"]
      }
    ],
    name: "floor"
  },
  path: ["building"],
  useData: useFloorBreadcrumbData
};
function appBarBackgroundColor(masterData, e) {
  var _a2;
  return (_a2 = e.building) == null ? void 0 : _a2.color;
}
function useFloorBreadcrumbData(floorId) {
  const floor2 = useFloor(floorId);
  const building2 = useBuilding(floor2.buildingId);
  return { ...floor2, building: building2 };
}
function floorEntityToStringWithContext(i18n, masterData, floor2) {
  var _a2;
  if (!floor2) {
    return entityToString("floor", floor2);
  }
  const floorMd = masterData.floors.get(floor2.id) ?? floor2;
  const { buildingId } = floorMd;
  const building2 = masterData.buildings.get(buildingId);
  if (building2) {
    return `${floorMd.name ?? floorMd.id} < ${building2.name ?? building2.id}`;
  }
  return floorMd.name || ((_a2 = floorMd.id) == null ? void 0 : _a2.toString()) || "floor?";
}
const floor = {
  breadcrumb: breadcrumb$9,
  appBarBackgroundColor,
  entityToStringWithContext: floorEntityToStringWithContext,
  pathToBuilding: ["building"],
  defaultSortOrder: sortFloorWithMasterData
};
const itemBreadcrumbQueryNode = {
  _: [
    "id",
    "reference",
    "code",
    "itemTypeId"
  ],
  name: "item"
};
const itemBreadcrumb = {
  queryNode: itemBreadcrumbQueryNode,
  path: ["itemType"]
};
const item = {
  breadcrumb: itemBreadcrumb,
  entityToString: itemEntityToString,
  pathToBuilding: ["room", "floor", "building"]
};
function itemEntityToString(i18n, e) {
  if (e) {
    const { itemType: itemType2 } = e;
    if (itemType2) {
      return `${itemType2.name} (${e.reference || e.id})`;
    } else if (e.reference) {
      return e.reference;
    }
  }
  return e ? `item|${e.id}` : "?";
}
const itemTypeStoreAtom = atomFamily({
  key: "itemTypeStore",
  default: void 0
});
const atom_$6 = itemTypeStoreAtom;
function useItemTypes() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$6(currentCompany.name));
  if (!store) {
    throw new Error("ItemTypeStore is not loaded");
  }
  return store;
}
function useItemType(itemTypeId) {
  const e = useItemTypeOptional(itemTypeId);
  if (!e) {
    throw new Error(`itemType is missing in store for id : ${itemTypeId}`);
  }
  return e;
}
function useItemTypeOptional(itemTypeId) {
  const store = useItemTypes();
  if (itemTypeId) {
    const e = store.get(itemTypeId);
    return e;
  }
}
const breadcrumb$8 = {
  queryNode: {
    _: [
      "id",
      "name"
    ],
    name: "itemType"
  },
  path: [],
  useData: (id) => useItemType(id)
};
const itemType = {
  breadcrumb: breadcrumb$8,
  entityToString: (i18n, e) => `${e == null ? void 0 : e.name}` || entityToString("itemType", e)
};
function keepStartOfStrings(tokens, maxLength) {
  return tokens.map((t) => t.substring(0, maxLength));
}
function cleanExcelWorksheetName(title) {
  const removedQuotes = title.replace(/'/g, " ");
  if (removedQuotes.length > 31) {
    return keepStartOfStrings(removedQuotes.split(" "), 5).map((t) => capitalizeFirstLetter(t)).join("").substring(0, 31);
  }
  return removedQuotes;
}
const green = { argb: "0080FABC" };
const personProperties = [
  "id",
  "firstname",
  "lastname",
  "code",
  {
    name: "organization",
    _: ["name", { name: "organization", _: ["name"] }]
  }
];
function roomAffectationsByRooms(translation, roomIds) {
  return {
    objectTypeName: "room",
    exportType: "hasManyRec",
    columnNameMappings: {
      "G": { label: "Espace (Départ)" },
      "H": { label: "Étage (Départ)" },
      "I": { label: "Bâtiment (Départ)" },
      "K": { label: "Nom de l espace (workplaceAffectation:workplace:room)", fgColor: green },
      "L": { label: "Nom de l étage (workplaceAffectation:workplace:room:floor)", fgColor: green },
      "M": { label: "Nom du bâtiment (workplaceAffectation:workplace:room:floor:building)", fgColor: green }
    },
    worksheetName: cleanExcelWorksheetName(objectTypeCapitalizedPluralLabel(translation, "roomAffectation")),
    queryNode: {
      name: "roomAffectation",
      required: true,
      _: [
        { name: "person", _: personProperties },
        roomToBuildingWithRoomFilterQueryNode(roomIds, true),
        "id"
      ]
    }
  };
}
function workplaceAffectationsByRooms(translation, roomIds) {
  return {
    objectTypeName: "room",
    exportType: "hasManyRec",
    columnNameMappings: {
      "G": { label: "Poste de travail (Départ)" },
      "H": { label: "Espace (Départ)" },
      "I": { label: "Étage (Départ)" },
      "J": { label: "Bâtiment (Départ)" },
      "L": { label: "Nom du poste de travail (workplaceAffectation:workplace)", fgColor: green },
      "M": { label: "Nom de l espace (workplaceAffectation:workplace:room)", fgColor: green },
      "N": { label: "Nom de l étage (workplaceAffectation:workplace:room:floor)", fgColor: green },
      "O": { label: "Nom du bâtiment (workplaceAffectation:workplace:room:floor:building)", fgColor: green }
    },
    worksheetName: cleanExcelWorksheetName(objectTypeCapitalizedPluralLabel(translation, "workplaceAffectation")),
    queryNode: {
      name: "workplaceAffectation",
      required: true,
      _: [
        { name: "person", _: personProperties },
        {
          name: "workplace",
          required: true,
          _: [
            "name",
            roomToBuildingWithRoomFilterQueryNode(roomIds, true)
          ]
        },
        "id"
      ]
    }
  };
}
const mouvementMatrixExportQueryNodes = (translation, roomIds) => [
  workplaceAffectationsByRooms(translation, roomIds),
  roomAffectationsByRooms(translation, roomIds)
];
const mouvementMatrixReport = { name: "mouvementMatrix", iconObjectTypeName: "workplaceAffectation", exportQueryNodes: mouvementMatrixExportQueryNodes };
function roomToBuildingWithRoomFilterQueryNode(roomIds, required) {
  return {
    name: "room",
    required,
    filters: [createFilter("in", "id", roomIds)],
    _: ["name", {
      name: "floor",
      required,
      _: ["name", {
        name: "building",
        required,
        _: ["name"]
      }]
    }]
  };
}
thenBy_moduleExports.firstBy((a2, b2) => {
  return a2.floor && b2.floor ? a2.floor.buildingId - b2.floor.buildingId : 0;
}).thenBy((a2, b2) => {
  return a2.floorId - b2.floorId;
}).thenBy((a2, b2) => {
  return a2.name && b2.name ? a2.name.localeCompare(b2.name) : 0;
});
const sortRoomWithMasterData = (masterData) => {
  return thenBy_moduleExports.firstBy((a2, b2) => {
    var _a2, _b;
    const fA = masterData.floors.get(a2.floorId || ((_a2 = a2.floor) == null ? void 0 : _a2.id) || 0);
    const fB = masterData.floors.get(b2.floorId || ((_b = b2.floor) == null ? void 0 : _b.id) || 0);
    const bA = masterData.buildings.get((fA == null ? void 0 : fA.buildingId) || 0);
    const bB = masterData.buildings.get((fB == null ? void 0 : fB.buildingId) || 0);
    return bA && bB ? sortOnName(bA, bB) : 0;
  }).thenBy((a2, b2) => {
    var _a2, _b;
    const fA = masterData.floors.get(a2.floorId || ((_a2 = a2.floor) == null ? void 0 : _a2.id) || 0);
    const fB = masterData.floors.get(b2.floorId || ((_b = b2.floor) == null ? void 0 : _b.id) || 0);
    return fA && fB ? sortOnLevel(fA, fB) : 0;
  }).thenBy((a2, b2) => {
    return a2.name && b2.name ? sortOnNameOptional(a2, b2) : 0;
  });
};
const roomBreadcrumb = {
  queryNode: {
    _: [
      "id",
      "name",
      "floorId"
    ],
    name: "room"
  },
  path: ["floor", "building"]
};
function roomEntityToStringWithContext(i18n, masterData, r2) {
  var _a2;
  if (!r2) {
    return entityToString("room", r2);
  }
  const { floor: floor2 } = r2;
  if (floor2) {
    return `${floorEntityToStringWithContext(i18n, masterData, floor2)} > ${r2.name || r2.id}`;
  }
  return `${r2.name}` || ((_a2 = r2.id) == null ? void 0 : _a2.toString()) || "room?";
}
const room = {
  breadcrumb: roomBreadcrumb,
  entityToStringWithContext: roomEntityToStringWithContext,
  appBarBackgroundColor: (masterData, e) => {
    const floor2 = masterData.floors.get(e.floorId);
    const building2 = masterData.buildings.get((floor2 == null ? void 0 : floor2.buildingId) ?? 0);
    return building2 == null ? void 0 : building2.color;
  },
  reports: [mouvementMatrixReport],
  defaultSortOrder: sortRoomWithMasterData,
  pathToBuilding: ["floor", "building"]
};
const workplaceBreadcrumbQueryNode = {
  _: ["id", "name", {
    name: "room",
    _: ["id", "name", "floorId"]
  }],
  name: "workplace"
};
const workplaceBreadcrumb = {
  queryNode: workplaceBreadcrumbQueryNode,
  path: ["room", "floor", "building"]
};
function workplaceEntityToStringWithContext(i18n, masterData, w) {
  var _a2;
  if (!w) {
    return entityToString("workplace", w);
  }
  const { room: room2 } = w;
  if (room2) {
    return `${roomEntityToStringWithContext(i18n, masterData, room2)} > ${w.name || w.id}`;
  }
  return w.name || ((_a2 = w.id) == null ? void 0 : _a2.toString());
}
const workplace = {
  breadcrumb: workplaceBreadcrumb,
  entityToStringWithContext: workplaceEntityToStringWithContext,
  appBarBackgroundColor: (masterData, e) => {
    var _a2;
    const floor2 = masterData.floors.get(((_a2 = e.room) == null ? void 0 : _a2.floorId) ?? 0);
    const building2 = masterData.buildings.get((floor2 == null ? void 0 : floor2.buildingId) ?? 0);
    return building2 == null ? void 0 : building2.color;
  },
  pathToBuilding: ["room", "floor", "building"]
};
const organizationStoreAtom = atomFamily({
  key: "organizationStore",
  default: void 0
});
const atom_$5 = organizationStoreAtom;
function useOrganizations() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$5(currentCompany.name));
  if (!store) {
    throw new Error("OrganizationStore is not loaded");
  }
  return store;
}
function useOrganization(organizationId) {
  const e = useOrganizationOptional(organizationId);
  if (!e) {
    throw new Error(`organization is missing in store for id : ${organizationId}`);
  }
  return e;
}
function useOrganizationOptional(organizationId) {
  const store = useOrganizations();
  if (organizationId) {
    const e = store.get(organizationId);
    return e;
  }
}
const breadcrumb$7 = {
  queryNode: {
    _: [
      "id",
      "name",
      "organizationId"
    ],
    name: "organization"
  },
  path: ["organization"],
  useData: (id) => useOrganization(id)
};
const organization = {
  entityToString: (i18n, o) => {
    if ((o == null ? void 0 : o.name) && (o == null ? void 0 : o.organization)) {
      return `${o.name} (${o.organization.name})`;
    }
    return (o == null ? void 0 : o.name) || entityToString("organization", o);
  },
  breadcrumb: breadcrumb$7
};
const workplaceTypeStoreAtom = atomFamily({
  key: "workplaceTypeStore",
  default: void 0
});
const atom_$4 = workplaceTypeStoreAtom;
function useWorkplaceTypes() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$4(currentCompany.name));
  if (!store) {
    throw new Error("WorkplaceTypeStore is not loaded");
  }
  return store;
}
function useWorkplaceType(workplaceTypeId) {
  const e = useWorkplaceTypeOptional(workplaceTypeId);
  if (!e) {
    throw new Error(`workplaceType is missing in store for id : ${workplaceTypeId}`);
  }
  return e;
}
function useWorkplaceTypeOptional(workplaceTypeId) {
  const store = useWorkplaceTypes();
  if (workplaceTypeId) {
    const e = store.get(workplaceTypeId);
    return e;
  }
}
const workplaceTypeBreadcrumb = {
  queryNode: {
    _: ["id", "name"],
    name: "workplaceType"
  },
  path: [],
  useData: (id) => {
    return useWorkplaceType(id);
  }
};
const workplaceType = {
  entityToString: (i18n, e) => {
    if (e) {
      return e.name;
    }
    return "workplaceType|?";
  },
  breadcrumb: workplaceTypeBreadcrumb
};
const breadcrumb$6 = {
  queryNode: {
    _: ["id", workplaceBreadcrumbQueryNode],
    name: "workplaceAffectation"
  },
  path: ["workplace", "room", "floor", "building"]
};
function workplaceAffectationEntityToString(i18n, wa) {
  if (wa) {
    const { person: person2, workplace: workplace2 } = wa;
    if (person2 && workplace2) {
      return `${personEntityToString(i18n, person2)} - ${entityToString("workplace", workplace2)}`;
    }
  }
  return entityToString("workplaceAffectation", wa);
}
const workplaceAffectation = {
  breadcrumb: breadcrumb$6,
  entityToString: workplaceAffectationEntityToString,
  pathToBuilding: ["workplace", "room", "floor", "building"]
};
function isExportQueytNode(r2) {
  return !!r2;
}
const companyExportAllQueryNodes = (translation, companyIds) => {
  const privateObjectTypes = getAllObjectTypeDefinitions().filter((otDef) => otDef.scope === "private");
  const excludeProperties = [];
  const companyObjectTypeDefinition = getObjectTypeDefinitionByName("company");
  return [companyObjectTypeDefinition, ...privateObjectTypes].map((otDef) => {
    const properties2 = getObjectTypePropertyTypesWithFilter(otDef.name, [isPropertyTypeScalar, isPropertyTypeId]);
    const propertyNames = properties2.map(({ name }) => name);
    const filters2 = propertyNames.includes("companyId") ? [createFilter("in", "companyId", companyIds)] : void 0;
    const _ = jupDifferenceWith(propertyNames, excludeProperties);
    const r2 = {
      exportType: "hasManyCount",
      objectTypeName: otDef.name,
      includeForeignKeys: true,
      queryNode: {
        name: otDef.name,
        filters: filters2,
        _
      }
    };
    return r2;
  }).filter(isExportQueytNode);
};
const companyExportAllReport = { name: "export-all", iconObjectTypeName: "company", exportQueryNodes: companyExportAllQueryNodes };
const breadcrumb$5 = {
  queryNode: {
    _: [
      "id",
      "name"
    ],
    name: "company"
  },
  path: []
};
const company = {
  breadcrumb: breadcrumb$5,
  reports: [
    companyExportAllReport
    // companyExportAllDuplicateReport
  ]
};
const queryNode$1 = { name: "buildingType", _: ["id", "name"] };
const buildingType = {
  breadcrumb: { queryNode: queryNode$1, path: [] },
  entityToString: (i18n, e) => (e == null ? void 0 : e.name) || entityToString("buildingType", e)
};
const personSecurityProfileStoreAtom = atomFamily({
  key: "personSecurityProfileStore",
  default: void 0
});
const atom_$3 = personSecurityProfileStoreAtom;
function usePersonSecurityProfiles() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$3(currentCompany.name));
  if (!store) {
    throw new Error("PersonSecurityProfileStore is not loaded");
  }
  return store;
}
function usePersonSecurityProfile(personSecurityProfileId) {
  const e = usePersonSecurityProfileOptional(personSecurityProfileId);
  if (!e) {
    throw new Error(`personSecurityProfile is missing in store for id : ${personSecurityProfileId}`);
  }
  return e;
}
function usePersonSecurityProfileOptional(personSecurityProfileId) {
  const store = usePersonSecurityProfiles();
  if (personSecurityProfileId) {
    const e = store.get(personSecurityProfileId);
    return e;
  }
}
const breadcrumb$4 = {
  queryNode: {
    _: [
      "id",
      "name"
    ],
    name: "personSecurityProfile"
  },
  path: [],
  useData: (id) => usePersonSecurityProfile(id)
};
const personSecurityProfile = {
  breadcrumb: breadcrumb$4,
  entityToString: (i18n, e) => e ? e.name : "?"
};
const personStateStoreAtom = atomFamily({
  key: "personStateStore",
  default: void 0
});
const atom_$2 = personStateStoreAtom;
function usePersonStates() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$2(currentCompany.name));
  if (!store) {
    throw new Error("PersonStateStore is not loaded");
  }
  return store;
}
function usePersonState(personStateId) {
  const e = usePersonStateOptional(personStateId);
  if (!e) {
    throw new Error(`personState is missing in store for id : ${personStateId}`);
  }
  return e;
}
function usePersonStateOptional(personStateId) {
  const store = usePersonStates();
  if (personStateId) {
    const e = store.get(personStateId);
    return e;
  }
}
const breadcrumb$3 = {
  queryNode: {
    _: [
      "id",
      "name"
    ],
    name: "personState"
  },
  path: [],
  useData: (id) => usePersonState(id)
};
const personState = {
  breadcrumb: breadcrumb$3,
  entityToString: (i18n, e) => e ? e.name : "?"
};
const costCenterStoreAtom = atomFamily({
  key: "costCenterStore",
  default: void 0
});
const atom_$1 = costCenterStoreAtom;
function useCostCenters() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_$1(currentCompany.name));
  if (!store) {
    throw new Error("CostCenterStore is not loaded");
  }
  return store;
}
function useCostCenter(costCenterId) {
  const e = useCostCenterOptional(costCenterId);
  if (!e) {
    throw new Error(`costCenter is missing in store for id : ${costCenterId}`);
  }
  return e;
}
function useCostCenterOptional(costCenterId) {
  const store = useCostCenters();
  if (costCenterId) {
    const e = store.get(costCenterId);
    return e;
  }
}
const costCenterBreadcrumb = {
  path: [],
  useData: (id) => useCostCenter(id)
};
const costCenter = {
  breadcrumb: costCenterBreadcrumb,
  entityToString: (i18n, e) => e ? e.name : "?"
};
const queryNode = { name: "roomType", _: ["id", "name"] };
const roomType = {
  breadcrumb: { queryNode, path: [] },
  entityToString: (i18n, e) => (e == null ? void 0 : e.name) || entityToString("roomType", e)
};
const userBreadcrumb = {
  queryNode: {
    name: "user",
    _: ["id", "firstname", "lastname", "sub", "picture"]
  },
  path: []
};
function userEntityToString(i18n, r2) {
  var _a2;
  if (!r2) {
    return entityToString("user", r2);
  }
  return userDisplayName(r2) || ((_a2 = r2.id) == null ? void 0 : _a2.toString());
}
const user = {
  breadcrumb: userBreadcrumb,
  entityToString: userEntityToString
};
const jupRoleBreadcrumb = {
  queryNode: {
    _: ["id", "name", "code"],
    name: "jupRole"
  },
  path: []
};
function jupRoleEntityToString(i18n, r2) {
  var _a2;
  if (!r2) {
    return entityToString("jupRole", r2);
  }
  return r2.name && r2.code ? `${r2.name} (${r2.code})` : r2.name || ((_a2 = r2.id) == null ? void 0 : _a2.toString());
}
const jupRole = {
  breadcrumb: jupRoleBreadcrumb,
  entityToString: jupRoleEntityToString
};
const breadcrumb$2 = {
  queryNode: {
    _: [
      "id",
      "labelBackward",
      "labelForward"
    ],
    name: "personToPersonType"
  },
  path: []
};
const personToPersonTypeEntityToString = (i18n, e) => {
  return e ? `${e.labelForward} (${e.labelBackward})` : "?";
};
const personToPersonType = {
  breadcrumb: breadcrumb$2,
  entityToString: personToPersonTypeEntityToString
};
const jupUserCompanyToJupRoleBreadcrumb = {
  queryNode: {
    _: [
      "id",
      { name: "jupRole", _: ["name", "id"] },
      userCompanyBreadcrumbQueryNode
    ],
    name: "jupUserCompanyToJupRole"
  },
  path: ["userCompany", "user"]
};
function jupUserCompanyToJupRoleEntityToString(i18n, masterData, r2) {
  var _a2, _b, _c;
  if (!r2) {
    return entityToString("jupUserCompanyToJupRole", r2);
  }
  const { userCompany: userCompany2 } = r2;
  if (userCompany2 == null ? void 0 : userCompany2.user) {
    return `${userDisplayName(userCompany2 == null ? void 0 : userCompany2.user)} | ${(_a2 = r2.jupRole) == null ? void 0 : _a2.name}`;
  }
  return ((_b = r2.jupRole) == null ? void 0 : _b.name) || ((_c = r2.id) == null ? void 0 : _c.toString());
}
const jupUserCompanyToJupRole = {
  breadcrumb: jupUserCompanyToJupRoleBreadcrumb,
  entityToStringWithContext: jupUserCompanyToJupRoleEntityToString
};
const jupRoleToJupObjectTypeBreadcrumb = {
  queryNode: {
    _: [
      "id",
      "arCreate",
      "arDelete",
      "arRead",
      "arUpdate",
      { name: "jupRole", _: ["name", "id"] },
      { name: "jupObjectType", _: ["name", "id"] }
    ],
    name: "jupRoleToJupObjectType"
  },
  path: []
};
function jupRoleToJupObjectTypeEntityToString(i18n, r2) {
  var _a2, _b, _c, _d, _e;
  if (!r2) {
    return entityToString("jupRoleToJupObjectType", r2);
  }
  const ar = [];
  if (r2.arCreate) ar.push("C");
  if (r2.arRead) ar.push("R");
  if (r2.arUpdate) ar.push("U");
  if (r2.arDelete) ar.push("D");
  if (((_a2 = r2.jupRole) == null ? void 0 : _a2.name) && ((_b = r2.jupObjectType) == null ? void 0 : _b.name) && ar.length > 0) {
    return `${(_c = r2.jupRole) == null ? void 0 : _c.name} - ${(_d = r2.jupObjectType) == null ? void 0 : _d.name} (${ar.join("")})`;
  }
  return (_e = r2.id) == null ? void 0 : _e.toString();
}
const jupRoleToJupObjectType = {
  breadcrumb: jupRoleToJupObjectTypeBreadcrumb,
  entityToString: jupRoleToJupObjectTypeEntityToString
};
const jupObjectTypeBreadcrumb = {
  queryNode: {
    _: ["id", "name"],
    name: "jupObjectType"
  },
  path: []
};
function jupObjectTypeEntityToString(i18n, r2) {
  if (!r2) {
    return entityToString("jupObjectType", r2);
  }
  if (!r2.name) {
    return entityToString("jupObjectType", r2);
  }
  return getObjectTypeCapitalizedSingularLabel(i18n.translate, r2.name);
}
const jupObjectType = {
  breadcrumb: jupObjectTypeBreadcrumb,
  entityToString: jupObjectTypeEntityToString
};
const jupUiOptionBreadcrumb = {
  queryNode: {
    _: ["id", "name"],
    name: "jupUiOption"
  },
  path: []
};
const jupUiOption = {
  breadcrumb: jupUiOptionBreadcrumb
};
const breadcrumb$1 = {
  queryNode: {
    _: ["id", itemBreadcrumbQueryNode],
    name: "itemToPerson"
  },
  path: ["item", "room", "floor", "building"]
};
function itemToPersonEntityToString(i18n, wa) {
  if (wa) {
    const { person: person2, item: item2 } = wa;
    if (person2 && item2) {
      return `${personEntityToString(i18n, person2)} - ${itemEntityToString(i18n, item2)}`;
    }
  }
  return entityToString("itemToPerson", wa);
}
const itemToPerson = {
  breadcrumb: breadcrumb$1,
  entityToString: itemToPersonEntityToString,
  pathToBuilding: ["item", "room", "floor", "building"]
};
function dimensionTypeLabel(i18nApi, dt) {
  const key = `dimensionTypes.${dt.name}.one`;
  if (i18nApi.keyExists(key)) {
    return i18nApi.translate(key);
  }
  return dt.name;
}
const dimensionTypeStoreAtom = atomFamily({
  key: "dimensionTypeStore",
  default: void 0
});
const atom_ = dimensionTypeStoreAtom;
function useDimensionTypes() {
  const currentCompany = useCurrentCompany();
  const store = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(atom_(currentCompany.name));
  if (!store) {
    throw new Error("DimensionTypeStore is not loaded");
  }
  return store;
}
function useDimensionType(dimensionTypeId) {
  const e = useDimensionTypeOptional(dimensionTypeId);
  if (!e) {
    throw new Error(`dimensionType is missing in store for id : ${dimensionTypeId}`);
  }
  return e;
}
function useDimensionTypeOptional(dimensionTypeId) {
  const store = useDimensionTypes();
  if (dimensionTypeId) {
    const e = store.get(dimensionTypeId);
    return e;
  }
}
const dtBreadcrumb = {
  queryNode: {
    _: [
      "id",
      "name"
    ],
    name: "dimensionType"
  },
  path: [],
  useData: (id) => useDimensionType(id)
};
const dimensionType = {
  entityToString: (i18n, e) => e ? dimensionTypeLabel(i18n, e) : "?",
  breadcrumb: dtBreadcrumb
};
function dimensionEntityToString(i18n, e) {
  return e ? e.name : entityToString("dimension", e);
}
const dimension = {
  entityToString: dimensionEntityToString,
  breadcrumb: {
    queryNode: {
      _: ["id", "name", "dimensionTypeId", { name: "dimensionType", _: ["id", "name"] }],
      name: "dimension"
    },
    path: ["dimensionType"]
  }
};
const dimensionToPerson = {
  entityToString: (i18n, e) => {
    if (!e) {
      return entityToString("dimensionToPerson", e);
    }
    const r2 = [
      dimensionEntityToString(i18n, e.dimension),
      personEntityToString(i18n, e.person)
    ];
    return r2.join(" - ");
  },
  pathToBuilding: ["dimension", "dimensionType"]
};
const contentRoleToUserCompany = {
  entityToString: (i18n, e) => {
    var _a2, _b;
    if ((_a2 = e == null ? void 0 : e.contentRole) == null ? void 0 : _a2.name) {
      return (_b = e.contentRole) == null ? void 0 : _b.name;
    }
    return entityToString("contentRoleToUserCompany", e);
  }
};
const breadcrumb = {
  queryNode: {
    _: [
      "id",
      "name"
    ],
    name: "object3dModel"
  },
  path: []
};
const object3dModel = {
  breadcrumb,
  entityToString: (i18n, e) => `${e == null ? void 0 : e.name}` || entityToString("object3dModel", e)
};
function getJupUiLayoutLabel(translation, jupUiLayout2) {
  return translation(`layoutViewSets.${jupUiLayout2.name}.label`);
}
const jupUiLayout = {
  entityToString: (i18n, e) => e ? getJupUiLayoutLabel(i18n.translate, e) : entityToString("jupUiLayout", e)
};
const customizedObjectTypes = {
  person,
  item,
  company,
  itemType,
  object3dModel,
  personSecurityProfile,
  personState,
  organization,
  buildingType,
  roomAffectation,
  dimensionToPerson,
  building,
  floor,
  dimensionType,
  dimension,
  room,
  workplace,
  workplaceAffectation,
  workplaceType,
  costCenter,
  roomType,
  userCompany,
  user,
  itemToPerson,
  jupUserCompanyToJupRole,
  jupRoleToJupObjectType,
  jupRole,
  jupObjectType,
  jupUiOption,
  personToPersonType,
  contentRoleToUserCompany,
  jupUiLayout,
  dimensionFloor: {
    pathToBuilding: ["floor", "building"]
  },
  organizationFloor: {
    pathToBuilding: ["floor", "building"]
  },
  personCompany: {
    breadcrumb: {
      queryNode: { name: "personCompany", _: ["id", "name"] },
      path: []
    }
  },
  dimensionRoom: {
    pathToBuilding: ["room", "floor", "building"]
  },
  contentRoleToFloor: {
    pathToBuilding: ["floor", "building"]
  }
};
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$1(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
const Root = ElementType.Root;
const Text$1 = ElementType.Text;
const Directive = ElementType.Directive;
const Comment$1 = ElementType.Comment;
const Script = ElementType.Script;
const Style = ElementType.Style;
const Tag = ElementType.Tag;
const CDATA$1 = ElementType.CDATA;
const Doctype = ElementType.Doctype;
class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent2) {
    this.parent = parent2;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev2) {
    this.prev = prev2;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next2) {
    this.next = next2;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}
class DataNode extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data2) {
    super();
    this.data = data2;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data2) {
    this.data = data2;
  }
}
class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}
class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}
class ProcessingInstruction extends DataNode {
  constructor(name, data2) {
    super(data2);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class NodeWithChildren extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children2) {
    super();
    this.children = children2;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children2) {
    this.children = children2;
  }
}
class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}
class Element extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children2 = [], type2 = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children2);
    this.name = name;
    this.attribs = attribs;
    this.type = type2;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a2, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
}
function isTag(node2) {
  return isTag$1(node2);
}
function isCDATA(node2) {
  return node2.type === ElementType.CDATA;
}
function isText(node2) {
  return node2.type === ElementType.Text;
}
function isComment(node2) {
  return node2.type === ElementType.Comment;
}
function isDirective(node2) {
  return node2.type === ElementType.Directive;
}
function isDocument(node2) {
  return node2.type === ElementType.Root;
}
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
function cloneNode(node2, recursive = false) {
  let result;
  if (isText(node2)) {
    result = new Text(node2.data);
  } else if (isComment(node2)) {
    result = new Comment(node2.data);
  } else if (isTag(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new Element(node2.name, { ...node2.attribs }, children2);
    children2.forEach((child) => child.parent = clone2);
    if (node2.namespace != null) {
      clone2.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node2["x-attribsNamespace"] };
    }
    if (node2["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node2["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new CDATA(children2);
    children2.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new Document(children2);
    children2.forEach((child) => child.parent = clone2);
    if (node2["x-mode"]) {
      clone2["x-mode"] = node2["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node2)) {
    const instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node2.type}`);
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children2 = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children2.length; i++) {
    children2[i].prev = children2[i - 1];
    children2[i - 1].next = children2[i];
  }
  return children2;
}
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c) => c.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c) => c.charCodeAt(0))
);
var _a;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end2, base2) {
    if (start !== end2) {
      const digitCount = end2 - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2) || isHexadecimalCharacter(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char2, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char2, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char2 = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char2);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char2)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char2 === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char2) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char2 === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char2 - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char2) {
      lo = mid + 1;
    } else if (midVal > char2) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
const getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match2;
  while ((match2 = xmlReplacer.exec(str)) !== null) {
    const i = match2.index;
    const char2 = str.charCodeAt(i);
    const next2 = xmlCodeMap.get(char2);
    if (next2 !== void 0) {
      ret += str.substring(lastIdx, i) + next2;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char2 & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape2(data2) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data2)) {
      if (lastIdx !== match2.index) {
        result += data2.substring(lastIdx, match2.index);
      }
      result += map2.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
const escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
const escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
const elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
const attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));
const unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a2;
  if (!attributes2)
    return;
  const encode = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
const singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node2, options = {}) {
  const nodes = "length" in node2 ? node2 : [node2];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node2, options) {
  switch (node2.type) {
    case Root:
      return render(node2.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node2);
    case Comment$1:
      return renderComment(node2);
    case CDATA$1:
      return renderCdata(node2);
    case Script:
    case Style:
    case Tag:
      return renderTag(node2, options);
    case Text$1:
      return renderText(node2, options);
  }
}
const foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
const foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data2 = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
function getOuterHTML(node2, options) {
  return render(node2, options);
}
function getInnerHTML(node2, options) {
  return hasChildren(node2) ? node2.children.map((node3) => getOuterHTML(node3, options)).join("") : "";
}
function getText(node2) {
  if (Array.isArray(node2))
    return node2.map(getText).join("");
  if (isTag(node2))
    return node2.name === "br" ? "\n" : getText(node2.children);
  if (isCDATA(node2))
    return getText(node2.children);
  if (isText(node2))
    return node2.data;
  return "";
}
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if (hasChildren(node2) && !isComment(node2)) {
    return textContent(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if (hasChildren(node2) && (node2.type === ElementType.Tag || isCDATA(node2))) {
    return innerText(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent2 = getParent(elem);
  if (parent2 != null)
    return getChildren(parent2);
  const siblings2 = [elem];
  let { prev: prev2, next: next2 } = elem;
  while (prev2 != null) {
    siblings2.unshift(prev2);
    ({ prev: prev2 } = prev2);
  }
  while (next2 != null) {
    siblings2.push(next2);
    ({ next: next2 } = next2);
  }
  return siblings2;
}
function getAttributeValue(elem, name) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next: next2 } = elem;
  while (next2 !== null && !isTag(next2))
    ({ next: next2 } = next2);
  return next2;
}
function prevElementSibling(elem) {
  let { prev: prev2 } = elem;
  while (prev2 !== null && !isTag(prev2))
    ({ prev: prev2 } = prev2);
  return prev2;
}
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev2 = replacement.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement;
  }
  const next2 = replacement.next = elem.next;
  if (next2) {
    next2.prev = replacement;
  }
  const parent2 = replacement.parent = elem.parent;
  if (parent2) {
    const childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent2, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent2;
  if (parent2.children.push(child) > 1) {
    const sibling = parent2.children[parent2.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append$1(elem, next2) {
  removeElement(next2);
  const { parent: parent2 } = elem;
  const currNext = elem.next;
  next2.next = currNext;
  next2.prev = elem;
  elem.next = next2;
  next2.parent = parent2;
  if (currNext) {
    currNext.prev = next2;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next2);
    }
  } else if (parent2) {
    parent2.children.push(next2);
  }
}
function prependChild(parent2, child) {
  removeElement(child);
  child.parent = parent2;
  child.prev = null;
  if (parent2.children.unshift(child) !== 1) {
    const sibling = parent2.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend$1(elem, prev2) {
  removeElement(prev2);
  const { parent: parent2 } = elem;
  if (parent2) {
    const childs = parent2.children;
    childs.splice(childs.indexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
}
function filter$2(test, node2, recurse = true, limit = Infinity) {
  return find$2(test, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
function find$2(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node2 = nodes[i];
    if (!isTag(node2)) {
      continue;
    } else if (test(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne(test, node2.children, true);
    }
  }
  return elem;
}
function existsOne(test, nodes) {
  return nodes.some((checked) => isTag(checked) && (test(checked) || existsOne(test, checked.children)));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag(elem))
      continue;
    if (test(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
const Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag;
    }
    return (elem) => isTag(elem) && elem.name === name;
  },
  tag_type(type2) {
    if (typeof type2 === "function") {
      return (elem) => type2(elem.type);
    }
    return (elem) => elem.type === type2;
  },
  tag_contains(data2) {
    if (typeof data2 === "function") {
      return (elem) => isText(elem) && data2(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data2;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a2, b2) {
  return (elem) => a2(elem) || b2(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node2) {
  const test = compileTest(options);
  return test ? test(node2) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter$2(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter$2(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type2, nodes, recurse = true, limit = Infinity) {
  return filter$2(Checks["tag_type"](type2), nodes, recurse, limit);
}
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node2 = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings2 = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node2, i, arr) => !arr.includes(node2, i + 1));
  nodes.sort((a2, b2) => {
    const relative = compareDocumentPosition(a2, b2);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item2) => {
      var _a3;
      const { children: children2 } = item2;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "id", children2);
      addConditionally(entry, "title", "title", children2);
      const href2 = (_a3 = getOneElement("link", children2)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch$1("summary", children2) || fetch$1("content", children2);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch$1("updated", children2);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item2) => {
      const { children: children2 } = item2;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "guid", children2);
      addConditionally(entry, "title", "title", children2);
      addConditionally(entry, "link", "link", children2);
      addConditionally(entry, "description", "description", children2);
      const pubDate = fetch$1("pubDate", children2) || fetch$1("dc:date", children2);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
const MEDIA_KEYS_STRING = ["url", "type", "lang"];
const MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node2) {
  return getElementsByTagName(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse = false) {
  const val2 = fetch$1(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
const DomUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return DocumentPosition;
  },
  append: append$1,
  appendChild,
  compareDocumentPosition,
  existsOne,
  filter: filter$2,
  find: find$2,
  findAll,
  findOne,
  findOneChild,
  getAttributeValue,
  getChildren,
  getElementById,
  getElements,
  getElementsByTagName,
  getElementsByTagType,
  getFeed,
  getInnerHTML,
  getName,
  getOuterHTML,
  getParent,
  getSiblings,
  getText,
  hasAttrib,
  hasChildren,
  innerText,
  isCDATA,
  isComment,
  isDocument,
  isTag,
  isText,
  nextElementSibling,
  prepend: prepend$1,
  prependChild,
  prevElementSibling,
  removeElement,
  removeSubsets,
  replaceElement,
  testElement,
  textContent,
  uniqueSort
}, Symbol.toStringTag, { value: "Module" }));
function text$1(elements) {
  const elems = elements !== null && elements !== void 0 ? elements : this ? this.root() : [];
  let ret = "";
  for (let i = 0; i < elems.length; i++) {
    ret += textContent(elems[i]);
  }
  return ret;
}
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  let next2 = contained;
  while (next2 && next2 !== next2.parent) {
    next2 = next2.parent;
    if (next2 === container) {
      return true;
    }
  }
  return false;
}
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
function camelCase(str) {
  return str.replace(/[._-](\w|$)/g, (_, x) => x.toUpperCase());
}
function cssCase(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function domEach(array, fn) {
  const len = array.length;
  for (let i = 0; i < len; i++)
    fn(array[i], i);
  return array;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
  CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
  CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
  CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
  CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
function isHtml(str) {
  const tagStart = str.indexOf("<");
  if (tagStart < 0 || tagStart > str.length - 3)
    return false;
  const tagChar = str.charCodeAt(tagStart + 1);
  return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
}
const hasOwn = Object.prototype.hasOwnProperty;
const rspace = /\s+/;
const dataAttrPrefix = "data-";
const rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
const rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name, xmlMode) {
  var _a2;
  if (!elem || !isTag(elem))
    return void 0;
  (_a2 = elem.attribs) !== null && _a2 !== void 0 ? _a2 : elem.attribs = {};
  if (!name) {
    return elem.attribs;
  }
  if (hasOwn.call(elem.attribs, name)) {
    return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];
  }
  if (elem.name === "option" && name === "value") {
    return text$1(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name, value) {
  if (value === null) {
    removeAttribute(el, name);
  } else {
    el.attribs[name] = `${value}`;
  }
}
function attr(name, value) {
  if (typeof name === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach(this, (el, i) => {
        if (isTag(el))
          setAttr(el, name, value.call(el, i, el.attribs[name]));
      });
    }
    return domEach(this, (el) => {
      if (!isTag(el))
        return;
      if (typeof name === "object") {
        for (const objName of Object.keys(name)) {
          const objValue = name[objName];
          setAttr(el, objName, objValue);
        }
      } else {
        setAttr(el, name, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name, this.options.xmlMode);
}
function getProp(el, name, xmlMode) {
  return name in el ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el[name]
  ) : !xmlMode && rboolean.test(name) ? getAttr(el, name, false) !== void 0 : getAttr(el, name, xmlMode);
}
function setProp(el, name, value, xmlMode) {
  if (name in el) {
    el[name] = value;
  } else {
    setAttr(el, name, !xmlMode && rboolean.test(name) ? value ? "" : null : `${value}`);
  }
}
function prop(name, value) {
  var _a2;
  if (typeof name === "string" && value === void 0) {
    const el = this[0];
    if (!el || !isTag(el))
      return void 0;
    switch (name) {
      case "style": {
        const property = this.css();
        const keys = Object.keys(property);
        for (let i = 0; i < keys.length; i++) {
          property[i] = keys[i];
        }
        property.length = keys.length;
        return property;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop2 = (_a2 = el.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
        if (typeof URL !== "undefined" && (name === "href" && (el.tagName === "a" || el.tagName === "link") || name === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
          return new URL(prop2, this.options.baseURI).href;
        }
        return prop2;
      }
      case "innerText": {
        return innerText(el);
      }
      case "textContent": {
        return textContent(el);
      }
      case "outerHTML": {
        return this.clone().wrap("<container />").parent().html();
      }
      case "innerHTML": {
        return this.html();
      }
      default: {
        return getProp(el, name, this.options.xmlMode);
      }
    }
  }
  if (typeof name === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name === "object") {
        throw new TypeError("Bad combination of arguments.");
      }
      return domEach(this, (el, i) => {
        if (isTag(el)) {
          setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);
        }
      });
    }
    return domEach(this, (el) => {
      if (!isTag(el))
        return;
      if (typeof name === "object") {
        for (const key of Object.keys(name)) {
          const val2 = name[key];
          setProp(el, key, val2, this.options.xmlMode);
        }
      } else {
        setProp(el, name, value, this.options.xmlMode);
      }
    });
  }
  return void 0;
}
function setData(elem, name, value) {
  var _a2;
  (_a2 = elem.data) !== null && _a2 !== void 0 ? _a2 : elem.data = {};
  if (typeof name === "object")
    Object.assign(elem.data, name);
  else if (typeof name === "string" && value !== void 0) {
    elem.data[name] = value;
  }
}
function readAllData(el) {
  for (const domName of Object.keys(el.attribs)) {
    if (!domName.startsWith(dataAttrPrefix)) {
      continue;
    }
    const jsName = camelCase(domName.slice(dataAttrPrefix.length));
    if (!hasOwn.call(el.data, jsName)) {
      el.data[jsName] = parseDataValue(el.attribs[domName]);
    }
  }
  return el.data;
}
function readData(el, name) {
  const domName = dataAttrPrefix + cssCase(name);
  const data2 = el.data;
  if (hasOwn.call(data2, name)) {
    return data2[name];
  }
  if (hasOwn.call(el.attribs, domName)) {
    return data2[name] = parseDataValue(el.attribs[domName]);
  }
  return void 0;
}
function parseDataValue(value) {
  if (value === "null")
    return null;
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  const num = Number(value);
  if (value === String(num))
    return num;
  if (rbrace.test(value)) {
    try {
      return JSON.parse(value);
    } catch {
    }
  }
  return value;
}
function data(name, value) {
  var _a2;
  const elem = this[0];
  if (!elem || !isTag(elem))
    return;
  const dataEl = elem;
  (_a2 = dataEl.data) !== null && _a2 !== void 0 ? _a2 : dataEl.data = {};
  if (name == null) {
    return readAllData(dataEl);
  }
  if (typeof name === "object" || value !== void 0) {
    domEach(this, (el) => {
      if (isTag(el)) {
        if (typeof name === "object")
          setData(el, name);
        else
          setData(el, name, value);
      }
    });
    return this;
  }
  return readData(dataEl, name);
}
function val(value) {
  const querying = arguments.length === 0;
  const element = this[0];
  if (!element || !isTag(element))
    return querying ? void 0 : this;
  switch (element.name) {
    case "textarea": {
      return this.text(value);
    }
    case "select": {
      const option = this.find("option:selected");
      if (!querying) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values2 = typeof value === "object" ? value : [value];
        for (const val2 of values2) {
          this.find(`option[value="${val2}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option.toArray().map((el) => text$1(el.children)) : option.attr("value");
    }
    case "input":
    case "option": {
      return querying ? this.attr("value") : this.attr("value", value);
    }
  }
  return void 0;
}
function removeAttribute(elem, name) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name))
    return;
  delete elem.attribs[name];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name) {
  const attrNames = splitNames(name);
  for (const attrName of attrNames) {
    domEach(this, (elem) => {
      if (isTag(elem))
        removeAttribute(elem, attrName);
    });
  }
  return this;
}
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length > 0) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end2 = idx + className.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
function addClass(value) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        const className = el.attribs["class"] || "";
        addClass.call([el], value.call(el, i, className));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag(el))
      continue;
    const className = getAttr(el, "class", false);
    if (className) {
      let setClass = ` ${className} `;
      for (const cn of classNames) {
        const appendClass = `${cn} `;
        if (!setClass.includes(` ${appendClass}`))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    } else {
      setAttr(el, "class", classNames.join(" ").trim());
    }
  }
  return this;
}
function removeClass(name) {
  if (typeof name === "function") {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        removeClass.call([el], name.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach(this, (el) => {
    if (!isTag(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el.attribs["class"]);
      let changed = false;
      for (let j = 0; j < numClasses; j++) {
        const index2 = elClasses.indexOf(classes[j]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        toggleClass.call([el], value.call(el, i, el.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag(el))
      continue;
    const elementClasses = splitNames(el.attribs["class"]);
    for (let j = 0; j < numClasses; j++) {
      const index2 = elementClasses.indexOf(classNames[j]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}
const Attributes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addClass,
  attr,
  data,
  hasClass,
  prop,
  removeAttr,
  removeClass,
  toggleClass,
  val
}, Symbol.toStringTag, { value: "Module" }));
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
const unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal$1(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse$2(selector) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match2 = selector.slice(selectorIndex + offset).match(reName);
    if (!match2) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match2;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type2) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type2;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type: type2 });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case 62: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === 124) {
          name = getName2(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name = getName2(2);
        } else {
          name = getName2(0);
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
            namespace = name;
            name = getName2(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== 61) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === 61) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
              sectionEnd += 1;
            }
            if (selector.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
              selectorIndex += 1;
            }
            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
          if (forceIgnore === 115) {
            ignoreCase = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105) {
            ignoreCase = true;
            stripWhitespace(1);
          }
        }
        if (selector.charCodeAt(selectorIndex) !== 93) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName2(2).toLowerCase(),
            data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name = getName2(1).toLowerCase();
        let data2 = null;
        if (selector.charCodeAt(selectorIndex) === 40) {
          if (unpackPseudos.has(name)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            }
            data2 = [];
            selectorIndex = parseSelector(data2, selector, selectorIndex + 1);
            if (selector.charCodeAt(selectorIndex) !== 41) {
              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
            }
            selectorIndex += 1;
          } else {
            data2 = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name)) {
              const quot = data2.charCodeAt(0);
              if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                data2 = data2.slice(1, -1);
              }
            }
            data2 = unescapeCSS(data2);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name, data: data2 });
        break;
      }
      case 44: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name;
        if (firstChar === 42) {
          selectorIndex += 1;
          name = "*";
        } else if (firstChar === 124) {
          name = "";
          if (selector.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name = getName2(0);
        } else {
          break loop;
        }
        if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
          namespace = name;
          if (selector.charCodeAt(selectorIndex + 1) === 42) {
            name = "*";
            selectorIndex += 2;
          } else {
            name = getName2(1);
          }
        }
        tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}
var boolbase$1;
var hasRequiredBoolbase;
function requireBoolbase() {
  if (hasRequiredBoolbase) return boolbase$1;
  hasRequiredBoolbase = 1;
  boolbase$1 = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };
  return boolbase$1;
}
var boolbaseExports = requireBoolbase();
const boolbase = /* @__PURE__ */ getDefaultExportFromCjs(boolbaseExports);
const procedure = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal(token2) {
  return !procedure.has(token2.type);
}
const attributes = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token2 = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token2;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure(token2) {
  var _a2, _b;
  let proc = (_a2 = procedure.get(token2.type)) !== null && _a2 !== void 0 ? _a2 : -1;
  if (token2.type === SelectorType.Attribute) {
    proc = (_b = attributes.get(token2.action)) !== null && _b !== void 0 ? _b : 4;
    if (token2.action === AttributeAction.Equals && token2.name === "id") {
      proc = 9;
    }
    if (token2.ignoreCase) {
      proc >>= 1;
    }
  } else if (token2.type === SelectorType.Pseudo) {
    if (!token2.data) {
      proc = 3;
    } else if (token2.name === "has" || token2.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token2.data)) {
      proc = Math.min(...token2.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}
const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
const caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
const attributeRules = {
  equals(next2, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter.getAttributeValue(elem, name);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name) === value && next2(elem);
  },
  hyphen(next2, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    const len = value.length;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr2 = adapter.getAttributeValue(elem, name);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return function hyphen(elem) {
      const attr2 = adapter.getAttributeValue(elem, name);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next2(elem);
    };
  },
  element(next2, data2, options) {
    const { adapter } = options;
    const { name, value } = data2;
    if (/\s/.test(value)) {
      return boolbase.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options) ? "i" : "");
    return function element(elem) {
      const attr2 = adapter.getAttributeValue(elem, name);
      return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
    };
  },
  exists(next2, { name }, { adapter }) {
    return (elem) => adapter.hasAttrib(elem, name) && next2(elem);
  },
  start(next2, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    const len = value.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter.getAttributeValue(elem, name);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value)) && next2(elem);
    };
  },
  end(next2, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    const len = -value.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a2;
        return ((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value)) && next2(elem);
    };
  },
  any(next2, data2, options) {
    const { adapter } = options;
    const { name, value } = data2;
    if (value === "") {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr2 = adapter.getAttributeValue(elem, name);
        return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.includes(value)) && next2(elem);
    };
  },
  not(next2, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    if (value === "") {
      return (elem) => !!adapter.getAttributeValue(elem, name) && next2(elem);
    } else if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter.getAttributeValue(elem, name);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next2(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name) !== value && next2(elem);
  }
};
const whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$1(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a2 = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a2 = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a2, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile(parsed) {
  const a2 = parsed[0];
  const b2 = parsed[1] - 1;
  if (b2 < 0 && a2 <= 0)
    return boolbase.falseFunc;
  if (a2 === -1)
    return (index2) => index2 <= b2;
  if (a2 === 0)
    return (index2) => index2 === b2;
  if (a2 === 1)
    return b2 < 0 ? boolbase.trueFunc : (index2) => index2 >= b2;
  const absA = Math.abs(a2);
  const bMod = (b2 % absA + absA) % absA;
  return a2 > 1 ? (index2) => index2 >= b2 && index2 % absA === bMod : (index2) => index2 <= b2 && index2 % absA === bMod;
}
function nthCheck(formula) {
  return compile(parse$1(formula));
}
function getChildFunc(next2, adapter) {
  return (elem) => {
    const parent2 = adapter.getParent(elem);
    return parent2 != null && adapter.isTag(parent2) && next2(elem);
  };
}
const filters = {
  contains(next2, text2, { adapter }) {
    return function contains2(elem) {
      return next2(elem) && adapter.getText(elem).includes(text2);
    };
  },
  icontains(next2, text2, { adapter }) {
    const itext = text2.toLowerCase();
    return function icontains(elem) {
      return next2(elem) && adapter.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next2, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next2, adapter);
    return function nthChild(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-child"(next2, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next2, adapter);
    return function nthLastChild(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-of-type"(next2, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next2, adapter);
    return function nthOfType(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-of-type"(next2, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next2, adapter);
    return function nthLastOfType(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  // TODO determine the actual root element
  root(next2, _rule, { adapter }) {
    return (elem) => {
      const parent2 = adapter.getParent(elem);
      return (parent2 == null || !adapter.isTag(parent2)) && next2(elem);
    };
  },
  scope(next2, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next2, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next2(elem);
    }
    return (elem) => context.includes(elem) && next2(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next2, _rule, { adapter }) {
    const func = adapter[name];
    if (typeof func !== "function") {
      return boolbase.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next2(elem);
    };
  };
}
const pseudos = {
  empty(elem, { adapter }) {
    return !adapter.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter.isTag(elem2) || adapter.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter, equals }) {
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    const firstChild = adapter.getSiblings(elem).find((elem2) => adapter.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter, equals }) {
    const siblings2 = adapter.getSiblings(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      if (equals(elem, siblings2[i]))
        return true;
      if (adapter.isTag(siblings2[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter, equals }) {
    const siblings2 = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = 0; i < siblings2.length; i++) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter, equals }) {
    const siblings2 = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter, equals }) {
    const elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter, equals }) {
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
  }
}
const aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
const PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next2, adapter) {
  if (next2 === boolbase.falseFunc)
    return boolbase.falseFunc;
  return (elem) => adapter.isTag(elem) && next2(elem);
}
function getNextSiblings(elem, adapter) {
  const siblings2 = adapter.getSiblings(elem);
  if (siblings2.length <= 1)
    return [];
  const elemIndex = siblings2.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings2.length - 1)
    return [];
  return siblings2.slice(elemIndex + 1).filter(adapter.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
const is$2 = (next2, token2, options, context, compileToken2) => {
  const func = compileToken2(token2, copyOptions(options), context);
  return func === boolbase.trueFunc ? next2 : func === boolbase.falseFunc ? boolbase.falseFunc : (elem) => func(elem) && next2(elem);
};
const subselects = {
  is: is$2,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is$2,
  where: is$2,
  not(next2, token2, options, context, compileToken2) {
    const func = compileToken2(token2, copyOptions(options), context);
    return func === boolbase.falseFunc ? next2 : func === boolbase.trueFunc ? boolbase.falseFunc : (elem) => !func(elem) && next2(elem);
  },
  has(next2, subselect, options, _context, compileToken2) {
    const { adapter } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === boolbase.falseFunc)
      return boolbase.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter);
    if (context && compiled !== boolbase.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next2(elem))
          return false;
        context[0] = elem;
        const childs = adapter.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter)] : childs;
        return adapter.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next2(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
  }
};
function compilePseudoSelector(next2, selector, options, context, compileToken2) {
  var _a2;
  const { name, data: data2 } = selector;
  if (Array.isArray(data2)) {
    if (!(name in subselects)) {
      throw new Error(`Unknown pseudo-class :${name}(${data2})`);
    }
    return subselects[name](next2, data2, options, context, compileToken2);
  }
  const userPseudo = (_a2 = options.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
  if (typeof stringPseudo === "string") {
    if (data2 != null) {
      throw new Error(`Pseudo ${name} doesn't have any arguments`);
    }
    const alias = parse$2(stringPseudo);
    return subselects["is"](next2, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name, data2, 1);
    return (elem) => userPseudo(elem, data2) && next2(elem);
  }
  if (name in filters) {
    return filters[name](next2, data2, options, context);
  }
  if (name in pseudos) {
    const pseudo = pseudos[name];
    verifyPseudoArgs(pseudo, name, data2, 2);
    return (elem) => pseudo(elem, options, data2) && next2(elem);
  }
  throw new Error(`Unknown pseudo-class :${name}`);
}
function getElementParent(node2, adapter) {
  const parent2 = adapter.getParent(node2);
  if (parent2 && adapter.isTag(parent2)) {
    return parent2;
  }
  return null;
}
function compileGeneralSelector(next2, selector, options, context, compileToken2) {
  const { adapter, equals } = options;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next2, selector, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next2, selector, options, context, compileToken2);
    }
    // Tags
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name = name.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name && next2(elem);
      };
    }
    // Traversal
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter)) {
            if (next2(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter)) {
          if (!isFalseCache.has(current)) {
            if (adapter.isTag(current) && next2(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next2(current))
            return true;
        } while (current = getElementParent(current, adapter));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent2(elem) {
        return adapter.getChildren(elem).some((elem2) => adapter.isTag(elem2) && next2(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent2 = adapter.getParent(elem);
        return parent2 != null && adapter.isTag(parent2) && next2(parent2);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings2 = adapter.getSiblings(elem);
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && next2(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter.prevElementSibling(elem);
          return previous != null && next2(previous);
        };
      }
      return function adjacent(elem) {
        const siblings2 = adapter.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next2(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next2;
    }
  }
}
function includesScopePseudo(t) {
  return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data2) => data2.some(includesScopePseudo)));
}
const DESCENDANT_TOKEN = { type: SelectorType.Descendant };
const FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
const SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token2, { adapter }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent2 = adapter.isTag(e) && adapter.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent2 && adapter.isTag(parent2);
  }));
  for (const t of token2) {
    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant) ;
    else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token2, options, context) {
  var _a2;
  token2.forEach(sortByProcedure);
  context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token2, options, finalContext);
  } else if (token2.some((t) => t.length > 0 && isTraversal(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token2.map((rules) => {
    if (rules.length >= 2) {
      const [first2, second] = rules;
      if (first2.type !== SelectorType.Pseudo || first2.name !== "scope") ;
      else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, boolbase.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules(rules, options, context) {
  var _a2;
  return rules.reduce((previous, rule) => previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : boolbase.trueFunc);
}
function reduceRules(a2, b2) {
  if (b2 === boolbase.falseFunc || a2 === boolbase.trueFunc) {
    return a2;
  }
  if (a2 === boolbase.falseFunc || b2 === boolbase.trueFunc) {
    return b2;
  }
  return function combine2(elem) {
    return a2(elem) || b2(elem);
  };
}
const defaultEquals = (a2, b2) => a2 === b2;
const defaultOptions = {
  adapter: DomUtils,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a2, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = DomUtils;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
const _compileToken = wrapCompile(compileToken);
function prepareContext(elems, adapter, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter);
  }
  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
}
function appendNextSiblings(elem, adapter) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter);
    elems.push(...nextSiblings);
  }
  return elems;
}
const filterNames = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function isFilter(s) {
  if (s.type !== "pseudo")
    return false;
  if (filterNames.has(s.name))
    return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    return s.data.some((s2) => s2.some(isFilter));
  }
  return false;
}
function getLimit(filter2, data2, partLimit) {
  const num = data2 != null ? parseInt(data2, 10) : NaN;
  switch (filter2) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
    case "lt":
      return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
    case "gt":
      return isFinite(num) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}
function getDocumentRoot(node2) {
  while (node2.parent)
    node2 = node2.parent;
  return node2;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector of selectors) {
    if (selector.some(isFilter)) {
      filteredSelectors.push(selector);
    } else {
      plainSelectors.push(selector);
    }
  }
  return [plainSelectors, filteredSelectors];
}
const UNIVERSAL_SELECTOR = {
  type: SelectorType.Universal,
  namespace: null
};
const SCOPE_PSEUDO = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function is$1(element, selector, options = {}) {
  return some([element], selector, options);
}
function some(elements, selector, options = {}) {
  if (typeof selector === "function")
    return elements.some(selector);
  const [plain, filtered] = groupSelectors(parse$2(selector));
  return plain.length > 0 && elements.some(_compileToken(plain, options)) || filtered.some((sel) => filterBySelector(sel, elements, options).length > 0);
}
function filterByPosition(filter2, elems, data2, options) {
  const num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
  switch (filter2) {
    case "first":
    case "lt":
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
    case "gt":
      return isFinite(num) ? elems.slice(num + 1) : [];
    case "even":
      return elems.filter((_, i) => i % 2 === 0);
    case "odd":
      return elems.filter((_, i) => i % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data2, elems, options));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter$1(selector, elements, options = {}) {
  return filterParsed(parse$2(selector), elements, options);
}
function filterParsed(selector, elements, options) {
  if (elements.length === 0)
    return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options);
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
    const filteredSelector = filteredSelectors[i];
    const missing = found ? elements.filter((e) => isTag(e) && !found.has(e)) : elements;
    if (missing.length === 0)
      break;
    const filtered = filterBySelector(filteredSelector, elements, options);
    if (filtered.length) {
      if (!found) {
        if (i === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el) => found.add(el));
      }
    }
  }
  return typeof found !== "undefined" ? found.size === elements.length ? elements : (
    // Filter elements to preserve order
    elements.filter((el) => found.has(el))
  ) : [];
}
function filterBySelector(selector, elements, options) {
  var _a2;
  if (selector.some(isTraversal$1)) {
    const root = (_a2 = options.root) !== null && _a2 !== void 0 ? _a2 : getDocumentRoot(elements[0]);
    const opts = { ...options, context: elements, relativeSelector: false };
    selector.push(SCOPE_PSEUDO);
    return findFilterElements(root, selector, opts, true, elements.length);
  }
  return findFilterElements(elements, selector, options, false, elements.length);
}
function select(selector, root, options = {}, limit = Infinity) {
  if (typeof selector === "function") {
    return find$1(root, selector);
  }
  const [plain, filtered] = groupSelectors(parse$2(selector));
  const results = filtered.map((sel) => findFilterElements(root, sel, options, true, limit));
  if (plain.length) {
    results.push(findElements(root, plain, options, limit));
  }
  if (results.length === 0) {
    return [];
  }
  if (results.length === 1) {
    return results[0];
  }
  return uniqueSort(results.reduce((a2, b2) => [...a2, ...b2]));
}
function findFilterElements(root, selector, options, queryForSelector, totalLimit) {
  const filterIndex = selector.findIndex(isFilter);
  const sub = selector.slice(0, filterIndex);
  const filter2 = selector[filterIndex];
  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
  const limit = getLimit(filter2.name, filter2.data, partLimit);
  if (limit === 0)
    return [];
  const elemsNoLimit = sub.length === 0 && !Array.isArray(root) ? getChildren(root).filter(isTag) : sub.length === 0 ? (Array.isArray(root) ? root : [root]).filter(isTag) : queryForSelector || sub.some(isTraversal$1) ? findElements(root, [sub], options, limit) : filterElements(root, [sub], options);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter2.name, elems, filter2.data, options);
  if (result.length === 0 || selector.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(isTraversal$1);
  if (remainingHasTraversal) {
    if (isTraversal$1(remainingSelector[0])) {
      const { type: type2 } = remainingSelector[0];
      if (type2 === SelectorType.Sibling || type2 === SelectorType.Adjacent) {
        result = prepareContext(result, DomUtils, true);
      }
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options = {
      ...options,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (el) => result.includes(el)
    };
  } else if (options.rootFunc && options.rootFunc !== boolbaseExports.trueFunc) {
    options = { ...options, rootFunc: boolbaseExports.trueFunc };
  }
  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? (
    // Query existing elements to resolve traversal.
    findElements(result, [remainingSelector], options, totalLimit)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    filterElements(result, [remainingSelector], options)
  );
}
function findElements(root, sel, options, limit) {
  const query = _compileToken(sel, options, root);
  return find$1(root, query, limit);
}
function find$1(root, query, limit = Infinity) {
  const elems = prepareContext(root, DomUtils, query.shouldTestNextSiblings);
  return find$2((node2) => isTag(node2) && query(node2), elems, true, limit);
}
function filterElements(elements, sel, options) {
  const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag);
  if (els.length === 0)
    return els;
  const query = _compileToken(sel, options);
  return query === boolbaseExports.trueFunc ? els : els.filter(query);
}
const reSiblingSelector = /^\s*[+~]/;
function find(selectorOrHaystack) {
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    const context = this.toArray();
    return this._make(haystack.filter((elem) => context.some((node2) => contains(node2, elem))));
  }
  return this._findBySelector(selectorOrHaystack, Number.POSITIVE_INFINITY);
}
function _findBySelector(selector, limit) {
  var _a2;
  const context = this.toArray();
  const elems = reSiblingSelector.test(selector) ? context : this.children().toArray();
  const options = {
    context,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select(selector, elems, options, limit));
}
function _getMatcher(matchMap) {
  return function(fn, ...postFns) {
    return function(selector) {
      var _a2;
      let matched = matchMap(fn, this);
      if (selector) {
        matched = filterArray(matched, selector, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
      );
    };
  };
}
const _matcher = _getMatcher((fn, elems) => {
  let ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value.length > 0)
      ret = ret.concat(value);
  }
  return ret;
});
const _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem, ...postFns) {
  let matches = null;
  const innerMatcher = _getMatcher((nextElem2, elems) => {
    const matched = [];
    domEach(elems, (elem) => {
      for (let next2; next2 = nextElem2(elem); elem = next2) {
        if (matches === null || matches === void 0 ? void 0 : matches(next2, matched.length))
          break;
        matched.push(next2);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function(selector, filterSelector) {
    matches = typeof selector === "string" ? (elem) => is$1(elem, selector, this.options) : selector ? getFilterFn(selector) : null;
    const ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return elems.length > 1 ? Array.from(new Set(elems)) : elems;
}
const parent = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, _removeDuplicates);
const parents = _matcher((elem) => {
  const matched = [];
  while (elem.parent && !isDocument(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, uniqueSort, (elems) => elems.reverse());
const parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
function closest(selector) {
  var _a2;
  const set = [];
  if (!selector) {
    return this._make(set);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]
  };
  const selectFn = typeof selector === "string" ? (elem) => is$1(elem, selector, selectOpts) : getFilterFn(selector);
  domEach(this, (elem) => {
    if (elem && !isDocument(elem) && !isTag(elem)) {
      elem = elem.parent;
    }
    while (elem && isTag(elem)) {
      if (selectFn(elem, 0)) {
        if (!set.includes(elem)) {
          set.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set);
}
const next = _singleMatcher((elem) => nextElementSibling(elem));
const nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
const nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
const prev = _singleMatcher((elem) => prevElementSibling(elem));
const prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
const prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
const siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag(el) && el !== elem), uniqueSort);
const children = _matcher((elem) => getChildren(elem).filter(isTag), _removeDuplicates);
function contents() {
  const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
  return this._make(elems);
}
function each(fn) {
  let i = 0;
  const len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false)
    ++i;
  return this;
}
function map(fn) {
  let elems = [];
  for (let i = 0; i < this.length; i++) {
    const el = this[i];
    const val2 = fn.call(el, i, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
function getFilterFn(match2) {
  if (typeof match2 === "function") {
    return (el, i) => match2.call(el, i, el);
  }
  if (isCheerio(match2)) {
    return (el) => Array.prototype.includes.call(match2, el);
  }
  return function(el) {
    return match2 === el;
  };
}
function filter(match2) {
  var _a2;
  return this._make(filterArray(this.toArray(), match2, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]));
}
function filterArray(nodes, match2, xmlMode, root) {
  return typeof match2 === "string" ? filter$1(match2, nodes, { xmlMode, root }) : nodes.filter(getFilterFn(match2));
}
function is(selector) {
  const nodes = this.toArray();
  return typeof selector === "string" ? some(nodes.filter(isTag), selector, this.options) : selector ? nodes.some(getFilterFn(selector)) : false;
}
function not(match2) {
  let nodes = this.toArray();
  if (typeof match2 === "string") {
    const matches = new Set(filter$1(match2, nodes, this.options));
    nodes = nodes.filter((el) => !matches.has(el));
  } else {
    const filterFn = getFilterFn(match2);
    nodes = nodes.filter((el, i) => !filterFn(el, i));
  }
  return this._make(nodes);
}
function has(selectorOrHaystack) {
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${selectorOrHaystack})`
  ) : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);
}
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function eq(i) {
  var _a2;
  i = +i;
  if (i === 0 && this.length <= 1)
    return this;
  if (i < 0)
    i = this.length + i;
  return this._make((_a2 = this[i]) !== null && _a2 !== void 0 ? _a2 : []);
}
function get(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
function toArray() {
  return Array.prototype.slice.call(this);
}
function index(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
function slice(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
function end() {
  var _a2;
  return (_a2 = this.prevObject) !== null && _a2 !== void 0 ? _a2 : this._make([]);
}
function add(other, context) {
  const selection = this._make(other, context);
  const contents2 = uniqueSort([...this.get(), ...selection.get()]);
  return this._make(contents2);
}
function addBack(selector) {
  return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
}
const Traversing = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _findBySelector,
  add,
  addBack,
  children,
  closest,
  contents,
  each,
  end,
  eq,
  filter,
  filterArray,
  find,
  first,
  get,
  has,
  index,
  is,
  last,
  map,
  next,
  nextAll,
  nextUntil,
  not,
  parent,
  parents,
  parentsUntil,
  prev,
  prevAll,
  prevUntil,
  siblings,
  slice,
  toArray
}, Symbol.toStringTag, { value: "Module" }));
function update(newChilds, parent2) {
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent2) {
    parent2.children = arr;
  } else {
    parent2 = null;
  }
  for (let i = 0; i < arr.length; i++) {
    const node2 = arr[i];
    if (node2.parent && node2.parent.children !== arr) {
      removeElement(node2);
    }
    if (parent2) {
      node2.prev = arr[i - 1] || null;
      node2.next = arr[i + 1] || null;
    } else {
      node2.prev = node2.next = null;
    }
    node2.parent = parent2;
  }
  return parent2;
}
function _makeDomArray(elem, clone2) {
  if (elem == null) {
    return [];
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children.slice(0);
  }
  if ("length" in elem) {
    if (elem.length === 1) {
      return this._makeDomArray(elem[0], clone2);
    }
    const result = [];
    for (let i = 0; i < elem.length; i++) {
      const el = elem[i];
      if (typeof el === "object") {
        if (el == null) {
          continue;
        }
        if (!("length" in el)) {
          result.push(clone2 ? cloneNode(el, true) : el);
          continue;
        }
      }
      result.push(...this._makeDomArray(el, clone2));
    }
    return result;
  }
  return [clone2 ? cloneNode(elem, true) : elem];
}
function _insert(concatenator) {
  return function(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el))
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent2) {
  var _a2, _b;
  const spliceArgs = [
    spliceIdx,
    spliceCount,
    ...newElems
  ];
  const prev2 = spliceIdx === 0 ? null : array[spliceIdx - 1];
  const next2 = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node2 = newElems[idx];
    const oldParent = node2.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node2);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent2 === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node2.parent = parent2;
    if (node2.prev) {
      node2.prev.next = (_a2 = node2.next) !== null && _a2 !== void 0 ? _a2 : null;
    }
    if (node2.next) {
      node2.next.prev = (_b = node2.prev) !== null && _b !== void 0 ? _b : null;
    }
    node2.prev = idx === 0 ? prev2 : newElems[idx - 1];
    node2.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
  }
  if (prev2) {
    prev2.next = newElems[0];
  }
  if (next2) {
    next2.prev = newElems[newElems.length - 1];
  }
  return array.splice(...spliceArgs);
}
function appendTo(target) {
  const appendTarget = isCheerio(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
function prependTo(target) {
  const prependTarget = isCheerio(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
const append = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, children2.length, 0, dom, parent2);
});
const prepend = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, 0, 0, dom, parent2);
});
function _wrap(insert) {
  return function(wrapper2) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const wrap2 = typeof wrapper2 === "function" ? wrapper2.call(el, i, el) : typeof wrapper2 === "string" && !isHtml(wrapper2) ? lastParent.find(wrapper2).clone() : wrapper2;
      const [wrapperDom] = this._makeDomArray(wrap2, i < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom))
        continue;
      let elInsertLocation = wrapperDom;
      let j = 0;
      while (j < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j];
        if (isTag(child)) {
          elInsertLocation = child;
          j = 0;
        } else {
          j++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
const wrap = _wrap((el, elInsertLocation, wrapperDom) => {
  const { parent: parent2 } = el;
  if (!parent2)
    return;
  const siblings2 = parent2.children;
  const index2 = siblings2.indexOf(el);
  update([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
});
const wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el))
    return;
  update(el.children, elInsertLocation);
  update(wrapperDom, el);
});
function unwrap(selector) {
  this.parent(selector).not("body").each((_, el) => {
    this._make(el).replaceWith(el.children);
  });
  return this;
}
function wrapAll(wrapper2) {
  const el = this[0];
  if (el) {
    const wrap2 = this._make(typeof wrapper2 === "function" ? wrapper2.call(el, 0, el) : wrapper2).insertBefore(el);
    let elInsertLocation;
    for (let i = 0; i < wrap2.length; i++) {
      if (wrap2[i].type === "tag")
        elInsertLocation = wrap2[i];
    }
    let j = 0;
    while (elInsertLocation && j < elInsertLocation.children.length) {
      const child = elInsertLocation.children[j];
      if (child.type === "tag") {
        elInsertLocation = child;
        j = 0;
      } else {
        j++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    if (!hasChildren(el) || !el.parent) {
      return;
    }
    const siblings2 = el.parent.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, el.parent);
  });
}
function insertAfter(target) {
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  const clones = [];
  for (const el of this._makeDomArray(target)) {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      continue;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      continue;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  }
  return this._make(clones);
}
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    if (!hasChildren(el) || !el.parent) {
      return;
    }
    const siblings2 = el.parent.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, el.parent);
  });
}
function insertBefore(target) {
  const targetArr = this._make(target);
  this.remove();
  const clones = [];
  domEach(targetArr, (el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function remove(selector) {
  const elems = selector ? this.filter(selector) : this;
  domEach(elems, (el) => {
    removeElement(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
function replaceWith(content) {
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const cont = typeof content === "function" ? content.call(el, i, el) : content;
    const dom = this._makeDomArray(cont);
    update(dom, null);
    const index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom, parent2);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
function empty() {
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    for (const child of el.children) {
      child.next = child.prev = child.parent = null;
    }
    el.children.length = 0;
  });
}
function html(str) {
  if (str === void 0) {
    const el = this[0];
    if (!el || !hasChildren(el))
      return null;
    return this._render(el.children);
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    for (const child of el.children) {
      child.next = child.prev = child.parent = null;
    }
    const content = isCheerio(str) ? str.toArray() : this._parse(`${str}`, this.options, false, el).children;
    update(content, el);
  });
}
function toString() {
  return this._render(this);
}
function text(str) {
  if (str === void 0) {
    return text$1(this);
  }
  if (typeof str === "function") {
    return domEach(this, (el, i) => this._make(el).text(str.call(el, i, text$1([el]))));
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    for (const child of el.children) {
      child.next = child.prev = child.parent = null;
    }
    const textNode = new Text(`${str}`);
    update(textNode, el);
  });
}
function clone() {
  const clone2 = Array.prototype.map.call(this.get(), (el) => cloneNode(el, true));
  const root = new Document(clone2);
  for (const node2 of clone2) {
    node2.parent = root;
  }
  return this._make(clone2);
}
const Manipulation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _makeDomArray,
  after,
  append,
  appendTo,
  before,
  clone,
  empty,
  html,
  insertAfter,
  insertBefore,
  prepend,
  prependTo,
  remove,
  replaceWith,
  text,
  toString,
  unwrap,
  wrap,
  wrapAll,
  wrapInner
}, Symbol.toStringTag, { value: "Module" }));
function css(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        setCss(el, prop2, val2, i);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
function setCss(el, prop2, value, idx) {
  if (typeof prop2 === "string") {
    const styles = getCss(el);
    const val2 = typeof value === "function" ? value.call(el, idx, styles[prop2]) : value;
    if (val2 === "") {
      delete styles[prop2];
    } else if (val2 != null) {
      styles[prop2] = val2;
    }
    el.attribs["style"] = stringify(styles);
  } else if (typeof prop2 === "object") {
    const keys = Object.keys(prop2);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      setCss(el, k, prop2[k], i);
    }
  }
}
function getCss(el, prop2) {
  if (!el || !isTag(el))
    return;
  const styles = parse(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles[prop2];
  }
  if (Array.isArray(prop2)) {
    const newStyles = {};
    for (const item2 of prop2) {
      if (styles[item2] != null) {
        newStyles[item2] = styles[item2];
      }
    }
    return newStyles;
  }
  return styles;
}
function stringify(obj) {
  return Object.keys(obj).reduce((str, prop2) => `${str}${str ? " " : ""}${prop2}: ${obj[prop2]};`, "");
}
function parse(styles) {
  styles = (styles || "").trim();
  if (!styles)
    return {};
  const obj = {};
  let key;
  for (const str of styles.split(";")) {
    const n = str.indexOf(":");
    if (n < 1 || n === str.length - 1) {
      const trimmed = str.trimEnd();
      if (trimmed.length > 0 && key !== void 0) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str.slice(0, n).trim();
      obj[key] = str.slice(n + 1).trim();
    }
  }
  return obj;
}
const Css = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  css
}, Symbol.toStringTag, { value: "Module" }));
const submittableSelector = "input,select,textarea,keygen";
const r20 = /%20/g;
const rCRLF = /\r?\n/g;
function serialize() {
  const arr = this.serializeArray();
  const retArr = arr.map((data2) => `${encodeURIComponent(data2.name)}=${encodeURIComponent(data2.value)}`);
  return retArr.join("&").replace(r20, "+");
}
function serializeArray() {
  return this.map((_, elem) => {
    const $elem = this._make(elem);
    if (isTag(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((_, elem) => {
    var _a2;
    const $elem = this._make(elem);
    const name = $elem.attr("name");
    const value = (_a2 = $elem.val()) !== null && _a2 !== void 0 ? _a2 : "";
    if (Array.isArray(value)) {
      return value.map((val2) => (
        /*
         * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
         * These can occur inside of `<textarea>'s`
         */
        { name, value: val2.replace(rCRLF, "\r\n") }
      ));
    }
    return { name, value: value.replace(rCRLF, "\r\n") };
  }).toArray();
}
const Forms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  serialize,
  serializeArray
}, Symbol.toStringTag, { value: "Module" }));
function getExtractDescr(descr) {
  var _a2;
  if (typeof descr === "string") {
    return { selector: descr, value: "textContent" };
  }
  return {
    selector: descr.selector,
    value: (_a2 = descr.value) !== null && _a2 !== void 0 ? _a2 : "textContent"
  };
}
function extract(map2) {
  const ret = {};
  for (const key in map2) {
    const descr = map2[key];
    const isArray = Array.isArray(descr);
    const { selector, value } = getExtractDescr(isArray ? descr[0] : descr);
    const fn = typeof value === "function" ? value : typeof value === "string" ? (el) => this._make(el).prop(value) : (el) => this._make(el).extract(value);
    if (isArray) {
      ret[key] = this._findBySelector(selector, Number.POSITIVE_INFINITY).map((_, el) => fn(el, key, ret)).get();
    } else {
      const $2 = this._findBySelector(selector, 1);
      ret[key] = $2.length > 0 ? fn($2[0], key, ret) : void 0;
    }
  }
  return ret;
}
const Extract = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extract
}, Symbol.toStringTag, { value: "Module" }));
class Cheerio {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(elements, root, options) {
    this.length = 0;
    this.options = options;
    this._root = root;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
}
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms, Extract);
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
})(CODE_POINTS || (CODE_POINTS = {}));
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR || (ERR = {}));
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType || (TokenType = {}));
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SEARCH"] = "search";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SEARCH"] = 94] = "SEARCH";
  TAG_ID2[TAG_ID2["SECTION"] = 95] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 96] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 97] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 98] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 99] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 100] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 101] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 102] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 103] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 104] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 105] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 106] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 107] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 108] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 109] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 110] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 111] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 112] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 113] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 114] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 115] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 116] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 117] = "TT";
  TAG_ID2[TAG_ID2["U"] = 118] = "U";
  TAG_ID2[TAG_ID2["UL"] = 119] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 120] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 121] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 122] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 123] = "XMP";
})(TAG_ID || (TAG_ID = {}));
/* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SEARCH, TAG_ID.SEARCH],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
const $ = TAG_ID;
({
  [NS.HTML]: /* @__PURE__ */ new Set([
    $.ADDRESS,
    $.APPLET,
    $.AREA,
    $.ARTICLE,
    $.ASIDE,
    $.BASE,
    $.BASEFONT,
    $.BGSOUND,
    $.BLOCKQUOTE,
    $.BODY,
    $.BR,
    $.BUTTON,
    $.CAPTION,
    $.CENTER,
    $.COL,
    $.COLGROUP,
    $.DD,
    $.DETAILS,
    $.DIR,
    $.DIV,
    $.DL,
    $.DT,
    $.EMBED,
    $.FIELDSET,
    $.FIGCAPTION,
    $.FIGURE,
    $.FOOTER,
    $.FORM,
    $.FRAME,
    $.FRAMESET,
    $.H1,
    $.H2,
    $.H3,
    $.H4,
    $.H5,
    $.H6,
    $.HEAD,
    $.HEADER,
    $.HGROUP,
    $.HR,
    $.HTML,
    $.IFRAME,
    $.IMG,
    $.INPUT,
    $.LI,
    $.LINK,
    $.LISTING,
    $.MAIN,
    $.MARQUEE,
    $.MENU,
    $.META,
    $.NAV,
    $.NOEMBED,
    $.NOFRAMES,
    $.NOSCRIPT,
    $.OBJECT,
    $.OL,
    $.P,
    $.PARAM,
    $.PLAINTEXT,
    $.PRE,
    $.SCRIPT,
    $.SECTION,
    $.SELECT,
    $.SOURCE,
    $.STYLE,
    $.SUMMARY,
    $.TABLE,
    $.TBODY,
    $.TD,
    $.TEMPLATE,
    $.TEXTAREA,
    $.TFOOT,
    $.TH,
    $.THEAD,
    $.TITLE,
    $.TR,
    $.TRACK,
    $.UL,
    $.WBR,
    $.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
});
/* @__PURE__ */ new Set([$.H1, $.H2, $.H3, $.H4, $.H5, $.H6]);
/* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
var State;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
})(State || (State = {}));
({
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
});
const IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
/* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
const SCOPING_ELEMENTS_HTML = /* @__PURE__ */ new Set([
  TAG_ID.APPLET,
  TAG_ID.CAPTION,
  TAG_ID.HTML,
  TAG_ID.MARQUEE,
  TAG_ID.OBJECT,
  TAG_ID.TABLE,
  TAG_ID.TD,
  TAG_ID.TEMPLATE,
  TAG_ID.TH
]);
/* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.OL, TAG_ID.UL]);
/* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
/* @__PURE__ */ new Set([TAG_ID.ANNOTATION_XML, TAG_ID.MI, TAG_ID.MN, TAG_ID.MO, TAG_ID.MS, TAG_ID.MTEXT]);
/* @__PURE__ */ new Set([TAG_ID.DESC, TAG_ID.FOREIGN_OBJECT, TAG_ID.TITLE]);
/* @__PURE__ */ new Set([TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML]);
/* @__PURE__ */ new Set([TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML]);
/* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML]);
/* @__PURE__ */ new Set([TAG_ID.TD, TAG_ID.TH]);
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType || (EntryType = {}));
({ type: EntryType.Marker });
new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
/* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
/* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
/* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
/* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
/* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);
atom({
  key: "raisedSnackbars",
  default: []
});
atom({
  key: "raisedErrors",
  default: []
});
function createCustomizedObjetType(objectType) {
  const customObjectType = customizedObjectTypes[objectType.definition.name];
  if (customObjectType) {
    const { reports, entityToString: entityToString2, entityToStringWithContext, breadcrumb: breadcrumb2, appBarBackgroundColor: useAppBarBackgroundColor, pathToBuilding } = customObjectType;
    if (entityToString2) {
      objectType.entityToString = entityToString2;
    }
    if (entityToStringWithContext) {
      objectType.entityToStringWithContext = entityToStringWithContext;
    }
    if (breadcrumb2) {
      objectType.breadcrumb = breadcrumb2;
    }
    if (useAppBarBackgroundColor) {
      objectType.appBarBackgroundColor = useAppBarBackgroundColor;
    }
    if (reports) {
      objectType.reports = reports;
    }
    if (pathToBuilding && pathToBuilding.length > 0) {
      objectType.pathToBuilding = pathToBuilding;
    }
    if (customObjectType.defaultSortOrder) {
      objectType.defaultSortOrder = customObjectType.defaultSortOrder;
    }
  }
  return objectType;
}
function getObjectTypes() {
  return generatedObjectTypes.map(createCustomizedObjetType);
}
function getObjectTypesStore() {
  return getObjectTypes().reduce((acc, v) => {
    acc[v.definition.camelized.singular] = v;
    return acc;
  }, {});
}
getObjectTypesStore();
getObjectTypesStore();
function getDeterminantByType(polyglotApi, singular, alternative, type2) {
  const definedKey = `models.${singular}.${type2}.defined`;
  const defined = polyglotApi.keyExists(definedKey) ? polyglotApi.translate(definedKey) : alternative;
  const undefinedKey = `models.${singular}.${type2}.undefined`;
  const unDefined = polyglotApi.keyExists(undefinedKey) ? polyglotApi.translate(undefinedKey) : alternative;
  return {
    defined,
    undefined: unDefined
  };
}
function objectTypeDeterminant(polyglotApi, objectTypeName) {
  const { singular } = getObjectTypeDefinitionByName(objectTypeName).capitalized;
  return getDeterminantByType(polyglotApi, singular, singular, "determinant");
}
function objectTypeDeterminants(polyglotApi, objectTypeName) {
  const { singular, plural } = getObjectTypeDefinitionByName(objectTypeName).capitalized;
  return getDeterminantByType(polyglotApi, singular, plural, "determinants");
}
function useFlattenDeterminants(objectTypeName) {
  const polyglotApi = useI18nApi();
  return getFlattenDeterminants(polyglotApi, objectTypeName);
}
function getFlattenDeterminants(polyglotApi, objectTypeName) {
  const determinant = objectTypeDeterminant(polyglotApi, objectTypeName);
  const determinants = objectTypeDeterminants(polyglotApi, objectTypeName);
  return {
    "determinant.defined": determinant.defined,
    "determinant.undefined": determinant.undefined,
    "determinants.defined": determinants.defined,
    "determinants.undefined": determinants.undefined
  };
}
function objectTypeIndexViewHelp(i18nApi, objectTypeName, viewName, isDefaultView) {
  const { singular } = getObjectTypeDefinitionByName(objectTypeName).capitalized;
  const actionKey = isDefaultView === true ? `entity.views.${viewName}.help` : `models.${singular}.views.${viewName}.help`;
  return i18nApi.translate(actionKey, { ...getFlattenDeterminants(i18nApi, objectTypeName) });
}
function ObjectTypeIndexViewHelp(props) {
  const { objectTypeName, view } = props;
  const i18nApi = useI18nApi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: objectTypeIndexViewHelp(i18nApi, objectTypeName, view.name, view.isDefaultView) });
}
const a = 40;
const b = 145;
export {
  I18NHelpContext,
  ObjectTypeIndexViewHelp,
  PropertyTypeLabel,
  PropertyTypeMandatoryLabel,
  SetupRecoilContext,
  a,
  appVersion,
  b,
  getObjectTypeDefinitionByName,
  getPropertyTypeByCode,
  getPropertyTypeByName,
  isTenantObjectType,
  useFlattenDeterminants,
  useTranslation,
  versionCookieKeyName
};
